homepage: https://github.com/phadej/skew-list
changelog-type: markdown
hash: 5d81ffe85408415208fce3a2ef9aa99dda060d420c46c5825e7d05468c66a43c
test-bench-deps:
  ral: ^>=0.2.1
  base: -any
  skew-list: -any
  indexed-traversable: -any
  criterion: ^>=1.6.0.0
  containers: -any
  tasty-quickcheck: ^>=0.10.2
  tasty-hunit: ^>=0.10.0.3
  tasty: ^>=1.4.2.3
  QuickCheck: ^>=2.14.2
  vector: ^>=0.13.0.0
maintainer: Oleg.Grenrus <oleg.grenrus@iki.fi>
synopsis: 'Random access lists: skew binary'
changelog: |
  # Version history for skew-list

  ## 0.1

  - First version. Released on an unsuspecting world.
basic-deps:
  base: '>=4.12.0.0 && <4.19'
  indexed-traversable: ^>=0.1.1
  strict: ^>=0.4.0.1 || ^>=0.5
  hashable: ^>=1.4.1.0
  deepseq: '>=1.4.4.0 && <1.5'
  QuickCheck: ^>=2.14.2
all-versions:
- '0.1'
author: Oleg Grenrus <oleg.grenrus@iki.fi>
latest: '0.1'
description-type: haddock
description: |-
  This package provides ordinary random access list, 'SkewList'
  implemented using skew binary approach.

  It's worth comparing to ordinary lists, binary random access list (as in @ral@ package) and vectors (@vector@ package)
  across two operations: indexing and consing.

  +------------------------------+------------+----------+
  |                              | Consing    | Indexing |
  +------------------------------+------------+----------+
  | Ordinary list, @[a]@         | O(1)       | O(n)     |
  +------------------------------+------------+----------+
  | Binary list, @RAList a@      | O(log n)   | O(log n) |
  +------------------------------+------------+----------+
  | Vector, @Vector@             | O(n)       | O(1)     |
  +------------------------------+------------+----------+
  | Sequence, @Seq@              | O(1)       | O(log n) |
  +------------------------------+------------+----------+
  | Skew binary list, @SkewList@ | O(1)       | O(log n) |
  +------------------------------+------------+----------+

  @SkewList@ improves upon ordinary list, the cons operation is still
  constant time (though with higher constant factor), but indexing
  can be done in a logarithmic time.

  Binary list cons is slower, as it might need to walk over whole
  /log n/ sized structure.

  @Vector@ is the other end of trade-off spectrum: indexing is constant time
  operation, but consing a new element will need to copy whole spine.

  @Seq@ from "Data.Sequence" has similar (but amortized) complexity bounds for
  cons and index as @SkewList@.  However (it seems) that indexing is quicker for
  @SkewList@ in practice. Also @SkewList@ has strict spine.
  On the other hand, @Seq@ has quick append if you need that.

  If you need both: fast consing and index, consider using @SkewList@.
license-name: BSD-3-Clause

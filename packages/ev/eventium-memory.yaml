all-versions:
- 0.1.0
author: ''
basic-deps:
  base: '>=4.9 && <5'
  containers: '>=0.6 && <0.8'
  eventium-core: '>=0'
  mtl: '>=2.2 && <2.4'
  safe: '>=0.3 && <0.4'
  stm: '>=2.5 && <2.6'
changelog: ''
changelog-type: markdown
description: "# Eventium Memory\n\nIn-memory implementations of event stores, read
  models, and projection caches for Eventium.\n\n## Overview\n\n`eventium-memory`
  provides thread-safe, in-memory storage implementations for the Eventium event sourcing
  framework. This package is ideal for development, testing, and prototyping event-sourced
  applications without requiring external dependencies like databases.\n\n## Features\n\n-
  ✅ **In-Memory Event Store** - Fast, STM-based event storage\n- ✅ **Thread-Safe**
  - Concurrent access via Software Transactional Memory\n- ✅ **No External Dependencies**
  - No database setup required\n- ✅ **Perfect for Testing** - Fast test execution
  with isolated state\n- ✅ **Projection Cache** - In-memory snapshot storage\n- ✅
  **Read Model Support** - Memory-based read model implementation\n\n## Components\n\n###
  Event Store (`Eventium.Store.Memory`)\nImplements both `EventStoreReader` and `EventStoreWriter`
  with:\n- Per-stream versioning\n- Global event ordering\n- Optimistic concurrency
  control\n- STM transactions for atomicity\n\n### Read Model (`Eventium.ReadModel.Memory`)\nIn-memory
  read model implementation for building query-optimized views.\n\n### Projection
  Cache (`Eventium.ProjectionCache.Memory`)\nStores projection snapshots in memory
  to avoid replaying entire event histories.\n\n## Usage\n\n```haskell\nimport Eventium.Store.Memory
  (newEventStore)\nimport Control.Concurrent.STM (atomically)\n\nmain :: IO ()\nmain
  = do\n  -- Create a new in-memory event store\n  store <- atomically newEventStore\n
  \ \n  -- Use it with your command handlers and projections\n  result <- applyCommandHandler
  \n    (eventStoreWriter store)\n    (eventStoreReader store) \n    myCommandHandler
  \n    aggregateId \n    command\n```\n\n## Installation\n\nAdd to your `package.yaml`:\n\n```yaml\ndependencies:\n
  \ - eventium-core\n  - eventium-memory\n```\n\nOr to your `.cabal` file:\n\n```cabal\nbuild-depends:\n
  \   eventium-core\n  , eventium-memory\n```\n\n## Use Cases\n\n### Development\nQuickly
  prototype event-sourced applications without database setup.\n\n### Testing\n- Fast
  test execution (no I/O overhead)\n- Isolated test state (each test gets fresh store)\n-
  Easy verification of event sequences\n\n### Demonstration\nPerfect for demos, tutorials,
  and learning event sourcing concepts.\n\n## Example\n\n```haskell\n-- Create store\nstore
  <- atomically newEventStore\n\n-- Write events\nwriteResult <- atomically $ \n  writeEvents
  (eventStoreWriter store) \n    streamKey \n    ExpectedPositionAny \n    [event1,
  event2]\n\n-- Read events back\nevents <- atomically $ \n  readEvents (eventStoreReader
  store) \n    streamKey \n    QueryRangeAll\n```\n\n## Limitations\n\n- **Not Persistent**
  - All data lost when process ends\n- **Memory Constraints** - Limited by available
  RAM\n- **Single Process** - No distributed access\n\nFor production use, consider:\n-
  `eventium-sqlite` - Persistent, single-process storage\n- `eventium-postgresql`
  - Persistent, multi-process storage\n\n## Documentation\n\n- [Main README](../README.md)
  - Project overview\n- [Design Documentation](../DESIGN.md) - Architecture details\n-
  [Examples](../examples/) - Working applications\n\n## License\n\nMIT - see [LICENSE.md](LICENSE.md)\n"
description-type: markdown
hash: e0ddef270da64960a6f4e8eae960ca0336817cffe328b606a4bbe39e7287c7bb
homepage: https://github.com/aleks-sidorenko/eventium#readme
latest: 0.1.0
license-name: MIT
maintainer: Alexander Sidorenko
synopsis: In-memory implementations for eventium
test-bench-deps:
  HUnit: '>=0'
  base: '>=4.9 && <5'
  containers: '>=0.6 && <0.8'
  eventium-core: '>=0'
  eventium-test-helpers: '>=0'
  hspec: '>=0'
  mtl: '>=2.2 && <2.4'
  safe: '>=0.3 && <0.4'
  stm: '>=2.5 && <2.6'

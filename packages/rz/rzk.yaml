homepage: https://github.com/fizruk/rzk#readme
changelog-type: markdown
hash: 8060bbd8705285f104ca7f5bac72bca22156dfe25303ddc6e111be6023287554
test-bench-deps:
  optparse-generic: -any
  base: '>=4.7 && <5'
  array: -any
  bifunctors: -any
  mtl: -any
  rzk: -any
  template-haskell: -any
maintainer: nickolay.kudasov@gmail.com
synopsis: An experimental proof assistant for synthetic ∞-categories
changelog: "# Changelog for `rzk`\n\nAll notable changes to this project will be documented
  in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand
  this project adheres to the\n[Haskell Package Versioning Policy](https://pvp.haskell.org/).\n\n##
  v0.4.1 — 2022-06-16\n\nThis is version contains minor changes, primarily in tools
  around rzk:\n\n- Add `rzk version` command (see [f1709dc7]( https://github.com/fizruk/rzk/commit/f1709dc7
  ));\n- Add action to release binaries (see [9286afae]( https://github.com/fizruk/rzk/commit/9286afae
  ));\n- Automate SVG rendering in MkDocs (see [#49]( https://github.com/fizruk/rzk/pull/49
  ));\n- Read `stdin` when no filepaths are given (see [936c15a3]( https://github.com/fizruk/rzk/commit/936c15a3
  ));\n- Add Pygments highlighting (see [01c2a017]( https://github.com/fizruk/rzk/commit/01c2a017
  ), [cbd656cc]( https://github.com/fizruk/rzk/commit/cbd656cc ), [5220ddf9]( https://github.com/fizruk/rzk/commit/5220ddf9
  ), [142ec003]( https://github.com/fizruk/rzk/commit/142ec003 ), [5c7425f2]( https://github.com/fizruk/rzk/commit/5c7425f2
  ));\n- Update HighlightJS config for rzk v0.4.0 (see [171ee63f]( https://github.com/fizruk/rzk/commit/171ee63f
  ));\n\n## v0.4.0 — 2022-05-18\n\nThis version introduces sections and variables.
  The feature is similar to <a href=\"https://coq.inria.fr/refman/language/core/assumptions.html#coq:cmd.Variable\"
  target=\"_blank\">`Variable` command in Coq</a>. An important difference, however,
  is that `rzk` does not allow definitions to use variables implicitly and adds `uses
  (...)` annotations to ensure such dependencies are not accidental.\n\n- Variables
  and sections (Coq-style) (see [#38]( https://github.com/fizruk/rzk/pull/38 ));\n\nMinor
  improvements:\n\n- Add flake, set up nix and cabal builds, cache nix store on CI
  (see [#39]( https://github.com/fizruk/rzk/pull/39 ));\n- Apply stylish-haskell (see
  [7d42ef62]( https://github.com/fizruk/rzk/commit/7d42ef62 ));\n\n## v0.3.0 — 2022-04-28\n\nThis
  version introduces an experimental feature for generating visualisations for simplicial
  terms in SVG.\nTo enable rendering, enable option `\"render\" = \"svg\"` (to disable,
  `\"render\" = \"none\"`):\n\n```rzk\n#set-option \"render\" = \"svg\"  -- enable
  rendering in SVG\n```\n\nMinor changes:\n\n- Exit with non-zero code upon a type
  error (see b135c4fb)\n- Fix external links and some typos in the documentation\n\nFixes:\n\n-
  Fixed an issue with tope solver when context was empty (see 6196af9e);\n- Fixed
  #33 (missing coherence check for restricted types).\n\n## v0.2.0 - 2022-04-20\n\nThis
  version was a complete rewrite of the proof assistant, using a new parser, a new
  internal representation, and a rewrite of the typechecking logic. This is still
  a prototype, but, arguably, significantly more stable and manageable than version
  0.1.0.\n\n### Language\n\nSyntax is almost entirely backwards compatible with version
  0.1.0.\nTypechecking has been fixed and improved.\n\n#### Breaking Changes\n\nThe
  only known breaking changes are:\n\n1. Terms like `second x y` which previous have
  been parsed as `second (x y)`\n  now are properly parsed as `(second x) y`.\n2.
  It is now necessary to have at least a minimal indentation in the definition of
  a term after a newline.\n3. Unicode syntax is temporarily disabled, except for dependent
  sums and arrows in function types.\n4. The restriction syntax `[ ... ]` now has
  a slightly different precedence, so some parentheses are required, e.g. in `(A ->
  B) [ phi |-> f]` or `(f t = g t) [ phi |-> f]`.\n5. Duplicate top-level definitions
  are no longer allowed.\n\n#### Deprecated Syntax\n\nThe angle brackets for extension
  types are supported, but deprecated,\nas they are completely unnecessary now: `<{t
  : I | psi t} -> A t [ phi t |-> a t ]>` can now be written as `{t : I | psi t} ->
  A t [ phi t |-> a t]`\nor even `(t : psi) -> A t [ phi t |-> a t ]`.\n\n#### Syntax
  Relaxation\n\nOtherwise, syntax is now made more flexible:\n\n1. Function parameters
  can be unnamed: `A -> B` is the same as `(_ : A) -> B`.\n2. Angle brackets are now
  optional: `{t : I | psi t} -> A t [ phi t |-> a t ]`\n3. Nullary extension types
  are possible: `A t [ phi t |-> a t ]`\n4. Lambda abstractions can introduce multiple
  arguments:\n\n    ```rzk\n    #def hom : (A : U) -> A -> A -> U\n      := \\A x
  y ->\n        (t : Δ¹) -> A [ ∂Δ¹ t |-> recOR(t === 0_2, t === 1_2, x, y) ]\n    ```\n\n5.
  Parameters can be introduced simultaneously for the type and body. Moreover, multiple
  parameters can be introduced with the same type:\n\n    ```rzk\n    #def hom (A
  : U) (x y : A) : U\n      := (t : Δ¹) -> A [ ∂Δ¹ t |-> recOR(t === 0_2, t === 1_2,
  x, y) ]\n    ```\n\n6. Restrictions can now support multiple subshapes, effectively
  internalising `recOR`:\n\n    ```rzk\n    #def hom (A : U) (x y : A) : U\n      :=
  (t : Δ¹) -> A [ t === 0_2 |-> x, t === 1_2 |-> y ]\n    ```\n\n7. There are now
  3 syntactic versions of `refl` with different amount of explicit annotations:\n
  \ `refl`, `refl_{x}` and `refl_{x : A}`\n\n8. There are now 2 syntactic versions
  of identity types (`=`): `x = y` and `x =_{A} y`.\n\n9. `recOR` now supports alternative
  syntax with an arbitrary number of subshapes:\n  `recOR( tope1 |-> term1, tope2
  |-> term2, ..., topeN |-> termN )`\n\n10. Now it is possible to have type ascriptions:
  `t as T`. This can help with ensuring types of subexpressions in parts of formalisations,
  or to upcast types.\n\n11. New (better) commands are now supported:\n\n    1. `#define
  <name> (<param>)* : <type> := <term>` — same as `#def`, but with full spelling of
  the word\n    2. `#postulate <name> (<param>)* : <type>` — postulate an axiom\n
  \   3. `#check <term> : <type>` — typecheck an expression against a given type\n
  \   4. `#compute-whnf <term>` — compute (WHNF) of a term\n    5. `#compute-nf <term>`
  — compute normal form of a term\n    6. `#compute <term>` — alias for `#compute-whnf`\n
  \   7. `#set-option <option> = <value>` — set a (typechecker) option:\n    \n        -
  `#set-option \"verbosity\" = \"silent\"` — no log printing\n        - `#set-option
  \"verbosity\" = \"normal\"` — log typechecking progress\n        - `#set-option
  \"verbosity\" = \"debug\"` — log every intermediate action\n          (may be useful
  to debug when some definition does not typecheck)\n\n    8. `#unset-option <option>`
  — revert option's value to its default\n\n#### Simple Shape Coercions\n\nIn some
  places, shapes (cube indexed tope families) can be used directly:\n\n1. In function
  parameters: `(Λ -> A) -> (Δ² -> A)` is the same as `({(t, s) : 2 * 2 | Λ (t, s)}
  -> A) -> ({(t, s) : 2 * 2 | Δ²} -> A)`\n\n2. In parameter types of lambda abstractions:
  `\\((t, s) : Δ²) -> ...` is the same as `\\{(t, s) : 2 * 2 | Δ² (t, s)} -> ...`\n\n####
  Better Type Inference\n\n1. It is now not required to annotate point variables with
  tope restrictions, the typechecker is finally smart enough to figure them out from
  the context.\n\n2. It is now possible to simply write `refl` in most situations.\n\n3.
  It is now possible to omit the index type in an identity type: `x = y`\n\n### Better
  output and error message\n\nThe output and error messages have been slightly improved,
  but not in a major way.\n\n### Internal representation\n\nA new internal representation
  (a version of second-order abstract syntax)\nallows to stop worrying about name
  captures in substitutions,\nso the implementation is much more trustworthy.\nThe
  new representation will also allow to bring in higher-order unification in the future,
  for better type inference, matching, etc.\n\nNew representation also allowed annotating
  each (sub)term with its type to avoid recomputations and some other minor speedups.
  There are still some performance issues, which need to be debugged, but overall
  it is much faster than version 0.1.0 already.\n"
basic-deps:
  optparse-generic: -any
  base: '>=4.7 && <5'
  array: -any
  bifunctors: -any
  mtl: -any
  rzk: -any
  template-haskell: -any
all-versions:
- 0.1.0
- 0.2.0
- 0.3.0
- 0.4.0
- 0.4.1
author: Nikolai Kudasov
latest: 0.4.1
description-type: markdown
description: |
  # rzk

  An experimental proof assistant for synthetic ∞-categories.

  See README at https://github.com/fizruk/rzk#readme.
license-name: BSD-3-Clause

homepage: https://github.com/lspitzner/multistate
changelog-type: markdown
hash: fbb0d8ade9ef73c8ed92488f5804d0ebe75d3a9c24bf53452bc3a4f32b34cb2e
test-bench-deps:
  base: <999
  hspec: ! '>=2 && <2.8'
  multistate: -any
  transformers: <0.6
maintainer: Lennart Spitzner <hexagoxel@hexagoxel.de>
synopsis: |-
  like mtl's ReaderT / WriterT / StateT, but more than one
  contained value/type.
changelog: "# Changelog for [`multistate` package](https://hackage.haskell.org/package/multistate)\n\n##
  0.8.0.2 *June 2019*\n\n  * Adapt for ghc-8.8 (optimistically; QuickCheck does not
  build so\n    tests are untested)\n\n## 0.8.0.1 *October 2018*\n\n  * Adapt for
  ghc-8.6 (really, this time)\n  * Make package -Wcompat-ible\n\n## 0.8.0.0 *April
  2018*\n\n  * Adapt for ghc-8.4\n  * Drop support for ghc<8.0\n  * Add class `MonadMultiGet`
  that roughly translates to \"any read access\"\n    (instances for Reader and State)\n
  \ * Add data-type `MultiGST` that has a single taggified HList instead of the\n
  \   three r, w, s lists with `MultiRWS`\n\n## 0.7.1.2 *August 2017*\n\n  * Adapt
  for ghc-8.2\n  \n  * Minor strictness fix for MultiRWS\n\n## 0.7.1.1 *May 2016*\n\n
  \ * Adapt for ghc-8\n\n## 0.7.1.0 *March 2016*\n\n  * Add new method `withoutMultiFoo`,
  inverse of `withMultiFoo`\n\n## 0.7.0.0 *February 2016*\n\n  * Add instances:\n\n
  \   + MonadIO\n    + Alternative\n    + MonadPlus\n    + MonadBase\n    + MonadTransControl\n
  \   + MonadBaseControl\n\n## 0.6.2.0 *June 2015*\n\n  * Add MonadFix instances\n\n##
  0.6.1.0 *June 2015*\n\n  * Export classes from transformer modules\n\n## 0.6.0.0
  *June 2015*\n\n  * Add `MultiRWST`\n\n  * Add inflate functions (e.g. `StateT _
  -> MultiStateT _`)\n\n  * Improve lazyness\n\n  * Move changelog from `README.md`
  to `changelog.md`\n\n## 0.5.0.0 *March 2015*\n    \n  * Breaking changes (!):\n\n
  \   Refactor some parts of the interface, see \"naming scheme\" in  the README;\n
  \   The changes are:\n\n      | old | new |\n      | --- | --- |\n      | `withMultiFoo`
  | `withMultiFooA` |\n      | `withMultiFoos` | `withMultiFoosA` |\n      | `mAskRaw`
  | `mGetRaw` |\n      | | `mPutRaw` |\n      | `evalMultiStateT` | `runMultiStateTNil`
  |\n      | `evalMultiStateTWithInitial` | `runMultiStateTA` |\n      | `evalMultiReaderT`
  | `runMultiReaderTNil` |\n      | `evalMultiReaderTWithInitial` | `runMultiReaderTA`
  |\n      | `execMultiWriterT` | `runMultiWriterTW` |\n\n  * Start using hspec; Add
  proper cabal test-suite.\n\n## 0.4.0.0: *March 2015*\n\n  * Refactor from `Control.Monad.*`
  to `Control.Monad.Trans.*`\n\n  * Put classes (`MonadMulti*`) into separate modules\n\n
  \ * Add Strict and Lazy variants\n\n  * Deprecate previous modules\n\n## 0.3.0.0
  *January 2015*\n\n  * Add `MultiWriter`\n\n  * Fixity for `(:+:)`\n\n  * support
  ghc-7.10\n\n## 0.2.0.0 *January 2015*\n\n  * Start using DataKinds and TypeOperators
  to make the HList\n    representation more readable. The translation roughly is:\n\n
  \   > ~~~~\n    > Null        -> '[]\n    > Cons a Null -> '[a]\n    > Cons a b
  \   -> a ': b\n    > TNull       -> HNil\n    > TCons a b   -> a :+: b\n    > ~~~~\n\n
  \ * Remove dependency on `tfp` package.\n\n## 0.1.3.2 *September 2014*\n  \n  *
  Add example\n\n  * Clean up / Add dependencies\n\n  * More documentation\n\n## 0.1.2
  *September 2014*\n\n  * Expose `HList` module\n\n  * Add haddocks\n\n## 0.1.1 *June
  2014*\n\n  * First version published on hackage\n"
basic-deps:
  base: ! '>=4.9 && <4.14'
  monad-control: ! '>=1.0 && <1.1'
  tagged: ! '>=0.7 && <0.9'
  mtl: ! '>=2.1 && <2.3'
  transformers-base: <0.5
  transformers: ! '>=0.3 && <0.6'
all-versions:
- 0.1.1
- 0.1.2
- 0.1.3.1
- 0.1.3.2
- 0.2.0.0
- 0.3.0.0
- 0.6.0.0
- 0.6.1.0
- 0.6.2.0
- 0.7.0.0
- 0.7.1.1
- 0.7.1.2
- 0.8.0.0
- 0.8.0.1
- 0.8.0.2
author: Jan Bracker, Lennart Spitzner
latest: 0.8.0.2
description-type: markdown
description: |
  # multistate

  [![Build Status](https://secure.travis-ci.org/lspitzner/multistate.svg)](http://travis-ci.org/lspitzner/multistate)
  [![Hackage](https://img.shields.io/hackage/v/multistate.svg)](https://hackage.haskell.org/package/multistate)

  ## Introduction

  When using multiple Reader/Writer/State transformers in the same monad
  stack, it becomes necessary to lift the operations in order to affect a
  specific transformer.
  Using heterogeneous lists (and all kinds of GHC extensions magic),
  this package provides transformers that remove that necessity:
  MultiReaderT/MultiWriterT/MultiStateT can contain a heterogeneous
  list of values.

  The type inferred for the getter/setter determines which value is
  read/written.

  ## Example

  ~~~~
  simpleExample :: IO ()
  simpleExample = runMultiStateTNil_       -- start with an empty state,
                                           --   i.e. :: MultiStateT '[] IO
                $ withMultiStateA 'H'      -- "adding" a char to the state
                $ withMultiStateA "ello, World!" -- and a string
                $ do                       -- so:
    -- the monad here is MultiStateT '[String, Char] IO
    let combinedPrint = do       -- no type signature necessary
          c  <- mGet             -- type of mGet inferred to be m Char
          cs <- mGet             --              inferred to be m String
          lift $ putStrLn (c:cs)
    combinedPrint
    mSet 'J'                     -- we modify the Char in the state.
                                 -- again, the type is inferred,
                                 -- without any manual lifting.
    combinedPrint
  ~~~~

  The output is:

  ~~~~
  Hello, World!
  Jello, World!
  ~~~~

  ( you can find both this and a more complex example
    in an executable in the package. )

  ## Error Messages

  If you try to execute an action that requires a specific type in the state,
  but the current state does not contain that type, the error message is
  something like

  ~~~~
  No instance for (Control.Monad.MultiState.ContainsType Foo '[]) x
  ~~~~

  where `Foo` is the missing type.

  ## Compatibility with Single-Valued Transformers

  It is possible to run single-valued actions inside multi-valued
  transformers using the `inflate` functions. A function transforming
  a multi-valued transformer with exactly one element into a
  single-valued transformer would be trivial, but it is currently not provided.

  ## Naming Scheme

  (Will refer to StateT in this paragraph, but equally valid for Reader/Writer)
  The mtl monad transformers make use of primarily three methods to "unwrap"
  a transformed value:
  `runStateT`, `evalStateT`, `execStateT`. These three all have a type
  matching the pattern `s -> t m a -> m b`, they differ in what `b` is.
  We will use a different naming scheme, for three reasons:

  1) "run", "eval" and "exec" are not in any way intuitive, and should be
     suffixed in any case.

  2) For MultiStateT, it makes sense to transform an existing transformer,
     adding another state. The signature would be close to that of runStateT,
     only without the unwrapping part, i.e. `s -> t m a -> t' m b`, where `s`
     is the initial state, and `t` is `t'` with another state added.

  3) Sometimes you might want to add/run a single state, or a bunch of them.
     For example, when running an arbitrary StateT, you would need to provide
     a HList of initial states, and would receive a HList of final states.

  Our naming scheme will instead be:

  1) `runStateT.*` unwraps a StateT. A suffix controls
     what exactly is returned by the function. There is a special version for
     when the list of states is Nil, `runStateTNil`.

  2) `withStateT.*` adds one or more states to a subcomputation. A suffix
     controls the exact return value.

  ~~~~
                   withStates
              /-------------------------------------------------------\
              |     withState                withState .. withState   v
  StateT '[s, ..] m --------> StateT '[..] m --------> .. --------> StateT '[] m
              |     <--------                                         |
              |   (withoutState)                                      |
              |                                                       |
              |                                                       |
              |   runStateT                            runStateTNil   |
              \--------------------> m .. <---------------------------/
  ~~~~

  Specific functions are (constraints omitted):

  ~~~~
  runMultiStateT = runMultiStateTAS
  runMultiStateTA  :: HList s -> MultiStateT s m a -> m a
  runMultiStateTAS :: HList s -> MultiStateT s m a -> m (a, s)
  runMultiStateTSA :: HList s -> MultiStateT s m a -> m (s, a)
  runMultiStateTS  :: HList s -> MultiStateT s m a -> m s
  runMultiStateT_  :: HList s -> MultiStateT s m a -> m ()

  runMultiStateTNil  :: MultiStateT '[] m a -> m a
  runMultiStateTNil_ :: MultiStateT '[] m a -> m ()

  withMultiState = withMultiStateAS
  withMultiStateA  :: s -> MultiStateT (s ': ss) m a -> MultiStateT ss m a
  withMultiStateAS :: s -> MultiStateT (s ': ss) m a -> MultiStateT ss m (a, s)
  withMultiStateSA :: s -> MultiStateT (s ': ss) m a -> MultiStateT ss m (s, a)
  withMultiStateS  :: s -> MultiStateT (s ': ss) m a -> MultiStateT ss m s
  withMultiState_  :: s -> MultiStateT (s ': ss) m a -> MultiStateT ss m ()

  withMultiStates = withMultiStatesAS
  withMultiStatesAS :: HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
  withMultiStatesSA :: HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1, a)
  withMultiStatesA  :: HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m a
  withMultiStatesS  :: HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1)
  withMultiStates_  :: HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m ()

  withoutMultiState :: MultiStateT ss m a -> MultiStateT (s ': ss) m a
  ~~~~

  ## Known Deficits

  This package currently lacks a complete set of "lifting instances", i.e.
  instance definitions for classes such as mtl's MonadWriter "over" the newly
  introduced monad transformers, as in

  ~~~~
  instance (MonadWriter w m) => MonadWriter w (MultiStateT c m) where ..
  ~~~~

  These "lifting instances" would be necessary
  to achieve full compatibility with existing transformers. Ping me if you
  find anything specific missing.

  ## Changelog

  See changelog.md
license-name: BSD-3-Clause

all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
- 0.2.0.0
author: Arthi-chaud
basic-deps:
  base: '>=4.7 && <5'
  bytestring: '>=0.11.0.0 && <0.13'
  deepseq: '>=1.4.6.1 && <1.6'
  extra: '>=1.0 && <2.0'
  linear-base: '>=0.4.0 && <0.5.0'
  mtl: '>=2.2.2 && <2.4'
  packed-data: '>=0'
  template-haskell: '>=2.18.0.0 && <=2.24.0.0'
changelog: "[0.2.0.0] â€” July 2025 \n\n* __Breaking Changes__:\n  * Complete rewrite
  of the 'NeedsBuilder'\n    * Please refer to the examples to see how to build packed
  data\n  * Dropping support for GHC < 9.10. \n    * 'NeedsBuilder' relies on linear
  types and type inference is broken before that version\n\n* Features:\n  * 'PackedReader'
  has been rewritten, however the API should be retro-compatible\n  * The code generator
  defines pattern synonyms, allowing one to pattern-match on packed data using a native
  'case' expression\n    * Refer to the examples (e.g. Sum) to see how it works\n
  \   * The generated 'case' functions are still generated, but they use these pattern
  synonyms under the hood\n"
changelog-type: markdown
description: "# `packed-data` for Haskell\n\n![Hackage Version](https://img.shields.io/hackage/v/packed-data)\n[![Doc](https://img.shields.io/badge/Documentation-Haddock-purple)](https://hackage.haskell.org/package/packed-data-0.1.0.1/docs/Data-Packed.html)\n\nBuild,
  traverse and deserialise packed data in Haskell. \n\n## What is this for?\n\nWhen
  components of a system exchange data, each component has to make sure that they
  send data in a way the recipient will be able to read. A simple example is an API,
  sending JSON data for the client to parse. This process of decoding the data takes
  time, especially for big objects like HTML pages.\n\n*Packed* data is data serialised
  into a binary format that is usable as-is, meaning there is no need to parse it
  to be able to use it. Another perk of such format is that it can be stored in files
  easily.\n\n\n`packed-data` allows using packed data type-safely, without explicit
  pointer arithmetic.\n\n## A portable library\n\nUnlike other implementations of
  packed-data-support (e.g. [Gibbon](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2017.26)),
  `packed-data` is a library that does not modify the compiler in any way. It relies
  solely on already existing libraries (like `ByteString`), Template Haskell and common
  GHC extensions. This means that, virtually, `packed-data` can be used with any version
  of GHC (as of today, it has been tested GHC 9.2-9.12).\n\nIts API is inspired by
  an example from the [Linear Haskell](https://dl.acm.org/doi/10.1145/3158093) paper
  (code available [here](https://github.com/tweag/linear-types/blob/12bed0d41d599e2697b29c5c4b37990642970e6c/Examples/src/Cursors/PureStorable.hs)).\n\n##
  Example\n\n```haskell\n\nimport qualified Data.Packed.Reader as R\nimport Data.Packed.Reader\nimport
  Data.Packed\n\ndata Tree a = Leaf a | Node (Tree a) (Tree a)\n\n$(mkPacked ''Tree
  '[])\n\n-- Compute sum of values in the tree\n-- Using the generated 'caseTree'
  function\nsumPacked :: PackedReader '[Tree Int] r Int\nsumPacked =\n    caseTree
  -- Generated by Template Haskell\n        ( R.do -- If Tree is a Leaf\n            !n
  <- reader\n            R.return n\n        )\n        ( R.do -- If Tree is a Node\n
  \           !left <- sumPacked\n            !right <- sumPacked\n            let
  !res = left + right\n            R.return res\n        )\n-- Alternatively, you
  can use generated pattern synonyms\nsumPacked = PackedReader $ \\case\n    PackedLeaf
  l -> reader `with` l\n    PackedNode n -> threadedWith n $ R.do\n        !left <-
  sumPacked2\n        !right <- sumPacked2\n        let !res = left + right\n        R.return
  res\n\n\ngetSum :: Packed '[Tree Int] -> IO Int\ngetSum = runReader sumPacked\n\npackTree
  :: Tree Int -> Packed '[Tree Int] \npackTree = pack \n```\n\nTake a look at the
  `benchmark` directory for more examples.\n\nDocumentation is available on [Hackage](https://hackage.haskell.org/package/packed-data-0.1.0.1/docs/Data-Packed.html)\n\n##
  Benchmark\n\nTo run benchmarks, run the following command:\n\n```\nstack bench packed-data:bench:tree-bench\n#
  Saves the report as CSV\nstack bench packed-data:bench:tree-bench --ba --csv bench.csv\n#
  Saves the report, and runs a specific test\nstach bench packed-data:bench:tree-bench
  --ba '--csv bench.csv sums'\n```\n\n"
description-type: markdown
hash: 053f28c6527b6ee90aa57b57d99e4a6d6166638cb10ec74b4f3ed0e2c9030755
homepage: https://github.com/Arthi-chaud/packed-haskell#readme
latest: 0.2.0.0
license-name: BSD-3-Clause
maintainer: aj530@kent.ac.uk
synopsis: ''
test-bench-deps:
  aeson: '>=0'
  base: '>=4.7 && <5'
  bytestring: '>=0'
  bytestring-strict-builder: '>=0.4.5 && <0.5'
  cassava: '>=0'
  criterion: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  filepath: '>=0'
  hspec: '>=0'
  listsafe: '>=0'
  mtl: '>=0'
  optparse-applicative: '>=0'
  packed-data: '>=0'
  process: '>=0'
  scientific: '>=0'
  split: '>=0'
  vector: '>=0'

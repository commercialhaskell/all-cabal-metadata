all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
author: Arthi-chaud
basic-deps:
  base: '>=4.7 && <5'
  bytestring: '>=0.11.0.0 && <0.13'
  bytestring-strict-builder: '>=0.4.5 && <0.5'
  deepseq: '>=1.4.6.1 && <1.6'
  extra: '>=1.0 && <2.0'
  mtl: '>=2.2.2 && <2.4'
  packed-data: '>=0'
  template-haskell: '>=2.18.0.0 && <=2.24.0.0'
changelog: ''
changelog-type: ''
description: "# `packed-data` for Haskell\n\n![Hackage Version](https://img.shields.io/hackage/v/packed-data)\n[![Doc](https://img.shields.io/badge/Documentation-Haddock-purple)](https://hackage.haskell.org/package/packed-data-0.1.0.1/docs/Data-Packed.html)\n\nBuild,
  traverse and deserialise packed data in Haskell. \n\n## What is this for?\n\nWhen
  components of a system exchange data, each component has to make sure that they
  send data in a way the recipient will be able to read. A simple example is an API,
  sending JSON data for the client to parse. This process of decoding the data takes
  time, especially for big objects like HTML pages.\n\n*Packed* data is data serialised
  into a binary format that is usable as-is, meaning there is no need to parse it
  to be able to use it. Another perk of such format is that it can be stored in files
  easily.\n\n\n`packed-data` allows using packed data type-safely, without explicit
  pointer arithmetic.\n\n## A portable library\n\nUnlike other implementations of
  packed-data-support (e.g. [Gibbon](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2017.26)),
  `packed-data` is a library that does not modify the compiler in any way. It relies
  solely on already existing libraries (like `ByteString`), Template Haskell and common
  GHC extensions. This means that, virtually, `packed-data` can be used with any version
  of GHC (as of today, it has been tested GHC 9.2-9.12).\n\nIts API is inspired by
  an example from the [Linear Haskell](https://dl.acm.org/doi/10.1145/3158093) paper
  (code available [here](https://github.com/tweag/linear-types/blob/12bed0d41d599e2697b29c5c4b37990642970e6c/Examples/src/Cursors/PureStorable.hs)).\n\n##
  Example\n\n```haskell\n\nimport qualified Data.Packed.Reader as R\nimport Data.Packed\n\ndata
  Tree a = Leaf a | Node (Tree a) (Tree a)\n\n$(mkPacked ''Tree '[])\n\n-- Compute
  sum of values in the tree\nsumPacked :: PackedReader '[Tree Int] r Int\nsumPacked
  =\n    caseTree -- Generated by Template Haskell\n        ( R.do -- If Tree is a
  Leaf\n            !n <- reader\n            R.return n\n        )\n        ( R.do
  -- If Tree is a Node\n            !left <- sumPacked\n            !right <- sumPacked\n
  \           let !res = left + right\n            R.return res\n        )\n\ngetSum
  :: Packed '[Tree Int] -> IO Int\ngetSum = runReader sumPacked\n\npackTree :: Tree
  Int -> Packed '[Tree Int] \npackTree = pack \n```\n\nTake a look at the `benchmark`
  directory for more examples.\n\nDocumentation is available on [Hackage](https://hackage.haskell.org/package/packed-data-0.1.0.1/docs/Data-Packed.html)\n\n##
  Benchmark\n\nTo run benchmarks, run the following command:\n\n```\nstack bench\n#
  Saves the report as CSV\nstack bench --ba --csv bench.csv\n# Saves the report, and
  runs a specific test\nstach bench --ba '--csv bench.csv sums'\n```\n\n"
description-type: markdown
hash: 11eb13f62ac6940538505fa8a0f74d22caa2198a122422a4513c0c7b6c140372
homepage: https://github.com/Arthi-chaud/packed-haskell#readme
latest: 0.1.0.3
license-name: BSD-3-Clause
maintainer: aj530@kent.ac.uk
synopsis: ''
test-bench-deps:
  aeson: '>=0'
  base: '>=4.7 && <5'
  bytestring: '>=0'
  bytestring-strict-builder: '>=0.4.5 && <0.5'
  cassava: '>=0'
  criterion: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  filepath: '>=0'
  hspec: '>=0'
  listsafe: '>=0'
  mtl: '>=0'
  optparse-applicative: '>=0'
  packed-data: '>=0'
  process: '>=0'
  scientific: '>=0'
  split: '>=0'
  vector: '>=0'

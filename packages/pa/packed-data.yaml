all-versions:
- 0.1.0.0
author: Arthi-chaud
basic-deps:
  base: '>=4.7 && <5'
  bytestring: '>=0.12.1.0 && <0.13'
  bytestring-strict-builder: '>=0.4.5 && <0.5'
  deepseq: '>=1.5.0.0 && <1.6'
  extra: '>=1.0 && <2.0'
  mtl: '>=2.3.1 && <2.4'
  packed-data: '>=0'
  template-haskell: '>=2.22.0.0 && <2.23'
  time: '>=1.14 && <1.15'
changelog: ''
changelog-type: ''
description: "# `Packed` Haskell\n\nBuild, traverse and deserialise packed data in
  Haskell. \n\n## What is this for?\n\nWhen components of a system exchange data,
  each component has to make sure that they send data in a way the recipient will
  be able to read. A simple example is an API, sending JSON data for the client to
  parse. This process of decoding the data takes time, especially for big objects
  like HTML pages.\n\n*Packed* data is data serialised into a binary format that is
  usable as-is, meaning there is no need to parse it to be able to use it. Another
  perk of such format is that it can be stored in files easily.\n\n\n`packed` allows
  using packed data type-safely, without explicit pointer arithmetic.\n\n## A portable
  library\n\nUnlike other implementations of packed-data-support (e.g. [Gibbon](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2017.26)),
  `packed` is a library that does not modify the compiler in any way. It relies solely
  on already existing libraries (like `ByteString`), Template Haskell and common GHC
  extensions. This means that, virtually, `packed` can be used with any version of
  GHC (although, as of today, it has only been tested with GHC 9.10).\n\nIts API is
  inspired by an example from the [Linear Haskell](https://dl.acm.org/doi/10.1145/3158093)
  paper (code available [here](https://github.com/tweag/linear-types/blob/12bed0d41d599e2697b29c5c4b37990642970e6c/Examples/src/Cursors/PureStorable.hs)).\n\n##
  Example\n\n```haskell\n\nimport qualified Data.Packed.Reader as R\nimport Data.Packed\n\ndata
  Tree a = Leaf a | Node (Tree a) (Tree a)\n\n$(mkPacked ''Tree '[])\n\n-- Compute
  sum of values in the tree\nsumPacked :: PackedReader '[Tree Int] r Int\nsumPacked
  =\n    caseTree -- Generated by Template Haskell\n        ( R.do -- If Tree is a
  Leaf\n            !n <- reader\n            R.return n\n        )\n        ( R.do
  -- If Tree is a Node\n            !left <- sumPacked\n            !right <- sumPacked\n
  \           let !res = left + right\n            R.return res\n        )\n\ngetSum
  :: Packed '[Tree Int] -> IO Int\ngetSum = runReader sumPacked\n\npackTree :: Tree
  Int -> Packed '[Tree Int] \npackTree = pack \n```\n\nTake a look at the `benchmark`
  directory for more examples.\n\n## Benchmark\n\nTo run benchmarks, run the following
  command:\n\n```\nstack bench\n# Saves the report as CSV\nstack bench --ba --csv
  bench.csv\n# Saves the report, and runs a specific test\nstach bench --ba '--csv
  bench.csv sums'\n```\n\nNote: Graphs of the benchmark results will be generated
  in the `graph/` directory when saving the report as CSV.\n"
description-type: markdown
hash: cb64f9b7189613887b0119e98f3f944566b70f20d4756206d1d37f0235bab43a
homepage: https://github.com/Arthi-chaud/packed-haskell#readme
latest: 0.1.0.0
license-name: BSD-3-Clause
maintainer: aj530@kent.ac.uk
synopsis: ''
test-bench-deps:
  Chart: '>=0'
  Chart-diagrams: '>=0'
  aeson: '>=0'
  base: '>=4.7 && <5'
  bytestring: '>=0'
  bytestring-strict-builder: '>=0.4.5 && <0.5'
  cassava: '>=0'
  criterion: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  filepath: '>=0'
  hspec: '>=0'
  listsafe: '>=0'
  mtl: '>=0'
  optparse-applicative: '>=0'
  packed-data: '>=0'
  split: '>=0'
  vector: '>=0'

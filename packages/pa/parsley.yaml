homepage: https://github.com/j-mie6/ParsleyHaskell
changelog-type: markdown
hash: 1aa0292458eb2e50c6e02f23df5dc87b84ae0e548b3587b8e6e7fcf325f1b6ec
test-bench-deps: {}
maintainer: Jamie Willis <j.willis19@imperial.ac.uk>
synopsis: A fast parser combinator library backed by Typed Template Haskell
changelog: |-
  # Revision history for `parsley`

  ## 0.1.0.0  -- 2021-05-22

  * First version. Released on an unsuspecting world.

  ## 0.1.0.1  -- 2021-05-22

  * Moved tests and benchmarks into a subproject, which will be easier later down the line.
  * Removed useless `dump-core` flag (only used by test and bench, not by the library).
  * Fleshed out README properly!

  ## 0.1.1.0  -- 2021-06-10

  * Added `IF_S`, `LAM_S` and `LET_S` to `Defunc`, which can be used with overloaded syntax
  * Admin: Removed `idioms-plugin` and `lift-plugin` from the test suite, depending on `parsley-garnish` instead
  * Fixed building with GHC 9
basic-deps:
  bytestring: '>=0.10.8 && <0.12'
  dependent-sum: '>=0.7.1 && <0.8'
  base: '>=4.10 && <4.16'
  unordered-containers: '>=0.2.13 && <0.3'
  text: '>=1.2.3 && <1.3'
  dependent-map: '>=0.4.0 && <0.5'
  array: '>=0.5.2 && <0.6'
  containers: '>=0.6 && <0.7'
  pretty-terminal: '>=0.1.0 && <0.2'
  ghc-prim: '>=0.5.3 && <1'
  mtl: '>=2.2.1 && <2.3'
  hashable: '>=1.2.7.0 && <1.4'
  template-haskell: '>=2.14 && <3'
all-versions:
- 0.1.0.1
- 0.1.1.0
author: Jamie Willis, Parsley Contributors
latest: 0.1.1.0
description-type: markdown
description: |-
  # Parsley ![GitHub Workflow Status](https://img.shields.io/github/workflow/status/j-mie6/ParsleyHaskell/CI) ![GitHub release](https://img.shields.io/github/v/release/j-mie6/ParsleyHaskell) [![GitHub license](https://img.shields.io/github/license/j-mie6/ParsleyHaskell.svg)](https://github.com/j-mie6/ParsleyHaskell/blob/master/LICENSE) ![GitHub commits since latest release (by SemVer)](https://img.shields.io/github/commits-since/j-mie6/ParsleyHaskell/latest)

  ## What is Parsley?
  Parsley is a very fast parser combinator library that outperforms the other libraries in both the
  parsec family, as well as Happy. To make this possible, it makes use of Typed Template Haskell
  to generate the code for the parsers.

  ## How do I use it? [![Hackage Version](https://img.shields.io/hackage/v/parsley)](https://hackage.haskell.org/package/parsley) ![Dependent repos (via libraries.io)](https://img.shields.io/librariesio/dependent-repos/hackage/parsley)
  Parsley is distributed on Hackage, and can be added by depending on the package `parsley`.

  The version policy adheres to the regular Haskell PVP, but the two major versions are distinguished
  in Parsley: the first is the _User API_ major version, which represents backwards incompatible changes
  in the regular PVP sense that could affect any users of the library; the second version is the
  _Internal API_ major version, which would only effect users who use part of the internal parsley
  modules. As such, for people that are **not** explicitly importing anything from `Parsley.Internal`, or
  its submodules, the second major version does not matter: `0.2.0.0` and `0.3.0.0` would be compatible,
  for instance.

  To use it, you'll need to write you parsers in another file from where they will be used: this is
  due to Template Haskell.

  ### How does Parsley being a _Staged Selective_ library change its use?
  By being a _Selective_ Parser Combinator library, Parsley does not support monadic operations such
  as `(>>=)` or `return`. Instead, the most powerful operations are `select` or `branch`. Most monadic
  power can be recovered using the functionality provided by `Parsley.Register`, as well as the
  selectives.

  The reason monads are not supported is because of the _Staging_: Parsley parsers are compiled ahead
  of time to produce fast code, but this means the entirety of the parser must be known before any
  input is provided, ruling out dynamic monadic operations. The use of staging (in this instance provided
  by Typed Template Haskell) means that the signatures of the combinators do not correspond to their
  counterparts in other libraries: they don't use raw values, they use code of values. A consequence
  of this is that Parsley does not implement instances of `Functor`, `Applicative`, `Alternative`,
  or indeed `Selective`; `do`-notation also cannot be used even with `ApplicativeDo`, except perhaps
  if `RebindableSyntax` is used.

  Code is provided to the combinators by way of the datatype `WQ` (or `Defunc` if you're feeling fancy),
  which pairs a normal value with its Haskell code representation:

  ```hs
  data WQ a = WQ a (Code a)
  ```

  This gives us combinators like:

  ```hs
  pure :: WQ a -> Parser a
  satisfy :: WQ a -> Parser a

  char :: Char -> Parser a
  char c = satisfy (WQ (== c) [||(== c)||])
  ```

  Using `WQ` explicitly like this can get annoying, which is what the `parsley-garnish` package is for!
  Currently, the garnish provides one plugin called `OverloadedQuotes`, which replaces the behaviour of
  the default _Untyped_ Template Haskell quotes in a file so that they produce one of `WQ` or `Defunc`.
  See the `Parsley.OverloadedQuotesPlugin` module in the [`parsley-garnish`](https://hackage.haskell.org/package/parsley-garnish) package for more information.

  ## How does it work?
  In short, Parsley represents all parsers as Abstract Syntax Trees (ASTs). The representation of the
  parsers the users write is called the Combinator Tree, which is analysed and optimised by Parsley.
  This representation is then transformed into an Abstract Machine in CPS form, this is analysed further
  before being partially evaluated at compile-time to generate high quality Haskell code. For the long
  version, I'd recommend checking out the paper!

  ## Bug Reports
  If you encounter a bug when using Parsley, try and minimise the example of the parser (and the input)
  that triggers the bug. If possible, make a self contained example: this will help me to identify the
  issue without too much issue. It might be helpful to import `Parsley.Internal.Verbose` to provide a
  debug dump that I can check out.

  ## References
  * This work spawned a paper at ICFP 2020: [**Staged Selective Parser Combinators**](https://dl.acm.org/doi/10.1145/3409002)

  ### Talks
  For talks on how writing parsers changes when using Parsley see either of these:
  * [*Garnishing Parsec with Parsley*](https://www.youtube.com/watch?v=tJcyY9L2z84) - Berlin Functional Programming Group, January 2021
  * [*Exploring Parsley: Working with Staged Selective Parsers*](https://www.youtube.com/watch?v=Zhu-cPY1eac) - MuniHac 2020

  For the technical overview of how Parsley works:
  * [*Staged Selective Parser Combinators*](https://www.youtube.com/watch?v=lH65PvRgm8M) - ICFP 2020
license-name: BSD-3-Clause

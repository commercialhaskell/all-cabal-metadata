homepage: https://github.com/anton-k/mig#readme
changelog-type: markdown
hash: bdc3b0ceac82b1ff040e740db33ff6d744e20049e60dd00ad7c5b211cf36ac83
test-bench-deps: {}
maintainer: anton.kholomiov@gmail.com
synopsis: Build lightweight and composable servers
changelog: |
  # Changelog for `combo`

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
  and this project adheres to the
  [Haskell Package Versioning Policy](https://pvp.haskell.org/).

  ## Unreleased

  ## 0.1.0.0 - YYYY-MM-DD
basic-deps:
  warp: -any
  exceptions: -any
  bytestring: -any
  wai: -any
  case-insensitive: -any
  base: '>=4.7 && <5'
  blaze-markup: -any
  text: -any
  http-api-data: -any
  containers: -any
  mtl: -any
  blaze-html: -any
  http-types: -any
  aeson: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
author: Anton Kholomiov
latest: 0.1.0.2
description-type: markdown
description: "# Mig - library to write composable and lightweight servers\n\nThe Mig
  is a library to build lightweight composable servers.\nThere are only couple of
  combinators and Monoid instance.\nWith it we can build type-safe servers from small
  parts.\n\nThe main strength is ability to build servers from parts\nand flexible
  DSL which features only small amount of functions.\n\nI like [scotty](https://hackage.haskell.org/package/scotty)
  for being very \nsimple and [servant](https://hackage.haskell.org/package/servant-server)
  for being composable, type-safe \nand how functions are used as handlers which provides
  decoupling of Web-handlers\nfrom application logic.\nBut sometimes scotty feels
  too imperative and lacks servant's composability.\nAnd servant with type-level magic
  and huge errors can feel to complicated.\nSo I wanted to create something in the
  middle. Something composable and simple \nat the same time.\nThe name `mig` (pronounced
  as meeg) is a russian word for \"instant moment\".\n\n## How to install\n\nWe can
  install from [hackage](https://hackage.haskell.org/package/mig) to use with cabal
  or use this snippet\nto depend on latest source in stack. Put it in `stack.yaml`
  file:\n\n```yaml\nextra-deps:\n- git: https://github.com/anton-k/mig\n  commit:
  be9269b83bb944d8dede4d36a51fb1aa6fb26516\n```\n\n## Quick start guide\n\nLet's create
  something cool with the library.\n\n### Hello world server\n\nAs a starting point
  let's look at hello-world server:\n\n```haskell\nmodule Main where\n\nimport Mig\nimport
  Data.Text (Text)\n\nmain :: IO ()\nmain = runServer 8080 server\n\nserver :: Server
  IO\nserver =\n  \"api\" /. \"v1\" /. \"hello\" /. hello\n\nhello :: Get Json IO
  Text\nhello = pure \"Hello World\"\n```\n\nThe main type is `Server`. We can think
  about it as function from request to response\nwhich sometimes can produce no output:\n\n```haskell\nnewtype
  Server m = Server (Req -> m (Maybe Resp))\n```\n\nIt is parametrised by the underlying
  monad. \nSo far library supports only three types of monads:\n* `IO`-monad\n* `ReaderT`
  over `IO` with possible newtype-wrappers.\n* `ReaderT env (ExceptT err) IO` - reader
  with `ExceptT` over `IO`.\n\nAlso we can create our custom monads as newtype wrappers
  over those monads\nand be able to use it with library. To do that we need to derive
  `HasServer` instance.\nIt can be done with deriving strategies (see `examples/Counter.hs`).
  \n\nTo run server we can use functions:\n\n```haskell\n-- | Runs server on port\nrunServer
  :: Int -> Server IO -> IO ()\nrunServer port server = ...\n\n-- | Convert to WAI
  application\ntoApplication :: ServerConfig -> Server IO -> Wai.Application\n```\n\nThe
  HTTP-method is specified with newtype wrapper `Get`:\n\n```haskell\nnewtype Get
  ty m a = Get (m a)\n```\n\nIt has phantom-argument for type of the response. In
  this example we return `Text`\nas response body with 200 ok status. It seems that
  we need two typed to specify result `ty` and `a`.\n\nBeside `Text` we also can return
  `Json`, `Html`, raw `ByteString` as response. But we have\nseveral ways to render
  handler result to response body. For example we can convert Int as Text\nand also
  as JSON. To distinguish between them we use phantom type for the type of response
  body.\n\n### Using monoid for route branches\n\nThe server has Monoid instance.
  With it we can build\nservers from several routes:\n\n```haskell\nserver :: Server
  IO\nserver =\n  \"api\" /. \"v1\" /.\n     mconcat\n       [ \"hello\" /. handle
  \"hello\"\n       , \"bye\" /. handle \"bye\"\n       ]\n\nhandle :: Text -> Get
  Text IO Text\nhandle prefix = Get $ pure $ prefix <> \" world\"\n```\n\nNote how
  branching by path is done with `Monoid` method `mconcat`.\nWe use `Get` inside the
  function `handle`.\n\n### Query parameters \n\nWe can turn a \"world\" into parameter:\n\n```haskell\nserver
  :: Server IO\nserver =\n  \"api\" /. \"v1\" /.\n     mconcat\n       [ \"hello\"
  /. handle \"hello\"\n       , \"bye\" /. handle \"bye\"\n       ]\n\nhandle :: Text
  -> Query \"who\" Text -> Get Text IO Text\nhandle prefix (Query name) = Get $ pure
  $ prefix <> \" \" <> name\n```\n\nBy changing the signature of the function we have
  requested required query\nparameter called `\"who\"`. We use type-level string literals
  to encode name of the parameter.\nIt is provided with url: `api/v1/hello?who=john`.\n\nIf
  we use `Optional` instead of `Query` parameter becomes optional and value\nis wrapped
  in `Maybe`.\n\n### Capture URI-parts\n\nIn the example we can note the duplication
  of path name `\"hello/bye\"` and that we\npass the same constants to our function
  `handle`.\nWe can capture that part of URI as argument with `Capture` argument:\n\n```haskell\nserver
  :: Server IO\nserver =\n  \"api\" /. \"v1\" /. handle\n\nhandle :: Capture Text
  -> Query \"who\" Text -> Get Text IO Text\nhandle (Capture prefix) (Query name)
  = Get $ pure $ prefix <> \" \" <> name\n```\n\nThis example is equivalent to previous
  one. Only we capture part of \nthe URI as text and use it in the message. Also with
  capture we can append all sorts of prefixes.\n\n### Route arguments\n\nThe cool
  part of it is that handle function can have any amount of input arguments\nwrapped
  in special newtypes and it will be decoded to proper server route.\n\nWe have newtypes
  for:\n\n* `Query \"name\" type` - required query parameter (`FromHttpApiData`)\n*
  `Optional \"name\" type` - optional query parameter (`FromHttpApiData`)\n* `Capture
  type` - capture part of the URI between slashes `/`. (`FromHttpApiData`)\n* `Body
  type` - input JSON body (`FromJSON`)\n* `RawBody` - input body as raw lazy bytestring
  (is `ByteString`)\n* `FormBody` - input URL-encoded form (it often comes from HTML-forms)
  (`FromForm`)\n* `Header \"name\" ty` - access header by name (`FromHttpApiData`)\n*
  `PathInfo` - access path info relative to the server (is `[Text]`)\n\nClass at in
  the parens is which class is used for convertion.\nOften we can derive the instance
  of that class with newtype-deriving or with Generic-deriving.\nWe can change the
  number of arguments because the function `(/.)` is overloaded\nby second argument
  and it can accept anything convertible to `Server` or an\ninstance of the class
  `ToServer`.\n\n### Route outputs\n\nAlso `newtype` wrappers can control behavior
  of the output.\nWe already saw `Get`-wrapper. It encodes Http-method. Also we can
  use\n`Post`, `Put`, `Delete`, etc.\n\nWe have output wrappers for:\n\n* http-methods:
  `Get`, `Post`, `Put`, `Delete`, etc.\n* append headers: `AddHeaders a`\n* change
  response status: `SetStatus a`\n* return error: `Either (Error ty) a`\n\nWe can
  nest wrappers to apply several behaviors. \nFor example we can update header, possible
  return error and return Post-method:\n\n```haskell\nhandle :: Query \"foo\" Int
  -> Post Json IO (Either (Error Text) (AddHeaders FooResponse))\n```\n\nHere `FooResponse`
  should have `ToJSON` instance. Possible implementation:\n\n```haskell\ndata FooResponse
  = FooResponse\n  { code :: Int\n  , message :: Text\n  }\n  deriving (Generic, ToJSON)\n\nhandle
  (Query code) = Post $ do\n  message <- readMessageBycode code\n  pure $ Right $
  AddHeaders headers $ FooResponse code message\n  where\n    headers = [\"Trace-Code\",
  Nothing]\n```\n\n### Errors\n\nThe errors can be returned from route with `(Either
  (Error ty))` output wrapper.\nWe signify to the user that our route returns errors.\nThe
  `Error` type contains status and details for the error:\n\n```haskell\ndata Error
  a = Error\n  { status :: Status\n    -- error status\n  , body :: a\n    -- message
  or error details\n  }\n```\n\nNote that `ToServer` instance takes care about proper
  conversion of the error\nvalue to the same response type as the main happy route
  branch.\n\n## Specific servers\n\nIf we write server of specific type. For example
  if we write JSON API with IO-based server\nwe can import specific route newtype-wrappers:\n\n```haskell\nimport
  Mig.Json.IO\n```\n\nIt will simplify the signatures of the functions:\n\n```haskell\nhandle
  :: Body FooRequest -> Post FooResponse\nhandle (Body req) = Post $ do\n  resp <-
  readResp req\n  pure resp\n```\n\nAs `Post` becomes specified to `Json` and `IO`:\n\n```haskell\nnewtype
  Post a = Post (IO a)\n```\n\nThere are similar modules for `Html`. If your server
  is not `IO`-based\nUse import of `Mig.Json`.\n\n## Reader based servers\n\nThere
  is very popular pattern of writing servers with monad `ReaderT ServerContext IO`.\nThe
  server context can contain shared context of the server and mutable stated wrapped
  in `TVar`'s\nor IO-based interfaces. We can access the context inside handler and
  shared for all routes.\n\nThe `mig` has support for Reader-pattern like monads.\nLet's
  build a simple counter server as example. User can see current value with `get`
  and add \nto the internal counter with method `put`.\n\nLet's define application
  monad first\n\n```haskell\nnewtype App a = App (ReaderT Env IO a)\n  deriving newtype
  (Functor, Applicative, Monad, MonadReader Env, MonadIO, HasServer)\n\ndata Env =
  Env\n  { current :: IORef Int\n  }\n```\n\nNote the deriving of `HasServer`. It
  is defined for reader over IO.\nWith it we can convert the `Server App` to `IO`-based
  server:\n\n```haskell\nrenderServer :: Server App -> Env -> IO (Server IO)\n```\n\nSo
  we can define our handlers with App-monad and render to `IO` to convert it to WAI-application\nand
  run as server.\n\nLet's define the server:\n\n```haskell\ncounter :: Server App\ncounter
  = do\n  \"counter\" /. \"api\" /.\n    mconcat\n      [ \"get\" /. handleGet\n      ,
  \"put\" /. handlePut\n      ]\n\nhandleGet :: Get Text App Int\nhandelGet = -- todo\n\nhandlePut
  :: Capture Int -> Post Text App ()\nhandlePut (Capture val) = -- todo\n```\n\nWe
  can render the server and run it:\n\n```haskell\nmain :: IO ()\nmain = do\n  env
  <- initEnv\n  server <- renderServer counter env\n  runServer 8085 server\n```\n\nLet's
  define the missing parts:\n\n```haskell\ninitEnv :: IO Env\ninitEnv = Env <$> newIORef
  0\n\nhandleGet :: Get Text App Int\nhandleGet = Get $ do\n  ref <- asks (.current)\n
  \ liftIO $ readIORef ref\n\nhandlePut :: Capture Int -> Get Json App ()\nhandlePut
  (Capture val) = Get $ do\n  ref <- asks (.current)\n  liftIO $ atomicModifyIORef'
  ref (\\cur -> (cur + val, ()))\n```\n\nSo we have studied how we can use custom
  Reader-based monads.\nThe trick is to derive `HasServer` on newtype wrapper and
  \nuse method `renderServer` to convert to `IO`-based server.\n\nPS: this is an open
  question. Is it possible to create a function:\n\n```haskell\nhoistServer :: (Monad
  m, Monad n) => (forall a . m a -> n a) -> Server m -> Server n\n```\n\nAs it is
  defined in the servant. With it we would be able to use any monad.\nBut I'm not
  sure how to achieve that. Help is appreciated, as it will make library even better!\nI
  guess it can be done with `MonadBaseControl` and if we turn the WAI function to:\n\n```haskell\ntoApplication
  :: MonadBaseControl m => Server m -> m Wai.Application\n```\n\n## Conclusion\n\nWe
  have walked through the whole library. As a summary of it's functions: we can \n\n*
  compose servers with path operator `(/.)` and monoid instance. \n* define handlers
  as functions with various input and output newtype-wrappers\n\nI hope that you like
  the concept and will enjoy the library. See the directory [`examples`](https://github.com/anton-k/mig/tree/main/examples)
  for more examples.\nWe can run the examples with stack by running:\n\n```\n> make
  run\n```\nin this repo. Change the Makefile to try different examples.\n\n\nAlso
  there are repos that show how to use library with most common\nHaskell patterns
  to create web-servers:\n\n* [Handle pattern](https://github.com/anton-k/handle-pattern-mig-app)\n*
  [Reader patten](https://github.com/anton-k/reader-pattern-mig-app)\n\nThis is a
  very first sketch of the library. I guess it can become even better. \nThe feedback
  is appreciated.\n\n"
license-name: BSD-3-Clause

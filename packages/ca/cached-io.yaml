all-versions:
- 0.1.0.1
- 0.1.1.0
- 1.1.0.0
- 1.2.0.0
- 1.3.0.0
- 1.3.1.0
author: SumAll, Inc.
basic-deps:
  base: '>=4.13.0.0 && <4.22'
  exceptions: '>=0.10.4 && <0.11'
  stm: '>=2.5 && <2.6'
  time: '>=1.9.3 && <1.16'
changelog: |
  # Revision history for cached-io

  ## 1.3.1.0

  - Add `cachedSTM` versions of all bindings.
  - Correctly transition the internal state to `Initializing` when filling the cache for the first time.
  - Remove unused `transformer` dependency

  ## 1.3.0.0

  - **Breaking** Caching functions previously returned `m (t a)`, but it was easy to accidentally use `join` when `m` and `t` were the same monad (eg. `IO (IO a)`), and not get any caching at all. These functions now use a `Cached` newtype for `t a` to make it more difficult to misuse.

  ### Migrating from <=1.2.0.0 to 1.3.0.0

  ```haskell
  -- Previous versions
  f :: IO ()
  f = do
    cachedAction <- cachedIO action :: IO (IO a)
    cachedResult <- cachedAction

  -- New version
  f :: IO ()
  f = do
    cachedAction <- cachedIO action :: IO (Cached IO a)
    cachedResult <- runCached cachedAction
  ```

  ## 1.2.0.0

  Thank you [glasserc](https://github.com/glasserc) for your work on previous versions, and a special thanks to
  [Arguggi](https://github.com/Arguggi) for contributing many of the improvements incorporated into this
  version.

  - [Bellroy](https://github.com/bellroy) is the new maintainer of this package. See https://github.com/glasserc/haskell-cached-io/pull/1.
  - New `cachedIO'` and `cachedIOWith'` support generating an action depending on the most recent cached value and its timestamp, if there was one.
  - `cachedIO ttl f` can now be run in a different monad to `f`. Similarly for `cachedIO'`, `cachedIOWith`, `cachedIOWith'`.
  - Fixes uncaught exceptions leaving the cache in a deadlocked state and other problems.

  ## 1.1.0.0 and prior

  These versions were published by [glasserc](https://github.com/glasserc).
changelog-type: markdown
description: |
  # cached-io: cache a single IO action

  Sometimes you have an action that does something really expensive
  whose results don't change that much. This is a simple library that
  lets you cache the output of that expensive action for a
  developer-specified length of time.

  `test/test-cachedIO.hs` shows a very basic usage example.

  ## Developing this library

  All standardised tooling is provided by `flake.nix`.

  ```shell
  nix develop
  ```

  ### Formatting code

  | To format | use                                                                                          |
  | --------- | -------------------------------------------------------------------------------------------- |
  | `*.cabal` | [`cabal-fmt`](https://hackage.haskell.org/package/cabal-fmt) (`cabal-fmt --inplace *.cabal`) |
  | `*.nix`   | [`nixpkgs-fmt`](https://github.com/nix-community/nixpkgs-fmt) (`nixpkgs-fmt *.nix`)          |

  We have not yet chosen a formatter for Haskell source. For now, try to follow
  the style of surrounding code.

  ### CI

  The GitHub Actions CI workflow for this repo is generated by [`haskell-ci`](https://github.com/haskell-CI/haskell-ci):

  ```shell
  haskell-ci regenerate
  ```
description-type: markdown
hash: 08d5544b8722d556b6db2564f09fda4c485359cf49c5e191c440998b06c848c3
homepage: ''
latest: 1.3.1.0
license-name: Apache-2.0
maintainer: Bellroy Tech Team <haskell@bellroy.com>
synopsis: A simple library to cache IO actions
test-bench-deps:
  base: '>=4.13.0.0 && <4.22'
  cached-io: '>=0'
  tasty: ^>=1.5
  tasty-hunit: ^>=0.10.0.3

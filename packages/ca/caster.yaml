homepage: https://github.com/kirisaki/caster#readme
changelog-type: markdown
hash: 36791db9bb9ceabff9b840b6352354b773818eabc2fdcea2edb8a0392f3707d0
test-bench-deps:
  fast-builder: -any
  bytestring: -any
  caster: -any
  base: ! '>=4 && <5'
  tasty-discover: -any
  text: -any
  quickcheck-instances: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
  QuickCheck: -any
  directory: -any
maintainer: kirisaki@klaraworks.net
synopsis: Multicast, thread-safe, and fast logger.
changelog: |
  # Change Log

  ## [0.0.1 -- 2019-04-13]

  ### Added

  - Basic functions.
basic-deps:
  fast-builder: ! '>=0.1.0.0'
  bytestring: ! '>=0.10.8.2'
  unix-time: ! '>=0.4.5'
  stm: ! '>=2.5.0.0'
  base: ! '>=4.10'
  text: ! '>=1.2.3.1'
all-versions:
- 0.0.1.0
- 0.0.2.0
author: Akihito KIRISAKI
latest: 0.0.2.0
description-type: markdown
description: "# caster\ncaster is a multicast, thread-safe and fast logger.\nIt's
  convenient when log towards multiple outputs, \nfor example, when you want to log
  to stdout and files same time.\nIt's possible to change format and log level each
  outputs.\nAlso, it converts text-like values and Show instances into log messages
  automatically.\n\n## Usage\n\nFirst, the logger requires concurrency.\n\n```haskell\nimport
  Control.Concurrent\n```\n\nThen, prepare to use the logger. \nIn following code,
  make `LogQueue`, `LogChan` and `Listener`,\nstart threads which relay messages from
  `LogChan` to the outputs \nand one which broadcasts messages to `LogChan`.\nBe careful
  not to change the order of `relayLog` and `broadcastLog`.\nIt causes that messages
  at the first are not logged correctly.\n\n```haskell\nimport System.IO\nimport System.Log.Caster\n\nmain
  = do\n  chan <- newLogChan\n  lq <- newLogQueue\n\n  -- log to a file..\n  handle
  <- openFile \"./foo.log\" \"caster_test_0.log\"\n  let FileListener = handleListener
  defaultFormatter handle\n  _ <- forkIO $ relayLog chan LogDebug fileListener\n\n
  \ -- log to stdout.\n  _ <- forkIO $ relayLog chan LogInfo stdoutListener\n\n  --
  start to broadcast.\n  _ <- forkIO $ broadcastLog lq chan\n  \n  -- give the LogQueue
  to the function which you want to log in.\n  someFunc lq\n\n```\n\nLast, push a
  message into the `LogQueue` with given functions in order to log.\n\n``` haskell\n\nsomeFunc
  :: LogQueue -> IO ()\nsomeFunc lq = do\n\n  -- log levels are matched to syslog.\n
  \ -- if you use OverloadedStrings, need to add type annotation.\n  debug lq (\"debug
  message\" :: String)\n  \n  -- or you can use helper operator or helper function.\n
  \ info lq $: \"info messages\"\n  info lq $ fix  \"info messages\"\n  \n  -- if
  the type is obviously, need not to annotate.\n  let msg = Data.Text.pack \"notice
  message\"\n  notice lq msg\n  \n  -- it's possible to give incetanse of Show.\n
  \ warn lq True\n  \n  -- there is the useful operator which concatrates text-like
  values.\n  -- the values are converted into byte string as utf-8.\n  let text =
  \"foo\" :: Data.Text.Text\n  let bs = \"bar\" :: Data.ByteString.Lazy.ByteString\n
  \ err lq $ text <:> bs <:> fix \"baz\"\n  \n```\n\nThe logger requires to be given
  `LogQueue`, \nso functions which log need to take `LogQueue` as a parameter. \nYou
  can inject `LogQueue` with Reader Monad and so on, \nbut I recommend to use easily
  [Data\\.Reflection](https://hackage.haskell.org/package/reflection).\n\n\n```haskell\n{-#
  LANGUAGE FlexibleContexts          #-}\n{-# LANGUAGE RankNTypes                #-}\n\nimport
  Control.Concurrent\nimport Control.Monad\nimport Data.Reflection\nimport System.Log.Caster\n\ntype
  UseLogger = Given LogQueue\n\nuseLogger :: UseLogger => LogQueue\nuseLogger = given\n\nsomeIO
  :: UseLogger => IO ()\nsomeIO = do\n  critical useLogger \"critical message\"\n
  \ alert useLogger \"alert message\"\n  emergency useLogger \"...\"\n  \ninject ::
  (UseLogger => a) -> IO a\ninject io = do\n  lq <- newLogQueue\n  give io lq\n  \nmain
  :: IO ()\nmain = do\n  chan <- newLogChan\n  _ <- forkIO $ relayLog chan LogDebug
  stdoutListener\n  join $ inject someIO\n  \n```\n"
license-name: BSD-3-Clause

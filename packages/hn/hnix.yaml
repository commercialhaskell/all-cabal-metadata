homepage: https://github.com/haskell-nix/hnix#readme
changelog-type: markdown
hash: 40edfce92ed0fd677853540680df3ca86e95baac1cd6e4e34ff0df6e160edb94
test-bench-deps:
  exceptions: -any
  serialise: -any
  data-fix: -any
  tasty-th: -any
  unix: -any
  split: -any
  base: -any
  time: -any
  tasty-hedgehog: -any
  Diff: -any
  megaparsec: -any
  filepath: -any
  criterion: -any
  process: -any
  hedgehog: -any
  containers: -any
  hnix: -any
  relude: -any
  tasty-hunit: -any
  pretty-show: -any
  prettyprinter: -any
  optparse-applicative: -any
  tasty: -any
  Glob: -any
  template-haskell: -any
  neat-interpolation: -any
  directory: -any
maintainer: johnw@newartisans.com
synopsis: Haskell implementation of the Nix language
changelog: "\n# ChangeLog\n\n## [(diff)](https://github.com/haskell-nix/hnix/compare/0.13.1...0.14.0#files_bucket)
  WIP\n\n* GHC 9.0 support.\n\n* HNix switched to pre-0.9 style of log (aka \"no log\").
  We temporarily stopped producing log, choosing effectiveness over writing about
  it.\n\n* All changes seem trivial (from the inside). There is no changes in `Nix.Expr.Shorthands`
  module. Would there be difficulties in migration - please write to us - we would
  tackle & solve it togather.\n\nA partial log:\n\n* Breaking:\n\n  * `Nix.Effects`:\n
  \   * rm `pathExits` in favour of `doesPathExist` (in `Nix.Render`: `class MonadFile`:
  `doesPathExist`)\n\n  * `Nix.Var`: was found being superflous ([report](https://github.com/haskell-nix/hnix/issues/946)),
  so reduced. use `Control.Monad.Ref` instead.\n\n  * `Nix.Normal`\n    * rename `opaque(,->Val)`,
  indicate that it is a literal.\n  \n  * `Nix.Thunk`:\n    * `class MonadThunkId
  m => MonadThunk{,F} t m a`:\n      * rename `query(M->){,F}`\n\n* Additional:\n\n
  \ * `Nix.Utils`:\n    * added type `TransformF`\n\n  * `Nix.Eval`:\n    * added
  fun:\n      * `evalContent`\n      * `addMetaInfo`\n      \n  * `Nix.Types.Assumption`:\n
  \   * added instances:\n      * `Assumption`: `{Semigroup,Monoid,One}`\n\n  * `Nix.Type.Env`:\n
  \   * added instances:\n      * `Env`: `{Semigroup,Monoid,One}`\n  \n  * `Nix`:\n
  \   * changed argument order:\n      * `nixEval`:\n        \n        ```haskell\n
  \       -- was:\n          => Maybe FilePath -> Transform g (m a) -> Alg g (m a)
  -> Fix g -> m a\n        -- became:\n          => Transform g (m a) -> Alg g (m
  a) -> Maybe FilePath -> Fix g -> m a\n        ```\n        \n  * `Nix.Normal`\n
  \   * add `thunkVal` literal & use it where appropriate `{deThunk, removeEffects}`\n
  \     \n  * `Nix.Thunk.Basic`:\n    * export `deferred`\n\n\n### [(diff)](https://github.com/haskell-nix/hnix/compare/0.13.0.1...0.13.1#files_bucket)
  0.13.1 (2021-05-22)\n  * [(link)](https://github.com/haskell-nix/hnix/pull/936/files)
  `Nix.Parser`: `annotateLocation`: Fix source location preservation.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/934/files)
  Require Cabal dependency `relude` `>= 1.0`: since imports & Cabal file got cleaned-up
  & that clean-up depends on `relude` reimports introduced in aforementioned version.\n
  \ * Refactors, reorganization in some modules, docs, clean-ups.\n\n#### [(diff)](https://github.com/haskell-nix/hnix/compare/0.13.0...0.13.0.1#files_bucket)
  0.13.0.1 (2021-05-11)\n  * [(link)](https://github.com/haskell-nix/hnix/pull/931/files)
  `Nix.Expr.Types`: Fix CPP on `Instances.TH.Lift` import.\n\n## [(diff)](https://github.com/haskell-nix/hnix/compare/0.12.0...0.13.0#files_bucket)
  0.13.0 (2021-05-10)\n\n* Breaking:\n\n  * [(link)](https://github.com/haskell-nix/hnix/pull/859/files)
  [(link)](https://github.com/haskell-nix/hnix/pull/863/files) [(link)](https://github.com/haskell-nix/hnix/pull/866/files)
  `Nix.Thunk`: `class MonadThunk t m a | t -> m, t -> a`. Class was initially designed
  with Kleisli arrows (`v -> m a`) in mind, which where put to have the design open
  and inviting customization & integration. Those functional arguments are for custom
  implementation, so  which in reality of the project were never used and HNax just
  \"essentially\" (simplifying, because `pure` was mixed with monadic binds to `f`)
  was passing `pure` into them (actually, `f <=< pure`). These Kliesli functors got
  arguments sorted properly and were moved to a `MonadThunkF` class and names gained
  `*F`. And `MonadThunk` now does only what is needed, for example `force` gets the
  thunk and computes it. All `MonadThunk{,F}` functions become with a classic Haskell
  arguments order, specialized, and got more straigh-forward to understand and use,
  and so now they tail recurse also.\n      \n      Now, for example, instead of `force
  t f` use it as `v <- force t` `f =<< force t`, or `f <=< force`.\n      \n      tl;dr:
  results:\n      \n      ```haskell\n      class MonadThunkId m => MonadThunk t m
  a | t -> m, t -> a where\n      \n        thunkId  :: t -> ThunkId m\n      \n        thunk
  \   :: m a -> m t\n      \n        queryM   :: m a -> t -> m a\n        -- old became
  `queryMF`\n      \n        force    :: t -> m a\n        -- old became `forceF`\n
  \     \n        forceEff :: t -> m a\n        -- old became `forceEffF`\n      \n
  \       further  :: t -> m t\n        -- old became `furtherF`\n      \n      \n
  \     -- | Class of Kleisli functors for easiness of customized implementation developlemnt.\n
  \     class MonadThunkF t m a | t -> m, t -> a where\n\n        queryMF   :: (a
  \  -> m r) -> m r -> t -> m r\n        -- was :: t -> m r -> (a   -> m r) -> m r\n\n
  \       forceF    :: (a   -> m r) -> t   -> m r\n        -- was :: t   -> (a   ->
  m r) -> m r\n\n        forceEffF :: (a   -> m r) -> t   -> m r\n        -- was ::
  t   -> (a   -> m r) -> m r\n\n        furtherF  :: (m a -> m a) -> t   -> m t\n
  \       -- was :: t   -> (m a -> m a) -> m t\n\n      ```\n      \n  * [(link)](https://github.com/haskell-nix/hnix/pull/862/files)
  [(link)](https://github.com/haskell-nix/hnix/pull/870/files) [(link)](https://github.com/haskell-nix/hnix/pull/871/files)
  \ [(link)](https://github.com/haskell-nix/hnix/pull/872/files) [(link)](https://github.com/haskell-nix/hnix/pull/873/files)
  `Nix.Value.Monad`: `class MonadValue v m`: instances became specialized, Kleisli
  versions unflipped the arguments of methods into a classical order and moved to
  the `class MonadValueF`. As a result, `demand` now gets optimized by GHC and also
  tail recurse. Please, use `f =<< demand t`, or just use `demandF`, while `demandF`
  in fact just `kleisli =<< demand t`.\n      \n      ```haskell\n      class MonadValue
  v m where\n      \n        demand :: v       ->         m v\n        -- old became
  `demandF`\n\n        inform :: v -> m v\n        -- old became `informF`\n      \n\n
  \     class MonadValueF v m where\n\n        demandF :: (v -> m r) -> v -> m r\n
  \       -- was :: v -> (v -> m r) -> m r\n\n        informF :: (m v -> m v) -> v
  -> m v\n        -- was :: v -> (m v -> m v) -> m v\n      ```\n      \n  * [(link)](https://github.com/haskell-nix/hnix/pull/863/files)
  `Nix.Normal`: `normalizeValue` removed first functional argument that was passing
  the function that did the thunk forcing. Now function provides the thunk forcing.
  Now to normalize simply use `normalizeValue v`. Old implementation now is `normalizeValueF`.\n\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/859/commits/8e043bcbda13ea4fd66d3eefd6da690bb3923edd)
  `Nix.Value.Equal`: `valueEqM`: freed from `RankNTypes: forall t f m .`.\n\n  * [(link)](https://github.com/haskell-nix/hnix/pull/802/commits/529095deaf6bc6b102fe5a3ac7baccfbb8852e49#)
  `Nix.Strings`: all `hacky*` functions replaced with lawful implemetations, because
  of that all functions become lawful - dropped the `principled` suffix from functions:\n
  \   * `Nix.String`:\n        ```haskell\n        hackyGetStringNoContext          ->\n
  \            getStringNoContext\n        hackyStringIgnoreContext         ->\n             stringIgnoreContext\n
  \       hackyMakeNixStringWithoutContext ->\n             makeNixStringWithoutContext\n\n
  \       principledMempty        -> mempty\n        principledStringMempty  -> mempty\n
  \       principledStringMConcat -> mconcat\n        principledStringMappend -> mappend\n\n
  \       principledGetContext                        ->\n                  getContext\n
  \       principledMakeNixString                     ->\n                  makeNixString\n
  \       principledIntercalateNixStrin               ->\n                  intercalateNixString\n
  \       principledGetStringNoContext                ->\n                  getStringNoContext\n
  \       principledStringIgnoreContext               ->\n                  stringIgnoreContext\n
  \       principledMakeNixStringWithoutContext       ->\n                  makeNixStringWithoutContext\n
  \       principledMakeNixStringWithSingletonContext ->\n                  makeNixStringWithSingletonContext\n
  \       principledModifyNixContents                 ->\n                  modifyNixContents\n
  \       ```\n\n  * [(link)](https://github.com/haskell-nix/hnix/pull/805/files):\n
  \   * Data type: `MonadFix1T t m`: `Nix.Standard` -> `Nix.Utils.Fix1`\n    * Children
  found their parents:\n        \n        ```haskell\n        Binary   NAtom :: Nix.Expr.Types
  -> Nix.Atoms\n        FromJSON NAtom :: Nix.Expr.Types -> Nix.Atoms\n        ToJSON
  \  NAtom :: Nix.Expr.Types -> Nix.Atoms\n\n        Eq1 (NValueF p m)     :: Nix.Value.Equal
  -> Nix.Value\n\n        Eq1 (NValue' t f m a) :: Nix.Value.Equal -> Nix.Value \n\n
  \       HasCitations m v (NValue' t f m a) :: Nix.Pretty -> Nix.Cited\n        HasCitations
  m v (NValue  t f m)   :: Nix.Pretty -> Nix.Cited\n\n        when\n          (package
  hashable >= 1.3.1) -- gained instance\n          $ Hashable1 NonEmpty:: Nix.Expr.Types
  -> Void -- please use upstreamed instance\n\n        -- | Was upstreamed, released
  in `ref-tf >= 0.5`.\n        MonadAtomicRef   (ST s) :: Nix.Standard -> Void\n\n
  \       MonadAtomicRef   (Fix1T t m) :: Nix.Standard -> Nix.Utils.Fix1\n        MonadRef
  \        (Fix1T t m) :: Nix.Standard -> Nix.Utils.Fix1\n        MonadEnv         (Fix1T
  t m) :: Nix.Standard -> Nix.Effects\n        MonadExec        (Fix1T t m) :: Nix.Standard
  -> Nix.Effects\n        MonadHttp        (Fix1T t m) :: Nix.Standard -> Nix.Effects\n
  \       MonadInstantiate (Fix1T t m) :: Nix.Standard -> Nix.Effects\n        MonadIntrospect
  \ (Fix1T t m) :: Nix.Standard -> Nix.Effects\n        MonadPaths       (Fix1T t
  m) :: Nix.Standard -> Nix.Effects\n        MonadPutStr      (Fix1T t m) :: Nix.Standard
  -> Nix.Effects\n        MonadStore       (Fix1T t m) :: Nix.Standard -> Nix.Effects\n
  \       MonadFile        (Fix1T t m) :: Nix.Standard -> Nix.Render\n\n        MonadEnv
  \        (Fix1 t)    :: Nix.Standard -> Nix.Effects\n        MonadExec        (Fix1
  t)    :: Nix.Standard -> Nix.Effects\n        MonadHttp        (Fix1 t)    :: Nix.Standard
  -> Nix.Effects\n        MonadInstantiate (Fix1 t)    :: Nix.Standard -> Nix.Effects\n
  \       MonadIntrospect  (Fix1 t)    :: Nix.Standard -> Nix.Effects\n        MonadPaths
  \      (Fix1 t)    :: Nix.Standard -> Nix.Effects\n        MonadPutStr      (Fix1
  t)    :: Nix.Standard -> Nix.Effects\n        ```\n  * [(link)](https://github.com/haskell-nix/hnix/pull/878/files)
  `Nix.Value`: `nvSet{,',P}`: got unflipped, now accept source position argument before
  the value.\n  \n  * [(link)](https://github.com/haskell-nix/hnix/pull/878/files)
  `Nix.Pretty`: `mkNixDoc`: got unflipped.\n  \n  * [(link)](https://github.com/haskell-nix/hnix/pull/886/commits/381b0e5df9cc620a25533ff1c84045a4ea37a833)
  `Nix.Value`: Data constructor for `NValue' t f m a` changed (`NValue -> NValue'`).\n
  \ \n  * [(link)](https://github.com/haskell-nix/hnix/pull/884/files) `Nix.Parser`:
  `Parser`: Data type was equivalent to `Either`, so became a type synonim for `Either`.\n\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/884/files) `Nix.Thunk.Basic`:
  `instance MonadThunk (NThunkF m v) m v`: `queryM`: implementation no longer blocks
  the thunk resource it only reads from.\n  \n  * [(link)](https://github.com/haskell-nix/hnix/pull/908/files):
  Migrated `(String -> Text)`:\n    * `Nix.Value`: `{NValueF, nvBuiltin{,'}, builtin{,2,3},
  describeValue}`\n    * `Nix.Eval`: `MonadNixEval`\n    * `Nix.Render.Frame`: `render{Expr,Value}`\n
  \   * `Nix.Type`: `TVar`\n    * `Nix.Thunk`: `ThunkLoop`\n    * `Nix.Exec`: `{nvBuiltinP,
  nixInstantiateExpr, exec}`\n    * `Nix.Effects`:\n      * `class`:\n        * `MonadExec:
  exec'`\n        * `MonadEnv: getEnvVar`\n        * `MonadInstantiate: instatiateExpr`\n
  \     * `parseStoreResult`\n    * `Nix.Effects.Derivation`: `renderSymbolic`\n    *
  `Nix.Lint`: `{NTypeF, symerr}`\n\n* Additional:\n  * [(link)](https://github.com/haskell-nix/hnix/commit/7e6cd97bf3288cb584241611fdb25bf85d7e0ba7)
  `cabal.project`: freed from the `cryptohash-sha512` override, Hackage trustees made
  a revision.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/824/commits/4422eb10959115f21045f39e302314a77df4b775)
  To be more approachable for user understanding, the thunk representation in outputs
  changed from `\"<CYCLE>\" -> \"<expr>\"`.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/925/commits/37e81c96996b07cbbdf9fa4bf380265e8c008482)
  The Nix evaluation cycle representation changed `\"<CYCLE>\" -> \"<cycle>\"`.\n
  \ * [(link)](https://github.com/haskell-nix/hnix/commit/51a3ff9e0065d50e5c625738696526c4a232b0cf)
  `Nix.Expr.Types`: added hacky implementation of `liftTyped` for `instance Lift (Fix
  NExprF)`.\n  * [(link)](https://github.com/haskell-nix/hnix/commit/51a3ff9e0065d50e5c625738696526c4a232b0cf)
  `Nix.Builtins`: `derivation` primOp internal code always fully evaluated, so GHC
  now always ships only fully compiled version in the bytecode.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/890):
  Project switched to prelude `relude`.\n  * A bunch of other stuff that is not user-facing.\n\n\n##
  [(diff)](https://github.com/haskell-nix/hnix/compare/0.11.1...0.12.0#files_bucket)
  0.12.0 (2021-01-05)\n\n* *Disclaimer*: Current `derivationStrict` primOp implementation
  and so every evaluation of a derivation into a store path currently relies on the
  `hnix-store-remote`, which for those operations relies on the running `nix-daemon`,
  and so operations use/produce effects into the `/nix/store`. Be cautious - it is
  effectful.\n\n* Introduction:\n  * New module `Nix.Effects.Derivation`.\n  * Operations
  on derivations:\n    * old got principled implementations.\n    * also new operations
  got introduced.\n  * Implementation of the `derivationStrict` primOp.\n\n* Breaking:\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  `Nix.Effects`: **class** `MonadStore` got principled implementation.\n    * `addPath'`
  got principled into `addToStore`.\n    * `toFile_` got principled into `addTextToStore'`.\n
  \   * For help & easy migration you may use `addPath` & `toFile_` `addTextToStore`
  standalone functions in the module.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  `Nix.Effects.Basic`: `defaultDerivationStrict` got reimplemented & moved into `Nix.Effects.Derivation`.\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  `Nix.Standard`: instance for `MonadStore (Fix1T t m)` got principled accoding to
  class `MonadStore` changes.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  `Nix.Fresh.Basic`: instance for `MonadStore (StdIdT m)` got principled.\n\n* Additional:\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  **New module `Nix.Effects.Derivation`**: [HNix(0.12.0):Nix.Effects.Derivation documentation](https://hackage.haskell.org/package/hnix-0.12.0/docs/Nix-Effects-Derivation.html).\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/9bcfbbe88ff0bd8d803296193ee1d8603dc5289e)
  `Nix.Convert`: Principled `NVPath -> NixString` coercion.\n    * In a form of principled
  `instance FromValue NixString m (NValue' t f m (NValue t f m))`.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/a8e6d28fdb98a1c34f425c8395338fdabe96becc)
  `Nix.String`: Allow custom computations inside string contexts.\n    * By providing
  `runWithStringContext{T,}'` methods into the API.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/e45f7632c51a9657f6e8d54c39fd4d21c466d85f)
  Includded support for new `base16-bytestring`, which advertices 2x-4x speed increase
  of its operations.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  `Nix.Effects`: `addPath` & `toFile_` standalone functions got principled implementation
  through the internal use of the new `MonadStore` type class implementation.\n  *
  [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  `Nix.Effects`: added `addTextToStore`, `parseStoreResult` implementations.\n  *
  [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  `Nix.Effects`: added type synonyms `{RecursiveFlag, RepairFlag, StorePathName, FilePathFilter,
  StorePathSet}`.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/760) `Nix.Exec`:
  Fixed the rendering of internal `Frames`.\n    * Which is an internal mechanism
  of a project to passing around messages with their context, still to be used internally).\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/3bba5549273c892c60aad5dd6d5058a8db40efbf)
  `HNix / Nix`: The library now also uses `hnix-store-remote`.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/554/commits/06b0fca9fd607eb2e995f003424e797a41ffa5b7)
  `cabal.project`: project uses `cryptohash-sha512` override, the `hnix-store-core`
  requires it from `hnix` and uses that override also. [Detailed info](https://github.com/haskell-hvr/cryptohash-sha512/pull/5#issuecomment-752796913).
  We promise to attend to this issue, probably by migrating to `cryptonite` in the
  nearest releases.\n\nFuture note: The HNix is a big project. During the initial
  development and currently the API for simplicity exposes allmost all functions,
  types, etc. Big open API means a big effort to create/maintain a quite noisy changelog
  and you parsing through it, and also creates a frequent requirements to mark releases
  as major and bother you due to some type changes in some parts that may not be used
  or applicable to be public API.\n\nThis year the most gracious API clean-up would
  happen, we would check and keep open what Hackage projects are using from the API,
  and the other parts would be open on the request by a way of rapid minor releases.
  That clean-up is also a work toward splitting the project into several packages
  some time in the future (split would be into something like Expressions, Evaluation,
  Executable, Extra), which migration also would be done most thoughful and graceful
  as possible, with as much easiness and automation provided for migration downstream
  as possible. If all goes as planned - all downstream would need to do is to get
  and run our script that would migrate our old map of module imports to new ones,
  and maybe manually add those newly formed packages into `.cabal` description.\n\nIf
  it is possible, please, try to switch & use the higher-level API functions where
  it is applicable. Thank you.\n\n\n### [(diff)](https://github.com/haskell-nix/hnix/compare/0.11.0...0.11.1#files_bucket)
  0.11.1 (2020-12-09)\n\n* Additional:\n  * [(link)](https://github.com/haskell-nix/hnix/commit/d32a6fbaf3df1c8879d1b19a18f21c031a73e56c)
  `Nix.Builtins`: `isString` fixed - It used to return `True` for values coercible
  to string like derivations and paths. It only accepts string values now.\n  * [(link)](https://github.com/haskell-nix/hnix/commit/53b4db2525a8f074d8c262fa7b66ce97e5820890)
  `Nix.Builtins`: `substring` fixed - Negative lengths used to capture an empty string.
  Now they capture the whole rmeainder of the string.\n  * [(link)](https://github.com/haskell-nix/hnix/commit/dc31c5e64f8c7aaaea14cac0134bd47544533e67)
  `Nix.Effects`: `pathExists` fixed - Now also works with directories.\n  * [(link)](https://github.com/haskell-nix/hnix/commit/e2ad934492eeac9881527610e4a1c1cf31ea1115)
  `Nix.Parser`: `->` is now properly right-associative (was non-associative).\n  *
  [(link)](https://github.com/haskell-nix/hnix/commit/50baea5e1e482be3c4fcc13c9a45b1083243f681)
  `Nix.Parser`: Nix `assert` parser (`nixAssert` function) now accepts top-level Nix
  format also (which means also accepts all kinds of statements), before that it accepted
  only regular Nix expressions.\n  * [(link)](https://github.com/haskell-nix/hnix/commit/59698de7185dfae508e5ccea4377a82023c4a0d5)
  `Nix.Render`: `renderLocation` now also shows/handles location of errors in raw
  strings.\n\n\n## [(diff)](https://github.com/haskell-nix/hnix/compare/0.10.1...0.11.0#files_bucket)
  0.11.0 (2020-11-02)\n\n* Breaking:\n  * [(link)](https://github.com/haskell-nix/hnix/pull/740)
  Deleted incorrect `instance Generic1 NKeyName` from `module Nix.Expr.Types`.\n  *
  [(link)](https://github.com/haskell-nix/hnix/pull/739) Parentheses now are properly
  included in the location annotation for Nix expressions, change of `nixParens` in
  `module Nix.Parser` essentially results in the change of all module `nix*` function
  results, essentially making results of the whole module more proper.\n\n* Additional:\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/741) Fix QQ Text lifting error:
  work around of [GHC#12596 \"can't find interface-file declaration\"](https://gitlab.haskell.org/ghc/ghc/-/issues/12596).\n
  \ * [(link)](https://github.com/haskell-nix/hnix/pull/744) Fix comments inclusion
  into location annotations, by using pre-whitespace position for source end locations.\n\n\n###
  [(diff)](https://github.com/haskell-nix/hnix/compare/0.10.0...0.10.1#files_bucket)
  0.10.1 (2020-09-13)\n\n* Additional:\n  * [(link)](https://github.com/haskell-nix/hnix/pull/715)
  `{Binding, NExpr, NExprF, NKeyName}` gained `Ord1` instances.\n    * These instances
  were required by downstream projects to be able to use newer HNix.\n  * [(link)](https://github.com/haskell-nix/hnix/pull/712)
  CLI gained `--long-version` option for gathering a detailed debug information.\n
  \   * Currently, reports Git commit and its date.\n    * [(link)](https://github.com/haskell-nix/hnix/issues/718)
  Currently does not work in case of use of the `nix-build`, in which case simply
  returns `UNKNOWN` placeholder.\n\n\n## [(diff)](https://github.com/haskell-nix/hnix/compare/0.9.1...0.10.0#files_bucket)
  0.10.0 (2020-09-12)\n\n* Breaking:\n  * [(link)](https://github.com/haskell-nix/hnix/pull/699)
  Removed `NExpr` `{FromJSON, ToJSON}` instances.\n    * This also removed the JSON
  output feature for unevaluated expression trees.\n\n* Additional:\n  * [(link)](https://github.com/haskell-nix/hnix/pull/703)
  CLI gained `--version` option.\n  * Dependencies:\n    * [(link)](https://github.com/haskell-nix/hnix/pull/686)
  Requires last major `data-fix` (`0.3`).\n    * [(link)](https://github.com/haskell-nix/hnix/pull/679)
  Requires last major `prettyprinter` (`1.7`).\n\n\n### [(diff)](https://github.com/haskell-nix/hnix/compare/0.9.0...0.9.1#files_bucket)
  0.9.1 (2020-07-13)\n\n* Additional:\n  * REPL:\n    * Better tab completion.\n    *
  Accepting multi-line input.\n    * Support for passing evaluated expression result
  of `hnix --eval -E`.\n      to REPL as an `input` variable.\n    * Support for loading
  `.hnixrc` from the current directory.\n  * Reporting of `builtins.nixVersion` bumped
  from 2.0 to 2.3.\n  * Dependencies:\n    * Freed from: `{interpolate, contravariant,
  semigroups, generic-random, tasty-quickcheck}`.\n    * Requires last major `repline`
  (`0.4`).\n\n\n## [(diff)](https://github.com/haskell-nix/hnix/compare/0.8.0...0.9.0#files_bucket)
  0.9.0 (2020-06-15)\n\n* Breaking:\n  * Removed instances due to migration to `haskeline
  0.8`:\n    * `instance MonadException m => MonadException(StateT(HashMap FilePath
  NExprLoc) m)`.\n    * `instance MonadException m => MonadException(Fix1T StandardTF
  m)`.\n  * Dependencies:\n    * Requires last major `haskeline` (`0.8`).\n\n* Additional:\n
  \ * Library: Official support for `GHC 8.4 - 8.10`.\n  * Executable complies only
  under `GHC 8.10`.\n\n* Changelog started. Previous release was `0.8.0`.\n\n\n---\n\nHNix
  uses [PVP Versioning][1].\n\n[1]: https://pvp.haskell.org\n"
basic-deps:
  http-client: '>=0.5.14 && <0.6 || >=0.6.4 && <0.8'
  exceptions: '>=0.10.0 && <0.11'
  free: ==5.1.*
  hnix-store-remote: '>=0.5.0 && <0.6'
  serialise: '>=0.2.1 && <0.3'
  semialign: '>=1.2 && <1.3'
  bytestring: '>=0.10.8 && <0.12'
  these: '>=1.0.1 && <1.2'
  lens-family: '>=1.2.2 && <2.2'
  logict: '>=0.6.0 && <0.7 || >=0.7.0.2 && <0.8'
  data-fix: '>=0.3.0 && <0.4'
  unix: '>=2.7.2 && <2.8'
  haskeline: '>=0.8.0.0 && <0.9'
  hashing: '>=0.1.0 && <0.2'
  split: '>=0.2.3 && <0.3'
  base: '>=4.12 && <5'
  time: '>=1.8.0 && <1.9 || >=1.9.3 && <1.10'
  comonad: '>=5.0.4 && <5.1'
  parser-combinators: '>=1.0.1 && <1.4'
  deriving-compat: '>=0.3 && <0.6'
  unordered-containers: '>=0.2.9 && <0.3'
  text: '>=1.2.3 && <1.3'
  megaparsec: '>=7.0 && <9.1'
  syb: '>=0.7 && <0.8'
  monad-control: '>=1.0.2 && <1.1'
  filepath: '>=1.4.2 && <1.5'
  gitrev: '>=1.1.0 && <1.4'
  process: '>=1.6.3 && <1.7'
  ref-tf: ==0.5.*
  lens-family-th: '>=0.5.0 && <0.6'
  array: '>=0.4 && <0.6'
  lens-family-core: '>=1.2.2 && <2.2'
  repline: '>=0.4.0.0 && <0.5'
  xml: '>=1.3.14 && <1.4'
  th-lift-instances: '>=0.1 && <0.2'
  containers: '>=0.5.11.0 && <0.7'
  some: '>=1.0.1 && <1.1'
  hnix: -any
  binary: '>=0.8.5 && <0.9'
  relude: '>=1.0.0 && <1.1.0'
  regex-tdfa: '>=1.2.3 && <1.4'
  http-client-tls: '>=0.3.5 && <0.4'
  cryptonite: -any
  mtl: '>=2.2.2 && <2.3'
  hashable: '>=1.2.5 && <1.4'
  transformers-base: '>=0.4.5 && <0.5'
  pretty-show: '>=1.9.5 && <1.11'
  base16-bytestring: '>=0.1.1 && <1.1'
  prettyprinter: '>=1.7.0 && <1.8'
  transformers: '>=0.5.5 && <0.6'
  optparse-applicative: '>=0.14.3 && <0.17'
  hnix-store-core: '>=0.5.0 && <0.6'
  deepseq: '>=1.4.3 && <1.5'
  scientific: '>=0.3.6 && <0.4'
  monadlist: '>=0.0.2 && <0.1'
  http-types: '>=0.12.2 && <0.13'
  aeson: '>=1.4.2 && <1.6'
  template-haskell: '>=2.13 && <2.18'
  vector: '>=0.12.0 && <0.13'
  neat-interpolation: '>=0.4 && <0.6'
  directory: '>=1.3.1 && <1.4'
all-versions:
- 0.2.0
- 0.2.1
- 0.3.2
- 0.3.3
- 0.3.4
- 0.4.0
- 0.5.0
- 0.5.1
- 0.5.2
- 0.6.0
- 0.6.1
- 0.7.0
- 0.7.1
- 0.8.0
- 0.9.0
- 0.9.1
- 0.10.0
- 0.10.1
- 0.11.0
- 0.11.1
- 0.12.0
- 0.12.0.1
- 0.13.0
- 0.13.0.1
- 0.13.1
- 0.14.0
author: John Wiegley
latest: 0.14.0
description-type: markdown
description: "[![Chatroom Gitter](https://img.shields.io/badge/Chatroom-Gitter-%23753a88)](https://gitter.im/haskell-nix/Lobby)\n[![Hackage](https://img.shields.io/hackage/v/hnix?color=%235e5086&label=Latest%20release%20on%20Hackage)](https://hackage.haskell.org/package/hnix)\n[![Hackage
  Matrix Builder](https://img.shields.io/badge/Hackage%20Matrix-Builder-%235e5086)](https://matrix.hackage.haskell.org/package/hnix)\n[![Bounds](https://img.shields.io/hackage-deps/v/hnix?label=Released%20dep%20bounds)](https://packdeps.haskellers.com/feed?needle=hnix)\n[![Hydra
  CI](https://img.shields.io/badge/Nixpkgs%20Hydra-CI-%234f72bb)](https://hydra.nixos.org/job/nixpkgs/trunk/haskellPackages.hnix.x86_64-linux#tabs-status)\n[![Repology
  page](https://img.shields.io/badge/Repology-page-%23005500)](https://repology.org/project/haskell:hnix/versions)\n\n\n#
  HNix\n\nParser, evaluator and type checker for the Nix language written in Haskell.\n\n\n##
  Prerequisites\nTooling is WIP, `nix-shell` and `nix-store` are still used for their
  purpose, so, to access them Nix is required to be installed.\n\n*Disclaimer*: Since
  still using Nix for some operations, current `derivationStrict` primOp implementation
  and so evaluations of a derivation into a store path currently rely on the `hnix-store-remote`,
  which for those operations relies on the running `nix-daemon`, and so operations
  use/produce effects into the `/nix/store`. Be cautious - it is effectful (produces
  `/nix/store` entries).\n\n## Building the project\n\n### Git clone\n\n```shell\ngit
  clone --recursive 'https://github.com/haskell-nix/hnix.git' && cd hnix\n```\n\n\n###
  (optional) Cachix prebuild binary caches\n\nIf you would use our Nix-shell environment
  for development, you can connect to our Cachix HNix build caches:\n\n1. Run:\n    ```shell\n
  \   nix-env -iA cachix -f https://cachix.org/api/v1/install\n    ```\n\n\n2. Run:
  `cachix use hnix`\n\n\n### Building with Cabal\n\nCabal [Quickstart](https://cabal.readthedocs.io/en/3.4/nix-local-build.html).\n\n1.
  (Optional), to enter the projects reproducible Nix environment:\n    ```shell\n
  \   nix-shell\n    ```\n    \n2. Building:\n    ```shell\n    cabal v2-configure\n
  \   cabal v2-build\n    ```\n  \n3. Loading the project into `ghci` REPL:\n    ```shell\n
  \   cabal v2-repl\n    ```\n    \n4. Testing:\n\n  * Default suite:\n    ```shell\n
  \   cabal v2-test\n    ```\n  \n  * All available tests:\n    ```shell\n    env
  ALL_TESTS=yes cabal v2-test\n    ```\n    \n  * Selected (list of tests is in `tests/Main.hs`):\n
  \   ```shell\n    env NIXPKGS_TESTS=yes PRETTY_TESTS=1 cabal v2-test\n    ```\n\n####
  Checking the project\n\n##### Benchmarks\n\nTo run benchmarks:\n\n```shell\ncabal
  v2-bench\n```\n\n##### Profiling\n\nGHC User Manual has a full [\"Profiling\"](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/profiling.html)
  section of relevant info.\n\nTo build `hnix` with profiling enabled:\n\n```shell\ncabal
  v2-run hnix --enable-profiling --flags=profiling -- <args> +RTS -p\n```\n\nOr to
  put simply:\n```shell\n# Run profiling for evaluation of a Firefox package.\n# Generate:\n#
  \ * for all functions\n#  * time profiling data\n#  * memory allocation profiling
  data\n#  * in the JSON profiling format\ncabal v2-run --enable-profiling --flags=profiling
  --enable-library-profiling --profiling-detail='all-functions' hnix -- --eval --expr
  '(import <nixpkgs> {}).firefox.outPath' +RTS -Pj\n\n# Then, upload the `hnix.prof`
  to the https://www.speedscope.app/ to analyze it.\n```\n\n\"RTS\" stands for \"RunTime
  System\" and has a lot of options, GHC User Manual has [\"Running a compiled program\"/\"Setting
  RTS options\"](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/runtime_control.html)
  sections describing them.\n\n##### Full debug info\n\nTo run stack traces & full
  tracing output on `hnix`:\n\n```shell\ncabal v2-configure --enable-tests --enable-profiling
  --flags=profiling --flags=tracing\ncabal v2-run hnix -- -v5 --trace <args> +RTS
  -xc\n```\n\nThis would give the most information as to what happens during parsing
  & evaluation.\n\n\n#### Runing executable\n\n```shell\ncabal v2-run hnix -- --help\n```\n(`--`
  is for separation between `cabal` & `hnix` args)\n\n\n### Building with Nix-build\n\nThere
  is a number of build options to use with `nix-build`, documentation of them is in:
  `./default.nix`, keys essentially pass-through the [Nixpkgs Haskell Lib API](https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/lib.nix).\n\nOptions
  can be used as:\n```shell\nnix-build \\\n  --arg <option1> <argument1> \\\n  --arg
  <option2> <argument2> \\\n  --argstr <option3> \"<strinTypeArg>\"\n```\n\n#### Checking
  the project\n##### Benchmarks\n\n```shell\nnix-build \\\n  --arg disableOptimization
  false \\\n  --arg enableDeadCodeElimination true \\\n  --arg doStrip true \\\n  --arg
  doBenchmark true\n```\n\n##### Profiling\n\n```shell\nnix-build \\\n  --arg disableOptimization
  false \\\n  --arg enableDeadCodeElimination true \\\n  --arg enableLibraryProfiling
  true \\\n  --arg enableExecutableProfiling true\n\n./result/bin/hnix <args> +RTS
  -p\n```\n\n##### Full debug info\n\n```shell\nnix-build \\\n  --arg disableOptimization
  false \\\n  --arg enableDeadCodeElimination true \\\n  --arg doBenchmark true \\\n
  \ --arg doStrip false \\\n  --arg enableLibraryProfiling true \\\n  --arg enableExecutableProfiling
  true \\\n  --arg doTracing true \\\n  --arg enableDWARFDebugging true\n\n./result/bin/hnix
  -v5 --trace <args> +RTS -xc\n```\n\n#### Runing executable\n\n```shell\n./result/bin/hnix\n```\n\n##
  Using HNix\n\nSee:\n```\nhnix --help\n```\n\nIt has a pretty full/good description
  of the current options.\n\n\n### Parse & print\n\nTo parse a file with `hnix` and
  pretty print the result:\n\n```shell\nhnix file.nix\n```\n\n### Evaluating and printing
  the resulting value\n\nExpression from a file:\n\n```shell\nhnix --eval file.nix\n```\n\nExpression:\n\n```shell\nhnix
  --eval --expr 'import <nixpkgs> {}'\n```\n\n### Evaluating Nixpkgs\n\nCurrently,
  the main high-level goal is to be able to evaluate all of Nixpkgs:\n\n```shell\nhnix
  --eval --expr \"import <nixpkgs> {}\" --find\n```\n\n### Options supported only
  by HNix\n\nTo see value provenance and thunk context:\n\n```shell\nhnix -v2 --values
  --thunk --eval --expr 'import <nixpkgs> {}'\n```\n\nTo see tracing as the evaluator
  runs (note that building with `cabal configure --flags=tracing` will produce much
  more output than this):\n\n```shell\nhnix --trace --eval --expr 'import <nixpkgs>
  {}'\n```\n\nTo attempt to generate a reduced test case demonstrating an error:\n\n```shell\nhnix
  --reduce bug.nix --eval --expr 'import <nixpkgs> {}'\n```\n\n### REPL\n\nTo enter
  REPL:\n```shell\nhnix --repl\n```\n\nEvaluate an expression and load it into REPL:\n```shell\nhnix
  --eval --expr '(import <nixpkgs> {}).pkgs.hello' --repl\n```\nThis binds the evaluated
  expression result to the `input` variable, so that variable can be inspected.\n\nUse
  the `:help` command for a list of all available REPL commands.\n\n#### Language
  laziness\n\nNix is a lazy language with the ability of recursion, so by default
  REPL and eval prints are lazy:\n\n```shell\nhnix \\\n  --eval \\\n  --expr '{ x
  = true; }'\n  \n{ x = \"<expr>\"; }\n```\n\nTo disable laziness add the `--strict`
  to commands or `:set strict` in the REPL.\n\n```shell\nhnix \\\n  --eval \\\n  --strict
  \\\n  --expr '{ x = true; }'\n  \n{ x = true; }\n```\n\n\n## Contributing\n\n* The
  Haskell Language Server (HLS) works great with our project.\n\n* [Design of the
  HNix code base Wiki article](https://github.com/haskell-nix/hnix/wiki/Design-of-the-HNix-code-base).\n\n1.
  If something in the [quests](https://github.com/haskell-nix/hnix/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22+no%3Aassignee)
  looks interesting, look through the thread and leave a comment taking it, to let
  others know you're working on it.\n\n2. You are free to chat with everyone on [Gitter](https://gitter.im/haskell-nix/Lobby).\n\n3.
  When the pull request is ready to be submitted, to save time - please, test it with:\n
  \   \n    ```shell\n    cabal v2-test\n    \n    # If forgot to clone recursively,
  run:\n    # git submodule update --init --recursive\n    ```\n    \n    Please,
  check that all default tests that were passing prior are still passing. It's OK
  if no new tests are passing.\n    \n    \n### (optional) Minimalistic development
  status loop with amazing [`ghcid`](https://github.com/ndmitchell/ghcid)\n\nIf HLS
  is not your cup of yea:\n\n```shell\nghcid --command=\"cabal v2-repl --repl-options=-fno-code
  --repl-options=-fno-break-on-exception --repl-options=-fno-break-on-error --repl-options=-v1
  --repl-options=-ferror-spans --repl-options=-j\"\n```\n(optional) To use projects
  reproducible environment, wrap `ghcid ...` command into a `nix-shell --command '
  '`.\n\nFor simplicity `alias` the command in your shell.\n\n\n## Current status\n\nTo
  understand the project implementation state see:\n  * [ChangeLog](https://github.com/haskell-nix/hnix/blob/master/ChangeLog.md)\n
  \ * [Opened reports](https://github.com/haskell-nix/hnix/issues)\n  * [Project status](https://github.com/haskell-nix/hnix/wiki/Project-status)\n
  \ * [Design of the HNix code base](https://github.com/haskell-nix/hnix/wiki/Design-of-the-HNix-code-base)\n\n"
license-name: BSD-3-Clause

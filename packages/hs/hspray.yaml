all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
- 0.1.3.0
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.2.2.0
- 0.2.3.0
- 0.2.4.0
- 0.2.5.0
- 0.2.6.0
- 0.2.7.0
- 0.3.0.0
author: Stéphane Laurent
basic-deps:
  base: '>=4.7 && <5'
  containers: '>=0.6.4.1 && <0.8'
  extra: '>=1.7 && <1.8'
  hashable: '>=1.3.4.0 && <1.5'
  matrix: '>=0.3.6.0 && <0.4'
  numeric-prelude: '>=0.4.4 && <0.5'
  text: '>=1.2.5.0 && <2.2'
  unordered-containers: '>=0.2.17.0 && <0.3'
changelog: "# Changelog for `hspray`\r\n\r\nAll notable changes to this project will
  be documented in this file.\r\n\r\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\r\nand
  this project adheres to the\r\n[Haskell Package Versioning Policy](https://pvp.haskell.org/).\r\n\r\n\r\n##
  0.1.0.0 - 2022-12-11\r\n\r\nFirst release.\r\n\r\n\r\n## 0.1.1.0 - 2022-12-12\r\n\r\n*
  New functions `toList`, `sprayTerms` and `bombieriSpray`.\r\n\r\n* New operation
  `.^`, to multiply a spray by an integer.\r\n\r\n* Added some unit tests.\r\n\r\n\r\n##
  0.1.2.0 - 2023-02-24\r\n\r\nNew function `derivSpray`, to differentiate a spray.\r\n\r\n\r\n##
  0.1.3.0 - 2023-08-29\r\n\r\n* `Powers(..)` is now exported.\r\n\r\n* Completed the
  README to show how to deal with symbolic coefficients.\r\n\r\n\r\n## 0.2.0.0 - 2024-03-14\r\n\r\n*
  New functions `prettySpray'` and `prettySprayXYZ`.\r\n\r\n* New function `substituteSpray`.\r\n\r\n*
  New function `sprayDivision`, to perform the division of a spray by a list \r\nof
  sprays.\r\n\r\n* New function `groebner`, to compute a Gröbner basis of a list of
  sprays.\r\n\r\n* New function `isSymmetricSpray`, to check whether a spray is a
  symmetric \r\npolynomial.\r\n\r\n* New function `isPolynomialOf`, to check whether
  a spray can be expressed as \r\na polynomial of a given list of sprays.\r\n\r\n\r\n##
  0.2.1.0 - 2024-03-22\r\n\r\n* New functions `permuteVariables` and `swapVariables`.\r\n\r\n*
  New function `resultant`, to compute the resultant of two sprays.\r\n\r\n* New function
  `subresultants`, to compute the subresultants of two sprays.\r\n\r\n\r\n## 0.2.1.1
  - 2024-03-25\r\n\r\n* Improved the documentation.\r\n\r\n* Flipped the order of
  appearance of the terms in the output of the \r\n`prettySpray` functions.\r\n\r\n\r\n##
  0.2.2.0 - 2024-03-26\r\n\r\n* Fixed an error in `esPolynomial`, which resulted to
  a bug in \r\n`isSymmetricSpray`.\r\n\r\n\r\n## 0.2.3.0 - 2024-03-28\r\n\r\n* New
  unit tests.\r\n\r\n* Fixed `resultant` and `subresultants`: the variables of the
  sprays they \r\nreturn were incorrect.\r\n\r\n* New function `gcdQX`, to compute
  the greatest common divisor of two \r\nunivariate sprays with rational coefficients.\r\n\r\n\r\n##
  0.2.4.0 - 2024-03-30\r\n\r\n* Flipped the order of the arguments in `permuteVariables`
  and `swapVariables`.\r\n\r\n* New function `gcdSpray`, to compute the greatest common
  divisor of two sprays\r\nwith coefficients in a field. \r\n\r\n* The function `gcdQX`
  has been removed since `gcdSpray` is more general.\r\n\r\n* The function `sprayDivision`
  has been renamed to `sprayDivisionRemainder`.\r\n\r\n* New function `sprayDivision`,
  returning the quotient and the remainder of the \r\ndivision of two sprays.\r\n\r\n\r\n##
  0.2.5.0 - 2024-04-02\r\n\r\n* New function `resultant'` which computes the resultant
  of two sprays with \r\ncoefficients in a field. Thus it is less general than the
  function `resultant` \r\nbut it is more efficient. \r\n\r\n* Fixed a small mistake
  in `isSymmetricSpray` and `isPolynomialOf`: these \r\nfunctions didn't deal with
  the constant term of the spray.\r\n\r\n* New function `psPolynomial` which computes
  the power sum polynomials.\r\n\r\n* A particular type of sprays, namely `SymbolicSpray
  a`, has been introduced. \r\nThe coefficients of these sprays are ratios of univariate
  polynomials with `a` \r\ncoefficients. There is a specialization `SymbolicQSpray`
  for the case when `a` \r\nis a type of rational numbers. The necessary instances
  have been defined and \r\nthere is the function `prettySymbolic(Q)Spray` to display
  such sprays. There are \r\nalso some functions to perform evaluation of such sprays.\r\n\r\n\r\n##
  0.2.6.0 - 2024-04-15\r\n\r\n* New function `collinearSprays` which checks whether
  two sprays are collinear.\r\n\r\n* The function `isPolynomialOf` threw an error
  when the number of variables in\r\nthe spray to be tested was less than the number
  of variables in the list of \r\nsprays. That is me who programmed this error and
  this was wrong: for example, \r\n`x = p1 - p2^*^p3` with `p1 = x + y^*^z`, `p2 =
  y`, and `p3 = z`.\r\n\r\n* New functions to print sprays with numeric coefficients,
  such as \r\n`prettyNumSpray` and `prettyQSpray`.\r\n\r\n* The functions `prettySpray`,
  `prettySpray'` and `prettySpray''` have been \r\nchanged.\r\n\r\n* New functions
  to print symbolic sprays.\r\n\r\n* Documentation and README have been improved.\r\n\r\n\r\n##
  0.2.7.0 - 2024-04-19\r\n\r\n* Defined `qlone`, which is the same as `lone` but always
  returns a rational \r\nspray (a `QSpray` spray).\r\n\r\n* The function `sprayDivision`
  ran into an infinite loop when the divisor was\r\nconstant. This has been fixed.\r\n\r\n*
  New function `characteristicPolynomial`, to compute the characteristic \r\npolynomial
  of a matrix. \r\n\r\n* Gegenbauer polynomials. They have been implemented mainly
  to provide an \r\nillustration of the type `Spray (Spray a)` in README.\r\n\r\n*
  New function `evalSpraySpray`, to evaluate the spray coefficients of a \r\n`Spray
  (Spray a)` spray, thereby yielding a `Spray a` spray.\r\n\r\n* New type `RatioOfSprays
  a`, whose objects represent ratios of polynomials \r\nrepresented by two `Spray
  a` objects. Thus the type `Spray (RatioOfSprays a)` \r\nallows more possibilities
  than the type `SymbolicSpray a` because it is not \r\nrestricted to univariate fractions
  of polynomials, and obviously it also \r\nallows more possibilities than the type
  `Spray (Spray a)`. Instances and \r\narithmetic operations for these ratios of sprays
  have been defined. The result \r\nof an arithmetic operation always is an irreducible
  fraction. See README for \r\nexamples.\r\n\r\n* Jacobi polynomials. They have been
  implemented mainly to experiment the type \r\n`Spray (RatioOfSprays a)`. By the
  way, this type has been named \r\n`ParametricSpray a`, but this is possibly temporary.\r\n\r\n*
  The class `HasVariables a` has been introduced in order to have some functions\r\nwhich
  apply to both `Spray a` objects and `RatioOfSprays a` objects.\r\n\r\n* The function
  `derivSpray` no longer exists. To get a derivative of a spray, \r\nuse the `derivative`
  function, which is also applicable to a ratio of sprays \r\n(this is a method of
  the class `HasVariables`).\r\n\r\n* A spray with coefficients in a field can now
  be divided by a scalar by using\r\nthe `/>` operator. This operator can also be
  used to divide a ratio of sprays \r\n(with coefficients in a field) by a scalar.\r\n\r\n\r\n##
  0.3.0.0 - 2024-04-21\r\n\r\n* The type `SymbolicSpray a` has been renamed to `OneParameterSpray
  a`, and \r\nall functions names which contained the string `Symbolic` have been
  changed by\r\nreplacing `Symbolic` with `OnePerameter`.\r\n\r\n* The class `HasVariables`,
  which is instantiated for `Spray` and \r\n`RatioOfSprays`, has a new method `changeVariables`
  allowing to perform \r\npolynomial transformations of the variables of a spray and
  of a ratio of \r\nsprays. For sprays, this is the same as the `composeSpray` function.\r\n\r\n*
  The class `HasVariables` is now also instantiated for `RatioOfPolynomials`.\r\n\r\n*
  The type alias `ParametricSpray a = Spray (RatioOfSprays a)` has been kept \r\nand
  the type alias `SimpleParametricSpray a = Spray (Spray a)` has been \r\nintroduced.
  We say that a `Spray b` spray is parametric when `b` has the \r\n`HasVariables`
  instance. So this applies to a `ParametricSpray a` spray, to \r\na `SimpleParametricSpray
  a` spray, and also to a `OneParameterSpray a` spray\r\n(recall that `OneParameterSpray
  a = Spray (RatioOfPolynomials a)`).\r\n\r\n* Functions to print `ParametricSpray`
  sprays and `SimpleParametricSpray` \r\nsprays.\r\n\r\n* Function `numberOfParameters`,
  returning the number of parameters of a \r\nparametric spray, that is to say the
  number of variables occurring in the \r\ncoefficients of this spray.\r\n\r\n* Function
  `changeParameters`, to perform polynomial transformations of the \r\nparameters
  of a parametric spray.\r\n\r\n* Function `substituteParameters` to replace the parameters
  of a parametric \r\nspray with some values. This is the same as `evalSpraySpray`(which
  will \r\nprobably disappear in the future).\r\n\r\n* Function `evalParametricSpray`
  to replace the variables of a parametric \r\nspray with some values."
changelog-type: markdown
description: "# hspray\r\n\r\n<!-- badges: start -->\r\n[![Stack-lts](https://github.com/stla/hspray/actions/workflows/Stack-lts.yml/badge.svg)](https://github.com/stla/hspray/actions/workflows/Stack-lts.yml)\r\n[![Stack-nightly](https://github.com/stla/hspray/actions/workflows/Stack-nightly.yml/badge.svg)](https://github.com/stla/hspray/actions/workflows/Stack-nightly.yml)\r\n<!--
  badges: end -->\r\n\r\n***Simple multivariate polynomials in Haskell.*** \r\nThis
  package deals with multivariate polynomials over a commutative ring, \r\nfractions
  of multivariate polynomials over a commutative field, and \r\nmultivariate polynomials
  with symbolic parameters in their coefficients.\r\n\r\n____\r\n\r\nThe main type
  provided by this package is `Spray a`. \r\nAn object of type `Spray a` represents
  a multivariate polynomial whose\r\ncoefficients are represented by the objects of
  type `a`. For example:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nx = lone
  1 :: Spray Double\r\ny = lone 2 :: Spray Double\r\nz = lone 3 :: Spray Double\r\npoly
  = (2 *^ (x^**^3 ^*^ y ^*^ z) ^+^ x^**^2) ^*^ (4 *^ (x ^*^ y ^*^ z))\r\nputStrLn
  $ prettyNumSpray poly\r\n-- 8.0*x^4.y^2.z^2 + 4.0*x^3.y.z\r\n```\r\n\r\nThis is
  the easiest way to construct a spray: first introduce the polynomial \r\nvariables
  with the `lone` function, and then combine them with arithmetic \r\noperations.\r\n\r\nThere
  are numerous functions to print a spray. If you don't like the letters \r\n`x`,
  `y`, `z` in the output of `prettyNumSpray`, you can use `prettyNumSprayXYZ` \r\nto
  change them to whatever you want:\r\n\r\n```haskell\r\nputStrLn $ prettyNumSprayXYZ
  [\"A\",\"B\",\"C\"] poly\r\n-- 8.0*A^4.B^2.C^2 + 4.0*A^3.B.C\r\n```\r\n\r\nNote
  that this function does not throw an error if you don't provide enough \r\nletters;
  in such a situation, it takes the first given letter and it appends \r\nit with
  the digit `i` to denote the `i`-th variable: \r\n\r\n```haskell\r\nputStrLn $ prettyNumSprayXYZ
  [\"A\",\"B\"] poly\r\n-- 8.0*A1^4.A2^2.A3^2 + 4.0*A1^3.A2.A3\r\n```\r\n\r\nThis
  is the same output as the one of `prettyNumSprayX1X2X3 \"A\" poly`.\r\n\r\nMore
  generally, one can use the type `Spray a` as long as the type `a` has \r\nthe instances
  `Eq` and `Algebra.Ring` (defined in the **numeric-prelude** \r\nlibrary). For example
  `a = Rational`:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nimport Data.Ratio\r\nx
  = lone 1 :: QSpray -- QSpray = Spray Rational\r\ny = lone 2 :: QSpray \r\nz = lone
  3 :: QSpray\r\npoly = ((2%3) *^ (x^**^3 ^*^ y ^*^ z) ^-^ x^**^2) ^*^ ((7%4) *^ (x
  ^*^ y ^*^ z))\r\nputStrLn $ prettyQSpray poly\r\n-- (7/6)*x^4.y^2.z^2 - (7/4)*x^3.y.z\r\n```\r\n\r\nOr
  `a = Spray Double`:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nalpha = lone
  1 :: Spray Double\r\nx = lone 1 :: Spray (Spray Double)\r\ny = lone 2 :: Spray (Spray
  Double)\r\npoly = ((alpha *^ x) ^+^ (alpha *^ y))^**^2  \r\nshowSprayXYZ' (prettyNumSprayXYZ
  [\"alpha\"]) [\"x\",\"y\"] poly\r\n-- (alpha^2)*x^2 + (2.0*alpha^2)*x.y + (alpha^2)*y^2\r\n```\r\n\r\nWe
  will come back to these sprays of type `Spray (Spray a)`. They can \r\nbe used to
  represent parametric polynomials.\r\n\r\n\r\n#### Evaluation of a spray:\r\n\r\n```haskell\r\nimport
  Math.Algebra.Hspray\r\nx = lone 1 :: Spray Double\r\ny = lone 2 :: Spray Double\r\nz
  = lone 3 :: Spray Double\r\nspray = 2 *^ (x ^*^ y ^*^ z) \r\n-- evaluate spray at
  x=2, y=1, z=2\r\nevalSpray spray [2, 1, 2]\r\n-- 8.0\r\n```\r\n\r\n#### Partial
  evaluation:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nimport Data.Ratio\r\nx1
  = lone 1 :: Spray Rational\r\nx2 = lone 2 :: Spray Rational\r\nx3 = lone 3 :: Spray
  Rational\r\nspray = x1^**^2 ^+^ x2 ^+^ x3 ^-^ unitSpray\r\nputStrLn $ prettyQSprayX1X2X3
  \"x\" spray\r\n-- x1^2 + x2 + x3 - 1\r\n--\r\n-- substitute x1 -> 2 and x3 -> 3,
  and don't substitute x2\r\nspray' = substituteSpray [Just 2, Nothing, Just 3] spray\r\nputStrLn
  $ prettyQSprayX1X2X3 \"x\" spray'\r\n-- x2 + 6\r\n```\r\n\r\n#### Differentiation
  of a spray:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nx = lone 1 :: Spray
  Double\r\ny = lone 2 :: Spray Double\r\nz = lone 3 :: Spray Double\r\nspray = 2
  *^ (x ^*^ y ^*^ z) ^+^ (3 *^ x^**^2)\r\nputStrLn $ prettyNumSpray spray\r\n-- 3.0*x^2
  + 2.0*x.y.z\r\n--\r\n-- derivative with respect to x\r\nputStrLn $ prettyNumSpray
  $ derivative 1 spray\r\n-- 6.0*x + 2.0*y.z\"\r\n```\r\n\r\n## Gröbner bases\r\n\r\nAs
  of version 2.0.0, it is possible to compute a Gröbner basis of the ideal \r\ngenerated
  by a list of spray polynomials.\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nimport
  Data.Ratio\r\n-- define the elementary monomials\r\no = lone 0 :: Spray Rational
  -- same as unitSpray\r\nx = lone 1 :: Spray Rational\r\ny = lone 2 :: Spray Rational\r\nz
  = lone 3 :: Spray Rational\r\n-- define three polynomials\r\np1 = x^**^2 ^+^ y ^+^
  z ^-^ o -- X² + Y + Z - 1\r\np2 = x ^+^ y^**^2 ^+^ z ^-^ o -- X + Y² + Z - 1\r\np3
  = x ^+^ y ^+^ z^**^2 ^-^ o -- X + Y + Z² - 1\r\n-- compute the reduced Gröbner basis\r\ngbasis
  = groebner [p1, p2, p3] True\r\n-- show result\r\nprettyResult = map prettyQSpray
  gbasis\r\nmapM_ print prettyResult\r\n-- \"x + y + z^2 - 1\"\r\n-- \"y^2 - y - z^2
  + z\"\r\n-- \"y.z^2 + (1/2)*z^4 - (1/2)*z^2\"\r\n-- \"z^6 - 4*z^4 + 4*z^3 - z^2\"\r\n```\r\n\r\n\r\n##
  Easier usage \r\n\r\nTo construct a spray using the ordinary symbols `+`, `-`, `*`
  and `^`, \r\none can hide these operators from **Prelude** and import them from
  the \r\n**numeric-prelude** library; constructing a spray in this context is easier:\r\n\r\n```haskell\r\nimport
  Prelude hiding ((+), (-), (*), (^), (*>), (<*))\r\nimport qualified Prelude as P\r\nimport
  Algebra.Additive              \r\nimport Algebra.Module                \r\nimport
  Algebra.Ring                  \r\nimport Math.Algebra.Hspray\r\nimport Data.Ratio\r\nx
  = lone 1 :: QSpray \r\ny = lone 2 :: QSpray \r\nz = lone 3 :: QSpray\r\nspray  =
  ((2%3) *^ (x^**^3 ^*^ y ^*^ z) ^-^ x^**^2) ^*^ ((7%4) *^ (x ^*^ y ^*^ z))\r\nspray'
  = ((2%3) *^ (x^3 * y * z) - x^2) * ((7%4) *^ (x * y * z))\r\nspray == spray'\r\n--
  True\r\n```\r\n\r\nNote that `*>` could be used instead of `*^` but running `lambda
  *> spray` \r\npossibly throws an \"ambiguous type\" error regarding the type of
  `lambda`.\r\n\r\nMaybe better (I didn't try yet), follow the \"Usage\" section on
  the \r\n[Hackage page](https://hackage.haskell.org/package/numeric-prelude-0.4.4#usage)
  \r\nof **numeric-prelude**.\r\n\r\n\r\n## Symbolic parameters in the coefficients\r\n\r\nAssume
  you have the polynomial `a * (x² + y²) + 2b/3 * z`, \r\nwhere `a` and `b` are symbolic
  rational numbers. You can represent this \r\npolynomial by a `Spray (Spray Rational)`
  spray as follows:\r\n\r\n```haskell\r\nimport Prelude hiding ((*), (+), (-), (^))\r\nimport
  qualified Prelude as P\r\nimport Algebra.Additive              \r\nimport Algebra.Ring
  \                 \r\nimport Math.Algebra.Hspray\r\n\r\nx = lone 1 :: Spray (Spray
  Rational)\r\ny = lone 2 :: Spray (Spray Rational)\r\nz = lone 3 :: Spray (Spray
  Rational)\r\na = lone 1 :: Spray Rational\r\nb = lone 2 :: Spray Rational\r\n\r\nspray
  = a *^ (x^2 + y^2) + ((2 *^ b) /^ 3) *^ z \r\nputStrLn $ \r\n  showSprayXYZ' (prettyQSprayXYZ
  [\"a\",\"b\"]) [\"X\",\"Y\",\"Z\"] spray\r\n-- (a)*X^2 + (a)*Y^2 + ((2/3)*b)*Z\r\n```\r\n\r\nYou
  can extract the powers and the coefficients as follows:\r\n\r\n```haskell\r\nl =
  toList spray\r\nmap fst l\r\n-- [[0,0,1],[2],[0,2]]\r\nmap toList $ map snd l\r\n--
  [[([0,1],2 % 3)],[([1],1 % 1)],[([1],1 % 1)]]\r\n```\r\n\r\nThese `Spray (Spray
  a)` sprays can be very useful. They represent polynomials \r\nwhose coefficients
  polynomially depend on some parameters. \r\nActually there is a type alias of `Spray
  (Spray a)` in **hspray**, namely \r\n`SimpleParametricSpray a`, and there are some
  convenient functions to deal \r\nwith sprays of this type. There is also a type
  alias of \r\n`SimpleParametricSpray Rational`, namely `SimpleParametricQSpray`.\r\nFor
  example we can print our `SimpleParametricQSpray` spray `spray` as follows:\r\n\r\n```haskell\r\nputStrLn
  $ \r\n  prettySimpleParametricQSprayABCXYZ [\"a\",\"b\"] [\"X\",\"Y\",\"Z\"] spray\r\n--
  { a }*X^2 + { a }*Y^2 + { (2/3)*b }*Z\r\n```\r\n\r\nThe \r\n[Gegenbauer polynomials](https://en.wikipedia.org/wiki/Gegenbauer_polynomials)\r\nare
  a real-life example of polynomials that can be represented by \r\n`SimpleParametricQSpray`
  sprays. They are univariate polynomials whose \r\ncoefficients polynomially depend
  on a parameter $\\alpha$ (the polynomial \r\ndependency is clearly visible from
  the recurrence relation given on \r\nWikipedia). Here is their recursive implementation
  in **hspray**:\r\n\r\n```haskell\r\ngegenbauerPolynomial :: Int -> SimpleParametricQSpray
  \r\ngegenbauerPolynomial n \r\n  | n == 0 = unitSpray\r\n  | n == 1 = (2.^a) *^
  x\r\n  | otherwise = \r\n    (2.^(n'' ^+^ a) /^ n') *^ (x ^*^ gegenbauerPolynomial
  (n - 1))\r\n    ^-^ ((n'' ^+^ 2.^a ^-^ unitSpray) /^ n') *^ gegenbauerPolynomial
  (n - 2)\r\n  where \r\n    x = lone 1 :: SimpleParametricQSpray\r\n    a = lone
  1 :: QSpray\r\n    n'  = toRational n\r\n    n'' = constantSpray (n' - 1)\r\n```\r\n\r\nLet's
  try it:\r\n\r\n```haskell\r\nn = 3\r\ng = gegenbauerPolynomial n\r\nputStrLn $ \r\n
  \ prettySimpleParametricQSprayABCXYZ [\"alpha\"] [\"X\"]  g\r\n-- { (4/3)*alpha^3
  + 4*alpha^2 + (8/3)*alpha }*X^3 + { -2*alpha^2 - 2*alpha }*X\r\n```\r\n\r\nLet's
  check the differential equation given in the Wikipedia article:\r\n\r\n```haskell\r\ng'
  \ = derivative 1 g\r\ng'' = derivative 1 g'\r\nalpha = lone 1 :: QSpray\r\nx     =
  lone 1 :: SimpleParametricQSpray\r\nnAsSpray = constantSpray (toRational n)\r\nshouldBeZero
  = \r\n  (unitSpray ^-^ x^**^2) ^*^ g''\r\n    ^-^ (2.^alpha ^+^ unitSpray) *^ (x
  ^*^ g')\r\n      ^+^ n.^(nAsSpray ^+^ 2.^alpha) *^ g\r\nputStrLn $ prettySpray shouldBeZero\r\n--
  0\r\n```\r\n\r\nNow, how to substitute a value to the parameter $\\alpha$? For example,
  it is \r\nsaid in the Wikipedia article that this yields the Legendre polynomials
  for \r\n$\\alpha = 1/2$. The package provides the function `substituteParameters`
  to \r\nperform this task:\r\n\r\n```haskell\r\nimport Data.Ratio (%)\r\nputStrLn
  $ \r\n  prettyQSpray'' $ substituteParameters g [1%2]\r\n-- (5/2)*X^3 - (3/2)*X\r\n```\r\n\r\nThis
  is a `Spray Rational` spray.\r\n\r\nThe Wikipedia article also provides the value
  at $1$ of the Gegenbauer \r\npolynomials in function of $\\alpha$. We can get this
  value with \r\n`evalParametricSpray`:\r\n\r\n```haskell\r\nputStrLn $ \r\n  prettyQSprayXYZ
  [\"alpha\"] $ evalParametricSpray g [1]\r\n-- (4/3)*alpha^3 + 2*alpha^2 + (2/3)*alpha\r\n```\r\n\r\nThis
  is also a `Spray Rational` spray.\r\n\r\n\r\n## Ratios of sprays and general parametric
  sprays\r\n\r\nSince you have just seen that the type `Spray (Spray a)` is named
  \r\n`SimpleParametricSpray`, you probably guessed there is also a more general \r\ntype
  named `ParametricSpray`. Yes, and this is an alias of \r\n`Spray (RatioOfSprays
  a)`, where the type `RatioOfSprays a` has not been \r\ndiscussed yet. The objects
  of this type represent fractions of multivariate \r\npolynomials and so this type
  is a considerable enlargment of the `Spray a` \r\ntype. Thus the `Spray (RatioOfSprays
  a)` sprays can represent multivariate \r\npolynomials whose coefficients depend
  on some parameters, with a dependence \r\ndescribed by a fraction of polynomials
  in these parameters. Let's start with \r\na short presentation of the ratios of
  sprays.\r\n\r\n### The `RatioOfSprays` type\r\n\r\nThe type `RatioOfSprays a`, whose
  objects represent ratios of sprays, has \r\nbeen introduced in version 0.2.7.0.
  \r\nTo construct a ratio of sprays, apply `%//%` between its numerator and \r\nits
  denominator:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nx = qlone 1 -- shortcut
  for  lone 1 :: Spray Rational\r\ny = qlone 2 \r\nrOS = (x ^-^ y) %//% (x^**^2 ^-^
  y^**^2)\r\nputStrLn $ prettyRatioOfQSprays rOS\r\n-- [ 1 ] %//% [ x + y ]\r\n```\r\n\r\nThe
  `%//%` operator always returns an *irreducible fraction*. If you are \r\n***sure***
  that your numerator and your denominator are coprime, you can use\r\nthe `%:%` instead,
  to gain some efficiency. But if they are not coprime, this \r\ncan have unfortunate
  consequences.\r\n\r\nThe `RatioOfSprays a` type makes sense when `a` has a field
  instance, and then \r\nit has a field instance too. To use the field operations,
  import the necessary\r\nmodules from **numeric-prelude**, and hide these operations
  from the `Prelude`\r\nmodule; then you can also use the **numeric-prelude** operations
  for sprays, \r\ninstead of using `^+^`, `^-^`, `^*^`, `^**^`:\r\n\r\n```haskell\r\nimport
  Prelude hiding ((+), (-), (*), (/), (^), (*>), (<*))\r\nimport qualified Prelude
  as P\r\nimport Algebra.Additive              \r\nimport Algebra.Module\r\nimport
  Algebra.RightModule\r\nimport Algebra.Ring\r\nimport Algebra.Field              \r\nimport
  Math.Algebra.Hspray\r\nx = qlone 1  \r\ny = qlone 2 \r\np = x^2 - 3*^(x * y) + y^3
  \r\nq = x - y\r\nrOS1 = p^2 %//% q\r\nrOS2 = rOS1 + unitRatioOfSprays\r\nrOS = rOS1^2
  + rOS1*rOS2 - rOS1/rOS2 + rOS2 -- slow!\r\n(rOS1 + rOS2) * (rOS1 - rOS2) == rOS1^2
  - rOS2^2\r\n-- True\r\nrOS / rOS == unitRatioOfSprays\r\n-- True\r\n```\r\n\r\nThe
  `RatioOfSprays a` type also has left and right module instances over `a` \r\nand
  over `Spray a` as well. That means you can multiply a ratio of sprays by\r\na scalar
  and by a spray, by using, depending on the side, either `*>` or `<*`:\r\n\r\n```haskell\r\nimport
  Data.Ratio ( (%) )\r\nrOS' = (3%4::Rational) *> rOS^2  +  p *> rOS\r\n```\r\n\r\nYou
  can also divide a ratio of sprays by a spray with `%/%`:\r\n\r\n```haskell\r\np
  *> (rOS' %/% p) == rOS'\r\n-- True\r\nrOS1 %/% p == p %//% q\r\n-- True\r\n```\r\n\r\nWhen
  `a` has a field instance, both a `Spray a` spray and a `RatioOfSprays a` \r\nratio
  of sprays can be divided by a scalar with the `/>` operator:\r\n\r\n```haskell\r\nk
  = 3 :: Rational\r\n(p /> k) *> rOS == p *> (rOS /> k)\r\n-- True\r\n```\r\n\r\nUse
  `evalRatioOfSprays` to evaluate a ratio of sprays:\r\n\r\n```haskell\r\nimport Data.Ratio
  ( (%) )\r\nf :: Algebra.Field.C a => a -> a -> a\r\nf u v = u^2 + u*v - u/v + v\r\nrOS
  == f rOS1 rOS2\r\n-- True\r\nvalues = [2%3, 7%4]\r\nr1 = evalRatioOfSprays rOS1
  values\r\nr2 = evalRatioOfSprays rOS2 values\r\nevalRatioOfSprays rOS values ==
  f r1 r2\r\n-- True\r\n```\r\n\r\n### The `ParametricSpray` type\r\n\r\nRecall that
  `SimpleParametricSpray a = Spray (Spray a)` and \r\n`ParametricSpray a = Spray (RatioOfSprays
  a)`, and we have the aliases \r\n`SimpleParametricQSpray = SimpleParametricSpray
  Rational` and \r\n`ParametricQSpray = ParametricSpray Rational`.\r\n\r\nThe functions
  `substituteParameters` and `evalParametricSpray`, that we \r\npreviously applied
  to a `SimpleParametricSpray a` spray, are also applicable \r\nto a `ParametricSpray
  a` spray. We didn't mention the function \r\n`changeParameters` yet, which is also
  applicable to these two types of sprays.\r\nThis function performs some polynomial
  transformations of the parameters of a\r\nparametric spray. \r\nFor example, consider
  the \r\n[Jacobi polynomials](https://en.wikipedia.org/wiki/Jacobi_polynomials).
  \r\nThey are univariate polynomials with two parameters $\\alpha$ and $\\beta$.
  \r\nThey are implemented in **hspray** as `ParametricQSpray` sprays. In fact \r\nit
  seems that the coefficients of the Jacobi polynomials *polynomially* \r\ndepend
  on $\\alpha$ and $\\beta$, and if this is true one could implement them \r\nas `SimpleParametricQSpray`
  sprays. I will come back to this point later. The \r\nrecurrence relation defining
  the Jacobi polynomials involves a division which \r\nmakes the type `ParametricQSpray`
  necessary anyway. \r\nThe `changeParameters` function is useful to derive the Gegenbauer
  polynomials \r\nfrom the Jacobi polynomials. Indeed, as asserted in the Wikipedia
  article, \r\nthe Gegenbauer polynomials coincide, up to a factor, with the Jacobi
  \r\npolynomials with parameters $\\alpha - 1/2$ and $\\alpha - 1/2$. Here is how
  \r\nto apply the `changeParameters` function to get this special case of Jacobi
  \r\npolynomials:\r\n\r\n```haskell\r\nimport Data.Ratio ( (%) )\r\nj = jacobiPolynomial
  3\r\nalpha = qlone 1\r\nalpha' = alpha ^-^ constantSpray (1%2)\r\nj' = changeParameters
  j [alpha', alpha']\r\n```\r\n\r\nNow let's come back to the conjecture claiming
  that the coefficients of the \r\nJacobi polynomials *polynomially* depend on $\\alpha$
  and $\\beta$, and thus \r\nthese polynomials can be represented by `SimpleParametricQSpray`
  sprays. \r\nMaybe this can be deduced from a formula given in the Wikipedia article,
  I \r\ndidn't spend some time on this problem. I made this conjecture because I \r\nobserved
  this fact for some small values of $n$, and I tried the function\r\n`canCoerceToSimpleParametricSpray`
  for other values, which always returned \r\n`True`. One can apply the function `asSimpleParametricSpray`
  to perform the \r\ncoercion.\r\n\r\n\r\n## The `OneParameterSpray` type\r\n\r\nFinally,
  let us mention the `OneParameterSpray a` type. Objects of this type \r\nrepresent
  multivariate polynomials whose coefficients are fractions \r\nof polynomials in
  only one parameter. So they are less general than the \r\n`ParametricSpray a` sprays,
  but they are a bit more efficient.\r\n\r\nAssume for example that you want to deal
  with the polynomial \r\n`4/5 * a/(a² + 1) * (x² + y²) + 2a/3 * yz`. \r\nThen you
  define it as follows:\r\n\r\n```haskell\r\nimport           Prelude hiding ((*),
  (+), (-), (/), (^), (*>))\r\nimport qualified Prelude as P\r\nimport           Algebra.Additive
  \             \r\nimport           Algebra.Module            \r\nimport           Algebra.Ring\r\nimport
  \          Algebra.Field\r\nimport           Math.Algebra.Hspray\r\nimport           Number.Ratio
  \      ( (%), T ( (:%) ) )\r\nx = lone 1 :: OneParameterQSpray \r\ny = lone 2 ::
  OneParameterQSpray \r\nz = lone 3 :: OneParameterQSpray\r\na = qsoleParameter\r\nspray
  \r\n  = ((4%5) *. (a :% (a^2 + one))) *> (x^2 + y^2)  +  (constQPoly (2%3) * a)
  *> (y * z)\r\nputStrLn $ prettyOneParameterQSpray' \"a\" spray\r\n-- { [ (4/5)*a
  ] %//% [ a^2 + 1 ] }*X^2 + { [ (4/5)*a ] %//% [ a^2 + 1 ] }*Y^2 + { (2/3)*a }*Y.Z\r\n```\r\n\r\nNot
  very easy... If you are more comfortable with the `ParametricSpray` sprays, \r\nconstruct
  such a spray and convert it to a `OneParameterSpray` with the \r\nfunction `parametricSprayToOneParameterSpray`
  or \r\n`parametricQSprayToOneParameterQSpray`.\r\n\r\nThe functions we have seen
  for the simple parametric sprays and the parametric \r\nsprays are also applicable
  to the one-parameter sprays. These are sprays of \r\ntype `Spray (RatioOfPolynomials
  a)`, where the type `RatioOfPolynomials a` \r\ndeals with objects that represent
  fractions of *univariate* polynomials.\r\n\r\nSimilary to the ratios of sprays,
  the nice point regarding these ratios of \r\nunivariate polynomials is that they
  are automatically written as irreducible \r\nfractions. For example:\r\n\r\n```haskell\r\npolyFrac
  = (a^8 - one) % (a - one)\r\nputStrLn $ prettyRatioOfQPolynomials \"a\" polyFrac\r\n--
  a^7 + a^6 + a^5 + a^4 + a^3 + a^2 + a + 1\r\n```\r\n\r\nNote that I used `%` here
  and not `:%`. That's because `:%` does not reduce \r\nthe fraction, it just constructs
  a fraction with the given numerator and \r\ndenominator. Whenever an arithmetic
  operation is performed on a fraction, the \r\nresult is always an irreducible fraction.
  \r\n\r\nThe `OneParameterSpray a` sprays are used in the \r\n[**jackpolynomials**
  package](https://github.com/stla/jackpolynomials). \r\n\r\nThere is a slightly annoying
  point to note: the type `OneParameterQSpray` \r\nis *not* `OneParameterSpray Rational`:
  it is `OneParameterSpray Rational'`, \r\nwhere `Rational'` is a type similar to
  `Rational` defined in the \r\n**numeric-prelude** package. I had to use this type
  because `Rational'` has \r\nthe necessary instances. \r\n\r\n\r\n## Other features\r\n\r\nResultant
  and subresultants of two polynomials, and greatest common divisor of \r\ntwo polynomials
  with coefficients in a field."
description-type: markdown
hash: cc67ea3ea5fe82b1c4bf793c7b561a9cf0fc4acf45a4ed833f276050c4bf3bde
homepage: https://github.com/stla/hspray#readme
latest: 0.3.0.0
license-name: GPL-3.0-only
maintainer: laurent_step@outlook.fr
synopsis: Multivariate polynomials and fractions of multivariate polynomials.
test-bench-deps:
  base: '>=4.7 && <5'
  hspray: '>=0'
  matrix: '>=0.3.6.0 && <0.4'
  numeric-prelude: '>=0.4.4 && <0.5'
  tasty: '>=1.4 && <1.6'
  tasty-bench: '>=0.3 && <0.4'
  tasty-hunit: '>=0.10 && <0.11'
  unordered-containers: '>=0.2.17.0 && <0.3'

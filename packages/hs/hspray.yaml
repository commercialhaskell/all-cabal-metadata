all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
- 0.1.3.0
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.2.2.0
- 0.2.3.0
- 0.2.4.0
- 0.2.5.0
- 0.2.6.0
author: Stéphane Laurent
basic-deps:
  base: '>=4.7 && <5'
  containers: '>=0.6.4.1 && <0.8'
  hashable: '>=1.3.4.0 && <1.5'
  matrix: '>=0.3.6.0 && <0.4'
  numeric-prelude: '>=0.4.4 && <0.5'
  text: '>=1.2.5.0 && <2.2'
  unordered-containers: '>=0.2.17.0 && <0.3'
changelog: "# Changelog for `hspray`\r\n\r\nAll notable changes to this project will
  be documented in this file.\r\n\r\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\r\nand
  this project adheres to the\r\n[Haskell Package Versioning Policy](https://pvp.haskell.org/).\r\n\r\n\r\n##
  0.1.0.0 - 2022-12-11\r\n\r\nFirst release.\r\n\r\n\r\n## 0.1.1.0 - 2022-12-12\r\n\r\n*
  New functions `toList`, `sprayTerms` and `bombieriSpray`.\r\n\r\n* New operation
  `.^`, to multiply a spray by an integer.\r\n\r\n* Added some unit tests.\r\n\r\n\r\n##
  0.1.2.0 - 2023-02-24\r\n\r\nNew function `derivSpray`, to differentiate a spray.\r\n\r\n\r\n##
  0.1.3.0 - 2023-08-29\r\n\r\n* `Powers(..)` is now exported.\r\n\r\n* Completed the
  README to show how to deal with symbolic coefficients.\r\n\r\n\r\n## 0.2.0.0 - 2024-03-14\r\n\r\n*
  New functions `prettySpray'` and `prettySprayXYZ`.\r\n\r\n* New function `substituteSpray`.\r\n\r\n*
  New function `sprayDivision`, to perform the division of a spray by a list of sprays.\r\n\r\n*
  New function `groebner`, to compute a Groebner basis of a list of sprays.\r\n\r\n*
  New function `isSymmetricSpray`, to check whether a spray is a symmetric polynomial.\r\n\r\n*
  New function `isPolynomialOf`, to check whether a spray can be expressed as a polynomial
  of a given list of sprays.\r\n\r\n\r\n## 0.2.1.0 - 2024-03-22\r\n\r\n* New functions
  `permuteVariables` and `swapVariables`.\r\n\r\n* New function `resultant`, to compute
  the resultant of two sprays.\r\n\r\n* New function `subresultants`, to compute the
  subresultants of two sprays.\r\n\r\n\r\n## 0.2.1.1 - 2024-03-25\r\n\r\n* Improved
  the documentation.\r\n\r\n* Flipped the order of appearance of the terms in the
  output of the `prettySpray` functions.\r\n\r\n\r\n## 0.2.2.0 - 2024-03-26\r\n\r\n*
  Fixed an error in `esPolynomial`, which resulted to a bug in `isSymmetricSpray`.\r\n\r\n\r\n##
  0.2.3.0 - 2024-03-28\r\n\r\n* New unit tests.\r\n\r\n* Fixed `resultant` and `subresultants`:
  the variables of the sprays they return were incorrect.\r\n\r\n* New function `gcdQX`,
  to compute the greatest common divisor of two univariate sprays with rational coefficients.\r\n\r\n\r\n##
  0.2.4.0 - 2024-03-30\r\n\r\n* Flipped the order of the arguments in `permuteVariables`
  and `swapVariables`.\r\n\r\n* New function `gcdSpray`, to compute the greatest common
  divisor of two sprays with coefficients in a field. \r\n\r\n* The function `gcdQX`
  has been removed since `gcdSpray` is more general.\r\n\r\n* The function `sprayDivision`
  has been renamed to `sprayDivisionRemainder`.\r\n\r\n* New function `sprayDivision`,
  returning the quotient and the remainder of the division of two sprays.\r\n\r\n\r\n##
  0.2.5.0 - 2024-04-02\r\n\r\n* New function `resultant'` which computes the resultant
  of two sprays with coefficients in a field. \r\nThus it is less general than the
  function `resultant` but it is more efficient. \r\n\r\n* Fixed a small mistake in
  `isSymmetricSpray` and `isPolynomialOf`: these functions didn't deal with \r\nthe
  constant term of the spray.\r\n\r\n* New function `psPolynomial` which computes
  the power sum polynomials.\r\n\r\n* A particular type of sprays, namely `SymbolicSpray
  a`, has been introduced. The coefficients of \r\nthese sprays are ratios of univariate
  polynomials with `a` coefficients. There is a specialization \r\n`SymbolicQSpray`
  for the case when `a` is a type of rational numbers. The necessary instances have
  \r\nbeen defined and there is the function `prettySymbolic(Q)Spray` to display such
  sprays. There are \r\nalso some functions to perform evaluation of such sprays.\r\n\r\n\r\n##
  0.2.6.0 - 2024-04-15\r\n\r\n* New function `collinearSprays` which checks whether
  two sprays are collinear.\r\n\r\n* The function `isPolynomialOf` threw an error
  when the number of variables in the spray \r\nto be tested was less than the number
  of variables in the list of sprays. That is me who \r\nprogrammed this error and
  this was wrong: for example, `x = p1 - p2^*^p3` with `p1 = x + y^*^z`, \r\n`p2 =
  y`, and `p3 = z`.\r\n\r\n* New functions to print sprays with numeric coefficients,
  such as `prettyNumSpray` and \r\n`prettyQSpray`.\r\n\r\n* The functions `prettySpray`,
  `prettySpray'` and `prettySpray''` have been changed.\r\n\r\n* New functions to
  print symbolic sprays.\r\n\r\n* Documentation and README have been improved."
changelog-type: markdown
description: "# hspray\r\n\r\n<!-- badges: start -->\r\n[![Stack-lts](https://github.com/stla/hspray/actions/workflows/Stack-lts.yml/badge.svg)](https://github.com/stla/hspray/actions/workflows/Stack-lts.yml)\r\n[![Stack-nightly](https://github.com/stla/hspray/actions/workflows/Stack-nightly.yml/badge.svg)](https://github.com/stla/hspray/actions/workflows/Stack-nightly.yml)\r\n<!--
  badges: end -->\r\n\r\n*Simple multivariate polynomials in Haskell.*\r\n\r\n___\r\n\r\nThe
  `Spray a` type represents the multivariate polynomials with coefficients \r\nin
  `a`. For example:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nx = lone 1
  :: Spray Double\r\ny = lone 2 :: Spray Double\r\nz = lone 3 :: Spray Double\r\npoly
  = (2 *^ (x^**^3 ^*^ y ^*^ z) ^+^ x^**^2) ^*^ (4 *^ (x ^*^ y ^*^ z))\r\nputStrLn
  $ prettyNumSpray poly\r\n-- 8.0*x^4.y^2.z^2 + 4.0*x^3.y.z\r\n```\r\n\r\nThis is
  the easiest way to construct a spray: first introduce the polynomial \r\nvariables
  with the `lone` function, and then use arithmetic operations.\r\n\r\nThere are numerous
  functions to print a spray. If you don't like the letters \r\n`x`, `y`, `z` in the
  output of `prettyNumSpray`, you can use `prettyNumSprayXYZ` \r\nto change them to
  whatever you want:\r\n\r\n```haskell\r\nputStrLn $ prettyNumSprayXYZ [\"A\",\"B\",\"C\"]
  poly\r\n-- 8.0*A^4.B^2.C^2 + 4.0*A^3.B.C\r\n```\r\n\r\nNote that this function does
  not throw an error if you don't provide enough \r\nletters:\r\n\r\n```haskell\r\nputStrLn
  $ prettyNumSprayXYZ [\"A\",\"B\"] poly\r\n-- 8.0*A1^4.A2^2.A3^2 + 4.0*A1^3.A2.A3\r\n```\r\n\r\nThis
  is the same output as the one of `prettyNumSprayX1X2X3 \"A\" poly`.\r\n\r\nMore
  generally, one can use the type `Spray a` as long as the type `a` has \r\nthe instances
  `Eq` and `Algebra.Ring` (defined in the **numeric-prelude** \r\nlibrary). For example
  `a = Rational`:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nimport Data.Ratio\r\nx
  = lone 1 :: QSpray -- QSpray = Spray Rational\r\ny = lone 2 :: QSpray \r\nz = lone
  3 :: QSpray\r\npoly = ((2%3) *^ (x^**^3 ^*^ y ^*^ z) ^-^ x^**^2) ^*^ ((7%4) *^ (x
  ^*^ y ^*^ z))\r\nputStrLn $ prettyQSpray poly\r\n-- (7/6)*x^4.y^2.z^2 - (7/4)*x^3.y.z\r\n```\r\n\r\nOr
  `a = Spray Double`:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nalpha = lone
  1 :: Spray Double\r\nx = lone 1 :: Spray (Spray Double)\r\ny = lone 2 :: Spray (Spray
  Double)\r\npoly = ((alpha *^ x) ^+^ (alpha *^ y))^**^2  \r\nshowSprayXYZ' (prettyNumSprayXYZ
  [\"alpha\"]) [\"x\",\"y\"] poly\r\n-- (alpha^2)*x^2 + (2.0*alpha^2)*x.y + (alpha^2)*y^2\r\n```\r\n\r\n####
  Evaluation:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nx = lone 1 :: Spray
  Double\r\ny = lone 2 :: Spray Double\r\nz = lone 3 :: Spray Double\r\npoly = 2 *^
  (x ^*^ y ^*^ z) \r\n-- evaluate poly at x=2, y=1, z=2\r\nevalSpray poly [2, 1, 2]\r\n--
  8.0\r\n```\r\n\r\n#### Partial evaluation:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nimport
  Data.Ratio\r\nx1 = lone 1 :: Spray Rational\r\nx2 = lone 2 :: Spray Rational\r\nx3
  = lone 3 :: Spray Rational\r\npoly = x1^**^2 ^+^ x2 ^+^ x3 ^-^ unitSpray\r\nputStrLn
  $ prettyQSprayX1X2X3 \"x\" poly\r\n-- x1^2 + x2 + x3 - 1\r\n--\r\n-- substitute
  x1 -> 2 and x3 -> 3\r\npoly' = substituteSpray [Just 2, Nothing, Just 3] poly\r\nputStrLn
  $ prettyQSprayX1X2X3 \"x\" poly'\r\n-- x2 + 6\r\n```\r\n\r\n#### Differentiation:\r\n\r\n```haskell\r\nimport
  Math.Algebra.Hspray\r\nx = lone 1 :: Spray Double\r\ny = lone 2 :: Spray Double\r\nz
  = lone 3 :: Spray Double\r\npoly = 2 *^ (x ^*^ y ^*^ z) ^+^ (3 *^ x^**^2)\r\nputStrLn
  $ prettyNumSpray poly\r\n-- 3.0*x^2 + 2.0*x.y.z\r\n--\r\n-- derivative with respect
  to x\r\nputStrLn $ prettyNumSpray $ derivSpray 1 poly\r\n-- 6.0*x + 2.0*y.z\"\r\n```\r\n\r\n##
  Gröbner bases\r\n\r\nAs of version 2.0.0, it is possible to compute a Gröbner basis.\r\n\r\n```haskell\r\nimport
  Math.Algebra.Hspray\r\nimport Data.Ratio\r\n-- define the elementary monomials\r\no
  = lone 0 :: Spray Rational -- same as unitSpray\r\nx = lone 1 :: Spray Rational\r\ny
  = lone 2 :: Spray Rational\r\nz = lone 3 :: Spray Rational\r\n-- define three polynomials\r\np1
  = x^**^2 ^+^ y ^+^ z ^-^ o -- X² + Y + Z - 1\r\np2 = x ^+^ y^**^2 ^+^ z ^-^ o --
  X + Y² + Z - 1\r\np3 = x ^+^ y ^+^ z^**^2 ^-^ o -- X + Y + Z² - 1\r\n-- compute
  the reduced Gröbner basis\r\ngbasis = groebner [p1, p2, p3] True\r\n-- show result\r\nprettyResult
  = map prettyQSpray gbasis\r\nmapM_ print prettyResult\r\n-- \"x + y + z^2 - 1\"\r\n--
  \"y^2 - y - z^2 + z\"\r\n-- \"y.z^2 + (1/2)*z^4 - (1/2)*z^2\"\r\n-- \"z^6 - 4*z^4
  + 4*z^3 - z^2\"\r\n```\r\n\r\n\r\n## Easier usage \r\n\r\nTo construct a polynomial
  using the ordinary symbols `+`, `*` and `-`, \r\none can hide these operators from
  **Prelude** and import them from \r\nthe **numeric-prelude** library:\r\n\r\n```haskell\r\nimport
  Prelude hiding ((*), (+), (-))\r\nimport qualified Prelude as P\r\nimport Algebra.Additive
  \             \r\nimport Algebra.Module                \r\nimport Algebra.Ring                  \r\nimport
  Math.Algebra.Hspray\r\n```\r\n\r\nOr, maybe better (I didn't try yet), follow the
  \"Usage\" section on the \r\n[Hackage page](https://hackage.haskell.org/package/numeric-prelude-0.4.4#usage)
  \r\nof **numeric-prelude**.\r\n\r\n\r\n## Symbolic coefficients\r\n\r\nAssume you
  have the polynomial `a * (x² + y²) + 2b/3 * z`, \r\nwhere `a` and `b` are symbolic
  coefficients. \r\nYou can define this polynomial as a `Spray` as follows:\r\n\r\n```haskell\r\nimport
  Prelude hiding ((*), (+), (-))\r\nimport qualified Prelude as P\r\nimport Algebra.Additive
  \             \r\nimport Algebra.Module                \r\nimport Algebra.Ring                  \r\nimport
  Math.Algebra.Hspray\r\nimport Data.Ratio\r\n\r\nx = lone 1 :: Spray (Spray Rational)\r\ny
  = lone 2 :: Spray (Spray Rational)\r\nz = lone 3 :: Spray (Spray Rational)\r\na
  = lone 1 :: Spray Rational\r\nb = lone 2 :: Spray Rational\r\n\r\npoly = a *^ (x*x
  + y*y) + ((2%3) *^ b) *^ z \r\nputStrLn $ showSprayXYZ' (prettyQSprayXYZ [\"a\",\"b\"])
  [\"X\",\"Y\",\"Z\"] poly\r\n-- (a)*X^2 + (a)*Y^2 + ((2/3)*b)*Z\r\n```\r\n\r\nYou
  can extract the powers and the coefficients as follows:\r\n\r\n```haskell\r\nl =
  toList poly\r\nmap fst l\r\n-- [[0,0,1],[2],[0,2]]\r\nmap toList $ map snd l\r\n--
  [[([0,1],2 % 3)],[([1],1 % 1)],[([1],1 % 1)]]\r\n```\r\n\r\n## The `SymbolicSpray`
  type\r\n\r\nIf you have only one symbolic coefficient, it is easier to deal with
  the sprays of type \r\n`SymbolicSpray`. These are sprays whose coefficients are
  ratios of univariate polynomials, \r\nso this allows more possibilities than a `Spray
  (Spray a)`. Since the variable \r\nof these univariate polynomials occurs in the
  coefficients of such a spray, I \r\ncall it the *outer variable* sometimes, although
  I do not very like this name \r\n(see below). And I say that the variables of the
  symbolic spray are the \r\n*inner variables* or the *main variables*, though I would
  prefer to simply call \r\nthem the *variables*.\r\nAssume you want to deal with
  the polynomial `4/5 * a/(a² + 1) * (x² + y²) + 2a/3 * yz`. \r\nThen you define it
  as follows:\r\n\r\n```haskell\r\nimport           Prelude hiding ((*), (+), (-),
  (/), (^), (*>))\r\nimport qualified Prelude as P\r\nimport           Algebra.Additive
  \             \r\nimport           Algebra.Module            \r\nimport           Algebra.Ring\r\nimport
  \          Algebra.Field                \r\nimport           Math.Algebra.Hspray\r\nimport
  \          Number.Ratio       ( (%), T ( (:%) ) )\r\nx = lone 1 :: SymbolicQSpray
  \r\ny = lone 2 :: SymbolicQSpray \r\nz = lone 3 :: SymbolicQSpray \r\na = outerQVariable
  \ \r\nsSpray \r\n  = ((4%5) *. (a :% (a^2 + one))) *> (x^2 + y^2)  +  (constQPoly
  (2%3) * a) *> (y * z)\r\nputStrLn $ prettySymbolicQSpray' \"a\" sSpray\r\n-- { [
  (4/5)*a ] %//% [ a^2 + 1 ] }*X^2 + { [ (4/5)*a ] %//% [ a^2 + 1 ] }*Y^2 + { (2/3)*a
  }*Y.Z\r\n```\r\n\r\nThere are three possible evaluations of a symbolic spray:\r\n\r\n```haskell\r\n--
  substitute a value for 'a':\r\nputStrLn $ \r\n  prettyQSpray''' $ evalSymbolicSpray
  sSpray (6%5)\r\n-- (24/61)*X^2 + (24/61)*Y^2 + (4/5)*Y.Z\r\n\r\n-- substitute a
  value for 'a' and some values for 'X', 'Y', 'Z':\r\nevalSymbolicSpray' sSpray (6%5)
  [2, 3, 4%7]\r\n-- 13848 % 2135\r\n\r\n-- substitute some values for 'X', 'Y', 'Z':\r\nputStrLn
  $ \r\n  prettyRatioOfQPolynomials \"a\" $ evalSymbolicSpray'' sSpray [2, 3, 4%7]\r\n--
  [ (8/7)*a^3 + (404/35)*a ] %//% [ a^2 + 1 ]\r\n```\r\n\r\nAlthough it does not make
  sense to replace the main variables (`X`, `Y`, `Z`)\r\nof a symbolic spray with
  some fractions of univariate polynomials, this feature \r\nis not provided. We rather
  consider that a `SymbolicSpray K` spray defines a \r\nmultivariate polynomial on
  the field `K` whose coefficients lie in `K` but \r\ndepend on a parameter, the so-called
  outer variable (`\"a\"`). By the way I am not \r\na fan of this name, and maybe
  the *parameter* would be a better name? And then\r\n*parametric spray* would be
  a better name than *symbolic spray*? Do not \r\nhesitate to open a Github issue
  to leave some comments if you want! \r\n\r\nThe nice point regarding these ratios
  of univariate polynomials is that they \r\nare automatically \"simplified\" (i.e.
  written as irreducible fractions). \r\nFor example:\r\n\r\n```haskell\r\npolyFrac
  = (a^8 - one) ^/^ (a - one)\r\nputStrLn $ prettyRatioOfQPolynomials \"a\" polyFrac\r\n--
  a^7 + a^6 + a^5 + a^4 + a^3 + a^2 + a + 1\r\n```\r\n\r\nMaybe you prefer the fractional
  form, but it is nice to see that this ratio of \r\npolynomials actually is a polynomial.
  \r\nNote that I used `^/^` here and not `:%`. That's because `:%` does not simplify
  \r\nthe fraction, it just constructs a fraction with the given numerator and denominator.\r\nWhenever
  an arithmetic operation is performed on a fraction, the result is always \r\nsimplified.
  So the `^/^` operator simply constructs a fraction with `:%` and then \r\nit multiplies
  it by one to get the simplification.\r\n\r\n\r\n## Other features\r\n\r\nResultant
  and subresultants of two polynomials, and greatest common divisor of \r\ntwo polynomials
  with coefficients in a field."
description-type: markdown
hash: 5be2a3a713df2e3dbbda9b385f71a2d85183f80232d8e739bc850373b14b1925
homepage: https://github.com/stla/hspray#readme
latest: 0.2.6.0
license-name: GPL-3.0-only
maintainer: laurent_step@outlook.fr
synopsis: Multivariate polynomials.
test-bench-deps:
  base: '>=4.7 && <5'
  hspray: '>=0'
  numeric-prelude: '>=0.4.4 && <0.5'
  tasty: '>=1.4 && <1.6'
  tasty-bench: '>=0.3 && <0.4'
  tasty-hunit: '>=0.10 && <0.11'

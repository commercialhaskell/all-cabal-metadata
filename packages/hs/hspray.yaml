all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
- 0.1.3.0
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.2.2.0
- 0.2.3.0
- 0.2.4.0
- 0.2.5.0
- 0.2.6.0
- 0.2.7.0
author: Stéphane Laurent
basic-deps:
  base: '>=4.7 && <5'
  containers: '>=0.6.4.1 && <0.8'
  extra: '>=1.7 && <1.8'
  hashable: '>=1.3.4.0 && <1.5'
  matrix: '>=0.3.6.0 && <0.4'
  numeric-prelude: '>=0.4.4 && <0.5'
  text: '>=1.2.5.0 && <2.2'
  unordered-containers: '>=0.2.17.0 && <0.3'
changelog: "# Changelog for `hspray`\r\n\r\nAll notable changes to this project will
  be documented in this file.\r\n\r\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\r\nand
  this project adheres to the\r\n[Haskell Package Versioning Policy](https://pvp.haskell.org/).\r\n\r\n\r\n##
  0.1.0.0 - 2022-12-11\r\n\r\nFirst release.\r\n\r\n\r\n## 0.1.1.0 - 2022-12-12\r\n\r\n*
  New functions `toList`, `sprayTerms` and `bombieriSpray`.\r\n\r\n* New operation
  `.^`, to multiply a spray by an integer.\r\n\r\n* Added some unit tests.\r\n\r\n\r\n##
  0.1.2.0 - 2023-02-24\r\n\r\nNew function `derivSpray`, to differentiate a spray.\r\n\r\n\r\n##
  0.1.3.0 - 2023-08-29\r\n\r\n* `Powers(..)` is now exported.\r\n\r\n* Completed the
  README to show how to deal with symbolic coefficients.\r\n\r\n\r\n## 0.2.0.0 - 2024-03-14\r\n\r\n*
  New functions `prettySpray'` and `prettySprayXYZ`.\r\n\r\n* New function `substituteSpray`.\r\n\r\n*
  New function `sprayDivision`, to perform the division of a spray by a list \r\nof
  sprays.\r\n\r\n* New function `groebner`, to compute a Gröbner basis of a list of
  sprays.\r\n\r\n* New function `isSymmetricSpray`, to check whether a spray is a
  symmetric \r\npolynomial.\r\n\r\n* New function `isPolynomialOf`, to check whether
  a spray can be expressed as \r\na polynomial of a given list of sprays.\r\n\r\n\r\n##
  0.2.1.0 - 2024-03-22\r\n\r\n* New functions `permuteVariables` and `swapVariables`.\r\n\r\n*
  New function `resultant`, to compute the resultant of two sprays.\r\n\r\n* New function
  `subresultants`, to compute the subresultants of two sprays.\r\n\r\n\r\n## 0.2.1.1
  - 2024-03-25\r\n\r\n* Improved the documentation.\r\n\r\n* Flipped the order of
  appearance of the terms in the output of the \r\n`prettySpray` functions.\r\n\r\n\r\n##
  0.2.2.0 - 2024-03-26\r\n\r\n* Fixed an error in `esPolynomial`, which resulted to
  a bug in \r\n`isSymmetricSpray`.\r\n\r\n\r\n## 0.2.3.0 - 2024-03-28\r\n\r\n* New
  unit tests.\r\n\r\n* Fixed `resultant` and `subresultants`: the variables of the
  sprays they \r\nreturn were incorrect.\r\n\r\n* New function `gcdQX`, to compute
  the greatest common divisor of two \r\nunivariate sprays with rational coefficients.\r\n\r\n\r\n##
  0.2.4.0 - 2024-03-30\r\n\r\n* Flipped the order of the arguments in `permuteVariables`
  and `swapVariables`.\r\n\r\n* New function `gcdSpray`, to compute the greatest common
  divisor of two sprays\r\nwith coefficients in a field. \r\n\r\n* The function `gcdQX`
  has been removed since `gcdSpray` is more general.\r\n\r\n* The function `sprayDivision`
  has been renamed to `sprayDivisionRemainder`.\r\n\r\n* New function `sprayDivision`,
  returning the quotient and the remainder of the \r\ndivision of two sprays.\r\n\r\n\r\n##
  0.2.5.0 - 2024-04-02\r\n\r\n* New function `resultant'` which computes the resultant
  of two sprays with \r\ncoefficients in a field. Thus it is less general than the
  function `resultant` \r\nbut it is more efficient. \r\n\r\n* Fixed a small mistake
  in `isSymmetricSpray` and `isPolynomialOf`: these \r\nfunctions didn't deal with
  the constant term of the spray.\r\n\r\n* New function `psPolynomial` which computes
  the power sum polynomials.\r\n\r\n* A particular type of sprays, namely `SymbolicSpray
  a`, has been introduced. \r\nThe coefficients of these sprays are ratios of univariate
  polynomials with `a` \r\ncoefficients. There is a specialization `SymbolicQSpray`
  for the case when `a` \r\nis a type of rational numbers. The necessary instances
  have been defined and \r\nthere is the function `prettySymbolic(Q)Spray` to display
  such sprays. There are \r\nalso some functions to perform evaluation of such sprays.\r\n\r\n\r\n##
  0.2.6.0 - 2024-04-15\r\n\r\n* New function `collinearSprays` which checks whether
  two sprays are collinear.\r\n\r\n* The function `isPolynomialOf` threw an error
  when the number of variables in\r\nthe spray to be tested was less than the number
  of variables in the list of \r\nsprays. That is me who programmed this error and
  this was wrong: for example, \r\n`x = p1 - p2^*^p3` with `p1 = x + y^*^z`, `p2 =
  y`, and `p3 = z`.\r\n\r\n* New functions to print sprays with numeric coefficients,
  such as \r\n`prettyNumSpray` and `prettyQSpray`.\r\n\r\n* The functions `prettySpray`,
  `prettySpray'` and `prettySpray''` have been \r\nchanged.\r\n\r\n* New functions
  to print symbolic sprays.\r\n\r\n* Documentation and README have been improved.\r\n\r\n\r\n##
  0.2.7.0 - 2024-04-19\r\n\r\n* Defined `qlone`, which is the same as `lone` but always
  returns a rational \r\nspray (a `QSpray` spray).\r\n\r\n* The function `sprayDivision`
  ran into an infinite loop when the divisor was\r\nconstant. This has been fixed.\r\n\r\n*
  New function `characteristicPolynomial`, to compute the characteristic \r\npolynomial
  of a matrix. \r\n\r\n* Gegenbauer polynomials. They have been implemented mainly
  to provide an \r\nillustration of the type `Spray (Spray a)` in README.\r\n\r\n*
  New function `evalSpraySpray`, to evaluate the spray coefficients of a \r\n`Spray
  (Spray a)` spray, thereby yielding a `Spray a` spray.\r\n\r\n* New type `RatioOfSprays
  a`, whose objects represent ratios of polynomials \r\nrepresented by two `Spray
  a` objects. Thus the type `Spray (RatioOfSprays a)` \r\nallows more possibilities
  than the type `SymbolicSpray a` because it is not \r\nrestricted to univariate fractions
  of polynomials, and obviously it also \r\nallows more possibilities than the type
  `Spray (Spray a)`. Instances and \r\narithmetic operations for these ratios of sprays
  have been defined. The result \r\nof an arithmetic operation always is an irreducible
  fraction. See README for \r\nexamples.\r\n\r\n* Jacobi polynomials. They have been
  implemented mainly to experiment the type \r\n`Spray (RatioOfSprays a)`. By the
  way, this type has been named \r\n`ParametricSpray a`, but this is possibly temporary.\r\n\r\n*
  The class `HasVariables` has been introduced in order to have some functions\r\nwhich
  apply to both `Spray a` objects and `RatioOfSprays a` objects.\r\n\r\n* The function
  `derivSpray` no longer exists. To get a derivative of a spray, \r\nuse the `derivative`
  function, which is also applicable to a ratio of sprays \r\n(this is a method of
  the class `HasVariables`).\r\n\r\n* A spray with coefficients in a field can now
  be divided by a scalar by using\r\nthe `/>` operator. This operator can also be
  used to divide a ratio of sprays \r\n(with coefficients in a field) by a scalar.\r\n"
changelog-type: markdown
description: "# hspray\r\n\r\n<!-- badges: start -->\r\n[![Stack-lts](https://github.com/stla/hspray/actions/workflows/Stack-lts.yml/badge.svg)](https://github.com/stla/hspray/actions/workflows/Stack-lts.yml)\r\n[![Stack-nightly](https://github.com/stla/hspray/actions/workflows/Stack-nightly.yml/badge.svg)](https://github.com/stla/hspray/actions/workflows/Stack-nightly.yml)\r\n<!--
  badges: end -->\r\n\r\n*Simple multivariate polynomials in Haskell.*\r\n\r\n___\r\n\r\nAn
  object of type `Spray a` represents a multivariate polynomial whose\r\ncoefficients
  are represented by the type `a`. For example:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nx
  = lone 1 :: Spray Double\r\ny = lone 2 :: Spray Double\r\nz = lone 3 :: Spray Double\r\npoly
  = (2 *^ (x^**^3 ^*^ y ^*^ z) ^+^ x^**^2) ^*^ (4 *^ (x ^*^ y ^*^ z))\r\nputStrLn
  $ prettyNumSpray poly\r\n-- 8.0*x^4.y^2.z^2 + 4.0*x^3.y.z\r\n```\r\n\r\nThis is
  the easiest way to construct a spray: first introduce the polynomial \r\nvariables
  with the `lone` function, and then use arithmetic operations.\r\n\r\nThere are numerous
  functions to print a spray. If you don't like the letters \r\n`x`, `y`, `z` in the
  output of `prettyNumSpray`, you can use `prettyNumSprayXYZ` \r\nto change them to
  whatever you want:\r\n\r\n```haskell\r\nputStrLn $ prettyNumSprayXYZ [\"A\",\"B\",\"C\"]
  poly\r\n-- 8.0*A^4.B^2.C^2 + 4.0*A^3.B.C\r\n```\r\n\r\nNote that this function does
  not throw an error if you don't provide enough \r\nletters:\r\n\r\n```haskell\r\nputStrLn
  $ prettyNumSprayXYZ [\"A\",\"B\"] poly\r\n-- 8.0*A1^4.A2^2.A3^2 + 4.0*A1^3.A2.A3\r\n```\r\n\r\nThis
  is the same output as the one of `prettyNumSprayX1X2X3 \"A\" poly`.\r\n\r\nMore
  generally, one can use the type `Spray a` as long as the type `a` has \r\nthe instances
  `Eq` and `Algebra.Ring` (defined in the **numeric-prelude** \r\nlibrary). For example
  `a = Rational`:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nimport Data.Ratio\r\nx
  = lone 1 :: QSpray -- QSpray = Spray Rational\r\ny = lone 2 :: QSpray \r\nz = lone
  3 :: QSpray\r\npoly = ((2%3) *^ (x^**^3 ^*^ y ^*^ z) ^-^ x^**^2) ^*^ ((7%4) *^ (x
  ^*^ y ^*^ z))\r\nputStrLn $ prettyQSpray poly\r\n-- (7/6)*x^4.y^2.z^2 - (7/4)*x^3.y.z\r\n```\r\n\r\nOr
  `a = Spray Double`:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nalpha = lone
  1 :: Spray Double\r\nx = lone 1 :: Spray (Spray Double)\r\ny = lone 2 :: Spray (Spray
  Double)\r\npoly = ((alpha *^ x) ^+^ (alpha *^ y))^**^2  \r\nshowSprayXYZ' (prettyNumSprayXYZ
  [\"alpha\"]) [\"x\",\"y\"] poly\r\n-- (alpha^2)*x^2 + (2.0*alpha^2)*x.y + (alpha^2)*y^2\r\n```\r\n\r\n####
  Evaluation:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nx = lone 1 :: Spray
  Double\r\ny = lone 2 :: Spray Double\r\nz = lone 3 :: Spray Double\r\npoly = 2 *^
  (x ^*^ y ^*^ z) \r\n-- evaluate poly at x=2, y=1, z=2\r\nevalSpray poly [2, 1, 2]\r\n--
  8.0\r\n```\r\n\r\n#### Partial evaluation:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nimport
  Data.Ratio\r\nx1 = lone 1 :: Spray Rational\r\nx2 = lone 2 :: Spray Rational\r\nx3
  = lone 3 :: Spray Rational\r\npoly = x1^**^2 ^+^ x2 ^+^ x3 ^-^ unitSpray\r\nputStrLn
  $ prettyQSprayX1X2X3 \"x\" poly\r\n-- x1^2 + x2 + x3 - 1\r\n--\r\n-- substitute
  x1 -> 2 and x3 -> 3\r\npoly' = substituteSpray [Just 2, Nothing, Just 3] poly\r\nputStrLn
  $ prettyQSprayX1X2X3 \"x\" poly'\r\n-- x2 + 6\r\n```\r\n\r\n#### Differentiation:\r\n\r\n```haskell\r\nimport
  Math.Algebra.Hspray\r\nx = lone 1 :: Spray Double\r\ny = lone 2 :: Spray Double\r\nz
  = lone 3 :: Spray Double\r\npoly = 2 *^ (x ^*^ y ^*^ z) ^+^ (3 *^ x^**^2)\r\nputStrLn
  $ prettyNumSpray poly\r\n-- 3.0*x^2 + 2.0*x.y.z\r\n--\r\n-- derivative with respect
  to x\r\nputStrLn $ prettyNumSpray $ derivative 1 poly\r\n-- 6.0*x + 2.0*y.z\"\r\n```\r\n\r\n##
  Gröbner bases\r\n\r\nAs of version 2.0.0, it is possible to compute a Gröbner basis.\r\n\r\n```haskell\r\nimport
  Math.Algebra.Hspray\r\nimport Data.Ratio\r\n-- define the elementary monomials\r\no
  = lone 0 :: Spray Rational -- same as unitSpray\r\nx = lone 1 :: Spray Rational\r\ny
  = lone 2 :: Spray Rational\r\nz = lone 3 :: Spray Rational\r\n-- define three polynomials\r\np1
  = x^**^2 ^+^ y ^+^ z ^-^ o -- X² + Y + Z - 1\r\np2 = x ^+^ y^**^2 ^+^ z ^-^ o --
  X + Y² + Z - 1\r\np3 = x ^+^ y ^+^ z^**^2 ^-^ o -- X + Y + Z² - 1\r\n-- compute
  the reduced Gröbner basis\r\ngbasis = groebner [p1, p2, p3] True\r\n-- show result\r\nprettyResult
  = map prettyQSpray gbasis\r\nmapM_ print prettyResult\r\n-- \"x + y + z^2 - 1\"\r\n--
  \"y^2 - y - z^2 + z\"\r\n-- \"y.z^2 + (1/2)*z^4 - (1/2)*z^2\"\r\n-- \"z^6 - 4*z^4
  + 4*z^3 - z^2\"\r\n```\r\n\r\n\r\n## Easier usage \r\n\r\nTo construct a spray using
  the ordinary symbols `+`, `-`, `*` and `^`, \r\none can hide these operators from
  **Prelude** and import them from the \r\n**numeric-prelude** library; constructing
  a spray in this context is easier:\r\n\r\n```haskell\r\nimport Prelude hiding ((+),
  (-), (*), (^), (*>), (<*))\r\nimport qualified Prelude as P\r\nimport Algebra.Additive
  \             \r\nimport Algebra.Module                \r\nimport Algebra.Ring                  \r\nimport
  Math.Algebra.Hspray\r\nimport Data.Ratio\r\nx = lone 1 :: QSpray \r\ny = lone 2
  :: QSpray \r\nz = lone 3 :: QSpray\r\npoly  = ((2%3) *^ (x^**^3 ^*^ y ^*^ z) ^-^
  x^**^2) ^*^ ((7%4) *^ (x ^*^ y ^*^ z))\r\npoly' = ((2%3) *^ (x^3 * y * z) - x^2)
  * ((7%4) *^ (x * y * z))\r\npoly == poly'\r\n-- True\r\n```\r\n\r\nNote that `*>`
  could be used instead of `*^` but running `lambda *> spray` \r\npossibly throws
  an \"ambiguous type\" error regarding the type of `lambda`.\r\n\r\nMaybe better
  (I didn't try yet), follow the \"Usage\" section on the \r\n[Hackage page](https://hackage.haskell.org/package/numeric-prelude-0.4.4#usage)
  \r\nof **numeric-prelude**.\r\n\r\n\r\n## Symbolic coefficients\r\n\r\nAssume you
  have the polynomial `a * (x² + y²) + 2b/3 * z`, \r\nwhere `a` and `b` are symbolic
  rational numbers. You can represent this \r\npolynomial by a `Spray (Spray Rational)`
  spray as follows:\r\n\r\n```haskell\r\nimport Prelude hiding ((*), (+), (-), (^))\r\nimport
  qualified Prelude as P\r\nimport Algebra.Additive              \r\nimport Algebra.Ring
  \                 \r\nimport Math.Algebra.Hspray\r\n\r\nx = lone 1 :: Spray (Spray
  Rational)\r\ny = lone 2 :: Spray (Spray Rational)\r\nz = lone 3 :: Spray (Spray
  Rational)\r\na = lone 1 :: Spray Rational\r\nb = lone 2 :: Spray Rational\r\n\r\npoly
  = a *^ (x^2 + y^2) + ((2 *^ b) /^ 3) *^ z \r\nputStrLn $ \r\n  showSprayXYZ' (prettyQSprayXYZ
  [\"a\",\"b\"]) [\"X\",\"Y\",\"Z\"] poly\r\n-- (a)*X^2 + (a)*Y^2 + ((2/3)*b)*Z\r\n```\r\n\r\nYou
  can extract the powers and the coefficients as follows:\r\n\r\n```haskell\r\nl =
  toList poly\r\nmap fst l\r\n-- [[0,0,1],[2],[0,2]]\r\nmap toList $ map snd l\r\n--
  [[([0,1],2 % 3)],[([1],1 % 1)],[([1],1 % 1)]]\r\n```\r\n\r\nThese `Spray (Spray
  a)` sprays can be very useful. They represent polynomials \r\nwhose coefficients
  depend on some parameters, with a polynomial dependence. \r\nFor example, the coefficients
  of the \r\n[Gegenbauer polynomials](https://en.wikipedia.org/wiki/Gegenbauer_polynomials)\r\nare
  polynomials in their parameter $\\alpha$ (this is clear from the recurrence \r\nrelation).
  Here is their implementation in **hspray**:\r\n\r\n```haskell\r\ngegenbauerPolynomial
  :: Int -> Spray (Spray Rational) \r\ngegenbauerPolynomial n \r\n  | n == 0 = unitSpray\r\n
  \ | n == 1 = (2.^a) *^ x\r\n  | otherwise = \r\n    (2.^(n'' ^+^ a) /^ n') *^ (x
  ^*^ gegenbauerPolynomial (n - 1))\r\n    ^-^ ((n'' ^+^ 2.^a ^-^ unitSpray) /^ n')
  *^ gegenbauerPolynomial (n - 2)\r\n  where \r\n    x = lone 1 :: Spray (Spray Rational)\r\n
  \   a = lone 1 :: Spray Rational\r\n    n'  = toRational n\r\n    n'' = constantSpray
  (n' - 1)\r\n```\r\n\r\nLet's try it:\r\n\r\n```haskell\r\nn = 3\r\ng = gegenbauerPolynomial
  n\r\nputStrLn $ \r\n  showSprayXYZ' (prettyQSprayXYZ [\"alpha\"]) [\"X\"] g\r\n--
  ((4/3)*alpha^3 + 4*alpha^2 + (8/3)*alpha)*X^3 + (-2*alpha^2 - 2*alpha)*X\r\n```\r\n\r\nLet's
  check the differential equation:\r\n\r\n```haskell\r\ng'  = derivative 1 g\r\ng''
  = derivative 1 g'\r\nalpha = lone 1 :: Spray Rational\r\nx     = lone 1 :: Spray
  (Spray Rational)\r\nnAsSpray = constantSpray (toRational n)\r\nshouldBeZero = \r\n
  \ (unitSpray ^-^ x^**^2) ^*^ g''\r\n  ^-^ (2.^alpha ^+^ unitSpray) *^ (x ^*^ g')\r\n
  \ ^+^ n.^(nAsSpray ^+^ 2.^alpha) *^ g\r\nputStrLn $ prettySpray shouldBeZero\r\n--
  0\r\n```\r\n\r\nNow, how to substitute a value to the parameter $\\alpha$? The package
  provides \r\nthe function `evalSpraySpray` to perform this task:\r\n\r\n```haskell\r\nputStrLn
  $ \r\n  prettyQSpray'' $ evalSpraySpray g [1]\r\n-- 8*X^3 - 4*X\r\n```\r\n\r\nThis
  is a `Spray Rational` spray.\r\n\r\n\r\n## The `SymbolicSpray` type\r\n\r\nIf you
  have only one symbolic coefficient, you can deal with the sprays \r\nof type `SymbolicSpray
  a`. These are sprays whose coefficients are \r\n*ratios of univariate polynomials*,
  \r\nso this allows more possibilities than a `Spray (Spray a)`. Since the variable
  \r\nof these univariate polynomials occurs in the coefficients of such a spray,
  I \r\ncall it the *outer variable* sometimes, although I do not very like this name
  \r\n(see below). And I say that the variables of the symbolic spray are the \r\n*inner
  variables* or the *main variables*, though I would prefer to simply call \r\nthem
  the *variables*.\r\nAssume you want to deal with the polynomial `4/5 * a/(a² + 1)
  * (x² + y²) + 2a/3 * yz`. \r\nThen you define it as follows:\r\n\r\n```haskell\r\nimport
  \          Prelude hiding ((*), (+), (-), (/), (^), (*>))\r\nimport qualified Prelude
  as P\r\nimport           Algebra.Additive              \r\nimport           Algebra.Module
  \           \r\nimport           Algebra.Ring\r\nimport           Algebra.Field\r\nimport
  \          Math.Algebra.Hspray\r\nimport           Number.Ratio       ( (%), T (
  (:%) ) )\r\nx = lone 1 :: SymbolicQSpray \r\ny = lone 2 :: SymbolicQSpray \r\nz
  = lone 3 :: SymbolicQSpray \r\na = outerQVariable  \r\nsSpray \r\n  = ((4%5) *.
  (a :% (a^2 + one))) *> (x^2 + y^2)  +  (constQPoly (2%3) * a) *> (y * z)\r\nputStrLn
  $ prettySymbolicQSpray' \"a\" sSpray\r\n-- { [ (4/5)*a ] %//% [ a^2 + 1 ] }*X^2
  + { [ (4/5)*a ] %//% [ a^2 + 1 ] }*Y^2 + { (2/3)*a }*Y.Z\r\n```\r\n\r\nThere are
  three possible evaluations of a symbolic spray:\r\n\r\n```haskell\r\n-- substitute
  a value for 'a':\r\nputStrLn $ \r\n  prettyQSpray''' $ evalSymbolicSpray sSpray
  (6%5)\r\n-- (24/61)*X^2 + (24/61)*Y^2 + (4/5)*Y.Z\r\n\r\n-- substitute a value for
  'a' and some values for 'X', 'Y', 'Z':\r\nevalSymbolicSpray' sSpray (6%5) [2, 3,
  4%7]\r\n-- 13848 % 2135\r\n\r\n-- substitute some values for 'X', 'Y', 'Z':\r\nputStrLn
  $ \r\n  prettyRatioOfQPolynomials \"a\" $ evalSymbolicSpray'' sSpray [2, 3, 4%7]\r\n--
  [ (8/7)*a^3 + (404/35)*a ] %//% [ a^2 + 1 ]\r\n```\r\n\r\nAlthough it does not make
  sense to replace the main variables (`X`, `Y`, `Z`)\r\nof a symbolic spray with
  some fractions of univariate polynomials, this feature \r\nis not provided. We rather
  consider that a `SymbolicSpray K` spray defines a \r\nmultivariate polynomial on
  the field `K` whose coefficients lie in `K` but \r\ndepend on a parameter, the so-called
  outer variable (`\"a\"`). By the way I am not \r\na fan of this name, and maybe
  the *parameter* would be a better name? And then\r\n*parametric spray* would be
  a better name than *symbolic spray*? Do not \r\nhesitate to open a Github issue
  to leave some comments if you want! \r\n\r\nThe nice point regarding these ratios
  of univariate polynomials is that they \r\nare automatically \"simplified\" (i.e.
  written as irreducible fractions). \r\nFor example:\r\n\r\n```haskell\r\npolyFrac
  = (a^8 - one) ^/^ (a - one)\r\nputStrLn $ prettyRatioOfQPolynomials \"a\" polyFrac\r\n--
  a^7 + a^6 + a^5 + a^4 + a^3 + a^2 + a + 1\r\n```\r\n\r\nMaybe you prefer the fractional
  form, but it is nice to see that this ratio of \r\npolynomials actually is a polynomial.
  \r\nNote that I used `^/^` here and not `:%`. That's because `:%` does not simplify
  \r\nthe fraction, it just constructs a fraction with the given numerator and denominator.\r\nWhenever
  an arithmetic operation is performed on a fraction, the result is always \r\nsimplified.
  So the `^/^` operator simply constructs a fraction with `:%` and then \r\nit multiplies
  it by one to get the simplification.\r\n\r\n\r\n## As of version 0.2.7: `RatioOfSprays`\r\n\r\nSo
  far we have good stuff to deal with symbolic coefficients: the \r\n`Spray (Spray
  a)` sprays and the `SymbolicSpray a` sprays. The \r\n`SymbolicSpray a` sprays are
  successfully used in the \r\n[**jackpolynomials** package](https://github.com/stla/jackpolynomials).
  \r\nHowever this is not enough. For example we cannot implement the \r\n[Jacobi
  polynomials](https://en.wikipedia.org/wiki/Jacobi_polynomials) \r\nwith symbolic
  parameters, because they have two parameters and their \r\nrecurrence relation involves
  some divisions of their coefficients. \r\n\r\nWe need a new type, similar to `SymbolicSpray
  a` but allowing multivariate \r\nfractions of polynomials for the coefficients.\r\n\r\nA
  first step in this direction has been achieved in version 0.2.7: the \r\ntype `RatioOfSprays
  a`, whose objects represent ratios of sprays, has \r\nbeen introduced. Thus it suffices
  to introduce the type \r\n`Spray (RatioOfSprays a)` now.\r\n\r\nThus the `Spray
  (RatioOfSprays a)` sprays are more general than the \r\n`SymbolicSpray a` sprays,
  which are restricted to univariate fractions \r\nof polynomials. But it is possible
  that the `Spray (RatioOfSprays a)` \r\nsprays will be less efficient than the `SymbolicSpray
  a` sprays in the \r\nunivariate case. I will have to benchmark in order to get an
  answer to \r\nthis question.\r\n\r\nTo construct a ratio of sprays, apply `%//%`
  between its numerator and \r\nits denominator:\r\n\r\n```haskell\r\nimport Math.Algebra.Hspray\r\nx
  = qlone 1 -- shortcut for  lone 1 :: Spray Rational\r\ny = qlone 2 \r\nrOS = (x
  ^-^ y) %//% (x^**^2 ^-^ y^**^2)\r\nputStrLn $ prettyRatioOfQSprays rOS\r\n-- [ 1
  ] %//% [ x + y ]\r\n```\r\n\r\nThe `%//%` operator always returns an irreducible
  fraction.\r\n\r\nThe `RatioOfSprays a` type makes sense when `a` has a field instance,
  and then \r\nit has a field instance too. To use the field operations, import the
  necessary\r\nmodules from **numeric-prelude**, and hide these operations from the
  `Prelude`\r\nmodule (then you can also use the **numeric-prelude** operations for
  sprays, \r\ninstead of using `^+^`, `^-^`, `^*^`, `^**^`):\r\n\r\n```haskell\r\nimport
  Prelude hiding ((+), (-), (*), (/), (^), (*>), (<*))\r\nimport qualified Prelude
  as P\r\nimport Algebra.Additive              \r\nimport Algebra.Module\r\nimport
  Algebra.RightModule\r\nimport Algebra.Ring\r\nimport Algebra.Field              \r\nimport
  Math.Algebra.Hspray\r\nx = qlone 1  \r\ny = qlone 2 \r\np = x^2 - 3*^(x * y) + y^3
  \r\nq = x - y\r\nrOS1 = p^2 %//% q\r\nrOS2 = rOS1 + unitRatioOfSprays\r\nrOS = rOS1^2
  + rOS1*rOS2 - rOS1/rOS2 + rOS2 -- slow!\r\n(rOS1 + rOS2) * (rOS1 - rOS2) == rOS1^2
  - rOS2^2\r\n-- True\r\n```\r\n\r\nThe `RatioOfSprays a` type also has left and right
  module instances over `a` \r\nand over `Spray a` as well. That means you can multiply
  a ratio of sprays by\r\na scalar and by a spray, by using, depending on the side,
  either `*>` or `<*`:\r\n\r\n```haskell\r\nimport Data.Ratio ( (%) )\r\nrOS' = (3%4::Rational)
  *> rOS^2  +  p *> rOS\r\nrOS' / rOS' == unitRatioOfSprays\r\n-- True\r\n```\r\n\r\nYou
  can also divide a ratio of sprays by a spray with `%/%`:\r\n\r\n```haskell\r\np
  *> (rOS' %/% p) == rOS'\r\n-- True\r\nrOS1 %/% p == p %//% q\r\n-- True\r\n```\r\n\r\nWhen
  `a` has a field instance, both a `Spray a` spray and a `RatioOfSprays a` \r\nratio
  of sprays can be divided by a scalar with the `/>` operator:\r\n\r\n```haskell\r\nk
  = 3 :: Rational\r\n(p /> k) *> rOS == p *> (rOS /> k)\r\n-- True\r\n```\r\n\r\nUse
  `evalRatioOfSprays` to evaluate a ratio of sprays:\r\n\r\n```haskell\r\nimport Data.Ratio
  ( (%) )\r\nf :: Algebra.Field.C a => a -> a -> a\r\nf u v = u^2 + u*v - u/v + v\r\nrOS
  == f rOS1 rOS2\r\n-- True\r\nvalues = [2%3, 7%4]\r\nr1 = evalRatioOfSprays rOS1
  values\r\nr2 = evalRatioOfSprays rOS2 values\r\nevalRatioOfSprays rOS values ==
  f r1 r2\r\n-- True\r\n```\r\n\r\n\r\n## Other features\r\n\r\nResultant and subresultants
  of two polynomials, and greatest common divisor of \r\ntwo polynomials with coefficients
  in a field."
description-type: markdown
hash: cb1787ca022853b6edba483c430c371a9bcc9d69f26ac32f8e2977f06cf1bad2
homepage: https://github.com/stla/hspray#readme
latest: 0.2.7.0
license-name: GPL-3.0-only
maintainer: laurent_step@outlook.fr
synopsis: Multivariate polynomials and fractions of multivariate polynomials.
test-bench-deps:
  base: '>=4.7 && <5'
  hspray: '>=0'
  matrix: '>=0.3.6.0 && <0.4'
  numeric-prelude: '>=0.4.4 && <0.5'
  tasty: '>=1.4 && <1.6'
  tasty-bench: '>=0.3 && <0.4'
  tasty-hunit: '>=0.10 && <0.11'

homepage: https://github.com/ndmitchell/cmdargs#readme
changelog-type: text
hash: d3bd67b852b08ab0327217272394afef051d682de068aad2d2cf3ed939faa957
test-bench-deps: {}
maintainer: Neil Mitchell <ndmitchell@gmail.com>
synopsis: Command line argument processing
changelog: ! "Changelog for CmdArgs\n\n0.10.16\n    Minor improvement to error messages\n0.10.15\n
  \   #43, GHC 8.2 compatibility\n0.10.14\n    #39, ensure correct line breaks in
  HTML help output\n    #18, preserve manual \\n in help messages\n    #25, reformat
  the README\n0.10.13\n    #24, support Ratio in some places\n0.10.12\n    GHC 7.2
  compatibility\n0.10.11\n    #15, never put [brackets] around optional args in Explicit\n0.10.10\n
  \   #14, fix @ file arguments\n0.10.9\n    #10, fix versionArgs (broken in 0.10.8)\n0.10.8\n
  \   Avoid compilation warnings on GHC 7.8\n    #9, add --numeric-version flag\n
  \   Update the copyright year\n    Change GetOpt.usageInfo to be more like GetOpt\n0.10.7\n
  \   #1, fix timestamps in .tar.gz dist file\n0.10.6\n    #625, more documentation
  about args/argPos\n    #626, ensure initial lists don't get reversed (fix after
  #610)\n0.10.5\n    #615, support lists inside a newtype\n0.10.4\n    #610, make
  sure it is O(n) to append arguments, not O(n^2)\n0.10.3\n    Append list items under
  an enum\n    Support &= ignore on enum fields\n0.10.2\n    Relax upper bounds to
  be GHC 7.7 compatible\n0.10.1\n    #569, set the test program to off by default\n\tComplete
  revamp of cmdargs-browser, far better Javascript\n    Add a missing case for Helper
  marshalling FlagNone\n0.10\n    Revert to 0.9.6, including modeExpandAt\n0.9.7\n
  \   Revert to 0.9.5, to fix up PVP breakage\n0.9.6\n    #539, hopefully more fixes
  to compiling in profile mode\n    #522, add modeExpandAt and noAtExpand annotation\n
  \   #522, don't @expand after --\n0.9.5\n    Don't specify TH extension unless quotation
  is true\n0.9.4\n    #539, specify the TH extension in the Cabal file\n    Allow
  transformers 0.3.*\n    Correct copyright in license and cabal file\n0.9.3\n    Add
  expandArgsAt and support for @ flag file directives\n0.9.2\n    Don't build the
  test program if quotation is turned off\n0.9.1\n    Improve the documentation for
  the Explicit module\n    #433, propagate groupname on modes in the Implicit code\n0.9\n
  \   #467, add completions for people running bash\n    #334, add a Quote module,
  to write pure in the impure syntax\n    #482, fix the sample in Explicit, don't
  use def\n    #461, fix the translation for enum/enum_\n    Make showHelp take an
  argument for the prefix bits\n    Add Helper interface, and initial cmdargs-browser
  code\n    Add splitArgs/joinArgs\n0.8\n    #450, redo the manual generator so Maker
  example is not cut off\n    Support all the types in Data.Int/Data.Word\n    Make
  modeArgs take a list of arguments as well\n0.7\n    No changes, just a version bump
  to allow requiring the GHC fix\n0.6.10\n    Change the annotate module to cope better
  with GHC's CSE\n0.6.9\n    #422, support newtype value as the underlying type\n0.6.8\n
  \   Allow versionArgs [summary] to override --version\n    Improve the documentation
  surrounding opt\n    Add modeReform to Mode\n    Add modeEmpty, to construct blank
  Mode values\n    Improve the documentation surrounding pure annotations.\n0.6.7\n
  \   #395, don't put two newlines after --help or --version\n0.6.6\n    #392, support
  helpArgs [groupname \"something\"]\n0.6.5\n    Don't fail with ambiguous enum if
  you exactly match a value\n    Put errors on stderr\n0.6.4\n    Eliminate the filepath
  dependence\n0.6.3\n    Switch mtl for transformers\n0.6.2\n    Build on GHC 7.0
  RC2, add an extra type signature\n    Add verbosityArgs to customise the verbose/quiet
  flags\n    Add helpArg/versionArg flags to customise those flags\n    Support multiline
  summary using \\n escape codes\n0.6.1\n    Build on GHC 6.10, don't rely on record
  name disambiguation\n0.6\n    Add ignore annotation for modes and flags\n    #350,
  make top-level help appear properly\n0.5\n    #351, name/explicit attributes on
  mode were broken (regression)\n0.4\n    #342, display common fields only once\n
  \   Raise errors if annotations are placed in invalid places\n    Rewrite the translation
  of annotation to explicit modes\n    Treat anything after -- as an argument\n    Add
  a pure annotation mechanism\n    Introduce System.Console.CmdArgs.Annotate\n0.3\n
  \   Add a documentation example for the Explicit mode\n    Improve the purity and
  annotations a bit, try disabling CSE\n    Change the help format\n    Rename groupHiden
  to groupHidden, patch from Matthew Cox\n    Bug, missing fields and explicit enums
  didn't work together\n0.2\n    #252, add support for grouped flags/modes\n    #333,
  support missing fields\n    Add support for reading tuple values (including nested)\n
  \   #292, add support for automatic enumerations\n    #221, make argpos work with
  non-string fields\n    #222, support opt and args together\n    #230, different
  modes can share short flags\n    #295, make verbosity flags explicit\n    #231,
  add support for Maybe\n    #256, add --option=false support\n    Complete rewrite
  to introduce Explicit module\n0.1.1\n    Start of changelog\n"
basic-deps:
  base: ! '>=4.4 && <5'
  filepath: -any
  process: ! '>=1.0'
  transformers: ! '>=0.2'
  template-haskell: -any
all-versions:
- '0.1'
- '0.2'
- '0.3'
- '0.4'
- '0.5'
- '0.6'
- '0.6.1'
- '0.6.2'
- '0.6.3'
- '0.6.4'
- '0.6.5'
- '0.6.6'
- '0.6.7'
- '0.6.8'
- '0.6.9'
- '0.6.10'
- '0.7'
- '0.8'
- '0.9'
- '0.9.1'
- '0.9.2'
- '0.9.3'
- '0.9.4'
- '0.9.5'
- '0.9.6'
- '0.9.7'
- '0.10'
- '0.10.1'
- '0.10.2'
- '0.10.3'
- '0.10.4'
- '0.10.5'
- '0.10.6'
- '0.10.7'
- '0.10.8'
- '0.10.9'
- '0.10.10'
- '0.10.11'
- '0.10.12'
- '0.10.13'
- '0.10.14'
- '0.10.15'
- '0.10.16'
author: Neil Mitchell <ndmitchell@gmail.com>
latest: '0.10.16'
description-type: markdown
description: ! "# CmdArgs: Easy Command Line Processing [![Hackage version](https://img.shields.io/hackage/v/cmdargs.svg?label=Hackage)](https://hackage.haskell.org/package/cmdargs)
  [![Build Status](https://img.shields.io/travis/ndmitchell/cmdargs.svg)](https://travis-ci.org/ndmitchell/cmdargs)\n\nCmdArgs
  is a Haskell library for defining command line parsers. The two features that make
  it a better choice than the standard [getopt library](http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html)
  are:\n\n* It's very concise to use. The HLint command line handling is three times
  shorter with CmdArgs.\n* It supports programs with multiple modes, such as [darcs](http://darcs.net)
  or [Cabal](http://haskell.org/cabal/).\n\nA very simple example of a command line
  processor is:\n\n    data Sample = Sample {hello :: String} deriving (Show, Data,
  Typeable)\n    \n    sample = Sample{hello = def &= help \"World argument\" &= opt
  \"world\"}\n             &= summary \"Sample v1\"\n    \n    main = print =<< cmdArgs
  sample\n\nDespite being very concise, this processor is already fairly well featured:\n\n
  \   $ runhaskell Sample.hs --hello=world\n    Sample {hello = \"world\"}\n    \n
  \   $ runhaskell Sample.hs --help\n    Sample v1, (C) Neil Mitchell 2009\n    \n
  \   sample [FLAG]\n    \n      -? --help[=FORMAT]  Show usage information (optional
  format)\n      -V --version        Show version information\n      -v --verbose
  \       Higher verbosity\n      -q --quiet          Lower verbosity\n      -h --hello=VALUE
  \   World argument (default=world)\n\n## User Manual\n\nThe rest of this document
  explains how to write the \"hello world\" of command line processors, then how to
  extend it with features into a complex command line processor. Finally this document
  gives three samples, which the `cmdargs` program can run. The three samples are:\n\n*
  `hlint` - the [HLint](https://github.com/ndmitchell/hlint#readme) program.\n* `diffy`
  - a program to compare the differences between directories.\n* `maker` - a make
  style program.\n\nFor each example you are encouraged to look at it's source (in
  the [repo](https://github.com/ndmitchell/cmdargs/tree/master/System/Console/CmdArgs/Test/Implicit))
  and run it (try `cmdargs hlint --help`). The HLint program is fairly standard in
  terms of it's argument processing, and previously used the [System.Console.GetOpt](http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html)
  library. Using GetOpt required 90 lines and a reasonable amount of duplication.
  Using CmdArgs the code requires 30 lines, and the logic is much simpler.\n\n**Acknowledgements**
  Thanks to Kevin Quick for substantial patches, and additional code contributions
  from Sebastian Fischer and Daniel Schoepe.\n\n\n## Hello World Example\n\nThe following
  code defines a complete command line argument processor:\n\n    {-# LANGUAGE DeriveDataTypeable
  #-}\n    {-# OPTIONS_GHC -fno-cse #-}\n    module Sample where\n    import System.Console.CmdArgs\n
  \   \n    data Sample = Sample {hello :: String}\n                  deriving (Show,
  Data, Typeable)\n    \n    sample = Sample{hello = def}\n    \n    main = print
  =<< cmdArgs sample\n\nTo use the CmdArgs library there are three steps:\n\n* Define
  a record data type (`Sample`) that contains a field for each argument. This type
  needs to have instances for `Show`, `Data` and `Typeable`.\n* Give a value of that
  type (`sample`) with default values (`def` is a default value of any type, but I
  could also have written `\"\"`). This value is turned into a command line by calling
  the `cmdArgs` function.\n* To ensure GHC evalutes attributes the right number of
  times we disable the CSE optimisation on this module.\n\nNow we have a reasonably
  functional command line argument processor. Some sample interactions are:\n\n    $
  runhaskell Sample.hs --hello=world\n    Sample {hello = \"world\"}\n    \n    $
  runhaskell Sample.hs --version\n    The sample program\n    \n    $ runhaskell Sample.hs
  --help\n    The sample program\n    \n    sample [OPTIONS]\n    \n      -? --help
  \       Display help message\n      -V --version     Print version information\n
  \     -h --hello=ITEM\n\nCmdArgs uses defaults to automatically infer a command
  line parser for a value, and provides annotations to override any of the the defaults.
  CmdArgs automatically supports `--help` and `--version` flags, and optionally supports
  verbosity flags.\n\n## Specifying Attributes\n\nIn order to control the behaviour
  we can add attributes. For example to add an attribute specifying the help text
  for the `--hello` argument we can write:\n\n    sample = Sample{hello = def &= help
  \"Who to say hello to\"}\n\nWe can add additional attributes, for example to specify
  the type of the value expected by hello:\n\n    sample = Sample {hello = def &=
  help \"Who to say hello to\" &= typ \"WORLD\"}\n\nNow when running `--help` the
  final line is:\n\n      -h --hello=WORLD  Who to say hello to\n\nThere are many
  more attributes, detailed in the [Haddock documentation](http://hackage.haskell.org/packages/archive/cmdargs/latest/doc/html/System-Console-CmdArgs.html#2).\n\n\n##
  Multiple Modes\n\nTo specify a program with multiple modes, similar to [darcs](http://darcs.net/),
  we can supply a data type with multiple constructors, for example:\n    \n    data
  Sample = Hello {whom :: String}\n                | Goodbye\n                  deriving
  (Show, Data, Typeable)\n    \n    hello = Hello{whom = def}\n    goodbye = Goodbye\n
  \   \n    main = print =<< cmdArgs (modes [hello,goodbye])\n\nCompared to the first
  example, we now have multiple constructors, and a sample value for each constructor
  is passed to `cmdArgs`. Some sample interactions with this command line are:\n\n
  \   $ runhaskell Sample.hs hello --whom=world\n    Hello {whom = \"world\"}\n    \n
  \   $ runhaskell Sample.hs goodbye\n    Goodbye\n    \n    $ runhaskell Sample.hs
  --help\n    The sample program\n    \n    sample [OPTIONS]\n    \n     Common flags\n
  \     -? --help       Display help message\n      -V --version    Print version
  information\n    \n    sample hello [OPTIONS]\n    \n      -w --whom=ITEM\n    \n
  \   sample goodbye [OPTIONS]\n\nAs before, the behaviour can be customised using
  attributes.\n\n\n## Larger Examples\n\nFor each of the following examples we first
  explain the purpose of the program, then give the source code, and finally the output
  of `--help`. The programs are intended to show sample uses of CmdArgs, and are available
  to experiment with through `cmdargs progname`.\n\n### HLint\n\nThe [HLint](https://github.com/ndmitchell/hlint#readme)
  program analyses a list of files, using various options to control the analysis.
  The command line processing is simple, but a few interesting points are:\n\n* The
  `--report` flag can be used to output a report in a standard location, but giving
  the flag a value changes where the file is output.\n* The `color` field is assigned
  two flag aliases, `--colour` and `-c`. Assigning the `-c` short flag explicitly
  stops either of the CPP fields using it.\n* The `show_` field would clash with `show`
  if given the expected name, but CmdArgs automatically strips the trailing underscore.\n*
  The `cpp_define` field has an underscore in it's name, which is transformed into
  a hyphen for the flag name.\n\nThe code is:\n\n    {-# LANGUAGE DeriveDataTypeable
  #-}\n    module HLint where\n    import System.Console.CmdArgs\n    \n    data HLint
  = HLint\n        {report :: [FilePath]\n        ,hint :: [FilePath]\n        ,color
  :: Bool\n        ,ignore_ :: [String]\n        ,show_ :: Bool\n        ,extension
  :: [String]\n        ,language :: [String]\n        ,utf8 :: Bool\n        ,encoding
  :: String\n        ,find :: [FilePath]\n        ,test_ :: Bool\n        ,datadir
  :: [FilePath]\n        ,cpp_define :: [String]\n        ,cpp_include :: [FilePath]\n
  \       ,files :: [FilePath]\n        }\n        deriving (Data,Typeable,Show,Eq)\n
  \   \n    hlint = HLint\n        {report = def &= opt \"report.html\" &= typFile
  &= help \"Generate a report in HTML\"\n        ,hint = def &= typFile &= help \"Hint/ignore
  file to use\"\n        ,color = def &= name \"c\" &= name \"colour\" &= help \"Color
  the output (requires ANSI terminal)\"\n        ,ignore_ = def &= typ \"MESSAGE\"
  &= help \"Ignore a particular hint\"\n        ,show_ = def &= help \"Show all ignored
  ideas\"\n        ,extension = def &= typ \"EXT\" &= help \"File extensions to search
  (defaults to hs and lhs)\"\n        ,language = def &= name \"X\" &= typ \"LANG\"
  &= help \"Language extension (Arrows, NoCPP)\"\n        ,utf8 = def &= help \"Use
  UTF-8 text encoding\"\n        ,encoding = def &= typ \"ENC\" &= help \"Choose the
  text encoding\"\n        ,find = def &= typFile &= help \"Find hints in a Haskell
  file\"\n        ,test_ = def &= help \"Run in test mode\"\n        ,datadir = def
  &= typDir &= help \"Override the data directory\"\n        ,cpp_define = def &=
  typ \"NAME[=VALUE]\" &= help \"CPP #define\"\n        ,cpp_include = def &= typDir
  &= help \"CPP include path\"\n        ,files = def &= args &= typ \"FILES/DIRS\"\n
  \       } &=\n        verbosity &=\n        help \"Suggest improvements to Haskell
  source code\" &=\n        summary \"HLint v0.0.0, (C) Neil Mitchell\" &=\n        details
  [\"Hlint gives hints on how to improve Haskell code\",\"\"\n                ,\"To
  check all Haskell files in 'src' and generate a report type:\",\"  hlint src --report\"]\n
  \   \n    mode = cmdArgsMode hlint\n\nProduces the `--help` output:\n\n    HLint
  v0.0.0, (C) Neil Mitchell\n    \n    hlint [OPTIONS] [FILES/DIRS]\n    Suggest improvements
  to Haskell source code\n    \n    Common flags:\n      -r --report[=FILE]            Generate
  a report in HTML\n      -h --hint=FILE                Hint/ignore file to use\n
  \     -c --colour --color            Color the output (requires ANSI terminal)\n
  \     -i --ignore=MESSAGE            Ignore a particular hint\n      -s --show                     Show
  all ignored ideas\n         --extension=EXT            File extensions to search
  (defaults to hs and lhs)\n      -X --language=LANG            Language extension
  (Arrows, NoCPP)\n      -u --utf8                        Use UTF-8 text encoding\n
  \        --encoding=ENC                Choose the text encoding\n      -f --find=FILE
  \               Find hints in a Haskell file\n      -t --test                        Run
  in test mode\n      -d --datadir=DIR                Override the data directory\n
  \        --cpp-define=NAME[=VALUE]  CPP #define\n         --cpp-include=DIR            CPP
  include path\n      -? --help                        Display help message\n      -V
  --version                    Print version information\n      -v --verbose                    Loud
  verbosity\n      -q --quiet                    Quiet verbosity\n    \n    Hlint
  gives hints on how to improve Haskell code\n    \n    To check all Haskell files
  in 'src' and generate a report type:\n      hlint src --report\n    \n\n### Diffy\n\nThe
  Diffy sample is a based on the idea of creating directory listings and comparing
  them. The tool can operate in two separate modes, `create` or `diff`. This sample
  is fictional, but the ideas are drawn from a real program. A few notable features:\n\n*
  There are multiple modes of execution, creating and diffing.\n* The diff mode takes
  exactly two arguments, the old file and the new file.\n* Default values are given
  for the `out` field, which are different in both modes.\n\nThe code is:\n\n    {-#
  LANGUAGE DeriveDataTypeable #-}\n    module Diffy where\n    import System.Console.CmdArgs\n
  \   \n    data Diffy = Create {src :: Maybe FilePath, out :: FilePath}\n               |
  Diff {old :: FilePath, new :: FilePath, out :: FilePath}\n                 deriving
  (Data,Typeable,Show,Eq)\n    \n    outFlags x = x &= help \"Output file\" &= typFile\n
  \   \n    create = Create\n        {src = def &= help \"Source directory\" &= typDir\n
  \       ,out = outFlags \"ls.txt\"\n        } &= help \"Create a fingerprint\"\n
  \   \n    diff = Diff\n        {old = def &= typ \"OLDFILE\" &= argPos 0\n        ,new
  = def &= typ \"NEWFILE\" &= argPos 1\n        ,out = outFlags \"diff.txt\"\n        }
  &= help \"Perform a diff\"\n    \n    mode = cmdArgsMode $ modes [create,diff] &=
  help \"Create and compare differences\" &= program \"diffy\" &= summary \"Diffy
  v1.0\"\n\nAnd `--help` produces:\n\n    Diffy v1.0\n     \n    diffy [COMMAND] ...
  [OPTIONS]\n      Create and compare differences\n     \n    Common flags:\n      -o
  --out=FILE     Output file\n      -? --help         Display help message\n      -V
  --version     Print version information\n     \n    diffy create [OPTIONS]\n      Create
  a fingerprint\n     \n      -s  --src=DIR  Source directory\n     \n    diffy diff
  [OPTIONS] OLDFILE NEWFILE\n      Perform a diff\n\n### Maker\n\nThe Maker sample
  is based around a build system, where we can either build a project, clean the temporary
  files, or run a test. Some interesting features are:\n\n* The build mode is the
  default, so `maker` on it's own will be interpreted as a build command.\n* The build
  method is an enumeration.\n* The `threads` field is in two of the constructors,
  but not all three. It is given the short flag `-j`, rather than the default `-t`.\n\nThe
  code is:\n\n    {-# LANGUAGE DeriveDataTypeable #-}\n    module Maker where\n    import
  System.Console.CmdArgs\n    \n    data Method = Debug | Release | Profile\n                  deriving
  (Data,Typeable,Show,Eq)\n    \n    data Maker\n        = Wipe\n        | Test {threads
  :: Int, extra :: [String]}\n        | Build {threads :: Int, method :: Method, files
  :: [FilePath]}\n          deriving (Data,Typeable,Show,Eq)\n    \n    threadsMsg
  x = x &= help \"Number of threads to use\" &= name \"j\" &= typ \"NUM\"\n    \n
  \   wipe = Wipe &= help \"Clean all build objects\"\n    \n    test_ = Test\n        {threads
  = threadsMsg def\n        ,extra = def &= typ \"ANY\" &= args\n        } &= help
  \"Run the test suite\"\n    \n    build = Build\n        {threads = threadsMsg def\n
  \       ,method = enum\n            [Release &= help \"Release build\"\n            ,Debug
  &= help \"Debug build\"\n            ,Profile &= help \"Profile build\"]\n        ,files
  = def &= args\n        } &= help \"Build the project\" &= auto\n    \n    mode =
  cmdArgsMode $ modes [build,wipe,test_]\n         &= help \"Build helper program\"\n
  \        &= program \"maker\"\n         &= summary \"Maker v1.0\\nMake it\"\n\nAnd
  `--help` produces:\n\n    Maker v1.0\n      Make it\n     \n    maker [COMMAND]
  ... [OPTIONS]\n      Build helper program\n     \n    Common flags:\n      -? --help
  \    Display help message\n      -V --version  Print version information\n     \n
  \   maker [build] [OPTIONS] [ITEM]\n      Build the project\n     \n      -j --threads=NUM
  \ Number of threads to use\n      -r --release      Release build\n      -d --debug
  \       Debug build\n      -p --profile      Profile build\n     \n    maker wipe
  [OPTIONS]\n      Clean all build objects\n     \n    maker test [OPTIONS] [ANY]\n
  \     Run the test suite\n     \n      -j --threads=NUM  Number of threads to use\n"
license-name: BSD3

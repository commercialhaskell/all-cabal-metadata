homepage: https://github.com/yesodweb/wai
changelog-type: markdown
hash: 3f8fcbd4dec70fb549f1f9ec2b038df215a30afd74c01c1d36ecb85845115ba3
test-bench-deps:
  bytestring: -any
  wai: -any
  base: ! '>=4.8 && <5'
  hspec: -any
maintainer: michael@snoyman.com
synopsis: Web Application Interface.
changelog: |
  # ChangeLog for wai

  ## 3.2.2.1

  * Fix missing reexport of `getRequestBodyChunk` [#753](https://github.com/yesodweb/wai/issues/753)

  ## 3.2.2

  * Deprecate `requestBody` in favor of the more clearly named `getRequestBodyChunk`. [#726](https://github.com/yesodweb/wai/pull/726)

  ## 3.2.1.2

  * Remove dependency on blaze-builder [#683](https://github.com/yesodweb/wai/pull/683)

  ## 3.2.1.1

  * Relax upper bound on bytestring-builder

  ## 3.2.1

  * add mapResponseStatus [#532](https://github.com/yesodweb/wai/pull/532)

  ## 3.2.0.1

  * Add missing changelog entry

  ## 3.2.0

  * Major version up due to breaking changes. We chose 3.2.0, not 3.1.0
    for consistency with Warp 3.2.0.
  * The Network.Wai.HTTP2 module was removed.
  * tryGetFileSize, hContentRange, hAcceptRanges, contentRangeHeader and
    chooseFilePart, adjustForFilePart and parseByteRanges were removed
    from the Network.Wai.Internal module.
  * New fields for Request:  requestHeaderReferer and requestHeaderUserAgent.

  ## 3.0.5.0

  * Avoid using the IsString Builder instance

  ## 3.0.4.0

  * A new module Network.Wai.HTTP2 is exported.

  ## 3.0.3.0

  * mapResponseHeaders, ifRequest and modifyResponse are exported.

  ## 3.0.2.3

  * Allow blaze-builder 0.4

  ## 3.0.2.2

  * Clarify some documentation on `rawPathInfo`. [Relevant Github
    discussion](https://github.com/yesodweb/wai/issues/325#issuecomment-69896780).
basic-deps:
  bytestring: ! '>=0.10.4'
  base: ! '>=4.8 && <5'
  text: ! '>=0.7'
  network: ! '>=2.2.1.5'
  vault: ! '>=0.3 && <0.4'
  transformers: ! '>=0.0'
  http-types: ! '>=0.7'
all-versions:
- 0.0.0
- 0.0.1
- 0.1.0
- 0.2.0
- 0.2.1
- 0.2.2
- 0.2.2.1
- 0.3.0
- 0.3.1
- 0.3.2
- 0.4.0
- 0.4.1
- 0.4.2
- 0.4.3
- 1.0.0
- 1.1.0
- 1.1.0.1
- 1.2.0
- 1.2.0.1
- 1.2.0.2
- 1.2.0.3
- 1.3.0
- 1.3.0.1
- 1.3.0.2
- 1.3.0.3
- 1.4.0
- 1.4.0.1
- 1.4.0.2
- 1.4.1
- 2.0.0
- 2.1.0
- 2.1.0.1
- 2.1.0.2
- 2.1.0.3
- 3.0.0
- 3.0.0.1
- 3.0.0.2
- 3.0.1
- 3.0.1.1
- 3.0.2
- 3.0.2.1
- 3.0.2.2
- 3.0.2.3
- 3.0.3.0
- 3.0.4.0
- 3.0.5.0
- 3.2.0
- 3.2.0.1
- 3.2.1
- 3.2.1.1
- 3.2.1.2
- 3.2.2
- 3.2.2.1
author: Michael Snoyman
latest: 3.2.2.1
description-type: markdown
description: |
  WAI: Web Application Interface
  ==============================

  Getting started
  ---------------

  You want a minimal example? Here it is!

  ~~~ {.haskell}
  {-# LANGUAGE OverloadedStrings #-}
  import Network.Wai
  import Network.HTTP.Types
  import Network.Wai.Handler.Warp (run)

  app :: Application
  app _ respond = do
      putStrLn "I've done some IO here"
      respond $ responseLBS
          status200
          [("Content-Type", "text/plain")]
          "Hello, Web!"

  main :: IO ()
  main = do
      putStrLn $ "http://localhost:8080/"
      run 8080 app
  ~~~

  Put that code into a file named _hello.hs_ and install [wai] and [warp] from Hackage:

      cabal install wai warp

  Run it:

      runhaskell hello.hs

  Point your browser to:

      http://localhost:8080/


  Serving static content
  ----------------------

  We can modify our previous example to serve static content. For this create a file named _index.html_:

      <p>Hello, Web!</p>

  Now we redefine `responseBody` to refer to that file:

  ~~~ {.haskell}
  app2 :: Application
  app2 _ respond = respond index

  index :: Response
  index = responseFile
      status200
      [("Content-Type", "text/html")]
      "index.html"
      Nothing
  ~~~


  Basic dispatching
  -----------------

  An `Application` maps `Request`s to `Response`s:

      ghci> :info  Application
      type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived

  Depending on the path info provided with each `Request` we can serve different `Response`s:

  ~~~ {.haskell}
  app3 :: Application
  app3 request respond = respond $ case rawPathInfo request of
      "/"     -> index
      "/raw/" -> plainIndex
      _       -> notFound

  plainIndex :: Response
  plainIndex = responseFile
      status200
      [("Content-Type", "text/plain")]
      "index.html"
      Nothing

  notFound :: Response
  notFound = responseLBS
      status404
      [("Content-Type", "text/plain")]
      "404 - Not Found"
  ~~~


  Doing without overloaded strings
  --------------------------------

  For the sake of efficiency, WAI uses the [bytestring] package.  We used GHCs [overloaded strings] to almost hide this fact. But we can easily do without.  What follows is a more verbose definition of `notFound`, that works without GHC extensions:

  ~~~ {.haskell .ignore}
  import qualified Data.ByteString.Char8 as B8
  import qualified Data.ByteString.Lazy.Char8 as LB8
  import           Data.CaseInsensitive (mk)

  notFound = responseLBS
      status404
      [(mk $ B8.pack "Content-Type", B8.pack "text/plain")]
      (LB8.pack "404 - Not Found")
  ~~~


   [wai]: http://hackage.haskell.org/package/wai
   [warp]: http://hackage.haskell.org/package/warp
   [overloaded strings]: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#overloaded-strings
   [bytestring]: http://hackage.haskell.org/package/bytestring
license-name: MIT

homepage: https://github.com/qfpl/waargonaut
changelog-type: markdown
hash: f51794e522467111d1ee0e79b2cad79a9fbe4863ca5c35a9282f6fa69b9b38f9
test-bench-deps:
  semigroupoids: ! '>=5.2.2 && <5.6'
  bytestring: ! '>=0.10.6 && <0.11'
  digit: ==0.7.*
  base: ! '>=4.7 && <4.13'
  tasty-hedgehog: ! '>=0.2 && <0.3'
  tasty-expected-failure: ! '>=0.11 && <0.12'
  text: ==1.2.*
  distributive: ! '>=0.5 && <0.7'
  filepath: ! '>=1.3'
  hedgehog: ==0.6.*
  doctest: ! '>=0.9.7'
  semigroups: ! '>=0.8.4 && <0.19'
  tagged: ! '>=0.8.6 && <0.9'
  containers: ! '>=0.5.6 && <0.7'
  lens: ! '>=4.15 && <4.18'
  zippers: ! '>=0.2 && <0.3'
  contravariant: ! '>=1.4 && <1.6'
  mtl: ! '>=2.2.2 && <2.3'
  tasty-hunit: ! '>=0.10 && <0.11'
  attoparsec: ! '>=0.13 && <0.15'
  tasty: ! '>=0.11 && <1.2'
  waargonaut: -any
  scientific: ! '>=0.3 && <0.4'
  generics-sop: ! '>=0.3.2 && <0.4'
  hedgehog-fn: ! '>=0.6 && <0.7'
  template-haskell: ! '>=2.8'
  natural: ! '>=0.3 && <0.4'
  vector: ! '>=0.12 && <0.13'
  directory: ! '>=1.1'
maintainer: oᴉ˙ldɟb@uɐǝs
synopsis: JSON wrangling
changelog: |
  # Revision history for waargonaut

  ## 0.5.2.0  -- 2019-01-03

  * Add `Waargonaut.Prettier` module that contains a traversal to modify a `Json` structure to add indentation and newlines.

  ## 0.5.1.0  -- 2019-01-02

  * Fix order of `either` decoder to match documentation, `Right` decoder was not being attempted first.
  * Expose functionality to check the 'type' of the JSON at the current cursor position.
  * Update list decoder to check that we're at an array before attempting to decode. It will now fail when attempting to decode a list and something of type list is not found. Previously it would return an empty list when a number was present.

  ## 0.5.0.0  -- 2018-12-18

  * Changed internal builder from `ByteString` to `Text` builder.
  * Fixed bug for going from `JString` <-> `Text`, was breaking round-trip.
  * Removed instances of `AsJString` for `Text` and `ByteString`, replaced with more correct `Prism` and some better functions.
  * Added regression tests for round tripping text and bytestring (char8).

  ## 0.4.2.0  -- 2018-11-29

  * Improved pretty printing of CursorHistory by condensing multiple numeric movements and removing the single movements following searching for keys.
  * Add `fromKeyOptional` and `atKeyOptional` that make it easier to handle optional keys on objects.
  * Add `prismDOrFail'` function to allow the user to construct an error from the value that was decoded.

  ## 0.4.1.0  -- 2018-11-20

  * Add `oneOf` decoder and tests

  ## 0.4.0.0  -- 2018-11-19

  * Redesign & rebuild of `Encoder` internals to allow for greater control and flexibility
  * Factor our law tests into their own module (a recheck of these tests is needed)
  * Fixed bug in `list` and `nonempty` decoders
  * Fixed bug in `foldCursor` function
  * Fixed bug in `Cons` instance for `CommaSep`
  * Fixed bug in documentation for `atKey`
  * Added `_MapLikeObj` `Prism`
  * Added some optics into object / maplikeobj keys
  * Fixed bug in `maybeOrNull` decoder to be more strict in what it accepts
  * Rewrote `either` decoder in terms of the alternative instance to allow for better errors

  ## 0.3.0.0  -- 2018-11-14

  * Change to use the `natural` package for `Natural` numbers.

  ## 0.2.1.0  -- 2018-11-13

  * Add `MonadError` and `Alt` instance for `Decoder`
  * Add property tests for the typeclass laws for `Encoder` and `Decoder`
  * Removed need for `MonadError` constraint on `prismDOrFail`

  ## 0.2.0.2  -- 2018-11-12

  * Fix `Applicative` instance for `Decoder`.

  ## 0.2.0.1  -- 2018-11-07

  * Update `moveToKey` to record a successful movement to a key, before continuing

  ## 0.2.0.0  -- 2018-11-06

  * Provide more precise errors from Decoder for missing or invalid keys
  * Removed a parameter from `KeyDecodeFailed` error constructor
  * Fix issue where printing the zipper movements had left and right movement arrows swapped.

  ## 0.1.0.0  -- 2018-11-01

  * First version. Released on an unsuspecting world.
basic-deps:
  semigroupoids: ! '>=5.2.2 && <5.4'
  hoist-error: ! '>=0.2 && <0.3'
  bytestring: ! '>=0.10.6 && <0.11'
  digit: ! '>=0.7 && <0.8'
  witherable: ! '>=0.2 && <0.4'
  hw-json: ! '>=0.9.0.1 && <0.10'
  base: ! '>=4.7 && <4.13'
  text: ! '>=1.2 && <1.3'
  distributive: ! '>=0.5 && <0.7'
  hw-balancedparens: ! '>=0.2 && <0.3'
  semigroups: ! '>=0.8.4 && <0.19'
  hw-prim: ! '>=0.6 && <0.7'
  tagged: ! '>=0.8.6 && <0.9'
  containers: ! '>=0.5.6 && <0.7'
  wl-pprint-annotated: ! '>=0.1 && <0.2'
  parsers: ! '>=0.12 && <0.13'
  lens: ! '>=4.15 && <4.18'
  hw-rankselect: ! '>=0.10 && <0.13'
  bifunctors: ! '>=5 && <5.6'
  zippers: ! '>=0.2 && <0.3'
  contravariant: ! '>=1.4 && <1.6'
  mtl: ! '>=2.2.2 && <2.3'
  mmorph: ! '>=1.1 && <1.2'
  nats: ! '>=1 && <1.2'
  transformers: ! '>=0.4 && <0.6'
  errors: ! '>=2.2 && <2.4'
  scientific: ! '>=0.3 && <0.4'
  generics-sop: ! '>=0.3.2 && <0.4'
  hw-bits: ! '>=0.7 && <0.8'
  natural: ! '>=0.3 && <0.4'
  vector: ! '>=0.12 && <0.13'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.0.1
- 0.2.0.2
- 0.2.1.0
- 0.3.0.0
- 0.4.0.0
- 0.4.1.0
- 0.4.2.0
- 0.5.0.0
- 0.5.1.0
- 0.5.2.0
author: QFPL @ Data61
latest: 0.5.2.0
description-type: markdown
description: "<img src=\"http://i.imgur.com/0h9dFhl.png\" width=\"300px\"/>\n\n[![Build
  Status](https://travis-ci.org/qfpl/waargonaut.svg?branch=master)](https://travis-ci.org/qfpl/waargonaut)\n\n#
  Waargonaut\n\nFlexible, precise, and efficient JSON decoding/encoding library. This
  package\nprovides a plethora of tools for decoding, encoding, and manipulating JSON
  data.\n\n## Features\n\n* Fully RFC compliant, with property based testing used
  to ensure the desired\n  invariants are preserved.\n\n* Encoders and Decoders are
  values, they are not tied to a typeclass and as such\n  you are not tied to a single
  interpretation of how a particular type\n  \"_should_\" be handled.\n  \n* No information
  is discarded on parsing. Trailing whitespace, and any\n  formatting whitespace (carriage
  returns etc) are all preserved. \n\n* A history keeping zipper is used for Decoding,
  providing precise control of\n  how _you_ decode _your_ JSON data. With informative
  error messages if things\n  don't go according to plan.\n\n* Flexible and expressive
  Decoder & Encoder functions let you parse and build\n  the JSON structures _you_
  require, with no surprises.\n\n* BYO parsing library, the parser built into Waargonaut
  does not tie you to a\n  particular parsing library. With the caveat that your parsing
  library must\n  have an instance of `CharParsing` from the [parsers](https://hackage.haskell.org/package/parsers)
  package.\n\n* Generic functions are provided to make the creation of Encoders and
  Decoders\n  are bit easier. However these _are_ tied to typeclasses, so they do
  come with\n  some assumptions.\n\n* Lenses, Prisms, and Traversals are provided
  to allow you to investigate and\n  manipulate the JSON data structures to your hearts
  content, without breaking\n  the invariants.\n\n* The awesome work on succinct data
  structures by John Ky and [Haskell Works](https://github.com/haskell-works/) \n
  \ is used to power the decoder. Providing the same zipper capabilities and\n  property
  based guarantees, but with all the speed and efficiency capabilities\n  that succinct
  data structures have to offer.\n\n## Example\n\n- Data Structure:\n```haskell\ndata
  Image = Image\n  { _imageWidth    :: Int\n  , _imageHeight   :: Int\n  , _imageTitle
  \   :: Text\n  , _imageAnimated :: Bool\n  , _imageIDs      :: [Int]\n  }\n```\n\n-
  Encoder:\n```haskell\nencodeImage :: Applicative f => Encoder f Image\nencodeImage
  = E.mapLikeObj $ \\img ->\n    E.intAt \"Width\" (_imageWidth img)\n  . E.intAt
  \"Height\" (_imageHeight img)\n  . E.textAt \"Title\" (_imageTitle img)\n  . E.boolAt
  \"Animated\" (_imageAnimated img)\n  . E.listAt E.int \"IDs\" (_imageIDs img)\n```\n\n-
  Decoder:\n```haskell\nimageDecoder :: Monad f => D.Decoder f Image\nimageDecoder
  = D.withCursor $ \\curs -> do\n  -- Move down into the JSON object.\n  io <- D.down
  curs\n  -- We need individual values off of our object,\n  Image\n    <$> D.fromKey
  \"Width\" D.int io\n    <*> D.fromKey \"Height\" D.int io\n    <*> D.fromKey \"Title\"
  D.text io\n    <*> D.fromKey \"Animated\" D.bool io\n    <*> D.fromKey \"IDs\" (D.list
  D.int) io\n```\n\n### Zippers\n\nWaargonaut uses zippers for its decoding which
  allows for precise control in\nhow you interrogate your JSON input. Take JSON structures
  and decode them\nprecisely as you require:\n\n##### Input:\n\n```JSON\n[\"a\",\"fred\",1,2,3,4]\n```\n\n#####
  Data Structure:\n\n```haskell\ndata Foo = Foo (Char,String,[Int])\n```\n\n#####
  Decoder:\n\nThe zipper starts the very root of the JSON input, we tell it to move
  'down'\ninto the first element.\n```haskell\nfooDecoder :: Monad f => Decoder f
  Foo\nfooDecoder = D.withCursor $ \\cursor -> do\n  fstElem <- D.down cursor\n```\nFrom
  the first element we can then decode the focus of the zipper using a\nspecific decoder:\n```haskell\n
  \ aChar <- D.focus D.unboundedChar fstElem\n```\nThe next thing we want to decode
  is the second element of the array, so we\nmove right one step or tooth, and then
  attempt to decode a string at the\nfocus.\n```haskell\n  aString <- D.moveRight1
  fstElem >>= D.focus D.string\n```\nFinally we want to take everything else in the
  list and combine them into a\nsingle list of Int values. Starting from the first
  element, we move right\ntwo positions (over the char and the string elements), then
  we use one of\nthe provided decoder functions that will repeatedly move in a direction
  and\ncombine all of the elements it can until it can no longer move.\n```haskell\n
  \ aIntList <- D.moveRightN 2 fstElem >>= D.rightwardSnoc [] D.int\n```\nLastly,
  we build the Foo using the decoded values.\n```haskell\n  pure $ Foo (aChar, aString,
  aIntList)\n```\n\nThe zipper stores the history of your movements, so any errors
  provide\ninformation about the path they took prior to encountering an error. Making\ndebugging
  precise and straight-forward.\n\n### Property Driven Development\n\nThis library
  is built to parse and produce JSON in accordance with the [RFC\n8259](https://tools.ietf.org/html/rfc8259)
  standard. The data structures,\nparser, and printer are built to satify the [Round
  Trip Property](https://teh.id.au/posts/2017/06/07/round-trip-property/):\n\nWhich
  may be expressed using the following pseudocode:\n\n```\nparse . print = id\n```\nThis
  indicates that any JSON produced by this library will be parsed back in as\nthe
  exact data structure that produced it. This includes whitespace such as\ncarriage
  returns and trailing whitespace. There is no loss of information.\n\nThere is also
  this property, again in pseudocode:\n\n```\nprint . parse . print = print\n```\nThis
  states that the printed form of the JSON will not change will be identical\nafter
  parsing and then re-printing. There is no loss of information.\n\nThis provides
  a solid foundation to build upon.\n\n**NB:** The actual code will of course return
  values that account for the\npossibility of failure. Computers being what they are.\n\n###
  TODO(s)\n\nIn no particular order...\n\n- [ ] improve/bikeshed encoding object api
  \n- [ ] gather feedback on tests/benchmarks that matter\n- [ ] provide testing functions
  so users can be more confident in their Encoder/Decoder construction\n- [x] (feedback
  required) documentation in the various modules to explain any weirdness or things
  that users may consider to be 'missing' or 'wrong'.\n- [x] (mostly) provide greater
  rationale behind lack of reliance in typeclasses for encoding/decoding\n- [ ] provide
  functions to add preset whitespace layouts to encoded json.\n"
license-name: BSD-3-Clause

homepage: https://github.com/qfpl/waargonaut
changelog-type: markdown
hash: e72600035675d3ae679482072eae736b1dd77f94d5eecdf12c509cee7973a955
test-bench-deps:
  bytestring: ! '>=0.10.6 && <0.11'
  digit: ==0.7.*
  base: ! '>=4.7 && <4.13'
  tasty-hedgehog: ! '>=0.2 && <0.3'
  tasty-expected-failure: ! '>=0.11 && <0.12'
  text: ==1.2.*
  distributive: ! '>=0.5 && <0.7'
  filepath: ! '>=1.3'
  hedgehog: ==0.6.*
  doctest: ! '>=0.9.7'
  semigroups: ! '>=0.8.4 && <0.19'
  tagged: ! '>=0.8.6 && <0.9'
  lens: ! '>=4.15 && <5'
  zippers: ! '>=0.2 && <0.3'
  tasty-hunit: ! '>=0.10 && <0.11'
  attoparsec: ! '>=0.13 && <0.15'
  tasty: ! '>=0.11 && <2'
  waargonaut: -any
  scientific: ! '>=0.3 && <0.4'
  generics-sop: ! '>=0.3.2 && <0.4'
  template-haskell: ! '>=2.8'
  vector: ! '>=0.12 && <0.13'
  directory: ! '>=1.1'
maintainer: oᴉ˙ldɟb@uɐǝs
synopsis: JSON wrangling
changelog: ! '# Revision history for waargonaut


  ## 0.2.0.1  -- 2018-11-07


  * Update `moveToKey` to record a successful movement to a key, before continuing


  ## 0.2.0.0  -- 2018-11-06


  * Provide more precise errors from Decoder for missing or invalid keys

  * Removed a parameter from `KeyDecodeFailed` error constructor

  * Fix issue where printing the zipper movements had left and right movement arrows
  swapped.


  ## 0.1.0.0  -- 2018-11-01


  * First version. Released on an unsuspecting world.

'
basic-deps:
  hoist-error: ! '>=0.2 && <0.3'
  bytestring: ! '>=0.10.6 && <0.11'
  digit: ! '>=0.7 && <0.8'
  witherable: ! '>=0.2 && <0.3'
  hw-json: ! '>=0.9.0.1 && <0.10'
  base: ! '>=4.7 && <4.13'
  text: ! '>=1.2 && <1.3'
  distributive: ! '>=0.5 && <0.7'
  hw-balancedparens: ! '>=0.2 && <0.3'
  semigroups: ! '>=0.8.4 && <0.19'
  hw-prim: ! '>=0.6 && <0.7'
  tagged: ! '>=0.8.6 && <0.9'
  containers: ! '>=0.5.6 && <0.7'
  wl-pprint-annotated: ! '>=0.1 && <0.2'
  parsers: ! '>=0.12 && <0.13'
  lens: ! '>=4.15 && <5'
  hw-rankselect: ! '>=0.10 && <0.13'
  bifunctors: ! '>=5 && <6'
  zippers: ! '>=0.2 && <0.3'
  contravariant: ! '>=1.4 && <2'
  mtl: ! '>=2.2.2 && <3'
  mmorph: ! '>=1.1 && <2'
  nats: ! '>=1 && <1.2'
  transformers: ! '>=0.4 && <0.6'
  errors: ! '>=2.2 && <3'
  scientific: ! '>=0.3 && <0.4'
  generics-sop: ! '>=0.3.2 && <4'
  hw-bits: ! '>=0.7 && <0.8'
  vector: ! '>=0.12 && <0.13'
all-versions:
- '0.1.0.0'
- '0.2.0.0'
- '0.2.0.1'
author: QFPL @ Data61
latest: '0.2.0.1'
description-type: markdown
description: ! "<img src=\"http://i.imgur.com/0h9dFhl.png\" width=\"300px\"/>\n\n[![Build
  Status](https://travis-ci.org/qfpl/waargonaut.svg?branch=master)](https://travis-ci.org/qfpl/waargonaut)\n\n#
  Waargonaut\n\nFlexible, precise, and efficient JSON decoding/encoding library. This
  package\nprovides a plethora of tools for decoding, encoding, and manipulating JSON
  data.\n\n## Features\n\n* Fully RFC compliant, with property based testing used
  to ensure the desired\n  invariants are preserved.\n\n* Encoders and Decoders are
  values, they are not tied to a typeclass and as such\n  you are not tied to a single
  interpretation of how a particular type\n  \"_should_\" be handled.\n  \n* No information
  is discarded on parsing. Trailing whitespace, and any\n  formatting whitespace (carriage
  returns etc) are all preserved. \n\n* A history keeping zipper is used for Decoding,
  providing precise control of\n  how _you_ decode _your_ JSON data. With informative
  error messages if things\n  don't go according to plan.\n\n* Flexible and expressive
  Decoder & Encoder functions let you parse and build\n  the JSON structures _you_
  require, with no surprises.\n\n* BYO parsing library, the parser built into Waargonaut
  does not tie you to a\n  particular parsing library. With the caveat that your parsing
  library must\n  have an instance of `CharParsing` from the [parsers](https://hackage.haskell.org/package/parsers)
  package.\n\n* Generic functions are provided to make the creation of Encoders and
  Decoders\n  are bit easier. However these _are_ tied to typeclasses, so they do
  come with\n  some assumptions.\n\n* Lenses, Prisms, and Traversals are provided
  to allow you to investigate and\n  manipulate the JSON data structures to your hearts
  content, without breaking\n  the invariants.\n\n* The awesome work on succinct data
  structures by John Ky and [Haskell Works](https://github.com/haskell-works/) \n
  \ is used to power the decoder. Providing the same zipper capabilities and\n  property
  based guarantees, but with all the speed and efficiency capabilities\n  that succinct
  data structures have to offer.\n\n## Example\n\n- Data Structure:\n```haskell\ndata
  Image = Image\n  { _imageWidth    :: Int\n  , _imageHeight   :: Int\n  , _imageTitle
  \   :: Text\n  , _imageAnimated :: Bool\n  , _imageIDs      :: [Int]\n  }\n```\n\n-
  Encoder:\n```haskell\nencodeImage :: Applicative f => Encoder f Image\nencodeImage
  = E.mapLikeObj $ \\img ->\n    E.intAt \"Width\" (_imageWidth img)\n  . E.intAt
  \"Height\" (_imageHeight img)\n  . E.textAt \"Title\" (_imageTitle img)\n  . E.boolAt
  \"Animated\" (_imageAnimated img)\n  . E.listAt E.int \"IDs\" (_imageIDs img)\n```\n\n-
  Decoder:\n```haskell\nimageDecoder :: Monad f => D.Decoder f Image\nimageDecoder
  = D.withCursor $ \\curs -> do\n  -- Move down into the JSON object.\n  io <- D.down
  curs\n  -- We need individual values off of our object,\n  Image\n    <$> D.fromKey
  \"Width\" D.int io\n    <*> D.fromKey \"Height\" D.int io\n    <*> D.fromKey \"Title\"
  D.text io\n    <*> D.fromKey \"Animated\" D.bool io\n    <*> D.fromKey \"IDs\" (D.list
  D.int) io\n```\n\n### Zippers\n\nWaargonaut uses zippers for its decoding which
  allows for precise control in\nhow you interrogate your JSON input. Take JSON structures
  and decode them\nprecisely as you require:\n\n##### Input:\n\n```JSON\n[\"a\",\"fred\",1,2,3,4]\n```\n\n#####
  Data Structure:\n\n```haskell\ndata Foo = Foo (Char,String,[Int])\n```\n\n#####
  Decoder:\n\nThe zipper starts the very root of the JSON input, we tell it to move
  'down'\ninto the first element.\n```haskell\nfooDecoder :: Monad f => Decoder f
  Foo\nfooDecoder = D.withCursor $ \\cursor -> do\n  fstElem <- D.down cursor\n```\nFrom
  the first element we can then decode the focus of the zipper using a\nspecific decoder:\n```haskell\n
  \ aChar <- D.focus D.unboundedChar fstElem\n```\nThe next thing we want to decode
  is the second element of the array, so we\nmove right one step or tooth, and then
  attempt to decode a string at the\nfocus.\n```haskell\n  aString <- D.moveRight1
  fstElem >>= D.focus D.string\n```\nFinally we want to take everything else in the
  list and combine them into a\nsingle list of Int values. Starting from the first
  element, we move right\ntwo positions (over the char and the string elements), then
  we use one of\nthe provided decoder functions that will repeatedly move in a direction
  and\ncombine all of the elements it can until it can no longer move.\n```haskell\n
  \ aIntList <- D.moveRightN 2 fstElem >>= D.rightwardSnoc [] D.int\n```\nLastly,
  we build the Foo using the decoded values.\n```haskell\n  pure $ Foo (aChar, aString,
  aIntList)\n```\n\nThe zipper stores the history of your movements, so any errors
  provide\ninformation about the path they took prior to encountering an error. Making\ndebugging
  precise and straight-forward.\n\n### Property Driven Development\n\nThis library
  is built to parse and produce JSON in accordance with the [RFC\n8259](https://tools.ietf.org/html/rfc8259)
  standard. The data structures,\nparser, and printer are built to satify the [Round
  Trip Property](https://teh.id.au/posts/2017/06/07/round-trip-property/):\n\nWhich
  may be expressed using the following pseudocode:\n\n```\nparse . print = id\n```\nThis
  indicates that any JSON produced by this library will be parsed back in as\nthe
  exact data structure that produced it. This includes whitespace such as\ncarriage
  returns and trailing whitespace. There is no loss of information.\n\nThere is also
  this property, again in pseudocode:\n\n```\nprint . parse . print = print\n```\nThis
  states that the printed form of the JSON will not change will be identical\nafter
  parsing and then re-printing. There is no loss of information.\n\nThis provides
  a solid foundation to build upon.\n\n**NB:** The actual code will of course return
  values that account for the\npossibility of failure. Computers being what they are.\n\n###
  TODO(s)\n\nIn no particular order...\n\n- [ ] improve/bikeshed encoding object api
  \n- [ ] gather feedback on tests/benchmarks that matter\n- [ ] provide testing functions
  so users can be more confident in their Encoder/Decoder construction\n- [x] (feedback
  required) documentation in the various modules to explain any weirdness or things
  that users may consider to be 'missing' or 'wrong'.\n- [x] (mostly) provide greater
  rationale behind lack of reliance in typeclasses for encoding/decoding\n- [ ] provide
  functions to add preset whitespace layouts to encoded json.\n"
license-name: BSD3

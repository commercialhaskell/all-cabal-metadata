homepage: https://github.com/athanclark/wai-middleware-content-type#readme
changelog-type: ''
hash: 67b9926c85f4d2a54a247cec44a4f4bea3f9f760a36ca60f8bcac496bd331b12
test-bench-deps:
  shakespeare: -any
  warp: -any
  exceptions: -any
  lucid: -any
  bytestring: -any
  clay: -any
  wai: -any
  wai-transformers: -any
  base: '>=4.11 && <5'
  unordered-containers: -any
  hspec: -any
  text: -any
  extractable-singleton: -any
  monad-control: -any
  tasty-hspec: -any
  blaze-builder: -any
  wai-middleware-content-type: -any
  hspec-wai: -any
  monad-control-aligned: '>=0.0.2'
  mtl: -any
  mmorph: -any
  hashable: -any
  blaze-html: -any
  transformers-base: -any
  monad-logger: -any
  transformers: -any
  tasty: -any
  wai-logger: -any
  resourcet: -any
  http-types: -any
  aeson: -any
  urlpath: -any
  http-media: -any
maintainer: athan.clark@gmail.com
synopsis: Route to different middlewares based on the incoming Accept header.
changelog: ''
basic-deps:
  shakespeare: -any
  exceptions: -any
  lucid: -any
  bytestring: -any
  clay: -any
  wai: '>=3.2'
  wai-transformers: '>=0.1.0'
  base: '>=4.11 && <5'
  unordered-containers: -any
  text: -any
  extractable-singleton: -any
  monad-control: -any
  blaze-builder: -any
  monad-control-aligned: '>=0.0.2'
  mtl: -any
  mmorph: -any
  hashable: -any
  blaze-html: -any
  transformers-base: -any
  monad-logger: -any
  transformers: -any
  wai-logger: -any
  resourcet: -any
  http-types: -any
  aeson: -any
  urlpath: '>=11.0.0'
  http-media: -any
all-versions:
- 0.4.0
- 0.4.1
- 0.5.0
- 0.5.0.1
- 0.5.1
- 0.5.2
- 0.6.0
- 0.6.1
- 0.6.1.1
- 0.6.1.2
- 0.6.2
- 0.7.0
author: Athan Clark
latest: 0.7.0
description-type: markdown
description: |
  wai-middleware-content-type
  ===========================

  Route middlewares based on the incoming `Accept` HTTP header,
  and other hints like the file extension (`foo.txt`) of the route
  requested.

  ## Usage

  This package provides many combinators for turning various data
  types into the response you'd expect. For instance,
  [blaze-html](https://hackage.haskell.org/package/blaze-html) gives
  us _strictly_ `Html` data, right? We can be sure to only respond
  with `Html`-compatible requests with our toolset:

  ```haskell
  import Network.Wai.Middleware.ContentType
  import Network.Wai.Trans


  myMiddleware :: MiddlewareT (ReaderT Env m)

  contentTypeRoutes :: Monad m =>
                       FileExtListenerT urlbase (Status -> ResponseHeaders -> Response) m ()
  contentTypeRoutes = do
    blaze myBlazeResponse
    cassius myCassiusResponse
    text myTextResponse


  contentMiddleware :: Monad m => MiddlewareT m
  contentMiddleware app req respond =
    fileExtsToMiddleware $
      mapResponse (\f -> f status200 []) contentTypeRoutes
  ```


  This library was designed for use with [nested-routes](https://hackage.haskell.org/package/nested-routes),
  but it's all good if you want to use it separately.
license-name: BSD-3-Clause

all-versions:
- 0.0.1.1
- 0.0.1.2
- 0.0.1.4
- 0.0.1.5
- 0.1.0
- 0.2.0
- 0.3.0
- 0.4.0
- 0.5.0
- 0.6.0
- 0.6.1
- 0.6.2
- 0.6.3
- 0.7.0
- 0.8.0
- 0.8.1
- 0.9.0
- 0.9.1
- 0.9.2.0
- 0.9.2.1
- 0.9.3.0
- 0.9.3.1
- 0.9.3.2
author: Tony Day
basic-deps:
  async: '>=2.2 && <2.3'
  base: '>=4.7 && <5'
  bytestring: '>=0.11.3 && <0.13'
  containers: '>=0.6 && <0.8'
  contravariant: '>=1.5 && <1.6'
  dlist: '>=1.0 && <1.1'
  exceptions: '>=0.10 && <0.11'
  kan-extensions: '>=5.2 && <5.3'
  mtl: '>=2.2.2 && <2.4'
  profunctors: '>=5.6.2 && <5.7'
  semigroupoids: '>=5.3 && <6.1'
  stm: '>=2.5.1 && <2.6'
  text: '>=1.2 && <2.2'
  time: '>=1.10 && <1.15'
changelog: |+
  0.9.3
  ===
  * stdBox, toLineBox, fromLineBox added to Box.IO

  * concurrentlyLeft & concurrentlyRight exposed in Box.Queue

changelog-type: markdown
description: "# box \n\n[![img](https://img.shields.io/hackage/v/box.svg)](https://hackage.haskell.org/package/box)
  [![img](https://github.com/tonyday567/box/workflows/haskell-ci/badge.svg)](https://github.com/tonyday567/box/actions?query=workflow%3Ahaskell-ci)\n\nA
  profunctor effect system.\n\n> What is all this stuff around me; this stream of
  experiences that I seem to be having all the time? Throughout history there have
  been people who say it is all illusion. ~ S Blackmore\n\n<a id=\"org2ba6799\"></a>\n\n#
  Usage\n\n    :set -XOverloadedStrings\n    import Box\n    import Prelude\n    import
  Data.Function\n    import Data.Bool\n\nStandard IO echoing:\n\n    echoC = Committer
  (\\s -> putStrLn (\"echo: \" <> s) >> pure True)\n    echoE = Emitter (getLine &
  fmap (\\x -> bool (Just x) Nothing (x ==\"quit\")))\n    glue echoC echoE\n\n    hello\n
  \   echo: hello\n    echo\n    echo: echo\n    quit\n\nCommitting to a list:\n\n
  \   > toListM echoE\n    hello\n    echo\n    quit\n    [\"hello\",\"echo\"]\n\nEmitting
  from a list:\n\n    > glue echoC <$|> witherE (\\x -> bool (pure (Just x)) (pure
  Nothing) (x==\"quit\")) <$> (qList [\"hello\", \"echo\", \"quit\"])\n    echo: hello\n
  \   echo: echo\n\n\n<a id=\"orgb128561\"></a>\n\n# Library Design\n\n\n<a id=\"orgd99cf15\"></a>\n\n###
  Resource Coinduction\n\nHaskell has an affinity with [coinductive functions](https://www.reddit.com/r/haskell/comments/j3kbge/comment/g7foelq/?utm_source=share&utm_medium=web2x&context=3);
  functions should expose destructors and allow for infinite data.\n\nThe key text,
  [Why Functional Programming Matters](https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf),
  details how producers and consumers can be separated by exploiting laziness, creating
  a speration of concern not available in other technologies. Utilising laziness,
  we can peel off (destruct) the next element of a list to be consumed without disturbing
  the pipeline of computations that is still to occur, for the cost of a thunk.\n\nSo
  how do you apply this to resources and their effects? One answer is that you destruct
  a (potentially long-lived) resource simply by using it. For example, reading and
  writing lines to standard IO:\n\n    :t getLine\n    :t putStrLn\n\n    getLine
  :: IO String\n    putStrLn :: String -> IO ()\n\nThese are the destructors that
  need to be transparently exposed if effects are to be good citizens in Haskell.\n\n\n<a
  id=\"org2a2a0b7\"></a>\n\n### What is a Box?\n\nA Box is simply the product of a
  consumer destructor and a producer destructor.\n\n    data Box m c e = Box\n      {
  committer :: Committer m c,\n        emitter :: Emitter m e\n      }\n\n\n<a id=\"org23b3a97\"></a>\n\n###
  Committer\n\nThe library denotes a consumer by wrapping a consumption destructor
  and calling it a Committer. Like much of base, there is failure hidden in the getLine
  example type. A better approach, for a consumer, is to signal whether consumption
  actually occurred.\n\n    newtype Committer m a = Committer\n      { commit :: a
  -> m Bool\n      }\n\nYou give a Committer an &rsquo;a&rsquo;, and the destructor
  tells you whether the consumption of the &rsquo;a&rsquo; was successful or not.
  A standard output committer is then:\n\n    stdC :: Committer IO String\n    stdC
  = Committer (\\s -> putStrLn s >> pure True)\n\n    <interactive>:19:1-4: warning:
  [GHC-63397] [-Wname-shadowing]\n        This binding for ‘stdC’ shadows the existing
  binding\n          defined at <interactive>:16:1\n\nA Committer is a contravariant
  functor, so contramap can be used to modify this:\n\n    import Data.Text as Text\n
  \   import Data.Functor.Contravariant\n    \n    echoC :: Committer IO Text\n    echoC
  = contramap (Text.unpack . (\"echo: \"<>)) stdC\n\n\n<a id=\"org5a69dab\"></a>\n\n###
  Emitter\n\nThe library denotes a producer by wrapping a production destructor and
  calling it an Emitter.\n\n    newtype Emitter m a = Emitter\n      { emit :: m (Maybe
  a)\n      }\n\nAn emitter returns an &rsquo;a&rsquo; on demand or not.\n\n    stdE
  :: Emitter IO String\n    stdE = Emitter (Just <$> getLine)\n\nAs a functor instance,
  an Emitter can be modified with fmap. Several library functions, such as witherE
  and filterE can also be used to stop emits or add effects.\n\n    echoE :: Emitter
  IO Text\n    echoE =\n      witherE (\\x -> bool (pure (Just x)) (putStrLn \"quitting\"
  *> pure Nothing) (x == \"quit\"))\n        (fmap Text.pack stdE)\n\n    <interactive>:52:1-5:
  warning: [GHC-63397] [-Wname-shadowing]\n        This binding for ‘echoE’ shadows
  the existing binding\n          defined at <interactive>:49:1\n\n\n<a id=\"org7eb6547\"></a>\n\n###
  Box duality\n\nA Box represents a duality in two ways:\n\n-   As the consumer and
  producer sides of a resource. The complete interface to standard IO, for example,
  could be:\n\n    stdIO :: Box IO String String\n    stdIO = Box (Committer (\\s
  -> putStrLn s >> pure True)) (Emitter (Just <$> getLine))\n\n-   As two ends of
  a computation.\n\n> This is how we can use a profunctor to glue together two categories
  ~ Milewski\n> [Promonads, Arrows, and Einstein Notation for Profunctors](https://bartoszmilewski.com/2019/03/27/promonads-arrows-and-einstein-notation-for-profunctors/)\n\n`glue`
  is the primitive with which we connect a Committer and Emitter.\n\n    > glue echoC
  echoE\n    hello\n    echo: hello\n    echo\n    echo: echo\n    quit\n    quitting\n\nEffectively
  the same computation, for a Box, is:\n\n    fuse (pure . pure) stdIO\n\n\n<a id=\"org6c7b1fc\"></a>\n\n###
  Continuation\n\nAs with many operators in the library, `qList` is actually a continuation:\n\n
  \   :t qList\n\n    qList\n      :: Control.Monad.Conc.Class.MonadConc m => [a]
  -> CoEmitter m a\n\n    type CoEmitter m a = Codensity m (Emitter m a)\n\nEffectively
  being a newtype wrapper around:\n\n    forall x. (Emitter m a -> m x) -> m x\n\nA
  good background on call-back style programming in Haskell is in the [managed](https://hackage.haskell.org/package/managed-1.0.10/docs/Control-Monad-Managed.html)
  library, which is a specialised version of Codensity.\n\nCodensity has an Applicative
  instance, and lends itself to applicative-style coding. To send a (queued) list
  to stdout, for example, you could say:\n\n    :t glue <$> pure toStdout <*> qList
  [\"a\", \"b\", \"c\"]\n\n    glue <$> pure toStdout <*> qList [\"a\", \"b\", \"c\"]\n
  \     :: Codensity IO (IO ())\n\nand then escape the continuation with:\n\n    runCodensity
  (glue <$> pure toStdout <*> (qList [\"a\", \"b\", \"c\"])) id\n\n    a\n    b\n
  \   c\n\nThis closes the continuation. The following code is equivalent:\n\n    close
  $ glue <$> pure toStdout <*> qList [\"a\", \"b\", \"c\"]\n\n    a\n    b\n    c\n\n
  \   close $ glue toStdout <$> qList [\"a\", \"b\", \"c\"]\n\n    a\n    b\n    c\n\nGiven
  the ubiquity of this method, the library supplies two applicative style operators
  that combine application and closure.\n\n-   `(<$|>)` fmap and close over a Codensity:\n\n
  \   glue toStdout <$|> qList [\"a\", \"b\", \"c\"]\n\n    a\n    b\n    c\n\n-   `(<*|>)`
  Apply and close over Codensity\n\n    glue <$> pure toStdout <*|> qList [\"a\",
  \"b\", \"c\"]\n\n    a\n    b\n    c\n\n\n<a id=\"org9d9d756\"></a>\n\n# Explicit
  Continuation\n\nYield-style streaming libraries are [coroutines](https://rubenpieters.github.io/assets/papers/JFP20-pipes.pdf),
  sum types that embed and mix continuation logic in with other stuff like effect
  decontruction. `box` sticks to a corner case of a product type representing a consumer
  and producer. The major drawback of eschewing coroutines is that continuations become
  explicit and difficult to hide. One example; taking the first n elements of an Emitter:\n\n
  \   :t takeE\n    takeE :: Monad m => Int -> Emitter m a -> Emitter (StateT Int
  m) a\n\nA disappointing type. The state monad can not be hidden, the running count
  has to sit somewhere, and so different glueing functions are needed:\n\n    -- |
  Connect a Stateful emitter to a (non-stateful) committer of the same type, supplying
  initial state.\n    --\n    -- >>> glueES 0 (showStdout) <$|> (takeE 2 <$> qList
  [1..3])\n    -- 1\n    -- 2\n    glueES :: (Monad m) => s -> Committer m a -> Emitter
  (StateT s m) a -> m ()\n    glueES s c e = flip evalStateT s $ glue (foist lift
  c) e\n\n\n<a id=\"orgde76b6e\"></a>\n\n# Future directions\n\nThe design and concepts
  contained within the box library is a hodge-podge, but an interesting mess, being
  at quite a busy confluence of recent developments.\n\n\n<a id=\"orga1ab71e\"></a>\n\n##
  Optics\n\nA Box is an adapter in the [language of optics](http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf)
  and the relationship between a resource&rsquo;s committer and emitter could be modelled
  by other optics.\n\n\n<a id=\"org1cf8e47\"></a>\n\n## Categorical Profunctor\n\nThe
  deprecation of Box.Functor awaits the development of [categorical functors](https://github.com/haskell/core-libraries-committee/issues/91#issuecomment-1325337471).
  Similarly to Filterable the type of a Box could be something like `FunctorOf Op(Kleisli
  Maybe) (Kleisli Maybe) (->)`. Or it could be something like the SISO type in [Programming
  with Monoidal Profunctors and Semiarrows](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4496714).\n\n\n<a
  id=\"orgedd280b\"></a>\n\n## Wider Types\n\nAlternatively, the types could be widened:\n\n
  \   newtype Committer f a = Committer { commit :: a -> f () }\n    \n    instance
  Contravariant (Committer f) where\n      contramap f (Committer a) = Committer (a
  . f)\n    \n    newtype Emitter f a = Emitter { emit :: f a }\n    \n    instance
  (Functor f) => Functor (Emitter f) where\n      fmap f (Emitter a) = Emitter (fmap
  f a)\n    \n    data Box f g b a =\n      Box { committer :: Committer g b, emitter
  :: Emitter f a }\n    \n    instance (Functor f) => Functor (Box f g b) where\n
  \     fmap f (Box c e) = Box c (fmap f e)\n    \n    instance (Functor f, Contravariant
  g) => Profunctor (Box f g) where\n      dimap f g (Box c e) = Box (contramap f c)
  (fmap g e)\n\n.. with the existing computations recovered with:\n\n    type CommitterB
  m a = Committer (MaybeT m) a\n    type EmitterB m a = Emitter (MaybeT m) a\n    type
  BoxB m b a = Box (MaybeT m) (MaybeT m) b a\n\n\n<a id=\"orgae9938a\"></a>\n\n##
  Introduce a [nucleus](https://golem.ph.utexas.edu/category/2013/08/the_nucleus_of_a_profunctor_so.html)\n\nAlternative
  to both of these, the Monad constraint could be rethought. There are the ends of
  the computational pipeline, but there is also the gluing/fusion/middle bit.\n\n
  \   connect :: (f a -> b) -> Committer g b -> Emitter f a -> g ()\n    connect w
  c e = emit e & w & commit c\n    \n    glue :: Box f g (f a) a -> g ()\n    glue
  (Box c e) = connect id c e\n    \n    nucleate ::\n      Functor f =>\n      (f
  a -> f b) ->\n      Committer g b ->\n      Emitter f a ->\n      f (g ())\n    nucleate
  n c e = emit e & n & fmap (commit c)\n\nThis has the nice property that the closure
  is not hidden (as is usually the case for a Monad constraint) so that, for instance,
  fusion along longer chains becomes possible.\n\n"
description-type: markdown
hash: dc1ea08603d06157ec725c5405b229ad6debe86b5c84698923dfc1af37751a88
homepage: https://github.com/tonyday567/box#readme
latest: 0.9.3.2
license-name: BSD-3-Clause
maintainer: tonyday567@gmail.com
synopsis: A profunctor effect system?
test-bench-deps:
  base: '>=4.14 && <5'
  doctest-parallel: '>=0.3 && <0.4'

homepage: https://github.com/robrix/fused-effects
changelog-type: markdown
hash: f590d457fbb63cf309e8b0a13c4af62f9149c4c0c395bf681e8b7f1f86dbb455
test-bench-deps:
  base: ! '>=4.9 && <4.13'
  hspec: ! '>=2.4.1'
  doctest: ! '>=0.7 && <1.0'
  fused-effects: -any
  QuickCheck: ! '>=2.7 && <2.12'
maintainer: robrix@github.com
synopsis: A fast, flexible, fused effect system.
changelog: ! '# 0.1.2.0


  - Adds support for ghc 8.6.2, courtesy of @jkachmar.

  - Adds a `Cut` effect which adds committed choice to nondeterminism.

  - Adds a `Cull` effect which adds pruning to nondeterminism.

  - Adds an example of using `NonDet`, `Cut`, and a character parser effect to define
  parsers.

  - Fixes the table of contents links in the README.


  # 0.1.1.0


  - Adds a `runNonDetOnce` handler which terminates immediately upon finding a solution.


  # 0.1.0.0


  Initial release.

'
basic-deps:
  MonadRandom: ! '>=0.5 && <0.6'
  base: ! '>=4.9 && <4.13'
  random: -any
  deepseq: ! '>=1.4.3 && <1.5'
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.2.0'
author: Nicolas Wu, Tom Schrijvers, Rob Rix, Patrick Thomson
latest: '0.1.2.0'
description-type: markdown
description: ! "# A fast, flexible, fused effect system for Haskell\n\n[![Build Status](https://travis-ci.com/robrix/fused-effects.svg?branch=master)](https://travis-ci.com/robrix/fused-effects)\n\n-
  [Overview][]\n  - [Algebraic effects][]\n  - [Higher-order effects][]\n  - [Fusion][]\n-
  [Usage][]\n  - [Using built-in effects][]\n  - [Running effects][]\n  - [Required
  compiler extensions][]\n  - [Defining new effects][]\n  - [Defining effect handlers][]\n-
  [Project overview][]\n  - [Development][]\n  - [Versioning][]\n- [Benchmarks][]\n-
  [Related work][]\n  - [Comparison to `mtl`][]\n  - [Comparison to `freer-simple`][]\n\n[Overview]:
  https://github.com/robrix/fused-effects#overview\n[Algebraic effects]: https://github.com/robrix/fused-effects#algebraic-effects\n[Higher-order
  effects]: https://github.com/robrix/fused-effects#higher-order-effects\n[Fusion]:
  https://github.com/robrix/fused-effects#fusion\n\n[Usage]: https://github.com/robrix/fused-effects#usage\n[Using
  built-in effects]: https://github.com/robrix/fused-effects#using-built-in-effects\n[Running
  effects]: https://github.com/robrix/fused-effects#running-effects\n[Required compiler
  extensions]: https://github.com/robrix/fused-effects#required-compiler-extensions\n[Defining
  new effects]: https://github.com/robrix/fused-effects#defining-new-effects\n[Defining
  effect handlers]: https://github.com/robrix/fused-effects#defining-effect-handlers\n\n[Project
  overview]: https://github.com/robrix/fused-effects#project-overview\n[Development]:
  https://github.com/robrix/fused-effects#development\n[Versioning]: https://github.com/robrix/fused-effects#versioning\n\n[Benchmarks]:
  https://github.com/robrix/fused-effects#benchmarks\n\n[Related work]: https://github.com/robrix/fused-effects#related-work\n[Comparison
  to `mtl`]: https://github.com/robrix/fused-effects#comparison-to-mtl\n[Comparison
  to `freer-simple`]: https://github.com/robrix/fused-effects#comparison-to-freer-simple\n\n\n##
  Overview\n\n`fused-effects` is an effect system for Haskell emphasizing expressivity
  and efficiency. The former is achieved by encoding [algebraic](#algebraic-effects),
  [higher-order](#higher-order-effects) effects, while the latter is the result of
  [fusing](#fusion) effect handlers all the way through computations.\n\nReaders already
  familiar with effect systems may wish to start with the [usage](#usage) instead.\n\n\n###
  Algebraic effects\n\nIn `fused-effects` and other systems with _algebraic_ (or,
  sometimes, _extensible_) effects, effectful programs are split into two parts: the
  specification (or _syntax_) of the actions to be performed, and the interpretation
  (or _semantics_) given to them. Thus, a program written using the syntax of an effect
  can be given different meanings by using different effect handlers.\n\nThese roles
  are performed by the effect and carrier types, respectively. Effects are datatypes
  with one constructor for each action. Carriers are generally `newtype`s, with a
  `Carrier` instance specifying how an effect’s constructors should be interpreted.
  Each carrier handles one effect, but multiple carriers can be defined for the same
  effect, corresponding to different interpreters for the effect’s syntax.\n\n\n###
  Higher-order effects\n\nUnlike most other effect systems, `fused-effects` offers
  _higher-order_ (or _scoped_) effects in addition to first-order algebraic effects.
  In a strictly first-order algebraic effect system, operations (like `local` or `catchError`)
  which specify some action limited to a given scope must be implemented as interpreters,
  hard-coding their meaning in precisely the manner algebraic effects were designed
  to avoid. By specifying effects as higher-order functors, these operations are likewise
  able to be given a variety of interpretations. This means, for example, that you
  can introspect and redefine both the `local` and `ask` operations provided by the
  `Reader` effect, rather than solely `ask` (as is the case with certain formulations
  of algebraic effects).\n\nAs Nicolas Wu et al showed in _[Effect Handlers in Scope][]_,
  this has implications for the expressiveness of effect systems. It also has the
  benefit of making effect handling more consistent, since scoped operations are just
  syntax which can be interpreted like any other, and are thus simpler to reason about.\n\n\n###
  Fusion\n\nIn order to maximize efficiency, `fused-effects` applies _fusion laws_,
  avoiding the construction of intermediate representations of effectful computations
  between effect handlers. In fact, this is applied as far as the initial construction
  as well: there is no representation of the computation as a free monad parameterized
  by some syntax type. As such, `fused-effects` avoids the overhead associated with
  constructing and evaluating any underlying free or freer monad.\n\nInstead, computations
  are performed in a monad named `Eff`, parameterized by the carrier type for the
  syntax. This carrier is specific to the effect handler selected, but since it isn’t
  described until the handler is applied, the separation between specification and
  interpretation is maintained. Computations are written against an abstract effectful
  signature, and only specialized to some concrete carrier when their effects are
  interpreted.\n\nCarriers needn’t be `Functor`s (let alone `Monad`s), allowing a
  great deal of freedom in the interpretation of effects. And since the interpretation
  is written as a typeclass instance which `ghc` is eager to inline, performance is
  excellent: approximately on par with `mtl`.\n\nFinally, since the fusion of carrier
  algebras occurs as a result of the selection of the carriers, it doesn’t depend
  on complex `RULES` pragmas, making it very easy to reason about and tune.\n\n\n##
  Usage\n\n### Using built-in effects\n\nLike other effect systems, effects are performed
  in a `Monad` extended with operations relating to the effect. In `fused-effects`,
  this is done by means of a `Member` constraint to require the effect’s presence
  in a _signature_, and a `Carrier` constraint to relate the signature to the `Monad`.
  For example, to use a `State` effect managing a `String`, one would write:\n\n```haskell\naction
  :: (Member (State String) sig, Carrier sig m) => m ()\n```\n\n(Additional constraints
  may be necessary depending on the precise operations required, e.g. to make the
  `Monad` methods available.)\n\nMultiple effects can be required simply by adding
  their corresponding `Member` constraints to the context. For example, to add a `Reader`
  effect managing an `Int`, we would write:\n\n```haskell\naction :: (Member (State
  String) sig, Member (Reader Int) sig, Carrier sig m) => m ()\n```\n\nDifferent effects
  make different operations available; see the documentation for individual effects
  for more information about their operations. Note that we generally don't program
  against an explicit list of effect components: we take the typeclass-oriented approach,
  adding new constraints to `sig` as new capabilities become necessary. If you want
  to name and share some predefined list of effects, it's best to use the `-XConstraintKinds`
  extension to GHC, capturing the elements of `sig` as a type synonym of kind `Constraint`:\n\n```haskell\ntype
  Shared sig = ( Member (State String) sig\n                  , Member (Reader Int)
  \  sig\n                  , Member (Writer Graph) sig\n                  )\n\nmyFunction
  :: (Shared sig, Carrier sig m) => Int -> m ()\n```\n\n### Running effects\n\nEffects
  are run with _effect handlers_, specified as functions (generally starting with
  `run…`) invoking some specific `Carrier` instance. For example, we can run a `State`
  computation using `runState`:\n\n```haskell\nexample1 :: (Carrier sig m, Effect
  sig) => [a] -> m (Int, ())\nexample1 list = runState 0 $ do\n  i <- get\n  put (i
  + length list)\n```\n\n`runState` returns a tuple of both the computed value (the
  `()`) and the final state (the `Int`), visible in the result of the returned computation.\n\nSince
  this function returns a value in some carrier `m`, effect handlers can be chained
  to run multiple effects. Here, we get the list to compute the length of from a `Reader`
  effect:\n\n```haskell\nexample2 :: (Carrier sig m, Effect sig, Monad m) => m (Int,
  ())\nexample2 = runReader \"hello\" . runState 0 $ do\n  list <- ask\n  put (length
  (list :: String))\n```\n\n(Note that the type annotation on `list` is necessary
  to disambiguate the requested value, since otherwise all the typechecker knows is
  that it’s an arbitrary `Foldable`. For more information, see the [comparison to
  `mtl`](#comparison-to--mtl-).)\n\nWhen all effects have been handled, a computation’s
  final value can be extracted with `run`:\n\n```haskell\nexample3 :: (Int, ())\nexample3
  = run . runReader \"hello\" . runState 0 $ do\n  list <- ask\n  put (length (list
  :: String))\n```\n\n`run` is itself actually an effect handler for the `Void` effect,
  which has no operations and thus can only represent a final result value.\n\nAlternatively,
  arbitrary `Monad`s can be embedded into effectful computations using the `Lift`
  effect. In this case, the underlying `Monad`ic computation can be extracted using
  `runM`. Here, we use the `MonadIO` instance for `Eff` to lift `putStrLn` into the
  middle of our computation:\n\n```haskell\nexample4 :: IO (Int, ())\nexample4 = runM
  . runReader \"hello\" . runState 0 $ do\n  list <- ask\n  liftIO (putStrLn list)\n
  \ put (length list)\n```\n\n(Note that we no longer need to give a type annotation
  for `list`, since `putStrLn` constrains the type for us.)\n\n### Required compiler
  extensions\n\nTo use effects, you'll need a relatively-uncontroversial set of extensions:
  `-XFlexibleContexts`, `-XFlexibleInstances`, and `-XMultiParamTypeClasses`.\n\nWhen
  defining your own effects, you'll need `-XTypeOperators` to declare a `Carrier`
  instance over (`:+:`), and `-XUndecidableInstances` to satisfy the coverage condition
  for this instance. `-XLambdaCase` provides a measure of syntactic convenience when
  handling an effect type with `handleSum.`  You may need `-XKindSignatures` if GHC
  cannot correctly infer the type of your handler; see the [documentation on common
  errors][common] for more information about this case.\n\n[common]: https://github.com/robrix/fused-effects/blob/master/docs/common_errors.md\n\nThe
  following invocation, taken from the teletype example, should suffice for any use
  or construction of effects:\n\n```haskell\n{-# LANGUAGE DeriveFunctor, FlexibleContexts,
  FlexibleInstances, GeneralizedNewtypeDeriving,\n    KindSignatures, LambdaCase,
  MultiParamTypeClasses, TypeOperators, UndecidableInstances #-}\n```\n\n### Defining
  new effects\n\nEffects are a powerful mechanism for abstraction, and so defining
  new effects is a valuable tool for system architecture. Effects are modelled as
  (higher-order) functors, with an explicit continuation denoting the remainder of
  the computation after the effect.\n\nIt’s often helpful to start by specifying the
  types of the desired operations. For our example, we’re going to define a `Teletype`
  effect, with `read` and `write` operations, which read a string from some input
  and write a string to some output, respectively:\n\n```haskell\ndata Teletype (m
  :: * -> *) k\nread :: (Member Teletype sig, Carrier sig m) => m String\nwrite ::
  (Member Teletype sig, Carrier sig m) => String -> m ()\n```\n\nEffect types must
  have two type parameters: `m`, denoting any computations which the effect embeds,
  and `k`, denoting the remainder of the computation after the effect. Note that since
  `Teletype` doesn’t use `m`, the compiler will infer it as being of kind `*` by default.
  The explicit kind annotation on `m` corrects that.\n\nNext, we can flesh out the
  definition of the `Teletype` effect by providing constructors for each primitive
  operation:\n\n```haskell\ndata Teletype (m :: * -> *) k\n  = Read (String -> k)\n
  \ | Write String k\n  deriving (Functor)\n```\n\nThe `Read` operation returns a
  `String`, and hence its continuation is represented as a function _taking_ a `String`.
  Thus, to continue the computation, a handler will have to provide a `String`. But
  since the effect type doesn’t say anything about where that `String` should come
  from, handlers are free to read from `stdin`, use a constant value, etc.\n\nOn the
  other hand, the `Write` operation returns `()`. Since a function `() -> k` is equivalent
  to a (non-strict) `k`, we can omit the function parameter.\n\nIn addition to a `Functor`
  instance (derived here using `-XDeriveFunctor`), we need two other instances: `HFunctor`
  and `Effect`. `HFunctor`, named for “higher-order functor,” has one non-default
  operation, `hmap`, which applies a function to any embedded computations inside
  an effect. Since `Teletype` is first-order (i.e. it doesn’t have any embedded computations),
  the definition of `hmap` can be given using `coerce`:\n\n```haskell\ninstance HFunctor
  Teletype where\n  hmap _ = coerce\n```\n\n`Effect` plays a similar role to the combination
  of `Functor` (which operates on continuations) and `HFunctor` (which operates on
  embedded computations). It’s used by `Carrier` instances to service any requests
  for their effect occurring inside other computations—whether embedded or in the
  continuations. Since these may require some state to be maintained, `handle` takes
  an initial state parameter (encoded as some arbitrary functor filled with `()`),
  and its function is phrased as a _distributive law_, mapping state functors containing
  unhandled computations to handled computations producing the state functor alongside
  any results.\n\nSince `Teletype`’s operations don’t have any embedded computations,
  the `Effect` instance only has to operate on the continuations, by wrapping the
  computations in the state and applying the handler:\n\n```haskell\ninstance Effect
  Teletype where\n  handle state handler (Read    k) = Read (handler . (<$ state)
  . k)\n  handle state handler (Write s k) = Write s (handler (k <$ state))\n```\n\nNow
  that we have our effect datatype, we can give definitions for `read` and `write`:\n\n```haskell\nread
  :: (Member Teletype sig, Carrier sig m) => m String\nread = send (Read ret)\n\nwrite
  :: (Member Teletype sig, Carrier sig m) => String -> m ()\nwrite s = send (Write
  s (ret ()))\n```\n\nThis gives us enough to write computations using the `Teletype`
  effect. The next section discusses how to run `Teletype` computations.\n\n\n###
  Defining effect handlers\n\nEffects only specify actions, they don’t actually perform
  them. That task is left up to effect handlers, typically defined as functions calling
  `interpret` to apply a given `Carrier` instance.\n\nFollowing from the above section,
  we can define a carrier for the `Teletype` effect which runs the calls in an underlying
  `MonadIO` instance:\n\n```haskell\nnewtype TeletypeIOC m a = TeletypeIOC { runTeletypeIOC
  :: m a }\n\ninstance (Carrier sig m, MonadIO m) => Carrier (Teletype :+: sig) (TeletypeIOC
  m) where\n  ret = TeletypeIOC . ret\n\n  eff = TeletypeIOC . handleSum (eff . handleCoercible)
  (\\ t -> case t of\n    Read    k -> liftIO getLine      >>= runTeletypeIOC . k\n
  \   Write s k -> liftIO (putStrLn s) >>  runTeletypeIOC   k)\n```\n\nHere, `ret`
  is responsible for wrapping pure values in the carrier, and `eff` is responsible
  for handling an effectful computations. Since the `Carrier` instance handles a sum
  (`:+:`) of `Teletype` and the remaining signature, `eff` has two parts: a handler
  for `Teletype` (`alg`), and a handler for teletype effects that might be embedded
  in other effects in the signature.\n\nIn this case, since the `Teletype` carrier
  is just a thin wrapper around the underlying computation, we can use `handleCoercible`
  to handle any embedded `TeletypeIOC` carriers by simply mapping `coerce` over them.\n\nThat
  leaves `alg`, which handles `Teletype` effects with one case per constructor. Since
  we’re assuming the existence of a `MonadIO` instance for the underlying computation,
  we can use `liftIO` to inject the `getLine` and `putStrLn` actions into it, and
  then proceed with the continuations, unwrapping them in the process.\n\nUsers could
  use `interpret` directly to run the effect, but it’s more convenient to provide
  effect handler functions applying `interpret` and then unwrapping the carrier:\n\n```haskell\nrunTeletypeIO
  :: (MonadIO m, Carrier sig m) => Eff (TeletypeIOC m) a -> m a\nrunTeletypeIO = runTeletypeIOC
  . interpret\n```\n\nIn general, carriers don’t have to be `Functor`s, let alone
  `Monad`s. However, sometimes—especially in cases where the carrier is a thin wrapper
  like this—they can be more convenient to write using (derived) `Monad` instances.
  In this case, by using `-XGeneralizedNewtypeDeriving`, we can derive `Functor`,
  `Applicative`, `Monad`, and `MonadIO` instances for `TeletypeIOC`:\n\n```haskell\nnewtype
  TeletypeIOC m a = TeletypeIOC { runTeletypeIOC :: m a }\n  deriving (Applicative,
  Functor, Monad, MonadIO)\n```\n\nThis allows us to use `liftIO` directly on the
  carrier itself, instead of only in the underlying `m`; likewise with `>>=`, `>>`,
  and `pure`:\n\n```haskell\ninstance (MonadIO m, Carrier sig m) => Carrier (Teletype
  :+: sig) (TeletypeIOC m) where\n  ret = pure\n  eff = handleSum (TeletypeIOC . eff
  . handleCoercible) (\\ t -> case t of\n    Read    k -> liftIO getLine      >>=
  k\n    Write s k -> liftIO (putStrLn s) >>  k)\n```\n\n## Project overview\n\nThis
  project builds a Haskell package named `fused-effects`. The library’s sources are
  in [`src`][], with doctests (property tests written in documentation comments) attached
  to most functions. Unit tests are in [`test`][], and library usage examples are
  in [`examples`][]. Further documentation can be found in [`docs`][].\n\nThis project
  adheres to the Contributor Covenant [code of conduct][]. By participating, you are
  expected to uphold this code.\n\nFinally, this project is licensed under the BSD
  3-clause [license][].\n\n[`src`]: https://github.com/robrix/fused-effects/tree/master/src\n[`test`]:
  https://github.com/robrix/fused-effects/tree/master/test\n[`examples`]: https://github.com/robrix/fused-effects/tree/master/examples\n[`docs`]:
  https://github.com/robrix/fused-effects/tree/master/docs\n[code of conduct]: https://github.com/robrix/fused-effects/blob/master/CODE_OF_CONDUCT.md\n[license]:
  https://github.com/robrix/fused-effects/blob/master/LICENSE.md\n\n\n### Development\n\nDevelopment
  of `fused-effects` is typically done using `cabal new-build`:\n\n```shell\ncabal
  new-build # build the library\ncabal new-test  # build and run the examples, unit
  tests, and doctests\n```\n\nThe package is available on [hackage][], and can be
  used by adding it to a component’s `build-depends` field in your `.cabal` file.\n\n[hackage]:
  http://hackage.haskell.org\n\n### Versioning\n\nThough `fused-effects` is suitable
  for production work, it is currently in a pre-release state. Though we will attempt
  to comply with the Haskell [Package Versioning Policy][pvp] standard, we make no
  concrete guarantees of API stability between versions < 1.0.0.0. Once v1.0.0.0 lands,
  all changes will abide by the PVP MAJOR.MAJOR.MINOR.PATCH standard.\n\n[pvp]: https://pvp.haskell.org/faq/\n\n##
  Benchmarks\n\n`fused-effects` has been [benchmarked against a number of other effect
  systems](https://github.com/joshvera/freemonad-benchmark). See also [@patrickt’s
  benchmarks](https://github.com/patrickt/effects-benchmarks).\n\n\n## Related work\n\n`fused-effects`
  is an encoding of higher-order algebraic effects following the recipes in _[Effect
  Handlers in Scope][]_ (Nicolas Wu, Tom Schrijvers, Ralf Hinze), _[Monad Transformers
  and Modular Algebraic Effects: What Binds Them Together][]_ (Tom Schrijvers, Maciej
  Piróg, Nicolas Wu, Mauro Jaskelioff), and _[Fusion for Free—Efficient Algebraic
  Effect Handlers][]_ (Nicolas Wu, Tom Schrijvers).\n\n[Effect Handlers in Scope]:
  http://www.cs.ox.ac.uk/people/nicolas.wu/papers/Scope.pdf\n[Monad Transformers and
  Modular Algebraic Effects: What Binds Them Together]: http://www.cs.kuleuven.be/publicaties/rapporten/cw/CW699.pdf\n[Fusion
  for Free—Efficient Algebraic Effect Handlers]: https://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/mpc2015.pdf\n\n\n###
  Comparison to `mtl`\n\nLike [`mtl`][], `fused-effects` provides a library of monadic
  effects which can be given different interpretations. In `mtl` this is done by defining
  new instances of the typeclasses encoding the actions of the effect, e.g. `MonadState`.
  In `fused-effects`, this is done by defining new instances of the `Carrier` typeclass
  for the effect.\n\nAlso like `mtl`, `fused-effects` allows scoped operations like
  `local` and `catchError` to be given different interpretations. As with first-order
  operations, `mtl` achieves this with a final tagless encoding via methods, whereas
  `fused-effects` achieves this with an initial algebra encoding via `Carrier` instances.\n\nUnlike
  `mtl`, effects are automatically available regardless of where they occur in the
  signature; in `mtl` this requires instances for all valid orderings of the transformers
  (O(n²) of them, in general).\n\nAlso unlike `mtl`, there can be more than one `State`
  or `Reader` effect in a signature. This is a tradeoff: `mtl` is able to provide
  excellent type inference for effectful operations like `get`, since the functional
  dependencies can resolve the state type from the monad type. On the other hand,
  this behaviour can be recovered in `fused-effects` using `newtype` wrappers with
  phantom type parameters and helper functions, e.g.:\n\n```haskell\nnewtype Wrapper
  s m a = Wrapper { runWrapper :: Eff m a }\n  deriving (Applicative, Functor, Monad)\n\ninstance
  Carrier sig m => Carrier sig (Wrapper s m) where …\n\ngetState :: (Carrier sig m,
  Member (State s) m) => Wrapper m s\ngetState = get\n```\n\nIndeed, `Wrapper` can
  now be made an instance of `MonadState`:\n\n```haskell\ninstance (Carrier sig m,
  Member (State s) m) => MTL.MonadState s (Wrapper s m) where\n  get = get\n  put
  = put\n```\n\nThus, the approaches aren’t mutually exclusive; consumers are free
  to decide which approach makes the most sense for their situation.\n\nUnlike `fused-effects`,
  `mtl` provides a `ContT` monad transformer; however, it’s worth noting that many
  behaviours possible with delimited continuations (e.g. resumable exceptions) are
  directly encodable as effects. Further, `fused-effects` provides a relatively large
  palette of these, including resumable exceptions, tracing, resource management,
  and others, as well as tools to define your own.\n\nFinally, thanks to the fusion
  and inlining of carriers, `fused-effects` is approximately as fast as `mtl` (see
  [benchmarks](#benchmarks)).\n\n[`mtl`]: http://hackage.haskell.org/package/mtl\n\n\n###
  Comparison to `freer-simple`\n\nLike [`freer-simple`][], `fused-effects` uses an
  initial encoding of library- and user-defined effects as syntax which can then be
  given different interpretations. In `freer-simple`, this is done with a family of
  interpreter functions (which cover a variety of needs, and which can be extended
  for more bespoke needs), whereas in `fused-effects` this is done with `Carrier`
  instances for `newtype`s.\n\n(Technically, it is possible to define handlers like
  `freer-simple`’s `interpret` using `fused-effects`, but passing handlers in as higher-order
  functions defeats the fusion and inlining of `Carrier` instances which makes `fused-effects`
  so efficient.)\n\nUnlike `fused-effects`, in `freer-simple`, scoped operations like
  `catchError` and `local` are implemented as interpreters, and can therefore not
  be given new interpretations.\n\nUnlike `freer-simple`, `fused-effects` has relatively
  little attention paid to compiler error messaging, which can make common (compile-time)
  errors somewhat more confusing to diagnose. Similarly, `freer-simple`’s family of
  interpreter functions can make the job of defining new effect handlers somewhat
  easier than in `fused-effects`. Further, `freer-simple` provides many of the same
  effects as `fused-effects`, plus a coroutine effect, but minus resource management
  and random generation.\n\nFinally, `fused-effects` has been [benchmarked](#benchmarks)
  as faster than `freer-simple`.\n\n[`freer-simple`]: http://hackage.haskell.org/package/freer-simple\n"
license-name: BSD3

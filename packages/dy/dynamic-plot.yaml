homepage: https://github.com/leftaroundabout/dynamic-plot
changelog-type: ''
hash: b1c62f57c94ef440325c692418dea0196d66b67e009b362d2cbfc60b45b15fdb
test-bench-deps: {}
maintainer: (@) jsag $ hvl.no
synopsis: Interactive diagram windows
changelog: ''
basic-deps:
  diagrams-lib: '>=1.3 && <1.5'
  manifold-random: -any
  linearmap-category: '>=0.3.5'
  JuicyPixels: '>3 && <4'
  free-vector-spaces: '>=0.1 && <0.2'
  base: '>=4.5 && <6'
  time: -any
  diagrams-cairo: -any
  vector-space: '>=0.8'
  glib: -any
  process: -any
  diagrams-gtk: -any
  data-default: -any
  semigroups: -any
  colour-space: -any
  manifolds: '>=0.4.2 && <0.6'
  tagged: -any
  containers: -any
  lens: <6.0
  mtl: -any
  random-fu: -any
  MemoTrie: -any
  gtk: '>0.10 && <0.16'
  diagrams-core: -any
  colour: '>=2 && <3'
  transformers: -any
  random: -any
  deepseq: -any
  constrained-categories: '>=0.2'
  vector: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.1.1.1
- 0.1.1.2
- 0.1.2.0
- 0.1.3.0
- 0.1.4.0
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
- 0.3.0.0
- 0.4.0.0
- 0.4.1.0
author: Justus Sagem√ºller
latest: 0.4.1.0
description-type: haddock
description: |-
  Haskell excels at handling data like continuous functions
  in a nice way, i.e. without discretising anything to finite arrays as
  is typically done in languages like Matlab. Instead, you can simply pass
  around functions or infinite data structures (or /very/ high-resolution data
  that would be infeasible to handle in a strict language).

  However when you want to /view/ the data, it will eventually need to be exported out of Haskell
  in some finite form. The purpose of this library is to delay this discretisation
  as long as possible: it implements an interactive plotting window that accepts continuous/recursive
  data and only &#x201c;flattens&#x201d; it according to the specific view configuration.
  You can then zoom in to a shown diagram and it will automatically calculate
  the features more detailedly, or zoom out and discover previosly unexpected
  features. You don't need to worry about specifying the range and/or resolution beforehand:
  the program will try to find a suitable default view based on /all/ data you're displaying,
  and you can always still zoom, resize or move later.

  <http://projects.haskell.org/diagrams> are used as the &#x201c;pre-rendered&#x201d; type. This
  makes the output usable in a very wide range of applications, though at the moment only the GTK
  window view is implemented.
license-name: GPL-3.0-only

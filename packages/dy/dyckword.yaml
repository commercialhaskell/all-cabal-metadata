all-versions:
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
- 0.1.0.4
author: Johannes Hildén
basic-deps:
  base: '>=4 && <5'
  exact-combinatorics: '>=0'
  text: '>=0'
changelog: ''
changelog-type: ''
description: "# dyckword [![Build Status](https://img.shields.io/travis/johanneshilden/dyckword/master.svg?style=flat)](https://travis-ci.org/johanneshilden/dyckword)\n\n##
  Documentation\n\nSee [Hackage](http://hackage.haskell.org/package/dyckword/docs/Math-DyckWord-Binary.html).\n\n##
  Install\n\n```\ncabal install dyckword\n```\n\n## Examples\n\n```\nλ> :set -XOverloadedStrings
  \n\nλ> toText $ unrank (10^889)\n(()((()((())(()()((()()()((()((())())(()(()()()(())()()()))((()()))())(()()(())((((()())((((()()(()()(())((()(())\n((((())))))(((((((()((())()()((())))()(()((())))(((())))))()())()()()()))(()))()(())(((())))))))()(())))()))()(()\n(((()())((()())()(()())())))())))))))))(((((()((())()))((()())()(((()()()(()(()))))((())((()))))((()())())())((()\n(()()))))))())()((())((((()(()(()()()((())((((((((()(((((((((()(())()(()()()((()))))()((())(((())(()())())((()())\n((()(()))())()())(()))))))()((()((())(())())(()))))()())()()(())(()()))()))((((()())(()()()))(())))((())))))())((\n()))))))))()(())((()((((((())(())))()(()(((((()()()))())))())(((())(()((()(((((((())())((())(()))((()(()()(()(()(\n())()(()))()()(((()(((()))(())))(()))((()))()(()))((())(()()()((()()())))(()))())(()))))()()))((())()())())(()())\n)))((()()))(((()))(()))((()))))())())()(()(()))())((())))()()()()(()())()(())())(((((()))())()(()())()()(((((())(\n)))(()(()))(((()()()())()()())())())(((((()())))))()))())())))(()()))()))()()))))())()(((((((())()(()(()))))(((((\n((((((()()((()())())(())))())))()(()))((((()))()()((()()()(()(((()))((())(((((((()()((())))())(()()(((()(()))))))\n))))()()((()(()()))())(())()(())(((()((((())))((()(((())(((()())))))(((((()))()(()((()()((()())())(((())())(())()\n)(()))())((((()(()())()(())(()(((()())()(()))()(()((()(((())))(())(()())))())(())()))((((()()(()))()()((((())()((\n((((())())())(()()((()(()())))))())())())))()))()))))((())((()))()()))((()()))(((()())()()()))()())))(((())))))))\n(((((())())()(())))((()()())()((((()())((((((((()(()()))))(()(())))))(())()(()((()()))(((((()(((())(((((((()))(((\n))(()(()(()()()(((())())))()((((((((())((((()((()(((((()))(())((()))))())(()(()())))((((())(()((()()))(((((()((((\n(((())()())())(()))()))()(()(()(((((()))(()))))))()())()))))()()())())((()(())))((())(((((((()()))((()()))))(((((\n(((()())()()))()())()(())()(()()(()))))))()))))()))())((())))))((()())(()(()))()()))()(())())((()())()))()())(())\n())(()()))())(()()))(()()()())()()())((())))))()(()())(()))()()())))(((())()(()()((()()))))))())((((((()()())))()\n())())((()())(((((()()(((((())()()()((()()(((((()((()(()())))(()(())(()()(()()(()(())))))()()(()())(()()))((())))\n))(())()))((()(()())((()))((()()()()()())))))())))()))()(((((((())))))))((())))))(((()()()())()()()()(()(()))(()(\n()())()(()()(()()(((())(())))))()((()))((()))(((((()(()()(()(((()((())))(()()(()()()(()((())()((()))()))(()()))))\n)()())((((())())(())()()()()((((()))))))((()()((())((()((((()())()))()((()((())())()()(((())()(((()(((((()((()))(\n)))))(())((()())()(()(((())))((((()(((()()())((()()()())())((((()(((()))()((((()(()))(()(((()()(()))())))())()(((\n()((()((())))(())))))))(()())()))()())())()))())()))())))))(((())))))))(()))((()())((())()())((()))))))()(()))())\n)(())))))))()())())))))))(()()(((())))(())((()(()()))(()()()()))(()()((()()()())))(()(()(()()))(())))(()())((())(\n)((()((()))(()()(()(()))(())))))))()()))())))))))))(()()))))(()))))())()(()()))()))((())))))()()()(()))))()(()(()\n((()))()(()(()(()))))()))())))()\n\nλ>
  size $ unrank (10^989)\n1651\n\nλ> rank $ fromText' \"(())()(((())))\"\n480\n\nλ>
  rank $ fromText' \"ooxxoxooooxxxx\"\n480\n\nλ> fromText \"aaaa\"\nLeft \"bad input\"\n\nλ>
  fromText \"()()\" > fromText \"(())\"\nTrue\n\nλ> mapM_ print (toText <$> wordsOfSize
  5)\n\"((((()))))\"\n\"(((()())))\"\n\"(((())()))\"\n\"(((()))())\"\n\"(((())))()\"\n\"((()(())))\"\n\"((()()()))\"\n\"((()())())\"\n\"((()()))()\"\n\"((())(()))\"\n\"((())()())\"\n\"((())())()\"\n\"((()))(())\"\n\"((()))()()\"\n\"(()((())))\"\n\"(()(()()))\"\n\"(()(())())\"\n\"(()(()))()\"\n\"(()()(()))\"\n\"(()()()())\"\n\"(()()())()\"\n\"(()())(())\"\n\"(()())()()\"\n\"(())((()))\"\n\"(())(()())\"\n\"(())(())()\"\n\"(())()(())\"\n\"(())()()()\"\n\"()(((())))\"\n\"()((()()))\"\n\"()((())())\"\n\"()((()))()\"\n\"()(()(()))\"\n\"()(()()())\"\n\"()(()())()\"\n\"()(())(())\"\n\"()(())()()\"\n\"()()((()))\"\n\"()()(()())\"\n\"()()(())()\"\n\"()()()(())\"\n\"()()()()()\"\n```\n\n##
  Background\n\nIn formal language theory, the *Dyck language* consists of all strings
  of evenly balanced left and right parentheses, brackets, or some other symbols,
  together with the *empty* word. Words in this language (named after German mathematician
  Walther von Dyck) are known as *Dyck words*, some examples of which are `()()()`,
  `(())((()))`, and `((()()))()`.\n\nThe type of Dyck language considered here is
  defined over a binary alphabet. If we take this alphabet to be the set Σ = {(, )},
  then the binary Dyck language is the subset of Σ* (the Kleene closure of Σ) of all
  words that satisfy two conditions:\n\n1. The number of left brackets must be the
  same as the number of right brackets.\n2. Going from left to right, for each character
  read, the total number of right brackets visited must be less than or equal to the
  number of left brackets up to the current position.\n\nE.g., `(()(()` and `())(())()`
  are **not** Dyck words.\n\nWhen regarded as a combinatorial class &ndash; with the
  size of a word defined as the number of bracket pairs it contains &ndash; the counting
  sequence associated with the Dyck language is the *Catalan numbers*.\n\n```\nλ>
  take 15 $ (length . wordsOfSize) <$> [0..]\n[1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440]\n```\n\n"
description-type: markdown
hash: 985ef2e81486761e5bdef080e96a97db654e71bd6911021b55dbf939e5f90a70
homepage: https://github.com/laserpants/dyckword#readme
latest: 0.1.0.4
license-name: BSD-3-Clause
maintainer: hildenjohannes@gmail.com
synopsis: A library for working with binary Dyck words.
test-bench-deps:
  ansi-terminal: '>=0'
  base: '>=0'
  dyckword: '>=0'
  hspec: '>=0'
  text: '>=0'

homepage: https://github.com/seanhess/amqp-worker#readme
changelog-type: markdown
hash: e4f5774d8718959ffe10428b7b20fb582d3bdc91bf9a38aad111409877ce1f27
test-bench-deps:
  exceptions: ==0.10.*
  bytestring: ==0.11.*
  base: '>=4.9 && <5'
  amqp: '>=0.20 && <1'
  text: ==1.2.*
  monad-loops: ==0.4.*
  resource-pool: '>=0.3 && <0.5'
  data-default: ==0.7.*
  amqp-worker: -any
  mtl: ==2.2.*
  transformers-base: ==0.4.*
  aeson: '>=2.0 && <2.3'
maintainer: seanhess@gmail.com
synopsis: Type-safe AMQP workers
changelog: |
  ### Version 0.4.0

  * removed MonadBaseControl following Data.Pool, other internal Data.Pool updates
  * updated to GHC 9.2 compat
basic-deps:
  exceptions: ==0.10.*
  bytestring: ==0.11.*
  base: '>=4.9 && <5'
  amqp: '>=0.20 && <1'
  text: ==1.2.*
  monad-loops: ==0.4.*
  resource-pool: '>=0.3 && <0.5'
  data-default: ==0.7.*
  amqp-worker: -any
  mtl: ==2.2.*
  transformers-base: ==0.4.*
  aeson: '>=2.0 && <2.3'
all-versions:
- 0.2.0
- 0.2.1
- 0.2.2
- 0.2.3
- 0.2.4
- 0.2.5
- 0.3.2
- 0.4.0
author: Sean Hess
latest: 0.4.0
description-type: markdown
description: |
  AMQP Worker
  -----------

  Type-safe AMQP workers. Compatible with RabbitMQ

      {-# LANGUAGE DeriveGeneric     #-}
      {-# LANGUAGE OverloadedStrings #-}
      module Main where

      import           Control.Concurrent      (forkIO)
      import           Control.Monad.Catch     (SomeException)
      import           Data.Aeson              (FromJSON, ToJSON)
      import           Data.Function           ((&))
      import           Data.Text               (Text, pack)
      import           GHC.Generics            (Generic)
      import           Network.AMQP.Worker     (Connection, Message (..),
                                                WorkerException, def, fromURI)
      import qualified Network.AMQP.Worker     as Worker
      import           Network.AMQP.Worker.Key
      import           System.IO               (BufferMode (..), hSetBuffering,
                                                stderr, stdout)

      data TestMessage = TestMessage
        { greeting :: Text }
        deriving (Generic, Show, Eq)

      instance FromJSON TestMessage
      instance ToJSON TestMessage


      newMessages :: Key Routing TestMessage
      newMessages = key "messages" & word "new"

      results :: Key Routing Text
      results = key "results"

      anyMessages :: Key Binding TestMessage
      anyMessages = key "messages" & star



      example :: IO ()
      example = do

        -- connect
        conn <- Worker.connect (fromURI "amqp://guest:guest@localhost:5672")

        let handleAnyMessages = Worker.topic anyMessages "handleAnyMessage"

        -- initialize the queues
        Worker.bindQueue conn (Worker.direct newMessages)
        Worker.bindQueue conn (Worker.direct results)

        -- topic queue!
        Worker.bindQueue conn handleAnyMessages

        putStrLn "Enter a message"
        msg <- getLine

        -- publish a message
        putStrLn "Publishing a message"
        Worker.publish conn newMessages (TestMessage $ pack msg)

        -- create a worker, the program loops here
        _ <- forkIO $ Worker.worker conn def (Worker.direct newMessages) onError (onMessage conn)
        _ <- forkIO $ Worker.worker conn def (handleAnyMessages) onError (onMessage conn)

        putStrLn "Press any key to exit"
        _ <- getLine
        return ()




      onMessage :: Connection -> Message TestMessage -> IO ()
      onMessage conn m = do
        let testMessage = value m
        putStrLn "Got Message"
        print testMessage
        Worker.publish conn results (greeting testMessage)


      onError :: WorkerException SomeException -> IO ()
      onError e = do
        putStrLn "Do something with errors"
        print e



      main :: IO ()
      main = do
        hSetBuffering stdout LineBuffering
        hSetBuffering stderr LineBuffering
        example
license-name: BSD-3-Clause

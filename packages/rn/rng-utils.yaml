homepage: https://bitbucket.org/soostone/rng-utils
changelog-type: markdown
hash: a5a0075b05b92ea1b210064a48da03a55dc200e20c1b0ac539ef61d52d248aea
test-bench-deps:
  bytestring: -any
  base: -any
  tasty-hedgehog: -any
  criterion: -any
  hedgehog: -any
  tasty: -any
  rng-utils: -any
maintainer: ozgun.ataman@soostone.com
synopsis: RNG within an IORef for convenient concurrent use
changelog: ! '0.3.0

  * Switch to IORef instead of MVar. This should provide better performance under
  high contention.

  * Swap out internal RNG for System.Random. It turns out that the gains to be had
  by using mwc-random are outshadowed by the mutation inherent to this library, so
  it is preferable to leverage System.Random which appears to be more commonly used
  and has better coverage of types to generate.

  * Add rngRIO and rngIO convenience functions for generating values.

'
basic-deps:
  bytestring: -any
  base: ! '>=4.5 && <5'
  random: -any
all-versions:
- '0.2'
- 0.2.1
- 0.3.0
author: Ozgun Ataman, Snap Framework Authors
latest: 0.3.0
description-type: markdown
description: ! '# rng-utils


  This simple utility wraps an IORef around random for the common use

  case of initializing an RNG once and using it in various places within

  an IO context. The haddocks should otherwise be self explanatory.


  Any comments, improvement opportunities, feedback most welcome.



  ## Upgrade Notes


  In version 0.3.0, rng-utils switched from targeting `mwc-random` to

  `random`. `random` sees more use in the Haskell ecosystem, has fewer

  dependencies and the performance difference was negligible in

  comparison to the concurrency mechanism. If you feel strongly that

  `mwc-random` should be part of the library, let us know in an issue

  and we can look into supporting multiple backends.

'
license-name: BSD-3-Clause

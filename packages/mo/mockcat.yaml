all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.3.0.0
- 0.3.1.0
- 0.4.0.0
- 0.5.0.0
- 0.5.1.0
- 0.5.2.0
- 0.5.3.0
- 0.5.4.0
- 0.5.5.0
- 0.6.0.0
- 1.0.0.0
- 1.0.1.0
- 1.1.0.0
- 1.2.0.0
- 1.2.1.0
- 1.3.0.0
- 1.3.1.0
- 1.3.2.0
author: funnycat <pujoheadsoft@gmail.com>
basic-deps:
  base: '>=4.7 && <5'
  containers: '>=0.6 && <0.8'
  mtl: '>=2.2.2 && <2.4'
  stm: '>=2.5 && <2.6'
  template-haskell: '>=2.18 && <2.24'
  text: '>=2.0 && <2.2'
  transformers: '>=0.5.6 && <0.7'
  unliftio: '>=0.2.25.0 && <0.2.26'
  unliftio-core: '>=0.2.1.0 && <0.2.2'
changelog: "# Changelog for `mockcat`\n\nAll notable changes to this project will
  be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand
  this project adheres to the\n[Haskell Package Versioning Policy](https://pvp.haskell.org/).\n\n##
  [1.3.2.0] - 2026-01-04\n### Added\n- **New Derivation Macros**:\n    - `deriveMockInstances`:
  Automatically derives `MockT` instances for user-defined \"Capability\" type classes
  (e.g., `MonadLogger`). It lifts operations to the base monad.\n        - *Note*:
  Type Families are currently not supported.\n    - `deriveNoopInstance`: Generates
  \"No-op\" instances where methods (returning `m ()`) do nothing. Useful for ignoring
  specific interactions (e.g., `MonadAuditor`).\n\n### Improved\n- **Compile-Time
  Verification**: Enhanced robustness of internal verification scripts (`verify_th_errors.sh`)
  to ensure consistent error reporting across GHC versions.\n- **Documentation**:
  Clarified \"Capability vs. Control\" design philosophy and limitations regarding
  Type Families in `deriveMockInstances`.\n\n## [1.3.1.0] - 2026-01-03\n### Added\n-
  **New Parameter Matcher**: Introduced `when` and `when_` as the primary functions
  for condition-based matching.\n    - These replace `expect` and `expect_` to improve
  readability (e.g., `mock (when (>5) ~> True)` reads naturally as \"mock when > 5\").\n\n###
  Changed\n- **Renaming / Deprecation**: `expect` and `expect_` have been renamed
  to `when` and `when_`.\n    - The old `expect` and `expect_` are now **DEPRECATED**
  and will trigger a compiler warning. They will be removed in a future major release.\n-
  **Documentation**: Updated `when` / `when_` usage and added guidance on resolving
  name collisions with `Control.Monad.when`.\n## [1.3.0.0] - 2026-01-03\n### Added\n-
  **Type-Safe Verification Result**: Generated mock helpers now return `MockResult
  params`. This type carries parameter information, enabling robust type inference
  and compile-time safety checks when using declarative verification (`expects`).\n
  \   - *This change is part of an ongoing effort to make misuse of mocks impossible
  at the type level.*\n\n### Changed\n- **Breaking Change**: Due to the introduction
  of `MockResult`, generated mock helpers (e.g., `_myMethod`) no longer return the
  mock function itself (`MockT m (FunctionType)`).\n    - Code that previously relied
  on capturing the returned function (e.g., `fn <- _myMethod ...`) will need to be
  updated.\n- **Refactoring**: Reorganized internal test verification logic to utilize
  `MockResult` properties.\n- **Internal**: Refactored test suite organization for
  better maintainability.\n\n## [1.2.1.0] - 2026-01-01\n### Added\n- **Dynamic Language
  Extension Detection**: `mockcat` now automatically identifies and requests only
  necessary extensions (e.g., `MultiParamTypeClasses`, `UndecidableInstances`) based
  on the target class definition.\n- **Granular Extension Optimization**: Simple multi-parameter
  type classes no longer require `AllowAmbiguousTypes` or `FunctionalDependencies`
  unless they are actually used.\n\n### Fixed\n- Resolved `NoVerification` scope issues
  in Template Haskell generated code.\n- Resolved ambiguous `any` occurrences in internal
  Template Haskell logic.\n- Fixed several typos in Template Haskell error messages.\n\n##
  [1.2.0.0] - 2025-12-31\n### Changed\n- **Breaking Change**: Changed the fixity of
  `expects` operator to `infixl 0` to resolve precedence issues with `$`.\n    - **Impact**:
  Code using `mock $ ... expects ...` will now fail to compile.\n    - **Migration**:
  Wrap the mock definition in parentheses: `mock (... ~> ...) expects ...`.\n- **Breaking
  Change**: `expects` now strictly enforces that it can only be applied to a mock
  creation action (`m fn`).\n    - Attempting to apply `expects` directly to a `MockSpec`
  (e.g. `(any ~> 1) expects ...`) or an already instantiated function will result
  in a compile-time `TypeError`.\n- Removed redundant `Typeable` constraints from
  `expects`, enabling cleaner builds on GHC 9.8+.\n\n## [1.1.0.0] - 2025-12-29\n###
  Added\n- **HPC Coverage Support**: Verification logic now robustly handles unstable
  `StableNames` caused by HPC instrumentation (`stack test --coverage`).\n- **Optimization
  Hardening**: Protected verification logic against GHC optimizations (CSE/LICM) to
  ensure stable tests in optimized builds.\n\n### Changed\n- **Automatic History Reset**:
  `runMockT` and `withMock` now strictly scope mock history. History is automatically
  reset to prevent interference between sequential tests or Property-Based Testing
  iterations.\n\n## [1.0.0.0] - 2025-12-24\n### Changed\n- **DSL Reboot**: Replaced
  `|>` with `~>` as the primary parameter chain operator (representing the \"mock
  arrow\").\n- **Terminology Shift**: Standardized terminology to \"called\" instead
  of \"applied\" throughout the library and error messages.\n- Simplified creating/stubbing
  API: `f <- mock $ ...` is now the canonical way.\n- Expanded structural diffing
  support for nested records and lists.\n- Unified verification API: All verification
  is now handled via `shouldBeCalled`.\n- **Strict by Default**: `makeMock` and `makePartialMock`
  now default to strict return values (implicit monadic return is disabled). `makeAutoLiftMock`
  was introduced for the previous behavior.\n\n### Added\n- Deep Structural Diff:
  Enhanced error messages with precise caret pointers for complex nested data structures.\n-
  STM-based concurrency for mock registration and call recording.\n- Infinite arity
  support for mock/stub building.\n\n### Removed\n- Backward compatibility with 0.x.x
  APIs (`stubFn`, `createMock`, `applied`, etc.).\n- `makeMockWithOptions`, `makePartialMockWithOptions`,
  and `MockOptions` (internalized to simplify API).\n\n### Migration Guide (0.x ->
  1.0)\nThis release is a complete reboot. Previous code **will break**.\n\n1.  **Operator
  Change**: Replace `|>` with `~>`.\n    ```haskell\n    -- Old\n    createStubFn
  $ \"arg\" |> \"result\"\n    \n    -- New\n    stub $ \"arg\" ~> \"result\"\n    ```\n\n2.
  \ **Mock Creation**: Use `mock` / `stub` instead of `createMock` / `createStubFn`.\n
  \   ```haskell\n    -- Old\n    f <- createMock $ \"arg\" |> \"result\"\n    \n
  \   -- New\n    f <- mock $ \"arg\" ~> \"result\"\n    ```\n\n3.  **Verification**:
  Use `shouldBeCalled` (unified API).\n    ```haskell\n    -- Old\n    f `shouldApplyTo`
  \"arg\"\n    \n    -- New\n    f `shouldBeCalled` \"arg\"\n    ```\n\n4.  **Template
  Haskell Generics**:\n    `makeMock` is now strict by default (requires explicit
  `pure` for IO actions).\n    - Use `makeAutoLiftMock` for old implicit behavior.\n
  \   - Or stick to `makeMock` and add `pure` to your return values.\n\n## 0.6.0.0\n###
  Changed\n- Removed the upper limit on variable arguments when creating stub functions.
  Previously, there was a restriction on the maximum number of arguments, but this
  limitation has been removed, allowing stub functions to accept an arbitrary number
  of arguments.\n\n## 0.5.5.0\n### Added\n- Aliases `expectApplyTimes` and `expectNever`
  (preferred names) for pre-run expectation declarations.\n\n### Documentation\n-
  README (EN/JA) now recommends `expectApplyTimes` / `expectNever` over legacy `applyTimesIs`
  / `neverApply`.\n- Clarified that `expectApplyTimes n` is the canonical form; `expectNever`
  is sugar for `expectApplyTimes 0`.\n\n### Notes\n- Legacy names remain exported
  for backward compatibility (no deprecation pragma yet). They may receive a soft
  deprecation notice in a future minor release after community feedback.\n\n\n## 0.5.4.0\n###
  Added\n- Parallel execution support (verified counting under concurrency, stress
  tests).\n- Verification helpers: `applyTimesIs`, `neverApply`.\n\n### Changed\n-
  Refactored `MockT` from `StateT` to `ReaderT (TVar [Definition])` architecture.\n-
  Simplified Template Haskell generated constraints.\n\n### Fixed\n- Race causing
  lost/double count in concurrent stub applications (strict `modifyTVar'`).\n\n###
  Removed\n- `unsafePerformIO` in TH-generated code.\n\n### Internal\n- Introduced
  `MonadMockDefs` abstraction.\n\n## 0.5.3.0\n### Added\n- `MonadUnliftIO` instance
  for `MockT` (initial groundwork for later parallel support).\n"
changelog-type: markdown
description: "<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/pujoheadsoft/mockcat/main/logo.png\"
  width=\"600px\" alt=\"Mockcat Logo\">\n    <h1>Declarative mocking with a single
  arrow <code>~&gt;</code></h1>\n</div>\n\n<div align=\"center\">\n\n[![Hackage](https://img.shields.io/hackage/v/mockcat.svg)](https://hackage.haskell.org/package/mockcat)\n[![Stackage
  LTS](http://stackage.org/package/mockcat/badge/lts)](http://stackage.org/lts/package/mockcat)\n[![Build
  Status](https://github.com/pujoheadsoft/mockcat/workflows/Test/badge.svg)](https://github.com/pujoheadsoft/mockcat/actions)\n\n[\U0001F1EF\U0001F1F5
  Japanese (日本語)](README-ja.md)\n\n</div>\n\n**Mockcat** is a lightweight, declarative
  mocking library for Haskell.  \nBy using the dedicated **Mock Arrow (`~>`)** operator,
  you can describe mock behavior with the same ease as defining standard functions.\n\n```haskell\n--
  Define\nf <- mock (\"input\" ~> \"output\")\n\n-- Verify\nf `shouldBeCalled` \"input\"\n```\n\n---\n\n##
  Concepts & Terminology\n\nMockcat adopts a design where \"verification happens at
  runtime, but 'conditions to be met' can be declared at definition time.\"\n\n*   **Stub**:\n
  \   Exists solely to keep the test moving by returning values. It does not care
  \"how it was called\".\n    The `stub` function returns a completely pure function.\n\n*
  \  **Mock**:\n    In addition to stubbing, it records and verifies \"was it called
  as expected?\".\n    The `mock` function returns a value while recording calls.
  Verification can be done at the end of the test, or declared as \"it must be called
  this way\" at definition time.\n\n---\n\n## Why Mockcat?\n\nThere's no need to brace
  yourself when writing mocks in Haskell.\n\nMockcat is a mocking library that **\"allows
  you to declaratively describe function behavior and intent without depending on
  specific architectures.\"**\n\n\"I can't test unless I introduce Typeclasses (MTL).\"\n\"I
  have to define dedicated data types just for mocking.\"\n(e.g., adding extra Typeclasses
  or Service Handle records just for testing)\n\nYou are freed from such constraints.
  You can mock existing functions as they are, and start writing tests even when the
  design isn't fully solidified.\n\n**Mockcat aims to let you write tests to explore
  design, rather than forcing you to fixate the design just for testing.**\n\n###
  Before / After\n\nSee how simple writing tests in Haskell can be.\n\n| | **Before:
  Handwritten...** \U0001F62B | **After: Mockcat** \U0001F431✨ |\n| :--- | :--- |
  :--- |\n| **Definition (Stub)**<br />\"I want to return<br />this value for this
  arg\" | <pre>f :: String -> IO String<br />f arg = case arg of<br />  \"a\" -> pure
  \"b\"<br />  _   -> error \"unexpected\"</pre><br />_Even simple branching consumes
  many lines._ | <pre>-- Use stub if verification is unneeded (Pure)<br />let f =
  stub (\"a\" ~> \"b\")</pre><br />_Behaves as a completely pure function._ |\n| **Verification
  (Verify)**<br />\"I want to test<br />if it was called correctly\" | <pre>-- Need
  to implement recording logic<br />ref <- newIORef []<br />let f arg = do<br />      modifyIORef
  ref (arg:)<br />      ...<br /><br />-- Verification logic<br />calls <- readIORef
  ref<br />calls `shouldBe` [\"a\"]</pre><br />_※ This is just one example. Real-world
  setups often require even more boilerplate._ | <pre>-- Use mock if verification
  is needed (Recorded internally)<br />f <- mock (\"a\" ~> \"b\")<br /><br />-- Just
  state what you want to verify<br />f `shouldBeCalled` \"a\"</pre><br />_Recording
  is automatic.<br />Focus on the \"Why\" and \"What\", not the \"How\"._ |\n\n###
  Key Features\n\n*   **Haskell Native DSL**: No need to memorize redundant data constructors
  or specialized notation. Write mocks naturally, just like function definitions (`arg
  ~> return`).\n*   **Architecture Agnostic**: Whether using MTL (Typeclasses), Service
  Handle (Records), or pure functions—Mockcat adapts to your design choice with minimal
  friction.\n*   **Verify by \"Condition\", not just Value**: Works even if arguments
  lack `Eq` instances. You can verify based on \"what properties it should satisfy\"
  (Predicates) rather than just strict equality.\n*   **Helpful Error Messages**:
  Shows \"structural diffs\" on failure, highlighting exactly what didn't match.\n
  \   ```text\n    function was not called with the expected arguments.\n\n      Closest
  match:\n        expected: Record { name = \"Alice\", age = 20 }\n         but got:
  Record { name = \"Alice\", age = 21 }\n                                             ^^^\n
  \     Specific difference in `age`:\n        expected: 20\n         but got: 21\n
  \                 ^^\n    ```\n*   **Intent-Driven Types**: Types exist not to restrict
  you, but to naturally guide you in expressing your testing intent.\n\n\n---\n\n##
  Quick Start\n\nCopy and paste the code below to experience Mockcat right now.\n\n###
  Installation\n\n`package.yaml`:\n```yaml\ndependencies:\n  - mockcat\n```\n\nOr
  `.cabal`:\n```cabal\nbuild-depends:\n    mockcat\n```\n\n### First Test (`Main.hs`
  / `Spec.hs`)\n\n```haskell\n{-# LANGUAGE BlockArguments #-}\n{-# LANGUAGE TypeApplications
  #-}\nimport Test.Hspec\nimport Test.MockCat\n\nmain :: IO ()\nmain = hspec spec\n\nspec
  :: Spec\nspec = do\n  it \"Quick Start Demo\" do\n    -- 1. Create a mock (Return
  42 when receiving \"Hello\")\n    f <- mock (\"Hello\" ~> (42 :: Int))\n\n    --
  2. Use it as a function\n    let result = f \"Hello\"\n    result `shouldBe` 42\n\n
  \   -- 3. Verify it was called\n    f `shouldBeCalled` \"Hello\"\n```\n\n---\n\n###
  At a Glance: Matchers\n| Matcher | Description | Example |\n| :--- | :--- | :---
  |\n| **`any`** | Matches any value | `f <- mock (any ~> True)` |\n| **`when`** |
  Matches condition | `f <- mock (when (> 5) \"gt 5\" ~> True)` |\n| **`\"val\"`**
  | Matches value (Eq) | `f <- mock (\"val\" ~> True)` |\n| **`inOrder`** | Order
  verification | ``f `shouldBeCalled` inOrderWith [\"a\", \"b\"]`` |\n| **`inPartial`**|
  Partial order | ``f `shouldBeCalled` inPartialOrderWith [\"a\", \"c\"]`` |\n\n---\n\n##
  User Guide\n\nMockcat supports two verification styles depending on your testing
  needs and preferences.\n\n1.  **Post-Verification Style (Spy)**:\n    Define mock
  behavior, run the code, and verify afterwards using `shouldBeCalled`.  \n    Ideal
  for exploratory testing or simple setups. (Used mainly in Sections 1 & 2 below)\n2.
  \ **Pre-Expectation Style (Declarative/Expectation)**:\n    Describe \"how it should
  be called\" at the definition time.  \n    Ideal for strict interaction testing.
  (Explained in Section 3)\n\n### 1. Function Mocking (`mock`) - [Basic]\n\nThe most
  basic usage. Creates a function that returns values for specific arguments.\n\n```haskell\n--
  Function that returns True for \"a\" -> \"b\"\nf <- mock (\"a\" ~> \"b\" ~> True)\n```\n\n**Flexible
  Matching**:\nYou can specify conditions (predicates) instead of concrete values.\n\n```haskell\n--
  Arbitrary string (param any)\nf <- mock (any ~> True)\n\n-- Condition (when)\nf
  <- mock (when (> 5) \"> 5\" ~> True)\n```\n\n### 2. Typeclass Mocking (`makeMock`)\n\nUseful
  when you want to bring existing typeclasses directly into your tests. Generates
  mocks from existing typeclasses using Template Haskell.\n\n```haskell\n{-# LANGUAGE
  TemplateHaskell #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleInstances
  #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE
  ScopedTypeVariables #-}\n{-# LANGUAGE TypeFamilies #-}\n\nclass Monad m => FileSystem
  m where\n  readFile :: FilePath -> m String\n  writeFile :: FilePath -> String ->
  m ()\n\n-- [Strict Mode] Default behavior. Consistent with 'mock'.\n-- If the return
  type is `m a`, the stub definition must return a value of type `m a` (e.g., `pure
  @IO \"value\"`, `throwIO Error`).\n-- Recommended when you prefer explicit descriptions
  faithful to Haskell's type system.\nmakeMock [t|FileSystem|]\n\n-- [Auto-Lift Mode]
  Convenience-focused mode.\n-- Automatically wraps pure values into the monad (m
  String).\nmakeAutoLiftMock [t|FileSystem|]\n```\n\n> [!NOTE]\n> If the class definition
  requires additional extensions (e.g., `MultiParamTypeClasses`, `UndecidableInstances`),
  Mockcat will display a detailed error message during compilation to guide you.\n\nUse
  `runMockT` block in your tests.\n\n```haskell\nspec :: Spec\nspec = do\n  it \"filesystem
  test\" do\n    result <- runMockT do\n      -- [Strict Mode] (if using makeMock)\n
  \     _readFile $ \"config.txt\" ~> pure @IO \"debug=true\"\n      _writeFile $
  \"log.txt\" ~> \"start\" ~> pure @IO ()\n\n      -- [Auto-Lift Mode] (if using makeAutoLiftMock)\n
  \     -- _readFile $ \"config.txt\" ~> \"debug=true\"\n\n      -- Run code under
  test (mock injected)\n      myProgram \"config.txt\"\n    \n    result `shouldBe`
  ()\n```\n\n### 3. Declarative Verification (`withMock` / `expects`)\n\nA style where
  you describe expectations at definition time. Verification runs automatically when
  exiting the scope.\nUseful when you want \"Definition\" and \"Verification\" to
  be written close together.\n\n```haskell\nwithMock $ do\n  -- Write expectations
  (expects) at definition time\n  f <- mock (any ~> True)\n    `expects` do\n      called
  once `with` \"arg\"\n\n  -- Execution\n  f \"arg\"\n```\n\n> [!IMPORTANT]\n> When
  using `expects` (declarative verification), you MUST wrap the mock definition in
  **parentheses `(...)`**.\n> The `$` operator pattern used in previous versions (`mock
  $ ... expected ...`) will cause compilation errors due to precedence changes.\n>\n>
  ❌ `mock $ any ~> True expects ...`\n> ✅ `mock (any ~> True) expects ...`\n\n> [!NOTE]\n>
  You can also use `expects` for declarative verification inside `runMockT` blocks.\n>
  This works seamlessly with generated typeclass mocks as well.\n>\n> ```haskell\n>
  runMockT do\n>   _readFile \"config.txt\" ~> pure \"value\"\n>     `expects` called
  once\n> ```\n\n### 4. Flexible Verification (Matchers)\n\nEven if arguments don't
  have `Eq` instances, or you don't want to depend on specific values, you can verify
  based on **intent**—\"what condition should be met\".\nMockcat provides **matchers**
  to verify properties of functions, not just value equality.\n\n#### Allow Any Value
  (`any`)\n\n```haskell\n-- Return True regardless of the argument\nf <- mock (any
  ~> True)\n\n-- Verify that it was called (arguments don't matter)\nf `shouldBeCalled`
  any\n```\n\n#### Verify with Conditions (`when`)\n\nYou can verify using \"conditions
  (predicates)\" instead of arbitrary values.\nPowerfully useful for types without
  `Eq` (like functions) or when checking partial matches.\n\n```haskell\n-- Return
  False only if the argument starts with \"error\"\nf <- mock do\n  onCase $ when
  (\\s -> \"error\" `isPrefixOf` s) \"start with error\" ~> False\n  onCase $ any
  ~> True\n```\n\nIf you don't need a label (description shown on error), you can
  use `when_`.\n\n```haskell\nf <- mock (when_ (> 5) ~> True)\n```\n\n### 5. Advanced
  Features - [Advanced]\n\n#### mock vs stub vs mockM\n\nIn most cases, **`mock`**
  is all you need.\nConsider other functions only when you need finer control.\n\n|
  Function | Verification (`shouldBeCalled`) | IO Dependency | Characteristics |\n|
  :--- | :---: | :---: | :--- |\n| **`stub`** | ❌ | None | **Pure Stub**. No IO dependency.
  Sufficient if verification isn't needed. |\n| **`mock`** | ✅ | Yes (Hidden) | **Mock**.
  Behaves as a pure function, but internally manages call history via IO. |\n| **`mockM`**
  | ✅ | Yes (Explicit) | **Monadic Mock**. Used within `MockT` or `IO`, allowing explicit
  handling of side effects (e.g., logging). |\n\n#### Partial Mocking: Mixing with
  Real Functions\n\nUseful when you want to replace only some methods with mocks while
  using real implementations for others.\n\n```haskell\n-- [Strict Mode]\nmakePartialMock
  [t|FileSystem|]\n\n-- [Auto-Lift Mode]\n-- Just like makeAutoLiftMock, there is
  an Auto-Lift version for Partial Mock.\nmakeAutoLiftPartialMock [t|FileSystem|]\n\ninstance
  FileSystem IO where ... -- Real instance is also required\n\ntest = runMockT do\n
  \ _readFile $ \"test\" ~> pure @IO \"content\" -- Only mock readFile (Strict)\n
  \ -- or\n  -- _readFile $ \"test\" ~> \"content\" -- (Auto-Lift)\n\n  program --
  writeFile runs the real IO instance\n```\n\n#### Derivation and Custom Instances\n\nWhen
  using `MockT`, you might need to handle type classes that are not directly related
  to the side effects you are mocking. Mockcat provides macros to help with these
  cases.\n\n##### MTL Instances (`MonadReader`, `MonadError`, etc.)\n`MockT` provides
  standard `mtl` instances (`MonadReader`, `MonadError`, `MonadState`, `MonadWriter`)
  out of the box. These instances automatically lift operations to the base monad.\n\n#####
  Custom Type Class Derivation (`deriveMockInstances`)\nFor custom \"Capability\"
  type classes (like `MonadLogger`, `MonadConfig`) that should just be lifted to the
  base monad, use `deriveMockInstances`.\n\n```haskell\nclass Monad m => MonadLogger
  m where\n  logInfo :: String -> m ()\n\nderiveMockInstances [t|MonadLogger|]\n```\nThis
  generates an instance for `MockT m` that calls `lift . logInfo`.\n> [!NOTE]\n> `deriveMockInstances`
  currently does not support type classes with Type Families.\n\n##### Explicit No-op
  Instances (`deriveNoopInstance`)\nSometimes you want a mock to do nothing for certain
  methods (especially those returning `m ()`) without having to define explicit stubs
  or provide a base implementation.\n\n```haskell\nclass Monad m => MonadAuditor m
  where\n  audit :: String -> m ()\n\nderiveNoopInstance [t|MonadAuditor|]\n```\nThis
  generates an instance for `MockT m` where `audit` simply returns `pure ()`.\n\n\n---\n\n####
  Design Philosophy: Capability vs. Control\n\nMockcat makes a distinction between
  **Capability** and **Control** when it comes to type class derivation.\n\n*   **Capability
  (Inject/Lift)**: Type classes that provide context or tools (e.g., `MonadReader`,
  `MonadLogger`).\n    *   **Approach**: Use `deriveMockInstances` or standard `mtl`
  instances. These should be lifted to the base monad to keep the environment consistent.\n*
  \  **Control (Mock)**: Type classes that represent external side effects or business
  logic boundaries (e.g., `UserRepository`, `PaymentGateway`).\n    *   **Approach**:
  Use `makeMock`. These must be explicitly stubbed or verified to ensure the test
  isolates the logic under test.\n\n---\n\n\n#### Monadic Return (`IO a`)\n\nUsed
  when you want a function returning `IO` to have different side effects (results)
  for each call.\n\n```haskell\nf <- mock do\n  onCase $ \"get\" ~> pure @IO 1 --
  1st call\n  onCase $ \"get\" ~> pure @IO 2 -- 2nd call\n```\n\n#### Named Mocks\n\nYou
  can attach labels to display function names in error messages.\n\n```haskell\nf
  <- mock (label \"myAPI\") (\"arg\" ~> True)\n```\n\n---\n\n## Encyclopedia (Feature
  Reference)\n\n※ Use this section as a dictionary when you get stuck.\n\n### Verification
  Matchers (`shouldBeCalled`)\n\n| Matcher | Description | Example |\n| :--- | :---
  | :--- |\n| `x` (Value itself) | Was called with that value | ``f `shouldBeCalled`
  (10 :: Int)`` |\n| `times n` | Exact count | ``f `shouldBeCalled` (times 3 `with`
  \"arg\")`` |\n| `once` | Exactly once | ``f `shouldBeCalled` (once `with` \"arg\")``
  |\n| `never` | Never called | ``f `shouldBeCalled` never`` |\n| `atLeast n` | n
  or more times | ``f `shouldBeCalled` atLeast 2`` |\n| `atMost n` | n or fewer times
  | ``f `shouldBeCalled` atMost 5`` |\n| `anything` | Any argument (count ignored)
  | ``f `shouldBeCalled` anything`` |\n| `inOrderWith [...]` | Strict order | ``f
  `shouldBeCalled` inOrderWith [\"a\", \"b\"]`` |\n| `inPartialOrderWith [...]` |
  Partial order (skips allowed) | ``f `shouldBeCalled` inPartialOrderWith [\"a\",
  \"c\"]`` |\n\n### Parameter Matchers (Definition)\n\n| Matcher | Description | Example
  |\n| :--- | :--- | :--- |\n| `any` | Any value | `any ~> True` |\n| `when pred label`
  | Condition | `when (>0) \"positive\" ~> True` |\n| `when_ pred` | No label | `when_
  (>0) ~> True` |\n\n### Declarative Verification DSL (`expects`)\n\nIn `expects`
  blocks, you can describe expectations declaratively using a builder-style syntax.\nIt
  shares the same vocabulary as `shouldBeCalled`.\n\n#### Basic Usage\n\nStart with
  `called` and chain conditions.\n\n```haskell\n-- Call count only\nmock (any ~> True)
  `expects` called once\n\n-- With arguments\nmock (any ~> True) `expects` (called
  once `with` \"arg\")\n\n-- Multiple expectations (in do block)\nmock (any ~> True)
  `expects` do\n  called once `with` \"A\"\n  called once `with` \"B\"\n```\n\n####
  Syntax Reference\n\n| Builder | Description | Example |\n| :--- | :--- | :--- |\n|
  **`called`** | **[Required]** Starts the expectation builder. | `called ...` |\n|
  **`times n`** | Expects exact call count. | `called . times 2` |\n| **`once`** |
  Alias for `times 1`. | `called . once` |\n| **`never`** | Expects 0 calls. | `called
  . never` |\n| **`with arg`** | Expects specific argument(s). | `called `with` \"value\"`
  |\n| **`with matcher`** | Uses a matcher for argument verification. | `called `with`
  when (>5) \"gt 5\"` |\n| **`inOrder`** | Verify usage order (when used in a list)
  | (See \"Order Verification\" section) |\n\n### FAQ\n\n<details>\n<summary><strong>Q.
  How are unevaluated lazy values handled?</strong></summary>\nA. They are not counted.
  Mockcat records calls only \"when the result is evaluated\" (Honest Laziness). This
  prevents false positives from unneeded calculations.\n</details>\n\n<details>\n<summary><strong>Q.
  Can I use it in parallel tests?</strong></summary>\nA. Yes. Internally uses `TVar`
  to count atomically, so it records accurately even when called in parallel via `mapConcurrently`,
  etc.\n</details>\n\n<details>\n<summary><strong>Q. Can I run tests with code coverage
  (HPC)?</strong></summary>\nA. Yes (since v1.1.0.0). Mockcat natively handles the
  instability of `StableName` introduced by HPC instrumentation, so you can run `stack
  test --coverage` without issues.\n</details>\n\n<details>\n<summary><strong>Q. What
  code does `makeMock` generate?</strong></summary>\nA. It generates a `MockT m` instance
  for the specified typeclass, and stub generation function definitions named `_methodName`
  corresponding to each method.\n</details>\n\n<details>\n<summary><strong>Q. Isn't
  this strictly a Spy?</strong></summary>\nA. Yes, according to definitions like xUnit
  Patterns, Mockcat's mocks which verify after execution are classified as **Test
  Spies**.<br>\nHowever, since many modern libraries (Jest, Mockito, etc.) group these
  under \"Mock\", and to avoid confusion from terminology proliferation, this library
  unifies them under the term **\"Mock\"**.\n</details>\n\n## Tips and Troubleshooting\n\n###
  Name collision with `Prelude.any`\nThe `any` parameter matcher from `Test.MockCat`
  may conflict with `Prelude.any`.\nTo resolve this, hide `any` from Prelude or use
  a qualified name.\n\n```haskell\nimport Prelude hiding (any)\n-- or\nimport qualified
  Test.MockCat as MC\n```\n\n### Name collision with `Control.Monad.when`\n`Test.MockCat`
  exports `when` (parameter matcher), which may conflict with `Control.Monad.when`.\nTo
  avoid this, hide `when` from `Test.MockCat` or use qualified import.\n\n```haskell\nimport
  Test.MockCat hiding (when)\n-- or\nimport Control.Monad hiding (when) -- if you
  want to use the matcher\n```\n\n### Ambiguous types with `OverloadedStrings`\nIf
  you have `OverloadedStrings` enabled, string literals may cause ambiguity errors.\nAdd
  explicit type annotations to resolve this.\n\n```haskell\nmock ((\"value\" :: String)
  ~> True)\n```\n\n---\n\n## Tested Versions\nmockcat is continuously tested in CI
  across these configurations:\n\n| GHC | Cabal | OS |\n|-----|-------|----|\n| 9.2.8
  | 3.10.3.0 / 3.12.1.0 | Ubuntu, macOS, Windows |\n| 9.4.8 | 3.10.3.0 / 3.12.1.0
  | Ubuntu, macOS, Windows |\n| 9.6.3 | 3.10.3.0 / 3.12.1.0 | Ubuntu, macOS, Windows
  |\n| 9.8.2 | 3.10.3.0 / 3.12.1.0 | Ubuntu, macOS, Windows |\n| 9.10.1 | 3.10.3.0
  / 3.12.1.0 | Ubuntu, macOS, Windows |\n| 9.12.2 | 3.12.1.0 | Ubuntu, macOS, Windows
  |\n\n_Happy Mocking!_ \U0001F431"
description-type: markdown
hash: 88753253a1167f83aac2e56c08025c7e33bc008990093978b9207b49f7a995ff
homepage: https://github.com/pujoheadsoft/mockcat#readme
latest: 1.3.2.0
license-name: MIT
maintainer: funnycat <pujoheadsoft@gmail.com>
synopsis: Declarative mocking with a single arrow `~>`.
test-bench-deps:
  QuickCheck: '>=2.14 && <2.17'
  async: '>=2.2.4 && <2.3'
  base: '>=4.7 && <5'
  containers: '>=0.6 && <0.8'
  hashable: '>=1.4 && <1.6'
  hspec: '>=2.11 && <2.13'
  inspection-testing: '>=0.4 && <0.7'
  mockcat: '>=0'
  mtl: '>=2.2.2 && <2.4'
  stm: '>=2.5 && <2.6'
  template-haskell: '>=2.18 && <2.24'
  text: '>=2.0 && <2.2'
  transformers: '>=0.5.6 && <0.7'
  unliftio: '>=0.2.25.0 && <0.2.26'
  unliftio-core: '>=0.2.1.0 && <0.2.2'
  unordered-containers: '>=0.2.19 && <0.3'

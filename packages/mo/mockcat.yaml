all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.3.0.0
- 0.3.1.0
- 0.4.0.0
- 0.5.0.0
- 0.5.1.0
- 0.5.2.0
- 0.5.3.0
- 0.5.4.0
- 0.5.5.0
- 0.6.0.0
- 1.0.0.0
- 1.0.1.0
author: funnycat <pujoheadsoft@gmail.com>
basic-deps:
  base: '>=4.7 && <5'
  containers: '>=0.6 && <0.8'
  mtl: '>=2.2.2 && <2.4'
  stm: '>=2.5 && <2.6'
  template-haskell: '>=2.18 && <2.24'
  text: '>=2.0 && <2.2'
  transformers: '>=0.5.6 && <0.7'
  unliftio: '>=0.2.25.0 && <0.2.26'
  unliftio-core: '>=0.2.1.0 && <0.2.2'
changelog: "# Changelog for `mockcat`\n\nAll notable changes to this project will
  be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand
  this project adheres to the\n[Haskell Package Versioning Policy](https://pvp.haskell.org/).\n\n##
  [1.0.0.0] - 2025-12-24\n### Changed\n- **DSL Reboot**: Replaced `|>` with `~>` as
  the primary parameter chain operator (representing the \"mock arrow\").\n- **Terminology
  Shift**: Standardized terminology to \"called\" instead of \"applied\" throughout
  the library and error messages.\n- Simplified creating/stubbing API: `f <- mock
  $ ...` is now the canonical way.\n- Expanded structural diffing support for nested
  records and lists.\n- Unified verification API: All verification is now handled
  via `shouldBeCalled`.\n- **Strict by Default**: `makeMock` and `makePartialMock`
  now default to strict return values (implicit monadic return is disabled). `makeAutoLiftMock`
  was introduced for the previous behavior.\n\n### Added\n- Deep Structural Diff:
  Enhanced error messages with precise caret pointers for complex nested data structures.\n-
  STM-based concurrency for mock registration and call recording.\n- Infinite arity
  support for mock/stub building.\n\n### Removed\n- Backward compatibility with 0.x.x
  APIs (`stubFn`, `createMock`, `applied`, etc.).\n- `makeMockWithOptions`, `makePartialMockWithOptions`,
  and `MockOptions` (internalized to simplify API).\n\n### Migration Guide (0.x ->
  1.0)\nThis release is a complete reboot. Previous code **will break**.\n\n1.  **Operator
  Change**: Replace `|>` with `~>`.\n    ```haskell\n    -- Old\n    createStubFn
  $ \"arg\" |> \"result\"\n    \n    -- New\n    stub $ \"arg\" ~> \"result\"\n    ```\n\n2.
  \ **Mock Creation**: Use `mock` / `stub` instead of `createMock` / `createStubFn`.\n
  \   ```haskell\n    -- Old\n    f <- createMock $ \"arg\" |> \"result\"\n    \n
  \   -- New\n    f <- mock $ \"arg\" ~> \"result\"\n    ```\n\n3.  **Verification**:
  Use `shouldBeCalled` (unified API).\n    ```haskell\n    -- Old\n    f `shouldApplyTo`
  \"arg\"\n    \n    -- New\n    f `shouldBeCalled` \"arg\"\n    ```\n\n4.  **Template
  Haskell Generics**:\n    `makeMock` is now strict by default (requires explicit
  `pure` for IO actions).\n    - Use `makeAutoLiftMock` for old implicit behavior.\n
  \   - Or stick to `makeMock` and add `pure` to your return values.\n\n## 0.6.0.0\n###
  Changed\n- Removed the upper limit on variable arguments when creating stub functions.
  Previously, there was a restriction on the maximum number of arguments, but this
  limitation has been removed, allowing stub functions to accept an arbitrary number
  of arguments.\n\n## 0.5.5.0\n### Added\n- Aliases `expectApplyTimes` and `expectNever`
  (preferred names) for pre-run expectation declarations.\n\n### Documentation\n-
  README (EN/JA) now recommends `expectApplyTimes` / `expectNever` over legacy `applyTimesIs`
  / `neverApply`.\n- Clarified that `expectApplyTimes n` is the canonical form; `expectNever`
  is sugar for `expectApplyTimes 0`.\n\n### Notes\n- Legacy names remain exported
  for backward compatibility (no deprecation pragma yet). They may receive a soft
  deprecation notice in a future minor release after community feedback.\n\n\n## 0.5.4.0\n###
  Added\n- Parallel execution support (verified counting under concurrency, stress
  tests).\n- Verification helpers: `applyTimesIs`, `neverApply`.\n\n### Changed\n-
  Refactored `MockT` from `StateT` to `ReaderT (TVar [Definition])` architecture.\n-
  Simplified Template Haskell generated constraints.\n\n### Fixed\n- Race causing
  lost/double count in concurrent stub applications (strict `modifyTVar'`).\n\n###
  Removed\n- `unsafePerformIO` in TH-generated code.\n\n### Internal\n- Introduced
  `MonadMockDefs` abstraction.\n\n## 0.5.3.0\n### Added\n- `MonadUnliftIO` instance
  for `MockT` (initial groundwork for later parallel support).\n"
changelog-type: markdown
description: "<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/pujoheadsoft/mockcat/main/logo.png\"
  width=\"600px\" alt=\"Mockcat Logo\">\n    <h1>Declarative mocking with a single
  arrow <code>~&gt;</code></h1>\n</div>\n\n<div align=\"center\">\n\n[![Hackage](https://img.shields.io/hackage/v/mockcat.svg)](https://hackage.haskell.org/package/mockcat)\n[![Stackage
  LTS](http://stackage.org/package/mockcat/badge/lts)](http://stackage.org/lts/package/mockcat)\n[![Build
  Status](https://github.com/pujoheadsoft/mockcat/workflows/Test/badge.svg)](https://github.com/pujoheadsoft/mockcat/actions)\n\n[\U0001F1EF\U0001F1F5
  Japanese (日本語)](README-ja.md)\n\n</div>\n\n**Mockcat** is a lightweight, declarative
  mocking library for Haskell.  \nBy using the dedicated **Mock Arrow (`~>`)** operator,
  you can describe mock behavior with the same ease as defining standard functions.\n\n```haskell\n--
  Define\nf <- mock $ \"input\" ~> \"output\"\n\n-- Verify\nf `shouldBeCalled` \"input\"\n```\n\n---\n\n##
  Concepts & Terminology\n\nMockcat adopts a design where \"verification happens at
  runtime, but 'conditions to be met' can be declared at definition time.\"\n\n*   **Stub**:\n
  \   Exists solely to keep the test moving by returning values. It does not care
  \"how it was called\".\n    The `stub` function returns a completely pure function.\n\n*
  \  **Mock**:\n    In addition to stubbing, it records and verifies \"was it called
  as expected?\".\n    The `mock` function returns a value while recording calls.
  Verification can be done at the end of the test, or declared as \"it must be called
  this way\" at definition time.\n\n---\n\n## Why Mockcat?\n\nThere's no need to brace
  yourself when writing mocks in Haskell.\n\nMockcat is a mocking library that **\"allows
  you to declaratively describe function behavior and intent without depending on
  specific architectures.\"**\n\n\"I can't test unless I introduce Typeclasses (MTL).\"\n\"I
  have to define dedicated data types just for mocking.\"\n(e.g., adding extra Typeclasses
  or Service Handle records just for testing)\n\nYou are freed from such constraints.
  You can mock existing functions as they are, and start writing tests even when the
  design isn't fully solidified.\n\n**Mockcat aims to let you write tests to explore
  design, rather than forcing you to fixate the design just for testing.**\n\n###
  Before / After\n\nSee how simple writing tests in Haskell can be.\n\n| | **Before:
  Handwritten...** \U0001F62B | **After: Mockcat** \U0001F431✨ |\n| :--- | :--- |
  :--- |\n| **Definition (Stub)**<br />\"I want to return<br />this value for this
  arg\" | <pre>f :: String -> IO String<br />f arg = case arg of<br />  \"a\" -> pure
  \"b\"<br />  _   -> error \"unexpected\"</pre><br />_Even simple branching consumes
  many lines._ | <pre>-- Use stub if verification is unneeded (Pure)<br />let f =
  stub $<br />  \"a\" ~> \"b\"</pre><br />_Behaves as a completely pure function._
  |\n| **Verification (Verify)**<br />\"I want to test<br />if it was called correctly\"
  | <pre>-- Need to implement recording logic<br />ref <- newIORef []<br />let f arg
  = do<br />      modifyIORef ref (arg:)<br />      ...<br /><br />-- Verification
  logic<br />calls <- readIORef ref<br />calls `shouldBe` [\"a\"]</pre><br />_※ This
  is just one example. Real-world setups often require even more boilerplate._ | <pre>--
  Use mock if verification is needed (Recorded internally)<br />f <- mock $ \"a\"
  ~> \"b\"<br /><br />-- Just state what you want to verify<br />f `shouldBeCalled`
  \"a\"</pre><br />_Recording is automatic.<br />Focus on the \"Why\" and \"What\",
  not the \"How\"._ |\n\n### Key Features\n\n*   **Haskell Native DSL**: No need to
  memorize redundant data constructors or specialized notation. Write mocks naturally,
  just like function definitions (`arg ~> return`).\n*   **Architecture Agnostic**:
  Whether using MTL (Typeclasses), Service Handle (Records), or pure functions—Mockcat
  adapts to your design choice with minimal friction.\n*   **Verify by \"Condition\",
  not just Value**: Works even if arguments lack `Eq` instances. You can verify based
  on \"what properties it should satisfy\" (Predicates) rather than just strict equality.\n*
  \  **Helpful Error Messages**: Shows \"structural diffs\" on failure, highlighting
  exactly what didn't match.\n    ```text\n    Expected arguments were not called.\n
  \     expected: [Record { name = \"Alice\", age = 20 }]\n       but got: [Record
  { name = \"Alice\", age = 21 }]\n                                                ^^\n
  \   ```\n*   **Intent-Driven Types**: Types exist not to restrict you, but to naturally
  guide you in expressing your testing intent.\n\n\n---\n\n## Quick Start\n\nCopy
  and paste the code below to experience Mockcat right now.\n\n### Installation\n\n`package.yaml`:\n```yaml\ndependencies:\n
  \ - mockcat\n```\n\nOr `.cabal`:\n```cabal\nbuild-depends:\n    mockcat\n```\n\n###
  First Test (`Main.hs` / `Spec.hs`)\n\n```haskell\n{-# LANGUAGE BlockArguments #-}\n{-#
  LANGUAGE TypeApplications #-}\nimport Test.Hspec\nimport Test.MockCat\n\nmain ::
  IO ()\nmain = hspec spec\n\nspec :: Spec\nspec = do\n  it \"Quick Start Demo\" do\n
  \   -- 1. Create a mock (Return 42 when receiving \"Hello\")\n    f <- mock $ \"Hello\"
  ~> (42 :: Int)\n\n    -- 2. Use it as a function\n    let result = f \"Hello\"\n
  \   result `shouldBe` 42\n\n    -- 3. Verify it was called\n    f `shouldBeCalled`
  \"Hello\"\n```\n\n---\n\n### At a Glance: Matchers\n| Matcher | Description | Example
  |\n| :--- | :--- | :--- |\n| **`any`** | Matches any value | `f <- mock $ any ~>
  True` |\n| **`expect`** | Matches condition | `f <- mock $ expect (> 5) \"gt 5\"
  ~> True` |\n| **`\"val\"`** | Matches value (Eq) | `f <- mock $ \"val\" ~> True`
  |\n| **`inOrder`** | Order verification | ``f `shouldBeCalled` inOrderWith [\"a\",
  \"b\"]`` |\n| **`inPartial`**| Partial order | ``f `shouldBeCalled` inPartialOrderWith
  [\"a\", \"c\"]`` |\n\n---\n\n## User Guide\n\nMockcat supports two verification
  styles depending on your testing needs and preferences.\n\n1.  **Post-Verification
  Style (Spy)**:\n    Define mock behavior, run the code, and verify afterwards using
  `shouldBeCalled`.  \n    Ideal for exploratory testing or simple setups. (Used mainly
  in Sections 1 & 2 below)\n2.  **Pre-Expectation Style (Declarative/Expectation)**:\n
  \   Describe \"how it should be called\" at the definition time.  \n    Ideal for
  strict interaction testing. (Explained in Section 3)\n\n### 1. Function Mocking
  (`mock`) - [Basic]\n\nThe most basic usage. Creates a function that returns values
  for specific arguments.\n\n```haskell\n-- Function that returns True for \"a\" ->
  \"b\"\nf <- mock $ \"a\" ~> \"b\" ~> True\n```\n\n**Flexible Matching**:\nYou can
  specify conditions (predicates) instead of concrete values.\n\n```haskell\n-- Arbitrary
  string (param any)\nf <- mock $ any ~> True\n\n-- Condition (expect)\nf <- mock
  $ expect (> 5) \"> 5\" ~> True\n```\n\n### 2. Typeclass Mocking (`makeMock`)\n\nUseful
  when you want to bring existing typeclasses directly into your tests. Generates
  mocks from existing typeclasses using Template Haskell.\n\n```haskell\n{-# LANGUAGE
  TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE DataKinds #-}\n{-#
  LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE
  MultiParamTypeClasses #-}\n{-# LANGUAGE TypeOperators #-}\n\nclass Monad m => FileSystem
  m where\n  readFile :: FilePath -> m String\n  writeFile :: FilePath -> String ->
  m ()\n\n-- [Strict Mode] Default behavior. Consistent with 'mock'.\n-- If the return
  type is `m a`, the stub definition must return a value of type `m a` (e.g., `pure
  @IO \"value\"`, `throwIO Error`).\n-- Recommended when you prefer explicit descriptions
  faithful to Haskell's type system.\nmakeMock [t|FileSystem|]\n\n-- [Auto-Lift Mode]
  Convenience-focused mode.\n-- Automatically wraps pure values into the monad (m
  String).\nmakeAutoLiftMock [t|FileSystem|]\n```\n\nUse `runMockT` block in your
  tests.\n\n```haskell\nspec :: Spec\nspec = do\n  it \"filesystem test\" do\n    result
  <- runMockT do\n      -- [Strict Mode] (if using makeMock)\n      _readFile $ \"config.txt\"
  ~> pure @IO \"debug=true\"\n      _writeFile $ \"log.txt\" ~> \"start\" ~> pure
  @IO ()\n\n      -- [Auto-Lift Mode] (if using makeAutoLiftMock)\n      -- _readFile
  $ \"config.txt\" ~> \"debug=true\"\n\n      -- Run code under test (mock injected)\n
  \     myProgram \"config.txt\"\n    \n    result `shouldBe` ()\n```\n\n### 3. Declarative
  Verification (`withMock` / `expects`)\n\nA style where you describe expectations
  at definition time. Verification runs automatically when exiting the scope.\nUseful
  when you want \"Definition\" and \"Verification\" to be written close together.\n\n```haskell\nwithMock
  $ do\n  -- Write expectations (expects) at definition time\n  f <- mock (any ~>
  True)\n    `expects` do\n      called once `with` \"arg\"\n\n  -- Execution\n  f
  \"arg\"\n```\n\n> [!NOTE]\n> You can also use `expects` for declarative verification
  inside `runMockT` blocks.\n> This provides a unified experience where \"Mock Creation\"
  and \"Expectation Declaration\" complete within a single block.\n\n### 4. Flexible
  Verification (Matchers)\n\nEven if arguments don't have `Eq` instances, or you don't
  want to depend on specific values, you can verify based on **intent**—\"what condition
  should be met\".\nMockcat provides **matchers** to verify properties of functions,
  not just value equality.\n\n#### Allow Any Value (`any`)\n\n```haskell\n-- Return
  True regardless of the argument\nf <- mock $ any ~> True\n\n-- Verify that it was
  called (arguments don't matter)\nf `shouldBeCalled` any\n```\n\n#### Verify with
  Conditions (`expect`)\n\nYou can verify using \"conditions (predicates)\" instead
  of arbitrary values.\nPowerfully useful for types without `Eq` (like functions)
  or when checking partial matches.\n\n```haskell\n-- Return False only if the argument
  starts with \"error\"\nf <- mock $ do\n  onCase $ expect (\\s -> \"error\" `isPrefixOf`
  s) \"start with error\" ~> False\n  onCase $ any ~> True\n```\n\n### 5. Advanced
  Features - [Advanced]\n\n#### mock vs stub vs mockM\n\nIn most cases, **`mock`**
  is all you need.\nConsider other functions only when you need finer control.\n\n|
  Function | Verification (`shouldBeCalled`) | IO Dependency | Characteristics |\n|
  :--- | :---: | :---: | :--- |\n| **`stub`** | ❌ | None | **Pure Stub**. No IO dependency.
  Sufficient if verification isn't needed. |\n| **`mock`** | ✅ | Yes (Hidden) | **Mock**.
  Behaves as a pure function, but internally manages call history via IO. |\n| **`mockM`**
  | ✅ | Yes (Explicit) | **Monadic Mock**. Used within `MockT` or `IO`, allowing explicit
  handling of side effects (e.g., logging). |\n\n#### Partial Mocking: Mixing with
  Real Functions\n\nUseful when you want to replace only some methods with mocks while
  using real implementations for others.\n\n```haskell\n-- [Strict Mode]\nmakePartialMock
  [t|FileSystem|]\n\n-- [Auto-Lift Mode]\n-- Just like makeAutoLiftMock, there is
  an Auto-Lift version for Partial Mock.\nmakeAutoLiftPartialMock [t|FileSystem|]\n\ninstance
  FileSystem IO where ... -- Real instance is also required\n\ntest = runMockT do\n
  \ _readFile $ \"test\" ~> pure @IO \"content\" -- Only mock readFile (Strict)\n
  \ -- or\n  -- _readFile $ \"test\" ~> \"content\" -- (Auto-Lift)\n\n  program --
  writeFile runs the real IO instance\n```\n\n#### Monadic Return (`IO a`)\n\nUsed
  when you want a function returning `IO` to have different side effects (results)
  for each call.\n\n```haskell\nf <- mock $ do\n  onCase $ \"get\" ~> pure @IO 1 --
  1st call\n  onCase $ \"get\" ~> pure @IO 2 -- 2nd call\n```\n\n#### Named Mocks\n\nYou
  can attach labels to display function names in error messages.\n\n```haskell\nf
  <- mock (label \"myAPI\") $ \"arg\" ~> True\n```\n\n---\n\n## Encyclopedia (Feature
  Reference)\n\n※ Use this section as a dictionary when you get stuck.\n\n### Verification
  Matchers (`shouldBeCalled`)\n\n| Matcher | Description | Example |\n| :--- | :---
  | :--- |\n| `x` (Value itself) | Was called with that value | ``f `shouldBeCalled`
  (10 :: Int)`` |\n| `times n` | Exact count | ``f `shouldBeCalled` (times 3 `with`
  \"arg\")`` |\n| `once` | Exactly once | ``f `shouldBeCalled` (once `with` \"arg\")``
  |\n| `never` | Never called | ``f `shouldBeCalled` never`` |\n| `atLeast n` | n
  or more times | ``f `shouldBeCalled` atLeast 2`` |\n| `atMost n` | n or fewer times
  | ``f `shouldBeCalled` atMost 5`` |\n| `anything` | Any argument (count ignored)
  | ``f `shouldBeCalled` anything`` |\n| `inOrderWith [...]` | Strict order | ``f
  `shouldBeCalled` inOrderWith [\"a\", \"b\"]`` |\n| `inPartialOrderWith [...]` |
  Partial order (skips allowed) | ``f `shouldBeCalled` inPartialOrderWith [\"a\",
  \"c\"]`` |\n\n### Parameter Matchers (Definition)\n\n| Matcher | Description | Example
  |\n| :--- | :--- | :--- |\n| `any` | Any value | `any ~> True` |\n| `expect pred
  label` | Condition | `expect (>0) \"positive\" ~> True` |\n| `expect_ pred` | No
  label | `expect_ (>0) ~> True` |\n\n### Declarative Verification DSL (`expects`)\n\nIn
  `expects` blocks, you can describe expectations declaratively.\nThe syntax used
  in `expects` shares the same vocabulary as `shouldBeCalled`.\n\n| Syntax | Description
  |\n| :--- | :--- |\n| `called` | Start expectation |\n| `once` | Called exactly
  once |\n| `times n` | Called n times |\n| `never` | Never called |\n| `with arg`
  | Expected argument |\n| `with matcher` | Argument verification with matcher |\n\n###
  FAQ\n\n<details>\n<summary><strong>Q. How are unevaluated lazy values handled?</strong></summary>\nA.
  They are not counted. Mockcat records calls only \"when the result is evaluated\"
  (Honest Laziness). This prevents false positives from unneeded calculations.\n</details>\n\n<details>\n<summary><strong>Q.
  Can I use it in parallel tests?</strong></summary>\nA. Yes. Internally uses `TVar`
  to count atomically, so it records accurately even when called in parallel via `mapConcurrently`,
  etc.\n</details>\n\n<details>\n<summary><strong>Q. What code does `makeMock` generate?</strong></summary>\nA.
  It generates a `MockT m` instance for the specified typeclass, and stub generation
  function definitions named `_methodName` corresponding to each method.\n</details>\n\n<details>\n<summary><strong>Q.
  Isn't this strictly a Spy?</strong></summary>\nA. Yes, according to definitions
  like xUnit Patterns, Mockcat's mocks which verify after execution are classified
  as **Test Spies**.<br>\nHowever, since many modern libraries (Jest, Mockito, etc.)
  group these under \"Mock\", and to avoid confusion from terminology proliferation,
  this library unifies them under the term **\"Mock\"**.\n</details>\n\n## Tips and
  Troubleshooting\n\n### Name collision with `Prelude.any`\nThe `any` parameter matcher
  from `Test.MockCat` may conflict with `Prelude.any`.\nTo resolve this, hide `any`
  from Prelude or use a qualified name.\n\n```haskell\nimport Prelude hiding (any)\n--
  or\nimport qualified Test.MockCat as MC\n```\n\n### Ambiguous types with `OverloadedStrings`\nIf
  you have `OverloadedStrings` enabled, string literals may cause ambiguity errors.\nAdd
  explicit type annotations to resolve this.\n\n```haskell\nmock $ (\"value\" :: String)
  ~> True\n```\n\n---\n\n## Tested Versions\nmockcat is continuously tested in CI
  across these configurations:\n\n| GHC | Cabal | OS |\n|-----|-------|----|\n| 9.2.8
  | 3.10.3.0 / 3.12.1.0 | Ubuntu, macOS, Windows |\n| 9.4.8 | 3.10.3.0 / 3.12.1.0
  | Ubuntu, macOS, Windows |\n| 9.6.3 | 3.10.3.0 / 3.12.1.0 | Ubuntu, macOS, Windows
  |\n| 9.8.2 | 3.10.3.0 / 3.12.1.0 | Ubuntu, macOS, Windows |\n| 9.10.1 | 3.10.3.0
  / 3.12.1.0 | Ubuntu, macOS, Windows |\n\n_Happy Mocking!_ \U0001F431"
description-type: markdown
hash: 77499f183a2480a9fe074d935df38e281bd1f806efef5c585fdcef32ca539ed4
homepage: https://github.com/pujoheadsoft/mockcat#readme
latest: 1.0.1.0
license-name: MIT
maintainer: funnycat <pujoheadsoft@gmail.com>
synopsis: Declarative mocking with a single arrow `~>`.
test-bench-deps:
  QuickCheck: '>=2.14 && <2.17'
  async: '>=2.2.4 && <2.3'
  base: '>=4.7 && <5'
  containers: '>=0.6 && <0.8'
  hashable: '>=1.4 && <1.6'
  hspec: '>=2.11 && <2.13'
  inspection-testing: '>=0.4 && <0.7'
  mockcat: '>=0'
  mtl: '>=2.2.2 && <2.4'
  stm: '>=2.5 && <2.6'
  template-haskell: '>=2.18 && <2.24'
  text: '>=2.0 && <2.2'
  transformers: '>=0.5.6 && <0.7'
  unliftio: '>=0.2.25.0 && <0.2.26'
  unliftio-core: '>=0.2.1.0 && <0.2.2'
  unordered-containers: '>=0.2.19 && <0.3'

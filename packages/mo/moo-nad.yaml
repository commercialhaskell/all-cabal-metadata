homepage: ''
changelog-type: markdown
hash: d83952461afcf6cc2fc6998d023395290f2998f75d6e3e6c2a4e42a4d2b20c99
test-bench-deps:
  base: ^>=4.15.0.0
  example-impl: -any
  mtl: ^>=2.2
  example-logic-that-logs: -any
  tasty-hunit: ^>=0.10.0.2
  dep-t: ^>=0.4.4
  tasty: ^>=1.3.1
maintainer: diaz_carrete@yahoo.com
synopsis: Invocation helpers for the ReaderT-record-of-functions style.
changelog: |
  # Revision history for moo-nad

  ## 0.1.0.0 -- YYYY-mm-dd

  * First version. Released on an unsuspecting world.
basic-deps:
  base: ^>=4.15.0.0
  mtl: ^>=2.2
  dep-t: ^>=0.4.4
all-versions:
- 0.1.0.1
author: Daniel Diaz Carrete
latest: 0.1.0.1
description-type: haddock
description: "Using a record-of-functions as the environment of some \nreader-like
  monad is a common way of structuring Haskell \napplications, somewhat resembling
  dependency injection in OOP.\n\nWe often want our program logic to be polymorphic
  over both the\nconcrete monad and the environment. One common solution is to\nabstract
  the monad using @MonadReader@, and abstract the environment\nusing @HasX@-style
  typeclasses.\n\nOne minor annoyance though is that invoking the function in the
  \nenvironment is often a bit cumbersome: you have to ask\nthe environment for the
  function, and then lift the result of\nthe function back into the reader-like monad.\n\nThis
  library supports a special twist on @ReaderT@-record-of-functions                     \nstyle:
  instead of depending only on typeclasses for abstraction, \nwe also use a module
  signature. This comes with different tradeoffs.\n\nOne benefit is that we support
  a simpler way of invoking functions from the\nenvironment, using a helper that takes
  care of both asking the environment\nand lifting function results, and which works
  uniformly for functions of any\narity."
license-name: BSD-3-Clause

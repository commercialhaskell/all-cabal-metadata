all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
- 0.2.3.0
author: Eiko
basic-deps:
  async: <2.4
  base: '>=4 && <5'
  data-default: '>=0.8.0 && <0.9'
  deepseq: <1.6
  exceptions: <0.11
  haskell-src-meta: '>=0.8 && <0.9'
  monad-control: '>=1.0.3 && <1.1'
  mtl: <2.4
  parsec: '>=3 && <4'
  resourcet: '>=1.3.0 && <1.4'
  stm: <2.6
  template-haskell: <2.24
  text: <2.2
  transformers-base: '>=0.4.6 && <0.5'
changelog: |
  # Revision history for monad-effect

  ## 0.1.0.0 -- 2025-09-20

  * First release of monad-effect

  ## 0.2.0.0 -- 2025-10-17

  * Refactored `Control.System` to use bracket pattern by default, users of `Control.Monad.Effect` are not affected. Adding many new combinators.

  ## 0.2.1.0 -- 2025-11-05

  * Exporting `lift`

  ## 0.2.2.0 -- 2025-12-02

  * Adding `ResultT` synonym, `MonadExcept` class

  * Adding `ReaderT` and `StateT` helpers

  * Adding `withAsyncEffT'` helper, generalized certain type signatures

  * Adding Exception instances and `tryAndThrow` IO utilities

  ## 0.2.3.0 -- 2025-12-13

  * Fix bogus instance logic of NonEmptySubList, used in effThrowEListIn adding liftExceptT helpers

  * Adding certain warnings and rename declareNoError to unsafeDeclareNoError

  * Adding type-apply helpers like `applyMods`, `applyErrors`, etc.

  * refine README.md
changelog-type: markdown
description: "# monad-effect - a lightweight, fast, algebraic effect system\n\nThis
  project is still in experimental beta and may evolve quickly. Feedback and contributions
  are very welcome.\n\n`monad-effect` gives you:\n\n- a single, optimisation-friendly
  monad transformer `EffT` that combines **Reader, State and algebraic errors**;\n-
  **modules** as the unit of effect (e.g. reader, state, logging, database, HTTP,
  metrics);\n- **explicit, composable error lists** instead of using `Text` / `SomeException`
  ; and\n- performant effect stacks, without sacrificing purity.\n\nMost users will
  work with the `Eff` / `EffT` type aliases and the built-in reader/state modules
  (`RModule`, `SModule`) and define their own modules around them.\n\n---\n\n- [Project
  Intuition](#project-intuition)\n- [Key Features](#key-features)\n  - [Algebraic
  exceptions](#algebraic-exceptions)\n  - [Purity](#purity)\n  - [Flexible and modular](#flexible-and-modular)\n-
  [Core Types and Abstractions](#core-types-and-abstractions)\n  - [EffT, Eff and
  EffT'](#efft-eff-and-efft)\n  - [Result and EList - algebraic error lists](#result-and-elist---algebraic-error-lists)\n
  \ - [Named error types - ErrorText, ErrorValue, MonadExcept](#named-error-types---errortext-errorvalue-monadexcept)\n
  \ - [Modules and the system view](#modules-and-the-system-view)\n  - [Built-in Reader
  and State modules - RModule and SModule](#built-in-reader-and-state-modules---rmodule-and-smodule)\n
  \ - [RS.Class - `MonadReadOnly`, `MonadReadable`, `MonadStateful`](#rsclass---monadreadonly-monadreadable-monadstateful)\n-
  [Getting Started - Examples](#getting-started---examples)\n  - [Quick start - algebraic
  state and errors](#quick-start---algebraic-state-and-errors)\n  - [Embedding and
  reshaping effects](#embedding-and-reshaping-effects)\n  - [Scoped module initialisation](#scoped-module-initialisation)\n
  \ - [Large application - a bot with many modules](#large-application---a-bot-with-many-modules)\n
  \ - [Example - database access](#example---database-access)\n- [Selected API Reference](#selected-api-reference)\n
  \ - [Core monad and runners](#core-monad-and-runners)\n  - [Error machinery](#error-machinery)\n\n##
  Project Intuition\n\nAt a high level you can think of:\n\n```haskell\nnewtype EffT
  mods es m a =\n  EffT { unEffT :: SystemRead mods -> SystemState mods -> m (Result
  es a, SystemState mods) }\n```\n\nas:\n\n- **one layer of `Reader`** over a *heterogeneous*
  environment `SystemRead mods`,\n- **one layer of `State`** over a *heterogeneous*
  state `SystemState mods`, and\n- a **typed, algebraic error channel** `Result es
  a`, where `es :: [Type]` is a *type-level list* of error types.\n\nYou explicitly
  say:\n\n- which **modules** (`mods`) your effect depends on (configuration, mutable
  state, handles, etc.);\n- which **errors** (`es`) it can throw (e.g. `IOException`,
  `ErrorText \"http\"`, `MyDomainError`); and\n- you get back both a **result** and
  the **final module state**.\n\nTypical use-cases:\n\n- replace one or more layers
  of `ReaderT`, `StateT`, `ExceptT` or even more equivalent ones, by a single `EffT`
  with a small list of modules and error types;\n- easily **add or remove error types**
  (`effCatch`, `effCatchIn`, `errorToEitherAll`, ... );\n- run the same effect in
  **pure monads** (e.g. `Identity`) and in `IO`; and\n- pass around **large module
  stacks** in real applications while keeping the types informative and composable.\n\n---\n\n##
  Key Features\n\n### Algebraic exceptions\n\nIn classic Haskell (and in other languages
  like Rust), exceptions are often encoded algebraically as `Maybe` or `Either`:\n\n-
  `Maybe a` is composable but not very informative - you lose any structured information
  about *why* something failed.\n- `Either e a` carries an error payload, but composing
  multiple distinct `Either e_i a` values across a codebase tends to either:\n  -
  collapse everything to a common super-type like `Text`/`SomeException` (and then
  you lose the ability to catch specific errors in a principled way, and loses the
  ability to declare that some of them won't happen); or\n  - nest `Either e0 (Either
  e1 (Either e2 a))`, which is unergonomic.\n- `ExceptT e m a` has the same compositional
  issues, *and* the transformer order matters:\n  - `StateT s (ExceptT e m) a ~ s
  -> m (Either e (a, s))` - once an exception is thrown, both `a` and the intermediate
  state are lost / rolled-back.\n  - `ExceptT e (StateT s m) a ~ s -> m (Either e
  a, s)` - the state up to the exception point is preserved, which is often what you
  actually want.\n\n`monad-effect` addresses these issues by:\n\n- using a **type-level
  list of error types** `es :: [Type]` and a non-empty sum `EList es` to track exactly
  which error types can occur; and\n- using `Result es a` as the algebraic error carrier
  (see the formal definition below), which behaves like `Either (EList es) a` and
  collapses to `a` when `es ~ '[]`.\n\nThe underlying representation\n\n```haskell\nSystemRead
  mods\n-> SystemState mods\n-> m (Result es a, SystemState mods)\n```\n\nmeans that
  module state is preserved when an algebraic exception is thrown (like `ExceptT e
  (StateT s m) a`), rather than discarded.\n\nYou can throw algebraic errors into
  the list (`effThrowIn` / `effThrow`), catch all errors (`effCatchAll`), or catch
  and *remove* a specific error type (`effCatchIn`) so that the remaining computation
  provably no longer produces that error.\n\n### Purity\n\nInstead of reaching for
  `IORef` / `TVar` for every bit of mutable state, you can also choose to keep states
  *pure* and model them as part of your self-defined modules. It's a design choice
  you can make : some effect systems force you into `IO`. While for concurrency programs
  you need `TVar`s, but we should have the ability to choose pure state where appropriate
  because we love purity.\n\nIn particular the library provides two built-in modules:\n\n-
  `SModule s` - a module holding a pure state of type `s`;\n- `RModule r` - a module
  holding a read-only value of type `r`.\n\nThese integrate with the `MonadStateful`
  / `MonadReadable` classes and provide the familiar `getS` / `putS` / `modifyS` /
  `askR` / `localR` APIs, while still participating in the larger module stack.\n\nUsing
  modules, you can:\n\n- keep configuration, pure in-memory state, handles, and effect
  interpreters in a single typed module stack; and\n- run the same code in `Identity`
  for pure tests, or in `IO` for production, by choosing appropriate runners.\n- Use
  it to run stateful tight computations without `IO` overhead (which GHC can optimize
  very well).\n\nTemplate Haskell helpers in `Module.RS.QQ` (`makeRModule`, `makeRSModule`)
  make it easy to generate simple reader/state modules with minimal boilerplate. However,
  right now you are expected to write a lot of modules by hand as they are much more
  flexible.\n\nBesides tight calculation that benefits from pure states, here is another
  example function that benefits from pure state: the function can be ran as a pure
  function with pure logging effect (writer / no-logging), or in IO whose logging
  prints to console/file.\n\n```haskell\neventHandler\n  :: (Monad pureMonad)\n  =>
  InputEvent\n  -> EffT\n      '[ Logging pureMonad LogData -- ^ We will use logging
  to generate diagnostics\n      , EventState                -- ^ We need to read
  and update the state\n      ]\n      '[ ErrorText \"not-allowed\"\n      ]\n      pureMonad\n
  \     [OutputCommands]      -- ^ Output commands from the event module\n```\n\n###
  Flexible and modular\n\nBecause both modules and errors are tracked at the type
  level:\n\n- `EffT '[] '[] m a` is isomorphic to `m a`;\n- `EffT '[] '[e] m a` is
  isomorphic to `m (Either e a)`;\n- `EffT '[] es  m a` is isomorphic to `m (Result
  es a)`.\n\nYou can:\n\n- **eliminate modules** once you have their inputs, using
  e.g.:\n\n  ```haskell\n  runEffTOuter\n    :: (ConsFDataList c (mod : mods), ConsFData1
  c mods, Monad m)\n    => ModuleRead mod\n    -> ModuleState mod\n    -> EffT' c
  (mod : mods) es m a\n    -> EffT' c mods es m (a, ModuleState mod)\n\n  runEffTOuter_\n
  \   :: ...\n    => ModuleRead mod -> ModuleState mod\n    -> EffT' c (mod : mods)
  es m a\n    -> EffT' c mods es m a\n  ```\n\n  and similarly `runEffTIn`/`runEffTIn_`
  to drop an inner module.\n\n- **embed smaller effects inside larger ones**, changing
  only modules (`embedMods`), only errors (`embedError`), or both (`embedEffT`).\n-
  move fluidly between `EffT` and more conventional forms via runners and converters
  like `runEffT00`, `runEffT01`, `errorToEither`, `errorToEitherAll`, `errorToMaybe`,
  and the `effEither*` / `effMaybe*` family of helpers.\n\nThe result is a small set
  of primitives that scale well to large applications with many modules such as database
  access, HTTP clients, metrics, logging, and domain-specific state.\n\n### Performant\n\nThe
  core transformer `EffT'` is one single layer and the `FData` data family is designed
  to be optimisation-friendly. The fact that we did not use complicated data structure
  nor `IO` for storing data means GHC can optimize, inline the data constructors,
  utilizing purity.\n\nThis gives blazingly fast performance, benchmarks (countdown,
  local state, deep catch) shows `monad-effect` is top-1 in most of the benchmarks,
  top-2 in some other ones. (See the last section for some benchmark pictures).\n\nIt
  is completely feasible to use `monad-effect` for pure single-threaded stateful tight
  loops with little or no extra overhead.\n\n## Core Types and Abstractions\n\nThis
  section spells out the main types and how they fit together. All snippets in this
  section are taken directly from the library, except where explicitly marked as simplified.\n\n###
  EffT, Eff and EffT'\n\nThe real core transformer is `EffT'`; `Eff` and `EffT` are
  its specialised aliases using the optimised `FData` container.\n\n```haskell\n--
  | EffTectful computation, using modules as units of effect.\n-- The tick indicates
  the polymorphic type 'c', the data structure\n-- used to store the modules (usually
  'FData' or 'FList').\nnewtype EffT' (c    :: (Type -> Type) -> [Type] -> Type)\n
  \             (mods :: [Type])\n              (es   :: [Type])\n              (m
  \   :: Type -> Type) a\n  = EffT'\n      { unEffT' :: SystemRead  c mods\n                ->
  SystemState c mods\n                -> m (Result es a, SystemState c mods)\n      }\n\n--
  Recommended, specialised aliases (use these in normal code):\ntype Eff   mods es
  \ = EffT' FData mods es IO\ntype EffT  mods es  = EffT' FData mods es\ntype Pure
  \ mods es  = EffT' FData mods es Identity\ntype In    mods es  = In'   FData mods
  es\n\n-- Error-enhanced IO and ExceptT-like transformer\ntype ResultT  es m  = EffT'
  FData '[] es m\ntype IO'      es    = EffT' FData '[] es IO\n```\n\nIntuitively:\n\n-
  `mods :: [Type]` - type-level list of **modules** (effects);\n- `es   :: [Type]`
  - type-level list of **error types** that this computation may throw;\n- `m` - the
  **base monad**; and\n- `c` - the container type (`FData` by default) used to hold
  the module environments and states.\n\nThe library provides runners such as:\n\n```haskell\nrunEffT\n
  \ :: Monad m\n  => SystemRead  c mods\n  -> SystemState c mods\n  -> EffT' c mods
  es m a\n  -> m (Result es a, SystemState c mods)\n\n-- No modules\nrunEffT0\n  ::
  (Monad m, ConsFNil c)\n  => EffT' c '[] es m a\n  -> m (Result es a)\n\n-- No modules,
  no errors\ntype NoError = '[]\n\nrunEffT00\n  :: (Monad m, ConsFNil c)\n  => EffT'
  c '[] NoError m a\n  -> m a\n\n-- No modules, single error, exposed as Either\nrunEffT01\n
  \ :: (Monad m, ConsFNil c)\n  => EffT' c '[] '[e] m a\n  -> m (Either e a)\n```\n\nThere
  are much more runners and combinators, see actual haddock documentation.\n\n`EffT`
  and `Eff` can therefore be specialised to behave like a more flexible `ExceptT`:\n\n```haskell\n--
  A flexible replacement for 'ExceptT es m'\ntype ResultT es m = EffT '[] es m\n```\n\n###
  Result and EList - algebraic error lists\n\nErrors are represented by the `Result`
  and `EList` types:\n\n```haskell\n-- | Sum of types, non-empty by construction.\ndata
  EList (ts :: [Type]) where\n  EHead :: !t          -> EList (t : ts)\n  ETail ::
  !(EList ts) -> EList (t : ts)\n\n-- | Error-aware result.\ndata Result (es :: [Type])
  (a :: Type) where\n  RSuccess :: a         -> Result es a\n  RFailure :: !(EList
  es) -> Result es a\n\nresultNoError :: Result '[] a -> a\nresultNoError (RSuccess
  a) = a\n```\n\nImportant facts:\n\n- `Result es a` behaves like `Either (EList es)
  a`.  \n- When `es ~ '[]`, `Result '[] a` is *effectively just `a`* (`resultNoError`
  witnesses this).\n- `EList es` is a **non-empty** sum type: you cannot construct
  an `EList '[]`, so a `RFailure` always carries *one of the listed error types*.\n\n###
  Named error types - ErrorText, ErrorValue, MonadExcept\n\nTo avoid defining a new
  ADT for every small error case, the library provides ad-hoc, named error wrappers:\n\n```haskell\n--
  | A named textual error.\nnewtype ErrorText (s :: k) = ErrorText Text\n  deriving
  newtype (IsString)\n\n-- | Use type application 'errorText @\"http\" \"text\"'\nerrorText
  :: forall s. Text -> ErrorText s\nerrorText = ErrorText\n\n-- | A named error that
  wraps an arbitrary value.\nnewtype ErrorValue (a :: k) (v :: Type) = ErrorValue
  v\n\n-- | Type application helper\nerrorValue :: forall s v. v -> ErrorValue s v\nerrorValue
  = ErrorValue\n\n-- | MonadExcept without a functional dependency,\n-- so a monad
  can throw multiple error types.\nclass Monad m => MonadExcept e m where\n  throwExcept
  :: e -> m a\n```\n\nSome useful instances:\n\n- `instance Exception e => MonadExcept
  e IO`\n- `instance MonadExcept e (Either e)`\n- `instance Monad m => MonadExcept
  e (ExceptT e m)`\n- `instance KnownSymbol s => MonadExcept (ErrorText s) (Either
  (Text, Text))`\n\nThis makes it very convenient to use `ErrorText \"http\"`, `ErrorText
  \"decode\"` etc. in larger codebases.\n\n### Modules and the system view\n\nModules
  are the **unit of effect**. A module describes:\n\n- what read-only data it exposes
  (`ModuleRead`); and\n- what mutable state it keeps (`ModuleState`).\n\n```haskell\nclass
  Module mod where\n  data ModuleRead  mod :: Type\n  data ModuleState mod :: Type\n\n--
  Modules that may be part of a \"system\"\nclass Module mod => SystemModule mod where\n
  \ data ModuleEvent    mod :: Type\n  data ModuleInitData mod :: Type\n\n-- System-wide
  containers (usually backed by 'FData')\ntype SystemRead     c mods = c ModuleRead
  \ mods\ntype SystemState    c mods = c ModuleState mods\ntype SystemEvent      mods
  = UList ModuleEvent    mods\ntype SystemInitData c mods = c ModuleInitData     mods\n```\n\nWithin
  `EffT'` you can access the data families, module reads and states using the provided
  helpers:\n\n```haskell\n-- | Synonyms\nqueryModule  :: (Monad m, In' c mod mods,
  Module mod)\n             => EffT' c mods es m (ModuleRead  mod)\naskModule    ::
  (Monad m, In' c mod mods, Module mod)\n             => EffT' c mods es m (ModuleRead
  \ mod)\n\nqueriesModule, asksModule\n  :: (Monad m, In' c mod mods, Module mod)\n
  \ => (ModuleRead mod -> a)\n  -> EffT' c mods es m a\n\ngetModule    :: (Monad m,
  In' c mod mods, Module mod)\n             => EffT' c mods es m (ModuleState mod)\ngetsModule
  \  :: (Monad m, In' c mod mods, Module mod)\n             => (ModuleState mod ->
  a) -> EffT' c mods es m a\n\nputModule    :: (Monad m, In' c mod mods, Module mod)\n
  \            => ModuleState mod -> EffT' c mods es m ()\nmodifyModule :: (Monad
  m, In' c mod mods, Module mod)\n             => (ModuleState mod -> ModuleState
  mod)\n             -> EffT' c mods es m ()\n```\n\nThe `SystemModule`/`ModuleEvent`/`ModuleInitData`
  pieces are primarily used by higher-level orchestration helpers (e.g. scoped initialisation
  via `withModule`).\n\n### Built-in Reader and State modules - RModule and SModule\n\nThe
  `Module.RS` module gives you ready-made reader/state modules and helpers to integrate
  existing `ReaderT`/`StateT` code.\n\n```haskell\n-- Reader module\ndata RModule
  (r :: Type)\n\ninstance Module (RModule r) where\n  newtype ModuleRead  (RModule
  r) = RRead  { rRead  :: r }\n  data    ModuleState (RModule r) = RState deriving
  (Generic, NFData)\n\n-- State module\ndata SModule (s :: Type)\n\ninstance Module
  (SModule s) where\n  data    ModuleRead  (SModule s) = SRead\n  newtype ModuleState
  (SModule s) = SState { sState :: s }\n    deriving newtype (Generic, NFData)\n```\n\nConvenience
  helpers:\n\n```haskell\n-- Reader-like interface\naskR   :: (Monad m, In' c (RModule
  r) mods) => EffT' c mods errs m r\nasksR  :: (Monad m, In' c (RModule r) mods) =>
  (r -> a) -> EffT' c mods errs m a\nlocalR :: (Monad m, In' c (RModule r) mods)\n
  \      => (r -> r) -> EffT' c mods errs m a -> EffT' c mods errs m a\n\n-- State-like
  interface\ngetS   :: (Monad m, In' c (SModule s) mods) => EffT' c mods errs m s\ngetsS
  \ :: (Monad m, In' c (SModule s) mods) => (s -> a) -> EffT' c mods errs m a\nputS
  \  :: (Monad m, In' c (SModule s) mods) => s -> EffT' c mods errs m ()\nmodifyS::
  (Monad m, In' c (SModule s) mods) => (s -> s) -> EffT' c mods errs m ()\n```\n\nYou
  also get helpers to run and embed modules:\n\n```haskell\nrunRModule   :: (ConsFDataList
  c (RModule r : mods), Monad m)\n             => r -> EffT' c (RModule r : mods)
  errs m a\n             -> EffT' c mods errs m a\n\nrunSModule   :: (ConsFDataList
  c (SModule s : mods), Monad m)\n             => s -> EffT' c (SModule s : mods)
  errs m a\n             -> EffT' c mods errs m (a, s)\n\nrunSModule_  :: (ConsFDataList
  c (SModule s : mods), Monad m)\n             => s -> EffT' c (SModule s : mods)
  errs m a\n             -> EffT' c mods errs m a\n```\n\nIntegrating with `ReaderT`/`StateT`
  (more in `Module.RS`):\n\n```haskell\nliftReaderT :: forall r mods errs m c a. (Monad
  m, In' c (RModule r) mods)\n            => ReaderT r m a\n            -> EffT' c
  mods errs m a\n\nembedReaderT :: forall r mods errs m c a. (Monad m, In' c (RModule
  r) mods)\n             => ReaderT r (EffT' c mods errs m) a\n             -> EffT'
  c mods errs m a\n```\n\n### RS.Class - `MonadReadOnly`, `MonadReadable`, `MonadStateful`\n\n`Control.Monad.RS.Class`
  defines type-class interfaces similar to `MonadReader`/`MonadState`, but *without*
  functional dependencies, so a single monad can have many readable and stateful values:\n\n```haskell\nclass
  Monad m => MonadReadOnly r m where\n  query   :: m r\n  queries :: (r -> r') ->
  m r'\n\nclass MonadReadOnly r m => MonadReadable r m where\n  local :: (r -> r)
  -> m a -> m a\n\nclass Monad m => MonadStateful s m where\n  get    :: m s\n  put
  \   :: s -> m ()\n  gets   :: (s -> a) -> m a\n  modify :: (s -> s) -> m ()\n```\n\nInstances
  are provided for `EffT'` and for monad transformers.\n\n---\n\n## Getting Started
  - Examples\n\nThis section focuses on how to *use* the core abstractions.\n\n###
  Quick start - algebraic state and errors\n\nA small (made-up) example that:\n\n-
  stores a `Map` as a state module,\n- throws a named `ErrorText \"Map.keyNotFound\"`
  when a key is missing,\n- and computes an average from a file.\n\n```haskell\n{-#
  LANGUAGE DataKinds #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE OverloadedStrings
  #-}\n\nmodule Examples where\n\nimport Control.Exception (IOException)\nimport Control.Monad\nimport
  Control.Monad.Effect        -- EffT types and combinators\nimport Module.RS                   --
  RModule / SModule helpers\nimport System.IO\nimport qualified Data.Map  as M\nimport
  qualified Data.Text as T\n\n-- | Wrap a lookup into an algebraic error instead of
  'Maybe'.\nmyLookup\n  :: (Show k, Ord k, Monad m)\n  => k\n  -> EffT '[SModule (M.Map
  k v)] '[ErrorText \"Map.keyNotFound\"] m v\nmyLookup k =\n  effMaybeInWith -- this
  converts a (Maybe v) return value into an algebraic error\n    (errorText @\"Map.keyNotFound\"
  $\n       \" where key = \" <> T.pack (show k)) -- using this converter function\n
  \   (getsS (M.lookup k))   -- :: EffT '[SModule (M.Map k v)] es m (Maybe v)\n\n--
  | This effect can run in pure monads like 'Identity' as well as 'IO'.\nlookups\n
  \ :: forall v m. Monad m\n  => EffT '[SModule (M.Map T.Text v)] '[ErrorText \"Map.keyNotFound\"]
  m (v, v, v)\nlookups = do\n  foo <- myLookup \"foo\"\n  bar <- myLookup \"bar\"\n
  \ baz <- myLookup \"baz\"\n  pure (foo, bar, baz)\n\nparse :: String -> Maybe [Double]\nparse
  = undefined  -- parsing logic\n\ncomputeAverageFromFile\n  :: FilePath\n  -> Eff\n
  \      '[SModule (M.Map T.Text Int)]\n       [ IOException\n       , ErrorText \"empty-file\"\n
  \      , ErrorText \"zero-numbers\"\n       , ErrorText \"Map.keyNotFound\"\n       ]\n
  \      Double\ncomputeAverageFromFile fp = do\n  -- Capture 'IOException' from 'readFile'
  as an algebraic error.\n  content <- embedError . liftIOException $ readFile' fp\n\n
  \ when (null content) $\n    effThrowIn (errorText @\"empty-file\" \"file is empty\")\n\n
  \ -- Turn a 'Maybe' into an ad-hoc algebraic error and immediately handle it.\n
  \ parsed <- pureMaybeInWith (errorText @\"parse-error\" \"parse error\") (parse
  content)\n              `effCatch` \\(_ :: ErrorText \"parse-error\") ->\n                pure
  [0]\n\n  -- Use another effect that requires the same module.\n  _ <- embedEffT
  (lookups @Int)\n\n  when (null parsed) $\n    effThrowIn (errorText @\"zero-numbers\"
  \"zero numbers\")\n\n  pure $ sum parsed / fromIntegral (length parsed)\n```\n\nYou
  can run such effects in various ways. For example, using the state module runner
  from `Module.RS` and `runEffT01`:\n\n```haskell\nimport Control.Monad.Effect\nimport
  Module.RS\nimport qualified Data.Map as M\n\nrunCounter\n  :: Int\n  -> Eff '[SModule
  Int] '[ErrorText \"zero\"] IO ()\n  -> IO (Either (ErrorText \"zero\") ((), Int))\nrunCounter
  initial action =\n  runEffT01 (runSModule initial action)\n```\n\nHere:\n\n- `runSModule`
  eliminates the `SModule` from the module list while threading the state, and\n-
  `runEffT01` eliminates the remaining error list as an `Either`.\n\n### Embedding
  and reshaping effects\n\nSometimes you want to run a smaller effect inside a bigger
  one; or change modules while keeping the error list, or vice versa. The library
  provides:\n\n```haskell\n-- Embed a smaller effect into a larger one (modules and/or
  errors).\nembedEffT\n  :: (SubList c mods mods', SubListEmbed es es', Monad m)\n
  \ => EffT' c mods es  m a\n  -> EffT' c mods' es' m a\n\n-- Only change the module
  list.\nembedMods\n  :: (Monad m, ConsFDataList c mods', SubListEmbed es es, SubList
  c mods mods')\n  => EffT' c mods es m a\n  -> EffT' c mods' es m a\n\n-- Only change
  the error list.\nembedError\n  :: (Monad m, SubList c mods mods, SubListEmbed es
  es')\n  => EffT' c mods es m a\n  -> EffT' c mods es' m a\n```\n\nThis is very useful
  when you have a reusable component that only needs a subset of modules.\n\n### Scoped
  module initialisation\n\nFor scoped initialisation and teardown, many projects define
  higher-level wrappers around the `Loadable`/`withModule` pattern. A (simplified)
  example from a real project:\n\n```haskell\nrunApp\n  :: EffT\n       '[ RModule
  ProxyState\n        , RModule ProxySettings\n        , PrometheusMan\n        ,
  LoggingModuleB\n        ]\n       NoError\n       IO\n       ()\n  -> IO ()\nrunApp
  app = do\n  -- Parse options, set up logging and metrics, etc...\n  opts :: ProxyOptions
  Unwrapped <- unwrapRecord \"Haskell Proxy Server\"\n  case optionsToSettings opts
  of\n    Nothing       -> putStrLn \"Invalid options provided.\"\n    Just settings
  -> do\n      -- Initialise loggers (implementation-specific).\n      baseStdLogger
  \ <- ...\n      baseFileLogger <- ...\n      let logger = baseStdLogger <> baseFileLogger\n\n
  \     -- Compose initialisation modules inside Eff, then eliminate back to IO.\n
  \     runEffT00 $\n        withLoggerCleanup logger $\n        (if settings.setPrometheus\n
  \          then withPrometheus ...\n           else withNoPrometheusMan) $\n        do\n
  \         state <- initializeState settings\n          runRModule settings $\n          runRModule
  state    $\n          app\n```\n\nThe exact set of modules (`PrometheusMan`, `LoggingModuleB`,
  ...) is either project-specific or reusable components you can build between projects,
  but the pattern is always:\n\n> build an `EffT` stack of modules, run your application
  logic there, then eliminate modules and errors with the provided runners.\n\n###
  Large application - a bot with many modules\n\nIn a larger system you might have
  many modules and a domain-specific error list. (Taken from a real-world bot application.)\n\n```haskell\n--
  The modules loaded into the bot\ntype Mods =\n  [ LogDatabase\n  , AsyncModule\n
  \ , ProxyWS\n  , CronTabTickModule\n  , StatusMonitorModule\n  , CommandModule\n
  \ , RecvSentCQ\n  , MeowActionQueue\n  , SModule BotConfig\n  , SModule WholeChat\n
  \ , SModule OtherData\n  , MeowConnection\n  , BotGlobal\n  , ConnectionManagerModule\n
  \ , MeowDataDb\n  , MeowCoreDb\n  , PrometheusMan\n  , LoggingModule\n  ]\n\n--
  Exceptions that require restarting the bot\ntype MeowErrs =\n  '[ ErrorText \"recv_connection\"\n
  \  , ErrorText \"send_connection\"\n   , ErrorText \"meowCoreDb\"\n   ]\n\ntype
  MeowT mods m = EffT mods MeowErrs m\ntype Meow         = MeowT Mods IO\n```\n\nThe
  bot initialisation then becomes a composition of `withX` helpers and `run*Module`
  runners:\n\n```haskell\nrunBot\n  :: BotInstance -- ^ Initial bot configuration\n
  \ -> Meow a -- ^ the bot loop function\n  -> EffT\n       '[ BotGlobal\n        ,
  ConnectionManagerModule\n        , MeowDataDb\n        , MeowCoreDb\n        , PrometheusMan\n
  \       , LoggingModule\n        ]\n       '[ErrorText \"meowCoreDb\"]\n       IO\n
  \      ()\nrunBot bot meow = do\n  -- embed some code into a larger context\n  botModule
  <- embedEffT $ botInstanceToModule bot\n\n  -- Build additional configuration/state
  modules...\n  -- initialise counters, status, etc.\n  -- not relevant for this example.\n\n
  \ embedNoError -- requires the scope inside to have 'NoError' and embeds it to a
  larger error context\n    $ effAddLogCat' (LogCat botModule.botId) -- adds a logging
  category to logs within the scope\n    $ ( case botRunFlag bot of\n          RunClient
  addr port -> void . withClientConnection addr port\n          RunServer addr port
  ->        withServerConnection addr port\n      ) -- running connection\n    $ (\\app
  -> do\n        AllData wc bc od <- embedEffT $ initAllData botconfig\n        runSModule_
  od $ runSModule_ wc $ runSModule_ bc $ app\n      ) -- domain state\n    $ withMeowActionQueue\n
  \   $ withRecvSentCQ\n    $ withModule CommandModuleInitData\n    $ withModule (StatusMonitorModuleInitData
  meowStat)\n    $ maybe id (\\init -> withWatchDog init . const) mWatchDogInit\n
  \   $ withCronTabTick\n    $ withProxyWS (ProxyWSInitData [(add, ip) | ProxyFlag
  add ip <- bot.botProxyFlags])\n    $ withAsyncModule\n    $ withLogDatabase\n    $
  meow\n```\n\nThe details of `withMeowActionQueue`, `withRecvSentCQ`, `withProxyWS`,
  etc. are application-specific, but the pattern is always:\n\n- each `withX` introduces
  one or more modules into the `EffT` stack and arranges their initial `ModuleRead`/`ModuleState`;
  and\n- the final `Meow` computation runs in a rich module environment, with its
  error list (`MeowErrs`) tracking only the domain errors that matter at that layer.\n\n###
  Example - database access\n\nYou can also use the type system to enforce that certain
  low-level errors are handled at the call-site. A typical pattern is to wrap a database
  action so it:\n\n- requires a specific module to be present; and\n- requires a specific
  error to be in the error list:\n\n```haskell\nrunMeowDataDB\n  :: ( In'   c MeowDataDb
  mods\n     , InList (ErrorText \"meowDataDb\") es\n     )\n  => ReaderT SqlBackend
  IO b\n  -> EffT' c mods es IO b\n```\n\nBecause `ErrorText \"meowDataDb\"` is in
  the error list, callers must either:\n\n- keep that error in their own `es` (and
  propagate it upward), or\n- explicitly catch and handle it. If they forget, GHC
  will report a type error.\n\nFor example:\n\n```haskell\n-- Forgetting to handle
  'ErrorText \"meowDataDb\"' here leads to a type error.\nfetchBlockMessages :: BotId
  -> ChatId -> ChatBlockSpan -> Meow [ChatMessage]\nfetchBlockMessages bid cid span
  = do\n  entities <-\n    runMeowDataDB (selectList [...conditions based on 'bid',
  'cid', 'span'...])\n      `effCatch` \\(_ :: ErrorText \"meowDataDb\") ->\n        pure
  []\n  pure (map entityVal entities)\n```\n\nHere `effCatch` both catches the database
  error and removes `ErrorText \"meowDataDb\"` from the error list, so the rest of
  `fetchBlockMessages` no longer has to account for it.\n\n---\n\n## Selected API
  Reference\n\nThis section is not exhaustive. It highlights key exports; for full
  details, please consult the Haddock documentation.\n\n### Core monad and runners\n\n-
  `Eff mods es a`, `EffT mods es m a`, `Pure mods es a`, `ResultT es m a`, `IO' es
  m a`\n- `runEffT`, `runEffT_`, `runEffT0`, `runEffT00`, `runEffT01`, `runResultT`\n-
  `runEffTOuter`, `runEffTOuter'`, `runEffTOuter_` - eliminate the *outermost* module
  while supplying its `ModuleRead`/`ModuleState`\n- `runEffTIn`, `runEffTIn'`, `runEffTIn_`
  - eliminate an *inner* module identified by its type\n- `replaceEffTIn` - replace
  a module with another, using custom conversion functions\n- `NoError`, `checkNoError`,
  `declareNoError`, `embedNoError`\n- `applyErrors`, `applyMods` - helpers that expose
  `es` / `mods` to type applications without changing the value\n\n### Error machinery\n\n-
  Types: `Result es a`, `EList es`, `SystemError`\n- Named wrappers: `ErrorText s`,
  `ErrorValue s v`, `errorText`, `errorValue`\n- Throwing:\n  - `effThrowIn`, `effThrow`
  - throw an error\n  - `effThrowEList`, `effThrowEListIn` - throw multiple errors
  via `EList`\n  - `MonadExcept e m` integration (e.g. via `tryAndThrow`, `tryAndThrowText`)\n-
  Catching:\n  - `effCatch` - catch the *first* error in the list\n  - `effCatchIn`
  - catch a *specific* error type and remove it from the list\n  - `effCatchAll` -
  catch all algebraic errors as an `EList es`\n- Converting errors:\n  - `errorToEither`,
  `errorToEitherAll`, `eitherAllToEffect`\n  - `errorInToEither`, `errorToMaybe`,
  `errorInToMaybe`, `errorToResult`\n  - `mapError` - map one error list into another\n-
  Turning `Either` / `Maybe` into errors:\n  - `effEitherWith`, `effEither`\n  - `effEitherInWith`,
  `effEitherIn`, `effEitherSystemException`\n  - `effMaybeWith`, `effMaybeInWith`\n
  \ - `pureMaybeInWith`, `pureEitherInWith`\n  - `baseEitherIn`, `baseEitherInWith`,
  `baseMaybeInWith`\n\n### IO lifting and exception bridging\n\nThese functions help
  you bridge `IO` exceptions into algebraic errors:\n\n- `liftIOException :: MonadIO
  m => IO a -> EffT' c mods '[IOException] m a`\n- `liftIOAt       :: (Exception e,
  MonadIO m) => IO a -> EffT' c mods '[e] m a`\n- `liftIOSafeWith :: (Exception e',
  MonadIO m) => (e' -> e) -> IO a -> EffT' c mods '[e] m a`\n- `liftIOText     ::
  MonadIO m => (Text -> Text) -> IO a -> EffT' c mods '[ErrorText s] m a`\n- `liftIOPrepend
  \ :: Text -> IO a -> EffT' c mods '[ErrorText s] IO a`\n\nTry/catch style:\n\n-
  `effTry`, `effTryWith` - catch exceptions thrown in the *base monad* and turn them
  into algebraic errors\n- `effTryIO`, `effTryIOWith`, `effTryIOIn`, `effTryIOInWith`\n-
  `effTryUncaught` - catch uncaught exceptions into error lists\n- `tryAndThrow`,
  `tryAndThrowWith`, `tryAndThrowText` - lift `IO` and rethrow via `MonadExcept`\n\n###
  Modules and module helpers\n\n- Core type classes:\n  - `Module` - defines `ModuleRead`
  and `ModuleState` associated data families\n  - `SystemModule` - extends `Module`
  with `ModuleEvent` and `ModuleInitData`\n  - `Loadable c mod mods es` - provides
  `withModule` for scoped module initialisation\n- System-wide aliases:\n  - `SystemRead
  c mods`, `SystemState c mods`\n  - `SystemEvent mods`, `SystemInitData c mods`\n
  \ - `SystemError`\n- Accessors from `Control.Monad.Effect`:\n  - `queryModule`,
  `queriesModule`, `askModule`, `asksModule`\n  - `getModule`, `getsModule`, `putModule`,
  `modifyModule`\n\n`withModule` (from `Control.System`) is particularly useful for
  implementing custom `withX` helpers that allocate resources, push a module on the
  stack, run an `EffT` computation, and then clean up.\n\n### Bracket patterns and
  concurrency\n\nResource-safe patterns:\n\n- `maskEffT` - `mask` in the base monad
  while staying in `EffT'`\n- `generalBracketEffT`, `generalBracketEffT'`\n- `bracketEffT`,
  `bracketEffT'`\n- `bracketOnErrorEffT`, `bracketOnErrorEffT'`\n\nConcurrency:\n\n-
  `forkEffT` - fork an `EffT` computation onto a new thread\n- `forkEffTFinally` -
  variants with finalisers\n- `asyncEffT`, `withAsyncEffT`, `withAsyncEffT'` - integrate
  `async` with `EffT`\n- `restoreAsync`, `restoreAsync_` - restore an `EffT` computation
  from an `Async` result\n\n### RS modules and interfaces\n\nFrom `Module.RS`:\n\n-
  Types:\n  - `RModule r`, `RNamed name r`\n  - `SModule s`, `SNamed name s`\n- Running
  modules:\n  - `runRModule`, `runRModuleIn`\n  - `runSModule`, `runSModule_`, `runSModuleIn`\n-
  Embedding existing `ReaderT`/`StateT`:\n  - `liftReaderT`, `embedReaderT`, `addReaderT`,
  `asReaderT`\n  - `liftStateT`, `embedStateT`, `addStateT`, `asStateT`\n- Convenience:\n
  \ - `askR`, `asksR`, `localR`\n  - `getS`, `getsS`, `putS`, `modifyS`\n  - `readOnly`
  - treat a state module as a read-only module inside a scope\n\nFrom `Control.Monad.RS.Class`:\n\n-
  `MonadReadOnly r m`, `MonadReadable r m`, `MonadStateful s m` - reader/state-like
  APIs without functional dependencies; `EffT'` has instances for these.\n\nFrom `Control.Monad.Class.Except`:\n\n-
  `MonadExcept e m` - multiple error types per monad\n- `ErrorText`, `ErrorValue`,
  `errorText`, `errorValue`\n\n### Template Haskell utilities\n\nFrom `Module.RS.QQ`:\n\n-
  `makeRModule`, `makeRModule_`, `makeRModule__`\n- `makeRSModule`, `makeRSModule_`\n\n`makeRModule`
  example (simplified):\n\n```haskell\n[makeRModule|MyModule\n  myRecord1 :: !MyType1\n
  \ myRecord2 ::  MyType2\n|]\n```\n\nGenerates (conceptually):\n\n- `data MyModule`\n-
  `instance Module MyModule` with:\n  - `data ModuleRead  MyModule  = MyModuleRead
  { myRecord1 :: !MyType1, myRecord2 :: MyType2 }`\n  - `data ModuleState MyModule
  \ = MyModuleState` (plus derivations)\n- `instance SystemModule MyModule` with:\n
  \ - `data ModuleEvent    MyModule`\n  - `data ModuleInitData MyModule`\n- runners
  `runMyModule`, `runMyModuleIn`, etc., and convenient type synonyms for `ModuleRead`
  / `ModuleState`.\n\n`makeRSModule` similarly builds a combined reader/state module
  from a compact specification, including optional lens generation for fields tagged
  with `Lens`.\n\n---\n\n## Performance, style and benchmarks\n\nThe core `EffT` design
  is **very optimisation-friendly**:\n\n- modules are stored in a specialised data
  family `FData`, not a linked list;\n- `FData` is generated by Template Haskell up
  to a fixed length (e.g. `FData3`, `FData4`, ...) with strict fields; and\n- GHC
  can often optimise `EffT`-based code down to tight loops, competitive with or better
  than hand-written `StateT`/`ExceptT` stacks.\n\nThe benchmarks in `benchmark/` compare:\n\n-
  `EffT` with `FList` (heterogeneous list),\n- `EffT` with `FData`, and\n- `StateT`
  from `mtl`.\n\nOn typical countdown/state benchmarks:\n\n- `EffT` + `FData` is around
  **25 times faster** than `StateT` without optimisation, and\n- about as fast as
  a properly optimised `StateT` (`-O2 -flate-dmd-anal`).\n\nSee the SVG charts under
  `benchmark/bench-result-*` in the repository for details.\n\n### Some Benchmarks\n\nSee
  the `benchmark` folder for more benchmarks. The benchmarks are copied from `heftia`,
  another effect system library, with some modifications.\n\n#### Countdown `-O2`\n![Countdown-O2](https://raw.githubusercontent.com/Eiko-Tokura/monad-effect/3aeceddb0c7e452b34032b404a5fdc068df322de/benchmark/bench-result-O2/countdown-deep.svg)\n\n####
  Countdown `-O0`\n![Countdown-O0](https://raw.githubusercontent.com/Eiko-Tokura/monad-effect/3aeceddb0c7e452b34032b404a5fdc068df322de/benchmark/bench-result-O0/countdown-deep.svg)\n\n####
  Deep Catch `-O2`\n![Catch-O2](https://raw.githubusercontent.com/Eiko-Tokura/monad-effect/3aeceddb0c7e452b34032b404a5fdc068df322de/benchmark/bench-result-O2/catch-deep.svg)\n\n####
  Deep Catch `-O0`\n![Catch-O0](https://raw.githubusercontent.com/Eiko-Tokura/monad-effect/3aeceddb0c7e452b34032b404a5fdc068df322de/benchmark/bench-result-O0/catch-deep.svg)\n\n####
  Local State `-O2`\n![Local-O2](https://raw.githubusercontent.com/Eiko-Tokura/monad-effect/3aeceddb0c7e452b34032b404a5fdc068df322de/benchmark/bench-result-O2/local-deep.svg)\n\n####
  Local State `-O0`\n![Local-O0](https://raw.githubusercontent.com/Eiko-Tokura/monad-effect/3aeceddb0c7e452b34032b404a5fdc068df322de/benchmark/bench-result-O0/local-deep.svg)\n\n###
  Flags\n\nGHC's type-checker sometimes needs more fuel for large module/error lists.
  It is recommended to build with:\n\n```bash\n-fconstraint-solver-iterations=16\n```\n\nor
  slightly higher when using very deep stacks.\n\n### Style and module design\n\n`monad-effect`
  does not impose a particular way to structure your modules. You can:\n\n- package
  a concrete implementation (e.g. Prometheus counter, HTTP manager, database connection
  pool) directly into a module; or\n- use a more “algebraic effects” style, where
  modules carry *handlers* for an algebraic effect GADT.\n\nAn example of the latter
  is a Prometheus counter module that carries a handler as read-only state\n\n```haskell\n{-#
  LANGUAGE DataKinds, TypeFamilies, RequiredTypeArguments #-}\nmodule Module.Prometheus.Counter
  where\n\nimport Control.Monad.Effect\nimport System.Metrics.Prometheus.Metric.Counter
  as C\n\n-- | A prometheus counter module that has a name\ndata PrometheusCounter
  (name :: k)\n\n-- | Counter effects written in algebraic effect style\ndata PrometheusCounterEffect
  a where\n  AddAndSampleCounter :: Int -> PrometheusCounterEffect CounterSample\n
  \ AddCounter          :: Int -> PrometheusCounterEffect ()\n  IncCounter          ::
  \       PrometheusCounterEffect ()\n  SetCounter          :: Int -> PrometheusCounterEffect
  ()\n  SampleCounter       ::        PrometheusCounterEffect CounterSample\n\n--
  | The effect handler type for a prometheus counter with given counter name\ntype
  PrometheusCounterHandler (name :: k) = forall c mods es m a. (In' c (PrometheusCounter
  name) mods, MonadIO m) => PrometheusCounterEffect a -> EffT' c mods es m a\n\n--
  | The module is declared as a reader module that carries a counter handler\ninstance
  Module (PrometheusCounter name) where\n  newtype ModuleRead  (PrometheusCounter
  name) = PrometheusCounterRead { prometheusCounterHandler :: PrometheusCounterHandler
  name }\n  data    ModuleState (PrometheusCounter name) = PrometheusCounterState\n\n--
  | Specify / interpret a counter effect with given counter name\nrunPrometheusCounter\n
  \ :: forall name\n  -> ( ConsFDataList c (PrometheusCounter name : mods)\n     ,
  Monad m\n     )\n  => PrometheusCounterHandler name -> EffT' c (PrometheusCounter
  name ': mods) es m a -> EffT' c mods es m a\nrunPrometheusCounter name handler =
  runEffTOuter_ (PrometheusCounterRead @_ @name handler) PrometheusCounterState\n{-#
  INLINE runPrometheusCounter #-}\n\n-- | Carry out a counter effect with given counter
  name\nprometheusCounterEffect :: forall name -> (In' c (PrometheusCounter name)
  mods, MonadIO m) => PrometheusCounterEffect a -> EffT' c mods es m a\nprometheusCounterEffect
  name eff = do\n  PrometheusCounterRead handler <- askModule @(PrometheusCounter
  name)\n  handler eff\n{-# INLINE prometheusCounterEffect #-}\n\n-- | Use a specific
  counter to carry out a counter effect\nuseCounter :: Counter -> PrometheusCounterHandler
  name\nuseCounter counter IncCounter              = liftIO $ C.inc counter\nuseCounter
  counter (AddCounter n)          = liftIO $ C.add n counter\nuseCounter counter (SetCounter
  n)          = liftIO $ C.set n counter\nuseCounter counter (AddAndSampleCounter
  n) = liftIO $ C.addAndSample n counter\nuseCounter counter SampleCounter           =
  liftIO $ C.sample counter\n{-# INLINE useCounter #-}\n\n-- | A counter handler that
  does nothing\nnoCounter :: Monad m => PrometheusCounterEffect a -> EffT mods es
  m a\nnoCounter IncCounter              = pure ()\nnoCounter (AddCounter _)          =
  pure ()\nnoCounter (SetCounter _)          = pure ()\nnoCounter (AddAndSampleCounter
  _) = pure (CounterSample 0)\nnoCounter SampleCounter           = pure (CounterSample
  0)\n{-# INLINE noCounter #-}\n```\n\n---\n\n## Documentation changes from previous
  versions\n\nCompared to earlier versions of the README:\n\n- The formal definition
  of `Result` has been updated to match the code in `Data.Result` (single `RSuccess`
  constructor, with `Result '[] a` behaving like `a`).\n\n- All examples now use the
  `errorText` / `errorValue` smart constructors instead of directly constructing using
  constructors `ErrorText` / `ErrorValue`. This avoids the filling kind type parameter
  `ErrorText @_ @\"...\"` noise.\n\n- The `myLookup` / `computeAverageFromFile` example
  has been synchronised with the code in `test/Examples.hs` and corrected to use `errorText
  @\"Map.keyNotFound\"` with a proper `Text` value.\n\n- Experimental system orchestration
  types (`WithSystem`, `EventLoopSystem`, event loops) and the `Resource` module are
  intentionally **not** described in detail here, as they may change or be removed
  in future versions. The focus is on `EffT`, modules, algebraic errors, and the RS/Except
  helper classes.\n\n- Minor wording updates were made throughout to reflect that
  `EffT`/`Eff` (with `FData`) are the recommended entry points for most users.\n\nFor
  full API details, please refer to the Haddock documentation generated from the source.\n"
description-type: markdown
hash: c83b75ab6be06289e0201d4afdb117a43c88d78a9a319429fea4712853a014aa
homepage: ''
latest: 0.2.3.0
license-name: BSD-3-Clause
maintainer: eikochanowo@outlook.com
synopsis: A fast and lightweight effect system.
test-bench-deps:
  base: '>=4 && <5'
  containers: '>=0'
  criterion: '>=0'
  data-effects: '>=0'
  effectful: '>=2.3 && <2.6'
  freer-simple: ^>=1.2
  fused-effects: ^>=1.1
  heftia-effects: '>=0'
  logict: '>=0.7.0.3 && <0.9'
  monad-effect: '>=0'
  mtl: '>=2.2 && <2.4'
  parsec: '>=0'
  polysemy: ^>=1.9
  tasty-bench: '>=0.3 && <0.5'
  text: '>=0'
  unix: '>=0'

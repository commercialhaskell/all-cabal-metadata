homepage: https://morpheusgraphql.com
changelog-type: markdown
hash: 36ca7b16952f1af08ce911adbb58abda2e5799b3eb14232f226e190690eb1461
test-bench-deps:
  bytestring: ! '>=0.10.4 && <0.11'
  morpheus-graphql: -any
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  uuid: ! '>=1.0 && <=1.4'
  megaparsec: ! '>=7.0.0 && <9.0.0'
  websockets: ! '>=0.11.0 && <=0.13'
  th-lift-instances: ! '>=0.1.1 && <=0.2.0'
  containers: ! '>=0.4.2.1 && <0.7'
  mtl: ! '>=2.0 && <=2.3'
  tasty-hunit: -any
  transformers: ! '>=0.3.0.0 && <0.6'
  tasty: -any
  scientific: ! '>=0.3.6.2 && <0.4'
  aeson: -any
  template-haskell: ! '>=2.0 && <=2.16'
  vector: ! '>=0.12.0.1 && <0.13'
maintainer: d.nalchevanidze@gmail.com
synopsis: Morpheus GraphQL
changelog: "# Changelog\n\n## [0.9.0] - 02.01.2020\n\n### Added\n\n- `WithOperation`
  constraint for Generic Resolvers (#347) thanks @dandoh\n\n### Fixed\n\n- liftEither
  support in MutResolver (#351)\n- selection of `__typename` on object und union objects
  (#337)\n- auto inferece of external types in gql document (#343)\n\n  th will generate
  field `m (Type m)` if type has an argument\n  \n  e.g for this types and DSL\n  \n
  \ ```hs\n  data Type1 = Type1 { ... }\n  type Type2 m = SomeType m\n  data Type3
  m = Type2 { bla :: m Text } deriving ...\n  ```\n\n  ```gql\n  type Query {\n    field1
  : Type1!\n    field2 : Type2!\n    field3 : Type3!\n  }\n  ```  \n\n  morpheus generates\n\n
  \ ```hs\n  data Query m = Query {\n    field1 :: m Type1\n    field2 :: m (Type2
  m)\n    field3 :: m (Type3 m)\n  } deriving ...\n  ```\n\n  now you can combine
  multiple gql documents:\n  \n  ```hs\n  importDocumentWithNamespace `coreTypes.gql`\n
  \ importDocumentWithNamespace `operations.gql`\n  ```\n\n### Changed\n\n- support
  of resolver fields `m type` for the fields without arguments\n\n  ```hs\n  data
  Diety m = Deity {\n      name :: m Text\n  }\n  -- is equal to\n  data Diety m =
  Deity {\n      name :: () -> m Text\n  }\n  ```\n\n- template haskell generates
  `m type`  insead of `() -> m type` for fields without argument (#334)\n\n  ```hs\n
  \ data Diety m = Deity {\n      name :: (Arrow () (m Text)),\n      power :: (Arrow
  () (m (Maybe Text)))\n  }\n  -- changed to\n  data Diety m = Deity {\n      name
  :: m Text,\n      power :: m (Maybe Text)\n  }\n  ```\n\n## [0.8.0] - 15.12.2019\n\n###
  Changed\n\n- deprecated: `INPUT_OBJECT`, `OBJECT`, `UNION`,\n\n  - use `INPUT` instead
  of `INPUT_OBJECT`\n  - use `deriving(GQLType)` insead of `OBJECT` or `UNION`\n\n-
  only namespaced Unions  generate regular graphql Union, other attempts will be wrapped
  inside an object with constructor name :\n\n  e.g:\n  \n  ```hs\n  data Character
  =\n    CharacterDeity Deity\n    SomeDeity Deity\n    deriving (GQLType)\n  ```\n\n
  \ where `Deity` is Object.\n  will generate\n\n  ```gql\n    union CHaracter = Deity
  | SomeDeity\n\n    type SomeDeity {\n      _0: Deity\n    }\n  ```\n\n### Added\n\n-
  `failRes` for resolver failures\n- added kind: INPUT , OUTPUT\n- Automatic Type
  Inference (only for Object, Union and Enum)\n- More general stateful resolvers which
  accept instances of MonadIO (Authored by Sebastian Pulido [sebashack])\n- Utility
  to create web-socket applications with custom MonadIO instances (Authored by Sebastian
  Pulido [sebashack])\n\n```hs\n\ndata Realm  =\n    Sky\n  | Sea\n  | Underworld\n
  \   deriving (Generic, GQLType)\n\ndata Deity  = Deity{\n    fullName:: Text,\n
  \   realm:: Realm\n  } deriving (Generic, GQLType)\n\ndata Character  =\n    CharacterDeity
  Deity -- Only <tyconName><conName> should generate direct link\n  -- RECORDS\n  |
  Creature { creatureName :: Text, creatureAge :: Int }\n  --- Types\n  | SomeDeity
  Deity\n  | CharacterInt Int\n  | SomeMutli Int Text\n  --- ENUMS\n  | Zeus\n  |
  Cronus deriving (Generic, GQLType)\n\n\n```\n\nwill generate schema:\n\n```gql\nenum
  Realm {\n  Sky\n  Sea\n  Underworld\n}\n\ntype Deity {\n  fullName: String!\n  realm:
  Realm!\n}\n\nunion Character =\n    Deity\n  | Creature\n  | SomeDeity\n  | CharacterInt\n
  \ | SomeMutli\n  | CharacterEnumObject\n\ntype Creature {\n  creatureName: String!\n
  \ creatureAge: Int!\n}\n\ntype SomeDeity {\n  _0: Deity!\n}\n\ntype CharacterInt
  {\n  _0: Int!\n}\n\ntype SomeMutli {\n  _0: Int!\n  _1: String!\n}\n\n# enum\ntype
  CharacterEnumObject {\n  enum: CharacterEnum!\n}\n\nenum CharacterEnum {\n  Zeus\n
  \ Cronus\n}\n```\n\nrules:\n\n- haskell union type with only empty constructors
  (e.g `Realm`), will generate graphql `enum`\n- haskell record without union (e.g
  `Deity`), will generate graphql `object`\n- namespaced Unions: `CharacterDeity`
  where `Character` is TypeConstructor and `Deity` referenced object (not scalar)
  type: will be generate regular graphql Union\n\n  ```gql\n  union Character =\n
  \       Deity\n      | ...\n  ```\n\n- for union recrods (`Creature { creatureName
  :: Text, creatureAge :: Int }`) will be referenced in union type, plus type `Creature`will
  be added in schema.\n\n  e.g\n\n  ```gql\n    union Character =\n      ...\n      |
  Creature\n      | ...\n\n    type Creature {\n      creatureName : String!\n      creatureAge:
  Int!\n    }\n\n  ```\n\n  - all empty constructors in union will be summed in type
  `<tyConName>Enum` (e.g `CharacterEnum`), this enum will be wrapped in `CharacterEnumObject`
  and this type will be added to union `Character`. as in example above\n\n  - there
  is only types left with form `TypeName Type1 2Type ..`(e.g `SomeDeity Deity` ,`CharacterInt
  Int`, `SomeMutli Int Text`),\n\n    morpheus will generate objet type from it:\n\n
  \   ```gql\n    type TypeName {\n      _0: Type1!\n      _1: Type2!\n      ...\n
  \   }\n    ```\n\n### Removed\n\n- removed kind: INPUT_UNION\n\n### Fixed\n\n- on
  filed resolver was displayed. unexhausted case exception of graphql error\n- support
  of signed numbers (e.g `-4`)\n- support of round floats (e.g `1.000`) \n- validation
  checks undefined fields on inputObject\n- variables are supported inside input values\n\n##
  [0.7.1] - 26.11.2019\n\n- max bound icludes: support-megaparsec-8.0\n\n## [0.7.0]
  - 24.11.2019\n\n### Removed\n\n- `toMorpheusHaskellAPi` from `Data.Morpheus.Document`
  functionality will be migrated in `morpheus-graphql-cli`\n\n### Changed\n\n- `liftM`
  to `MonadTrans` instance method `lift`\n\n- `liftEitherM` to `liftEither`\n\n- `Resolver
  operation m event value` -> `Resolver operation event m value` , monad trans needs
  that last 2 type arguments are monad and value that why it was necessary\n\n- exposed
  `Data.Morpheus.Types.Internal.AST`\n\n- Mutation Resolver was changed from\n\n```\nresolver
  :: () -> ResolveM EVENT IO Address\nresolver = MutResolver  {\n  mutEvents = [someEventForSubscription],\n
  \ mutResolver = lift setDBAddress\n}\n```\n\n```haskell\n-- Mutation Wit Event Triggering
  : sends events to subscription\nresolver :: () -> ResolveM EVENT IO Address\nresolver
  = MutResolver \\$ do\n  value <- lift setDBAddress\n  pure ([someEventForSubscription],
  value)\n-- or\n-- Mutation Without Event Triggering\nresolver :: () -> ResolveM
  EVENT IO Address\nresolver _args = lift setDBAddress\n```\n\n### Added\n\n- added
  `parseDSL` to `Data.Morpheus.Document`\n\n- GraphQL SDL support fully supports descriptions:
  onTypes, fields , args ...\n  with (enums, inputObjects , union, object)\n  for
  example :\n\n  ```gql\n  \"\"\"\n  Description for Type Address\n  \"\"\"\n  type
  Address {\n    \"\"\"\n    Description for Field city\n    \"\"\"\n    city: String!\n
  \   street(\n      \"\"\"\n      Description argument id\n      \"\"\"\n      id:
  ID!\n    ): Int!\n  }\n  ```\n\n  ###### GraphQL SDL\n\n  ```gql\n  type User {\n
  \   name: String! @deprecated(reason: \"some reason\")\n  }\n  ```\n\n  will displayed
  in introspection\n\n  ###### introspection.json\n\n  ```json\n  {\n    \"data\":
  {\n      \"__type\": {\n        \"fields\": [\n          {\n            \"name\":
  \"city\",\n            \"isDeprecated\": true,\n            \"deprecationReason\":
  \"test deprecation field with reason\"\n          }\n        ]\n      }\n    }\n
  \ }\n  ```\n\n- basic support of directive `@deprecated` on `enumValue` and object
  `field`, only on introspection\n\n- GraphQL Client deprecation warnings\n\n  on
  type\n\n  ```gql\n  type Human {\n    humanName: String!\n    lifetime: Lifetime!
  @deprecated(reason: \"some reason\")\n    profession: Profession\n  }\n  ```\n\n
  \ compiler output:\n\n  ```json\n  warning:\n    Morpheus Client Warning:\n    {\n
  \     \"message\":\"the field \\\"Human.lifetime\\\" is deprecated. some reason\",\n
  \     \"locations\":[{\"line\":24,\"column\":15}]\n    }\n  ```\n\n- new helper
  resolver types aliases:\n\n  - ResolveQ : for Query\n  - ResolveM : for Mutation\n
  \ - ResolveS : for Subscription\n\n  `ResolveM EVENT IO Address` is same as `MutRes
  EVENT IO (Address (MutRes EVENT IO))`\n\n  is helpfull wenn you want to resolve
  GraphQL object\n\n### Fixed\n\n- added missing Monad instance for Mutation resolver\n-
  `defineByIntrospectionFile` does not breaks if schema contains interfaces\n- Morpheus
  Client supports `Subscription` and `Mutation`operations\n\n## [0.6.2] - 2.11.2019\n\n###
  Added\n\n- support of ghc 8.8.1\n\n## [0.6.0] - 1.11.2019\n\n### Removed\n\n- removed
  `morpheus` cli for code generating, if you need cli you should use\n  [morpheus-graphql-cli](https://github.com/morpheusgraphql/morpheus-graphql-cli/)\n\n-
  example `API` executable is removed from Production build\n\n### Added\n\n- helper
  functions: `liftEitherM` , `liftM`\n\n  ```haskell\n    liftM :: m a -> Resolver
  o m e a\n    liftEitherM :: m (Either String a) -> Resolver o m e a\n  ```\n\n##
  [0.5.0] - 31.10.2019\n\n### Added\n\n- dummy support of `directives`, only parsing
  not actual implementation\n\n### Fixed\n\n- can be parsed `implements` with multiple
  interfaces separated by `&`\n- can be parsed default value on `inputobject`\n- Parser
  supports anonymous Operation: `query` , `mutation` , `subscription`\n  for example:\n\n
  \ ```gql\n  mutation {\n     name\n  }\n  ```\n\n- Morpheus client does not breaks
  on `Boolean` type, converts every GraphQL type `Boolean` to haskell `Bool` and GQL
  `String` to `Text`\n\n### Changed\n\n- Reduced `GQLRootResolver` signature :\n\n
  \ `GQLRootResolver IO () () Query () ()` -> `GQLRootResolver IO () Query () ()`\n\n
  \ `GQLRootResolver IO Channel Content Query Mutation Subscription` -> `GQLRootResolver
  IO APIEvent Query Mutation Subscription`\n\n  where `APIEvent = Event Channel Content`\n\n-
  `GQLRootResolver` automatically assigns corresponding monad to GraphQL Types.\n\n
  \ you can write just:\n\n  ```hs\n  GQLRootResolver IO APIEvent Query  Mutation
  Subscription\n  ```\n\n  instead of:\n\n  ```hs\n  GQLRootResolver IO APIEvent (Query
  (Resolver IO))  (Mutation (MutResolver IO ApiEvent) (Subscription (SubResolver IO
  ApiEvent))\n  ```\n\n  where operations are generated by `importGQLDocument` or
  have form :\n\n  ```\n  data Query m = Query {\n    field1 :: Args -> m Field1,\n
  \   ....\n  }\n  ```\n\n- `()` was replaced with `Undefined` in `GQLRootResolver`
  for empty operations `mutation`, `subscription`\n  ```\n  rootResolver :: GQLRootResolver
  IO () Query Undefined Undefined\n  ```\n- Root Operations `Query`, `Mutation`, `Subscription`
  are passed to root resolvers without boxing inside a monad.\n- there are only 3
  kind of resolvers `MutResolver`, `SubResolver` , `QueryResolver` defined by GADT
  `Resolver`\n\n## [0.4.0] - 09.10.2019\n\n## Changed\n\n- support of Default Value:\n\n
  \ - on query: Parsing Validating and resolving\n  - on Document: only Parsing\n\n-
  'lens' is removed from Library, client field collision can be handled with GraphQL
  `alias`:\n  ```gql\n  {\n    user {\n      name\n      friend {\n        friendName:
  name\n      }\n    }\n  }\n  ```\n\n### Fixed:\n\n- `Data.Morpheus.Document.toGraphQLDocument`
  generates only my user defined types. #259\n- Morpheus Client Namespaces Input Type
  Fields, they don't collide anymore:\n  example:\n  schema:\n\n  ```gql\n  input
  Person {\n    name: String!\n  }\n  ```\n\n  query:\n\n  ```gql\n  query GetUser
  (parent: Person!) {\n    ....\n  }\n  ```\n\n  wil generate:\n\n  ```hs\n  data
  GetUserArgs = GetUserArgs {\n    getUserArgsParent: Person\n  } deriving ...\n\n
  \ data Person = Person {\n    personName: Person\n  } deriving ...\n  ```\n\n- Morpheus
  Client Generated Output Object And Union Types don't collide:\n\n  ```gql\n  type
  Person {\n    name: String!\n    parent: Person!\n    friend: Person!\n  }\n  ```\n\n
  \ And we select\n\n  ```gql\n  {\n    user {\n      name\n      friend {\n        name\n
  \     }\n      parent {\n        name\n      }\n      bestFriend: friend {\n        name\n
  \       parent {\n          name\n        }\n      }\n    }\n  }\n  ```\n\n  client
  will Generate:\n\n  - `UserPerson` from `{user`\n  - `UserFriendPerson`: from `{user{freind`\n
  \ - `UserParentPerson`: from `{user{parent`\n  - `UserBestFriendPerson`: from `{user{bestFrend`\n
  \ - `UserBestFriendParentPerson`: from `{user{bestFrend{parent`\n\n- GraphQL Client
  Defines enums and Input Types only once per query and they don't collide\n\n## [0.3.1]
  - 05.10.2019\n\n### Changed\n\n- removed dependencies: attoparsec , utf8-string\n-
  updated aeson lower bound up to: 1.4.4.0\n\n## [0.3.0] - 04.10.2019\n\n### Added\n\n-
  user can import GraphQL Document and generate types with it.\n\n  ```haskell\n    importGQLDocument
  \"API.gql\"\n  ```\n\n  this will generate types defined in `API.gql`\n\n### Fixed\n\n-
  `String` defined in GQLDcoument will be converted to `Text` by template haskell\n\n-
  `importGQLDocument` and `gqlDocument` supports Mutation, Subscription and Resolvers
  with custom Monad\n\n  for example. if we have:\n\n  ```gql\n  type Deity {\n    name:
  String!\n    power: Power!\n  }\n  ```\n\n  where `Power` is another object defined
  by gql schema.\n  template haskell will represent this type as:\n\n  ```haskell\n
  \    data Deity m = Deity {\n       name :: () -> m Text,\n       power :: () ->
  m (Power m)\n     }\n  ```\n\n  where `m` is resolver Monad.\n\n- `importGQLDocumentWithNamespace`
  generates namespaced haskell records. so that you have no more problem with name
  collision.\n  from this gql type:\n\n  ```gql\n  type Deity {\n    name: (id:Int)String!\n
  \   power: Power!\n  }\n  ```\n\n  will be generated.\n\n  ```haskell\n  data Deity
  m = Deity {\n    deityName :: DeityNameArgs -> m Text,\n    deityPower :: () ->
  m (Power m)\n  }\n\n  data DeityNameArgs = DeityNameArgs {\n    deityNameArgsId
  :: Int\n  }\n  ```\n\n### Changed\n\n- `GQLType` is mandatory for every GQL Type
  (including Query, Mutation and Subscription)\n- subscription Resolver changed\n\n
  \ from:\n\n  ```haskell\n    Subscription {newDeity = \\args -> Event {channels
  = [ChannelA], content = newDeityResolver } }\n  ```\n\n  to:\n\n  ```haskell\n    Subscription
  {newDeity = \\args -> SubResolver {subChannels = [ChannelA], subResolver = newDeityResolver
  } }\n  ```\n\n## [0.2.2] - 30.08.2019\n\n### Fixed\n\n- Parser Supports GraphQL
  multiline comments\n- Morpheus GraphQL Client: Support GraphQL Alias\n- Support
  of GraphQL Interfaces on GraphQL Document:\n\n  ```gql\n  # simple.gql\n  interface
  Node {\n    nodeId: ID!\n  }\n\n  type SimpleType implements Node {\n    nodeId:
  ID!\n    name: String!\n  }\n  ```\n\n  morpheus compiler will read interfaces and
  validate implements.\n  template haskell will generate haskell types only for types
  not for interfaces.\n\n  haskell type from `simple.gql`:\n\n  ```haskell\n   data
  SimpleType = SimpleType {\n      nodeId :: ID!\n      name   :: Text!\n    }  deriving
  (Generic)\n  ```\n\n  at the time compiler does not validates field Arguments by
  interface\n\n## [0.2.1] - 23.08.2019\n\n- assets are added to cabal source files\n\n##
  [0.2.0] - 23.08.2019\n\n### Added\n\n- Parser Supports GraphQL comments\n- Enhanced
  Subscription: mutation can trigger subscription with arguments\n- Experimental Support
  of Input Unions\n- GraphQL schema generating with: `Data.Morpheus.Document.toGraphQLDocument`\n-
  Generating dummy Morpheus Api from `schema.gql`:\n\n  ```\n  morpheus build schema/mythology.gql
  src/MythologyApi.hs\n  ```\n\n  [details](https://github.com/morpheusgraphql/morpheus-graphql/issues/184)\n\n-
  `convertToJSONName` & `convertToHaskellName` has been extended to support all Haskell
  2010 reserved identities. [details](https://github.com/morpheusgraphql/morpheus-graphql/issues/207)\n\n-
  `GraphQL Client` with Template haskell QuasiQuotes (Experimental, Not fully Implemented)\n\n
  \ ```haskell\n  defineQuery\n    [gql|\n      query GetHero ($byRealm: Realm)\n
  \       {\n          deity (realm:$byRealm) {\n            power\n            fullName\n
  \         }\n        }\n    |]\n  ```\n\n  will Generate:\n\n  - response type `GetHero`,
  `Deity` with `Lens` Instances\n  - input types: `GetHeroArgs` , `Realm`\n  - instance
  for `Fetch` typeClass\n\n  so that\n\n  ```haskell\n    fetchHero :: Args GetHero
  -> m (Either String GetHero)\n    fetchHero = fetch jsonRes args\n        where\n
  \         args = GetHeroArgs {byRealm = Just Realm {owner = \"Zeus\", surface =
  Just 10}}\n          jsonRes :: ByteString -> m ByteString\n          jsonRes =
  <fetch query from server>\n  ```\n\n  resolves well typed response `GetHero`.\n\n-
  Ability to define `GQLSchema` with GraphQL syntax ,\n  so that with this schema\n\n
  \ ```haskell\n\n  [gqlDocument|\n    type Query {\n      deity (uid: Text! ) : Deity!\n
  \   }\n\n    type Deity {\n      name  : Text!\n      power : Text\n    }\n  |]\n\n
  \ rootResolver :: GQLRootResolver IO () () Query () ()\n  rootResolver =\n    GQLRootResolver
  {queryResolver = return Query {deity}, mutationResolver = pure (), subscriptionResolver
  = pure ()}\n    where\n      deity DeityArgs {uid} = pure Deity {name, power}\n
  \       where\n          name _ = pure \"Morpheus\"\n          power _ = pure (Just
  \"Shapeshifting\")\n  ```\n\n  Template Haskell Generates types: `Query` , `Deity`,
  `DeityArgs`, that can be used by `rootResolver`\n\n  generated types are not compatible
  with `Mutation`, `Subscription`,\n  they can be used only in `Query`, but this issue
  will be fixed in next release\n\n### Fixed:\n\n- Parser supports enums inside input
  Object\n- fulfilled fragment Validation (added: unusedFragment,nameConflict)\n-
  correct decoding of Enums with more than 3 constructor #201\n\n### Changed\n\n-
  WebSocket subProtocol changed from `graphql-subscriptions` to `graphql-ws`\n\n-
  type familiy `KIND` is moved into typeClasses `GQLType`, so you should replace\n\n
  \ ```haskell\n  type instance KIND Deity = OBJECT\n\n  instance GQLType Deity where\n
  \   description  = const \"Custom Description for Client Defined User Type\"\n\n
  \ data Deity = Deity { fullName :: Text } deriving (Generic)\n  ```\n\n  with\n\n
  \ ```haskell\n  instance GQLType Deity where\n  type KIND Deity = OBJECT\n  description
  = const \"Custom Description for Client Defined User Type\"\n\n  data Deity = Deity
  { fullName :: Text } deriving (Generic)\n  ```\n\n- Duplicated variable names in
  Http requests are validated using `Aeson`'s `jsonNoDup` function. So the following
  request will\n  result in a parsing error\n\n  ```\n  {\"query\":\"...\",\n  \"variables\":{\"email\":\"foo@mail.net\",
  \"email\":\"bar@mail.net\",...}}\n  ```\n\n## [0.1.1] - 1.07.2019\n\n### Fixed:\n\n-
  () as Subscription or Mutation does not defines Operator without fields\n\n## [0.1.0]
  - 30.06.2019\n\nthanks for contributing to: @krisajenkins, @hovind, @vmchale, @msvbg\n\n###
  Added\n\n- support for Union Types: `type instance KIND <type> = UNION`\n- support
  of haskell Types: `Map`, `Set`, and Pair `(a,b)`\n- GraphQL Resolver supports custom
  Monad\n- add `Interpreter` class with instances:\n\n  - `ByteString -> m ByteString`
  and Lazy `ByteString`, where `m` is resolver monad\n  - `Text -> m Text` and Lazy
  `Text`, where `m` is resolver monad\n  - `GQLRequest -> m GQLResponse` , When you
  using it inside another Component that have Manual `ToJSON` deriving,\n    you have
  to ensure that `GQLResponse` will be encoded with `toEncoding`, and not with `toJSON`.\n\n-
  Schema Validation:\n\n  - Name Collision\n\n- support of Parsing input values: `Objects`,`Arrays`\n-
  support scalar type: `ID`\n- scalar Types are validated by `GQLScalar` instance
  function `parseValue`\n- TypeFamily `KIND` with:\n\n  - `SCALAR`\n  - `OBJECT`,\n
  \ - `ENUM`\n  - `INPUT_OBJECT`\n  - `UNION`\n\n- inline Fragments\n- GraphQL [Aliases](https://graphql.org/learn/queries/#aliases)\n-
  Subscriptions: `GQLSubscription`\n\n  - `a -> EffectM b` operation: is resolver
  that contains side effect in `EffectM`.\n    is used for Mutation and Subscribe
  communication\n  - `gqlEffectResolver [\"CHANNEL_ID\"]`: packs as effect Resolver.\n
  \   if mutation and subscription resolver have same channel then\n    every call
  of mutation will trigger subscription resolver\n  - `GQLState`: shared state between
  `http` and `websocket` server\n  - `gqlSocketApp` :converts `interpreter` to `websocket`
  application\n  - `graphql-subscriptions`: `Apollo GraphQL` subProtocol\n\n- language:\n
  \ - Query supports : `__type(name:\"type\")`\n  - On every Object can be selected
  : `__typename`\n\n### Changed\n\n- `GQLRootResolver`, `GQLType(..)` , `GQLScalar(..)`\n
  \ are moved in `Data.Morpheus.Types`\n- `GQLRoot { query, mutation, subscription
  }` to `GQLRootResolver {queryResolver, mutationResolver, subscriptionResolver}`\n-
  `interpreter`: can be used in `http` and `websocket` server\n- `GQLKind` renamed
  as `GQLType`\n- types can be derived just with `(Generic,GQLType)`\n- haskell record
  field `type'` will generate GQL Object field `type`\n- public API (all other modules
  are hidden):\n  - Data.Morpheus\n  - Data.Morpheus.Kind\n  - Data.Morpheus.Types\n
  \ - Data.Morpheus.Execution.Subscription\n\n### Fixed:\n\n- parser can read fields
  with digits like: a1 , \\_1\n- you can use Wrapped type and Wrapped Primitive Types
  issue #136:\n  - wrapped TypesNames will be separated with \"\\_\" : typeName(Either
  A B) -> \"Either_A_B\"\n- introspection:\n  - argument supports `Non-Null` and `List`\n
  \ - every field has correct kind\n\n### Removed\n\n- `GQLArgs`: you can derive arguments
  just with `Generic` without `GQLArgs`\n- `GQLObject`: replaced with instance `type
  instance KIND <Type> = OBJECT`\n- `GQLEnum`: replaced with instance `type instance
  KIND <Type> = ENUM`\n- `GQLInput`: replaced with instance `type instance KIND <Type>
  = INPUT_OBJECT`\n- `Typeable` : with new deriving it is not required anymore\n-
  `Wrapper`: with TypeFamilies there is no need for `Wrapper`\n- `a ::-> b` is Replaced
  by `a -> ResM b` where `ResM` is alias for `Resolver IO a`\n- `GQLMutation` , `GQLQuery`
  : with new deriving it is not required anymore\n- `Resolver` constructor replaced
  by functions:\n  - `gqlResolver` : packs `m Either String a` to `Resolver m a`\n
  \ - `gqlEffectResolver`: resolver constructor for effectedResolver\n  - `liftEffectResolver`:
  lifts normal resolver to Effect Resolver.\n"
basic-deps:
  bytestring: ! '>=0.10.4 && <0.11'
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  uuid: ! '>=1.0 && <=1.4'
  megaparsec: ! '>=7.0.0 && <9.0.0'
  websockets: ! '>=0.11.0 && <=0.13'
  th-lift-instances: ! '>=0.1.1 && <=0.2.0'
  containers: ! '>=0.4.2.1 && <0.7'
  mtl: ! '>=2.0 && <=2.3'
  transformers: ! '>=0.3.0.0 && <0.6'
  scientific: ! '>=0.3.6.2 && <0.4'
  aeson: ! '>=1.4.4.0 && <=1.6'
  template-haskell: ! '>=2.0 && <=2.16'
  vector: ! '>=0.12.0.1 && <0.13'
all-versions:
- 0.0.1
- 0.1.0
- 0.1.1
- 0.2.0
- 0.2.1
- 0.2.2
- 0.3.0
- 0.3.1
- 0.4.0
- 0.5.0
- 0.6.0
- 0.6.1
- 0.6.2
- 0.7.0
- 0.7.1
- 0.8.0
- 0.9.0
author: Daviti Nalchevanidze
latest: 0.9.0
description-type: markdown
description: "# Morpheus GraphQL [![Hackage](https://img.shields.io/hackage/v/morpheus-graphql.svg)](https://hackage.haskell.org/package/morpheus-graphql)
  [![CircleCI](https://circleci.com/gh/morpheusgraphql/morpheus-graphql.svg?style=svg)](https://circleci.com/gh/morpheusgraphql/morpheus-graphql)\n\nBuild
  GraphQL APIs with your favourite functional language!\n\nMorpheus GraphQL (Server
  & Client) helps you to build GraphQL APIs in Haskell with native Haskell types.\nMorpheus
  will convert your Haskell types to a GraphQL schema and all your resolvers are just
  native Haskell functions. Mopheus GraphQL can also convert your GraphQL Schema or
  Query to Haskell types and validate them in compile time.\n\nMorpheus is still in
  an early stage of development, so any feedback is more than welcome, and we appreciate
  any contribution!\nJust open an issue here on GitHub, or join [our Slack channel](https://morpheus-graphql-slack-invite.herokuapp.com/)
  to get in touch.\n\n## Getting Started\n\n### Setup\n\nTo get started with Morpheus,
  you first need to add it to your project's dependencies, as follows (assuming you're
  using hpack):\n\n_package.yml_\n\n```yaml\ndependencies:\n  - morpheus-graphql\n```\n\nAdditionally,
  you should tell stack which version to pick:\n\n_stack.yml_\n\n```yaml\nresolver:
  lts-14.8\n\nextra-deps:\n  - morpheus-graphql-0.9.0\n```\n\nAs Morpheus is quite
  new, make sure stack can find morpheus-graphql by running `stack upgrade` and `stack
  update`\n\n### Building your first GraphQL API\n\n### with GraphQL syntax\n\n_schema.gql_\n\n```gql\ntype
  Query {\n  deity(name: String!): Deity!\n}\n\n\"\"\"\nDescription for Deity\n\"\"\"\ntype
  Deity {\n  \"\"\"\n  Description for name\n  \"\"\"\n  name: String!\n  power: String
  String! @deprecated(reason: \"some reason for\")\n}\n```\n\n_API.hs_\n\n```haskell\n{-#
  LANGUAGE DeriveGeneric         #-}\n{-# LANGUAGE FlexibleContexts      #-}\n{-#
  LANGUAGE FlexibleInstances     #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-#
  LANGUAGE NamedFieldPuns        #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-#
  LANGUAGE ScopedTypeVariables   #-}\n{-# LANGUAGE TemplateHaskell       #-}\n{-#
  LANGUAGE TypeFamilies          #-}\n\nmodule API (api) where\n\nimport qualified
  Data.ByteString.Lazy.Char8 as B\n\nimport           Data.Morpheus              (interpreter)\nimport
  \          Data.Morpheus.Document     (importGQLDocumentWithNamespace)\nimport           Data.Morpheus.Types
  \       (GQLRootResolver (..), IORes)\nimport           Data.Text                  (Text)\n\nimportGQLDocumentWithNamespace
  \"schema.gql\"\n\nrootResolver :: GQLRootResolver IO () Query Undefined Undefined\nrootResolver
  =\n  GQLRootResolver\n    {\n      queryResolver = Query {queryDeity},\n      mutationResolver
  = Undefined,\n      subscriptionResolver = Undefined\n    }\n  where\n    queryDeity
  QueryDeityArgs {queryDeityArgsName} = pure Deity\n      {\n        deityName = pure
  \"Morpheus\"\n      , deityPower = pure (Just \"Shapeshifting\")\n      }\n\napi
  :: ByteString -> IO ByteString\napi = interpreter rootResolver\n```\n\nTemplate
  Haskell Generates types: `Query` , `Deity`, `DeityArgs`, that can be used by `rootResolver`\n\n`descriptions`
  and `deprecations` will be displayed in introspection.\n\n`importGQLDocumentWithNamespace`
  will generate Types with namespaced fields. If you don't need napespacing use `importGQLDocument`\n\n###
  with Native Haskell Types\n\nTo define a GraphQL API with Morpheus we start by defining
  the API Schema as a native Haskell data type,\nwhich derives the `Generic` typeclass.
  Lazily resolvable fields on this `Query` type are defined via `a -> IORes b`, representing
  resolving a set of arguments `a` to a concrete value `b`.\n\n```haskell\ndata Query
  m = Query\n  { deity :: DeityArgs -> m Deity\n  } deriving (Generic, GQLType)\n\ndata
  Deity = Deity\n  { fullName :: Text         -- Non-Nullable Field\n  , power    ::
  Maybe Text   -- Nullable Field\n  } deriving (Generic,GQLType)\n\ndata DeityArgs
  = DeityArgs\n  { name      :: Text        -- Required Argument\n  , mythology ::
  Maybe Text  -- Optional Argument\n  } deriving (Generic)\n```\n\nFor each field
  in the `Query` type defined via `a -> m b` (like `deity`) we will define a resolver
  implementation that provides the values during runtime by referring to\nsome data
  source, e.g. a database or another API. Fields that are defined without `a -> m
  b` you can just provide a value.\n\nIn above example, the field of `DeityArgs` could
  also be named using reserved identities (such as: `type`, `where`, etc), in order
  to avoid conflict, a prime symbol (`'`) must be attached. For example, you can have:\n\n```haskell\ndata
  DeityArgs = DeityArgs\n  { name      :: Text        -- Required Argument\n  , mythology
  :: Maybe Text  -- Optional Argument\n  , type'     :: Text\n  } deriving (Generic)\n```\n\nThe
  field name in the final request will be `type` instead of `type'`. The Morpheus
  request parser converts each of the reserved identities in Haskell 2010 to their
  corresponding names internally. This also applies to selections.\n\n```haskell\nresolveDeity
  :: DeityArgs -> IORes e Deity\nresolveDeity DeityArgs { name, mythology } = liftEither
  $ dbDeity name mythology\n\naskDB :: Text -> Maybe Text -> IO (Either String Deity)\naskDB
  = ...\n```\n\nTo make this `Query` type available as an API, we define a `GQLRootResolver`
  and feed it to the Morpheus `interpreter`. A `GQLRootResolver` consists of `query`,
  `mutation` and `subscription` definitions, while we omit the latter for this example:\n\n```haskell\nrootResolver
  :: GQLRootResolver IO () Query Undefined Undefined\nrootResolver =\n  GQLRootResolver\n
  \   { queryResolver = Query {deity = resolveDeity}\n    , mutationResolver = Undefined\n
  \   , subscriptionResolver = Undefined\n    }\n\ngqlApi :: ByteString -> IO ByteString\ngqlApi
  = interpreter rootResolver\n```\n\nAs you can see, the API is defined as `ByteString
  -> IO ByteString` which we can either invoke directly or use inside an arbitrary
  web framework\nsuch as `scotty` or `serverless-haskell`. We'll go for `scotty` in
  this example:\n\n```haskell\nmain :: IO ()\nmain = scotty 3000 $ post \"/api\" $
  raw =<< (liftIO . gqlApi =<< body)\n```\n\nIf we now send a POST request to `http://localhost:3000/api`
  with a GraphQL Query as body for example in a tool like `Insomnia`:\n\n```GraphQL\nquery
  GetDeity {\n  deity (name: \"Morpheus\") {\n    fullName\n    power\n  }\n}\n```\n\nour
  query will be resolved!\n\n```JSON\n{\n  \"data\": {\n    \"deity\": {\n      \"fullName\":
  \"Morpheus\",\n      \"power\": \"Shapeshifting\"\n    }\n  }\n}\n```\n\n## Serverless
  Example\n\nIf you are interested in creating a `Morpheus GraphQL` API with `Serverless`,
  you should take a look at our example in this repository:\n[_Mythology API_](https://github.com/morpheusgraphql/mythology-api)
  it is our example project build with `Morpheus GraphQL` and `Serverless-Haskell`,\nwhere
  you can query different mythology characters with `GraphiQL`.\n\nMythology API is
  deployed on : [_api.morpheusgraphql.com_](https://api.morpheusgraphql.com) where
  you can test it with `GraphiQL`\n\n![Mythology Api](https://morpheusgraphql.com/assets/img/mythology-api.png
  \"mythology-api\")\n\n## Advanced topics\n\n### Enums\n\nYou can use Union Types
  as Enums, but they're not allowed to have any parameters.\n\n```haskell\ndata City\n
  \ = Athens\n  | Sparta\n  | Corinth\n  | Delphi\n  | Argos\n  deriving (Generic)\n\ninstance
  GQLType City where\n  type KIND City = ENUM\n```\n\n### Union types\n\nTo use union
  type, all you have to do is derive the `GQLType` class. Using GraphQL [_fragments_](https://graphql.org/learn/queries/#fragments),
  the arguments of each data constructor can be accessed from the GraphQL client.\n\n```haskell\ndata
  Character\n  = CharacterDeity Deity -- Only <tyconName><conName> should generate
  direct link\n  -- RECORDS\n  | Creature { creatureName :: Text, creatureAge :: Int
  }\n  --- Types\n  | SomeDeity Deity\n  | CharacterInt Int\n  | SomeMutli Int Text\n
  \ --- ENUMS\n  | Zeus\n  | Cronus\n  deriving (Generic, GQLType)\n```\n\nwhere `Deity`
  is an object.\n\nAs you see there are different kinds of unions. `morpheus` handles
  them all.\n\nThis type will be represented as\n\n```gql\nunion Character =\n    Deity
  # unwrapped union: becouse Character + Deity = CharacterDeity\n  | Creature\n  |
  SomeDeity # wrapped union: becouse Character + Deity != SomeDeity\n  | CharacterInt\n
  \ | SomeMutli\n  | CharacterEnumObject # object wrapped for enums\n\ntype Creature
  {\n  creatureName: String!\n  creatureAge: Int!\n}\n\ntype SomeDeity {\n  _0: Deity!\n}\n\ntype
  CharacterInt {\n  _0: Int!\n}\n\ntype SomeMutli {\n  _0: Int!\n  _1: String!\n}\n\n#
  enum\ntype CharacterEnumObject {\n  enum: CharacterEnum!\n}\n\nenum CharacterEnum
  {\n  Zeus\n  Cronus\n}\n```\n\n- namespaced Unions: `CharacterDeity` where `Character`
  is TypeConstructor and `Deity` referenced object (not scalar) type: will be generate
  regular graphql Union\n  \n- for all other unions will be generated new object type.
  for types without record syntaxt, fields will be automatally indexed.\n\n- all empty
  constructors in union will be summed in type `<tyConName>Enum` (e.g `CharacterEnum`),
  this enum will be wrapped in `CharacterEnumObject` and added to union members.\n\n###
  Scalar types\n\nTo use custom scalar types, you need to provide implementations
  for `parseValue` and `serialize` respectively.\n\n```haskell\ndata Odd = Odd Int
  \ deriving (Generic)\n\ninstance GQLScalar Odd where\n  parseValue (Int x) = pure
  $ Odd (...  )\n  parseValue (String x) = pure $ Odd (...  )\n  serialize  (Odd value)
  = Int value\n\ninstance GQLType Odd where\n  type KIND Odd = SCALAR\n```\n\n###
  Applicative and Monad instance\n\nThe `Resolver` type has `Applicative` and `Monad`
  instances that can be used to compose resolvers.\n\n### Introspection\n\nMorpheus
  converts your schema to a GraphQL introspection automatically. You can use tools
  like `Insomnia` to take a\nlook at the introspection and validate your schema.\nIf
  you need a description for your GQLType inside of the introspection you can define
  the GQLType instance manually\nand provide an implementation for the `description`
  function:\n\n```haskell\ndata Deity = Deity\n{ ...\n} deriving (Generic)\n\ninstance
  GQLType Deity where\n  description = const \"A supernatural being considered divine
  and sacred\"\n```\n\nscreenshots from `Insomnia`\n\n![alt text](https://morpheusgraphql.com/assets/img/introspection/spelling.png
  \"spelling\")\n![alt text](https://morpheusgraphql.com/assets/img/introspection/autocomplete.png
  \"autocomplete\")\n![alt text](https://morpheusgraphql.com/assets/img/introspection/type.png
  \"type\")\n\n## Handling Errors\n\nfor errors you can use use either `liftEither`
  or `failRes`:\nat the and they have same result.\n\nwith `liftEither`\n\n```haskell\nresolveDeity
  :: DeityArgs -> IORes e Deity\nresolveDeity DeityArgs {} = liftEither $ dbDeity\n\ndbDeity
  ::  IO Either Deity\ndbDeity = pure $ Left \"db error\"\n```\n\nwith `failRes`\n\n```haskell\nresolveDeity
  :: DeityArgs -> IORes e Deity\nresolveDeity DeityArgs { } = failRes \"db error\"\n```\n\n###
  Mutations\n\nIn addition to queries, Morpheus also supports mutations. The behave
  just like regular queries and are defined similarly:\n\n```haskell\nnewtype Mutation
  m = Mutation\n  { createDeity :: MutArgs -> m Deity\n  } deriving (Generic, GQLType)\n\nrootResolver
  :: GQLRootResolver IO  () Query Mutation Undefined\nrootResolver =\n  GQLRootResolver\n
  \   { queryResolver = Query {...}\n    , mutationResolver = Mutation { createDeity
  }\n    , subscriptionResolver = Undefined\n    }\n    where\n      -- Mutation Without
  Event Triggering\n      createDeity :: MutArgs -> ResolveM () IO Deity\n      createDeity_args
  = lift setDBAddress\n\ngqlApi :: ByteString -> IO ByteString\ngqlApi = interpreter
  rootResolver\n```\n\n### Subscriptions\n\nim morpheus subscription and mutation
  communicating with Events,\n`Event` consists with user defined `Channel` and `Content`.\n\nEvery
  subscription has its own Channel by which it will be triggered\n\n```haskell\ndata
  Channel\n  = ChannelA\n  | ChannelB\n\ndata Content\n  = ContentA Int\n  | ContentB
  Text\n\ntype MyEvent = Event Channel Content\n\nnewtype Query m = Query\n  { deity
  :: m Deity\n  } deriving (Generic)\n\nnewtype Mutation m = Mutation\n  { createDeity
  :: m Deity\n  } deriving (Generic)\n\nnewtype Subscription (m ::  * -> * ) = Subscription\n
  \ { newDeity :: m  Deity\n  } deriving (Generic)\n\ntype APIEvent = Event Channel
  Content\n\nrootResolver :: GQLRootResolver IO APIEvent Query Mutation Subscription\nrootResolver
  = GQLRootResolver\n  { queryResolver        = Query { deity = fetchDeity }\n  ,
  mutationResolver     = Mutation { createDeity }\n  , subscriptionResolver = Subscription
  { newDeity }\n  }\n where\n  -- Mutation Without Event Triggering\n  createDeity
  :: ResolveM EVENT IO Address\n  createDeity = MutResolver \\$ do\n      value <-
  lift dbCreateDeity\n      pure (\n        [Event { channels = [ChannelA], content
  = ContentA 1 }],\n        value\n      )\n  newDeity = SubResolver [ChannelA] subResolver\n
  \  where\n    subResolver (Event [ChannelA] (ContentA _value)) = fetchDeity  --
  resolve New State\n    subResolver (Event [ChannelA] (ContentB _value)) = fetchDeity
  \  -- resolve New State\n    subResolver _ = fetchDeity -- Resolve Old State\n```\n\n##
  Morpheus `GraphQL Client` with Template haskell QuasiQuotes\n\n```hs\ndefineByDocumentFile\n
  \   \"./schema.gql\"\n  [gql|\n    query GetHero ($character: Character)\n      {\n
  \       deity (fatherOf:$character) {\n          name\n          power\n          worships
  {\n            deity2Name: name\n          }\n        }\n      }\n  |]\n```\n\nwith
  schema:\n\n```gql\ninput Character {\n  name: String!\n}\n\ntype Deity {\n  name:
  String!\n  worships: Deity\n}\n```\n\nwill validate query and Generate:\n\n- namespaced
  response and variable types\n- instance for `Fetch` typeClass\n\n```hs\ndata GetHero
  = GetHero {\n  deity: DeityDeity\n}\n\n-- from: {user\ndata DeityDeity = DeityDeity
  {\n  name: Text,\n  worships: Maybe DeityWorshipsDeity\n}\n\n-- from: {deity{worships\ndata
  DeityWorshipsDeity = DeityWorshipsDeity {\n  name: Text,\n}\n\ndata GetHeroArgs
  = GetHeroArgs {\n  getHeroArgsCharacter: Character\n}\n\ndata Character = Character
  {\n  characterName: Person\n}\n```\n\nas you see, response type field name collision
  can be handled with GraphQL `alias`.\n\nwith `fetch` you can fetch well typed response
  `GetHero`.\n\n```haskell\n  fetchHero :: Args GetHero -> m (Either String GetHero)\n
  \ fetchHero = fetch jsonRes args\n      where\n        args = GetHeroArgs {getHeroArgsCharacter
  = Person {characterName = \"Zeus\"}}\n        jsonRes :: ByteString -> m ByteString\n
  \       jsonRes = <GraphQL APi>\n```\n\nin this case, `jsonRes` is resolves a request
  into a response in some monad `m`.\n\nA `fetch` resolver implementation against
  [a real API](https://swapi.graph.cool) may look like the following:\n\n```haskell\n{-#
  LANGUAGE OverloadedStrings #-}\n\nimport Data.ByteString.Lazy (ByteString)\nimport
  qualified Data.ByteString.Char8 as C8\nimport Network.HTTP.Req\n\nresolver :: String
  -> ByteString -> IO ByteString\nresolver tok b = runReq defaultHttpConfig $ do\n
  \   let headers = header \"Content-Type\" \"application/json\"\n    responseBody
  <$> req POST (https \"swapi.graph.cool\") (ReqBodyLbs b) lbsResponse headers\n```\n\nthis
  is demonstrated in examples/src/Client/StarWarsClient.hs\n\ntypes can be generated
  from `introspection` too:\n\n```haskell\ndefineByIntrospectionFile \"./introspection.json\"\n```\n\n##
  Morpheus CLI for Code Generating\n\nyou should use [morpheus-graphql-cli](https://github.com/morpheusgraphql/morpheus-graphql-cli)\n\n#
  About\n\n## The name\n\n_Morpheus_ is the greek god of sleep and dreams whose name
  comes from the greek word _μορφή_ meaning form or shape.\nHe is said to be able
  to mimic different forms and GraphQL is good at doing exactly that: Transforming
  data in the shape\nof many different APIs.\n\n## Team\n\nMorpheus is written and
  maintained by [_nalchevanidze_](https://github.com/nalchevanidze)\n\n## Roadmap\n\n-
  Medium future:\n  - Stabilize API\n  - Specification-isomorphic error handling\n-
  Long term:\n  - Support all possible GQL features\n  - Performance optimization\n"
license-name: MIT

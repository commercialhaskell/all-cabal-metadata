homepage: https://morpheusgraphql.com
changelog-type: markdown
hash: 830f6d7671bb11818817d7512d95a03827fc60e2835732dc96d01c0ae541a5bb
test-bench-deps:
  bytestring: ! '>=0.10.4 && <0.11'
  morpheus-graphql: -any
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  uuid: ! '>=1.0 && <=1.4'
  megaparsec: ! '>=7.0.0 && <8.0'
  websockets: ! '>=0.11.0 && <=0.12.5.3'
  containers: ! '>=0.4.2.1 && <0.7'
  lens: -any
  mtl: ! '>=2.0 && <=2.2.2'
  tasty-hunit: -any
  transformers: ! '>=0.3.0.0 && <0.6'
  tasty: -any
  scientific: ! '>=0.3.6.2 && <0.4'
  aeson: -any
  template-haskell: -any
  vector: ! '>=0.12.0.1 && <0.13'
maintainer: d.nalchevanidze@gmail.com
synopsis: Morpheus GraphQL
changelog: |
  ## [0.3.1] - 05.10.2019

  ### Changed

  - removed dependencies: attoparsec , utf8-string
  - updated aeson lower bound up to: 1.4.4.0

  ## [0.3.0] - 04.10.2019

  ### Added

  - user can import GraphQL Document and generate types with it.

    ```haskell
      importGQLDocument "API.gql"
    ```

    this will generate types defined in `API.gql`

  ### Fixed

  - `String` defined in GQLDcoument will be converted to `Text` by template haskell

  - `importGQLDocument` and `gqlDocument` supports Mutation, Subscription and Resolvers with custom Monad

    for example. if we have:

    ```gql
    type Deity {
      name: String!
      power: Power!
    }
    ```

    where `Power` is another object defined by gql schema.
    template haskell will represent this type as:

    ```haskell
       data Deity m = Deity {
         name :: () -> m Text,
         power :: () -> m (Power m)
       }
    ```

    where `m` is resolver Monad.

  - `importGQLDocumentWithNamespace` generates namespaced haskell records. so that you have no more problem with name collision.
    from this gql type:

    ```gql
    type Deity {
      name: (id:Int)String!
      power: Power!
    }
    ```

    will be generated.

    ```haskell
    data Deity m = Deity {
      deityName :: DeityNameArgs -> m Text,
      deityPower :: () -> m (Power m)
    }

    data DeityNameArgs = DeityNameArgs {
      deityNameArgsId :: Int
    }
    ```

  ### Changed

  - `GQLType` is mandatory for every GQL Type (including Query, Mutation and Subscription)
  - subscription Resolver changed

    from:

    ```haskell
      Subscription {newDeity = \args -> Event {channels = [ChannelA], content = newDeityResolver } }
    ```

    to:

    ```haskell
      Subscription {newDeity = \args -> SubResolver {subChannels = [ChannelA], subResolver = newDeityResolver } }
    ```

  ## [0.2.2] - 30.08.2019

  ### Fixed

  - Parser Supports GraphQL multiline comments
  - Morpheus GraphQL Client: Support GraphQL Alias
  - Support of GraphQL Interfaces on GraphQL Document:

    ```gql
    # simple.gql
    interface Node {
      nodeId: ID!
    }

    type SimpleType implements Node {
      nodeId: ID!
      name: String!
    }
    ```

    morpheus compiler will read interfaces and validate implements.
    template haskell will generate haskell types only for types not for interfaces.

    haskell type from `simple.gql`:

    ```haskell
     data SimpleType = SimpleType {
        nodeId :: ID!
        name   :: Text!
      }  deriving (Generic)
    ```

    at the time compiler does not validates field Arguments by interface

  ## [0.2.1] - 23.08.2019

  - assets are added to cabal source files

  ## [0.2.0] - 23.08.2019

  ### Added

  - Parser Supports GraphQL comments
  - Enhanced Subscription: mutation can trigger subscription with arguments
  - Experimental Support of Input Unions
  - GraphQL schema generating with: `Data.Morpheus.Document.toGraphQLDocument`
  - Generating dummy Morpheus Api from `schema.gql`:

    ```
    morpheus build schema/mythology.gql src/MythologyApi.hs
    ```

    [details](https://github.com/morpheusgraphql/morpheus-graphql/issues/184)

  - `convertToJSONName` & `convertToHaskellName` has been extended to support all Haskell 2010 reserved identities. [details](https://github.com/morpheusgraphql/morpheus-graphql/issues/207)

  - `GraphQL Client` with Template haskell QuasiQuotes (Experimental, Not fully Implemented)

    ```haskell
    defineQuery
      [gql|
        query GetHero ($byRealm: Realm)
          {
            deity (realm:$byRealm) {
              power
              fullName
            }
          }
      |]
    ```

    will Generate:

    - response type `GetHero`, `Deity` with `Lens` Instances
    - input types: `GetHeroArgs` , `Realm`
    - instance for `Fetch` typeClass

    so that

    ```haskell
      fetchHero :: Args GetHero -> m (Either String GetHero)
      fetchHero = fetch jsonRes args
          where
            args = GetHeroArgs {byRealm = Just Realm {owner = "Zeus", surface = Just 10}}
            jsonRes :: ByteString -> m ByteString
            jsonRes = <fetch query from server>
    ```

    resolves well typed response `GetHero`.

  - Ability to define `GQLSchema` with GraphQL syntax ,
    so that with this schema

    ```haskell

    [gqlDocument|
      type Query {
        deity (uid: Text! ) : Deity!
      }

      type Deity {
        name  : Text!
        power : Text
      }
    |]

    rootResolver :: GQLRootResolver IO () () Query () ()
    rootResolver =
      GQLRootResolver {queryResolver = return Query {deity}, mutationResolver = pure (), subscriptionResolver = pure ()}
      where
        deity DeityArgs {uid} = pure Deity {name, power}
          where
            name _ = pure "Morpheus"
            power _ = pure (Just "Shapeshifting")
    ```

    Template Haskell Generates types: `Query` , `Deity`, `DeityArgs`, that can be used by `rootResolver`

    generated types are not compatible with `Mutation`, `Subscription`,
    they can be used only in `Query`, but this issue will be fixed in next release

  ### Fixed:

  - Parser supports enums inside input Object
  - fulfilled fragment Validation (added: unusedFragment,nameConflict)
  - correct decoding of Enums with more than 3 constructor #201

  ### Changed

  - WebSocket subProtocol changed from `graphql-subscriptions` to `graphql-ws`

  - type familiy `KIND` is moved into typeClasses `GQLType`, so you should replace

    ```haskell
    type instance KIND Deity = OBJECT

    instance GQLType Deity where
      description  = const "Custom Description for Client Defined User Type"

    data Deity = Deity { fullName :: Text } deriving (Generic)
    ```

    with

    ```haskell
    instance GQLType Deity where
    type KIND Deity = OBJECT
    description = const "Custom Description for Client Defined User Type"

    data Deity = Deity { fullName :: Text } deriving (Generic)
    ```

  - Duplicated variable names in Http requests are validated using `Aeson`'s `jsonNoDup` function. So the following request will
    result in a parsing error

    ```
    {"query":"...",
    "variables":{"email":"foo@mail.net", "email":"bar@mail.net",...}}
    ```

  ## [0.1.1] - 1.07.2019

  ### Fixed:

  - () as Subscription or Mutation does not defines Operator without fields

  ## [0.1.0] - 30.06.2019

  thanks for contributing to: @krisajenkins, @hovind, @vmchale, @msvbg

  ### Added

  - support for Union Types: `type instance KIND <type> = UNION`
  - support of haskell Types: `Map`, `Set`, and Pair `(a,b)`
  - GraphQL Resolver supports custom Monad
  - add `Interpreter` class with instances:

    - `ByteString -> m ByteString` and Lazy `ByteString`, where `m` is resolver monad
    - `Text -> m Text` and Lazy `Text`, where `m` is resolver monad
    - `GQLRequest -> m GQLResponse` , When you using it inside another Component that have Manual `ToJSON` deriving,
      you have to ensure that `GQLResponse` will be encoded with `toEncoding`, and not with `toJSON`.

  - Schema Validation:

    - Name Collision

  - support of Parsing input values: `Objects`,`Arrays`
  - support scalar type: `ID`
  - scalar Types are validated by `GQLScalar` instance function `parseValue`
  - TypeFamily `KIND` with:

    - `SCALAR`
    - `OBJECT`,
    - `ENUM`
    - `INPUT_OBJECT`
    - `UNION`

  - inline Fragments
  - GraphQL [Aliases](https://graphql.org/learn/queries/#aliases)
  - Subscriptions: `GQLSubscription`

    - `a -> EffectM b` operation: is resolver that contains side effect in `EffectM`.
      is used for Mutation and Subscribe communication
    - `gqlEffectResolver ["CHANNEL_ID"]`: packs as effect Resolver.
      if mutation and subscription resolver have same channel then
      every call of mutation will trigger subscription resolver
    - `GQLState`: shared state between `http` and `websocket` server
    - `gqlSocketApp` :converts `interpreter` to `websocket` application
    - `graphql-subscriptions`: `Apollo GraphQL` subProtocol

  - language:
    - Query supports : `__type(name:"type")`
    - On every Object can be selected : `__typename`

  ### Changed

  - `GQLRootResolver`, `GQLType(..)` , `GQLScalar(..)`
    are moved in `Data.Morpheus.Types`
  - `GQLRoot { query, mutation, subscription }` to `GQLRootResolver {queryResolver, mutationResolver, subscriptionResolver}`
  - `interpreter`: can be used in `http` and `websocket` server
  - `GQLKind` renamed as `GQLType`
  - types can be derived just with `(Generic,GQLType)`
  - haskell record field `type'` will generate GQL Object field `type`
  - public API (all other modules are hidden):
    - Data.Morpheus
    - Data.Morpheus.Kind
    - Data.Morpheus.Types
    - Data.Morpheus.Execution.Subscription

  ### Fixed:

  - parser can read fields with digits like: a1 , \_1
  - you can use Wrapped type and Wrapped Primitive Types issue #136:
    - wrapped TypesNames will be separated with "\_" : typeName(Either A B) -> "Either_A_B"
  - introspection:
    - argument supports `Non-Null` and `List`
    - every field has correct kind

  ### Removed

  - `GQLArgs`: you can derive arguments just with `Generic` without `GQLArgs`
  - `GQLObject`: replaced with instance `type instance KIND <Type> = OBJECT`
  - `GQLEnum`: replaced with instance `type instance KIND <Type> = ENUM`
  - `GQLInput`: replaced with instance `type instance KIND <Type> = INPUT_OBJECT`
  - `Typeable` : with new deriving it is not required anymore
  - `Wrapper`: with TypeFamilies there is no need for `Wrapper`
  - `a ::-> b` is Replaced by `a -> ResM b` where `ResM` is alias for `Resolver IO a`
  - `GQLMutation` , `GQLQuery` : with new deriving it is not required anymore
  - `Resolver` constructor replaced by functions:
    - `gqlResolver` : packs `m Either String a` to `Resolver m a`
    - `gqlEffectResolver`: resolver constructor for effectedResolver
    - `liftEffectResolver`: lifts normal resolver to Effect Resolver.
basic-deps:
  warp: -any
  wai-websockets: ! '>=1.0 && <=3.5'
  bytestring: ! '>=0.10.4 && <0.11'
  wai: -any
  morpheus-graphql: -any
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2.8.0 && <0.3'
  text: ! '>=1.2.3.0 && <1.3'
  uuid: ! '>=1.0 && <=1.4'
  megaparsec: ! '>=7.0.0 && <8.0'
  filepath: ! '>=1.1 && <1.5'
  websockets: ! '>=0.11.0 && <=0.12.5.3'
  containers: ! '>=0.4.2.1 && <0.7'
  lens: -any
  mtl: ! '>=2.0 && <=2.2.2'
  transformers: ! '>=0.3.0.0 && <0.6'
  optparse-applicative: ! '>=0.12 && <0.15'
  scientific: ! '>=0.3.6.2 && <0.4'
  scotty: -any
  aeson: ! '>=1.4.4.0 && <=1.6'
  template-haskell: -any
  vector: ! '>=0.12.0.1 && <0.13'
all-versions:
- 0.0.1
- 0.1.0
- 0.1.1
- 0.2.0
- 0.2.1
- 0.2.2
- 0.3.0
- 0.3.1
author: Daviti Nalchevanidze
latest: 0.3.1
description-type: markdown
description: |
  # Morpheus GraphQL [![Hackage](https://img.shields.io/hackage/v/morpheus-graphql.svg)](https://hackage.haskell.org/package/morpheus-graphql) [![CircleCI](https://circleci.com/gh/morpheusgraphql/morpheus-graphql.svg?style=svg)](https://circleci.com/gh/morpheusgraphql/morpheus-graphql)

  Build GraphQL APIs with your favourite functional language!

  Morpheus GraphQL (Server & Client) helps you to build GraphQL APIs in Haskell with native haskell types.
  Morpheus will convert your haskell types to a GraphQL schema and all your resolvers are just native Haskell functions. Mopheus GraphQL can also convert your GraphQL Schema or Query to Haskell types and validate them in compile time.

  Morpheus is still in an early stage of development, so any feedback is more than welcome, and we appreciate any contribution!
  Just open an issue here on GitHub, or join [our Slack channel](https://morpheus-graphql-slack-invite.herokuapp.com/) to get in touch.

  ## Getting Started

  ### Setup

  To get started with Morpheus, you first need to add it to your project's dependencies, as follows (assuming you're using hpack):

  _package.yml_

  ```yaml
  dependencies:
    - morpheus-graphql
  ```

  Additionally, you should tell stack which version to pick:

  _stack.yml_

  ```yaml
  resolver: lts-13.30

  extra-deps:
    - aeson-1.4.4.0
    - time-compat-1.9.2.2
  ```

  As Morpheus is quite new, make sure stack can find morpheus-graphql by running `stack update`

  ### Building your first GrqphQL API

  ### with GraphQL syntax

  _schema.gql_

  ```gql
  type Query {
    deity(name: String!): Deity!
  }

  type Deity {
    name: String!
    power: String
  }
  ```

  _API.hs_

  ```haskell
  {-# LANGUAGE DeriveGeneric         #-}
  {-# LANGUAGE FlexibleContexts      #-}
  {-# LANGUAGE FlexibleInstances     #-}
  {-# LANGUAGE MultiParamTypeClasses #-}
  {-# LANGUAGE NamedFieldPuns        #-}
  {-# LANGUAGE OverloadedStrings     #-}
  {-# LANGUAGE ScopedTypeVariables   #-}
  {-# LANGUAGE TemplateHaskell       #-}
  {-# LANGUAGE TypeFamilies          #-}

  module API (api) where

  import qualified Data.ByteString.Lazy.Char8 as B

  import           Data.Morpheus              (interpreter)
  import           Data.Morpheus.Document     (importGQLDocumentWithNamespace)
  import           Data.Morpheus.Types        (GQLRootResolver (..), IORes)
  import           Data.Text                  (Text)

  importGQLDocumentWithNamespace "schema.gql"

  rootResolver :: GQLRootResolver IO () () (Query IORes) () ()
  rootResolver =
    GQLRootResolver
      {queryResolver = return Query {queryDeity}, mutationResolver = pure (), subscriptionResolver = pure ()}
    where
      queryDeity QueryDeityArgs {queryDeityArgsName} = pure Deity {deityName, deityPower}
        where
          deityName _ = pure "Morpheus"
          deityPower _ = pure (Just "Shapeshifting")

  api :: ByteString -> IO ByteString
  api = interpreter rootResolver
  ```

  Template Haskell Generates types: `Query` , `Deity`, `DeityArgs`, that can be used by `rootResolver`

  `importGQLDocumentWithNamespace` will generate Types with namespaced fields. if you don't need napespacing use `importGQLDocument`

  ### with Native Haskell Types

  To define a GraphQL API with Morpheus we start by defining the API Schema as a native Haskell data type,
  which derives the `Generic` typeclass. Lazily resolvable fields on this `Query` type are defined via `a -> IORes b`, representing resolving a set of arguments `a` to a concrete value `b`.

  ```haskell
  data Query = Query
    { deity :: DeityArgs -> IORes Deity
    } deriving (Generic, GQLType)

  data Deity = Deity
    { fullName :: Text         -- Non-Nullable Field
    , power    :: Maybe Text   -- Nullable Field
    } deriving (Generic)

  instance GQLType Deity where
    type  KIND Deity = OBJECT

  data DeityArgs = DeityArgs
    { name      :: Text        -- Required Argument
    , mythology :: Maybe Text  -- Optional Argument
    } deriving (Generic)
  ```

  For each field in the `Query` type defined via `a -> IORes b` (like `deity`) we will define a resolver implementation that provides the values during runtime by referring to
  some data source, e.g. a database or another API. Fields that are defined without `a -> IORes b` you can just provide a value.

  In above example, the field of `DeityArgs` could also be named using reserved identities (such as: `type`, `where`, etc), in order to avoid conflict, a prime symbol (`'`) must be attached. For example, you can have:

  ```haskell
  data DeityArgs = DeityArgs
    { name      :: Text        -- Required Argument
    , mythology :: Maybe Text  -- Optional Argument
    , type'     :: Text
    } deriving (Generic)
  ```

  The field name in the final request will be `type` instead of `type'`. The Morpheus request parser converts each of the reserved identities in Haskell 2010 to their corresponding names internally. This also applies to selections.

  ```haskell
  resolveDeity :: DeityArgs -> IORes Deity
  resolveDeity args = gqlResolver $ askDB (name args) (mythology args)

  askDB :: Text -> Maybe Text -> IO (Either String Deity)
  askDB = ...
  ```

  Note that the type `a -> IORes b` is just Synonym for `a -> ExceptT String IO b`

  To make this `Query` type available as an API, we define a `GQLRootResolver` and feed it to the Morpheus `interpreter`. A `GQLRootResolver` consists of `query`, `mutation` and `subscription` definitions, while we omit the latter for this example:

  ```haskell
  rootResolver :: GQLRootResolver IO () () Query () ()
  rootResolver =
    GQLRootResolver
      { queryResolver = return Query {deity = resolveDeity}
      , mutationResolver = return ()
      , subscriptionResolver = return ()
      }

  gqlApi :: ByteString -> IO ByteString
  gqlApi = interpreter rootResolver
  ```

  As you can see, the API is defined as `ByteString -> IO ByteString` which we can either invoke directly or use inside an arbitrary web framework
  such as `scotty` or `serverless-haskell`. We'll go for `scotty` in this example:

  ```haskell
  main :: IO ()
  main = scotty 3000 $ post "/api" $ raw =<< (liftIO . gqlApi =<< body)
  ```

  If we now send a POST request to `http://localhost:3000/api` with a GraphQL Query as body for example in a tool like `Insomnia`:

  ```GraphQL
  query GetDeity {
    deity (name: "Morpheus") {
      fullName
      power
    }
  }
  ```

  our query will be resolved!

  ```JSON
  {
    "data": {
      "deity": {
        "fullName": "Morpheus",
        "power": "Shapeshifting"
      }
    }
  }
  ```

  ## Serverless Example

  If you are interested in creating a `Morpheus GraphQL` API with `Serverless`, you should take a look at our example in this repository:
  [_Mythology API_](https://github.com/morpheusgraphql/mythology-api) it is our example project build with `Morpheus GraphQL` and `Serverless-Haskell`,
  where you can query different mythology characters with `GraphiQL`.

  Mythology API is deployed on : [_api.morpheusgraphql.com_](https://api.morpheusgraphql.com) where you can test it with `GraphiQL`

  ![Mythology Api](./assets/img/mythology-api.png "mythology-api")

  ## Advanced topics

  ### Enums

  You can use Union Types as Enums, but they're not allowed to have any parameters.

  ```haskell
  data City
    = Athens
    | Sparta
    | Corinth
    | Delphi
    | Argos
    deriving (Generic)

  instance GQLType City where
    type KIND City = ENUM
  ```

  ### Union types

  To use union type, all you have to do is derive the `GQLType` class. Using GraphQL [_fragments_](https://graphql.org/learn/queries/#fragments), the arguments of each data constructor can be accessed from the GraphQL client.

  ```haskell
  data Character
    = DEITY Deity
    | HUMAN Human
    deriving (Generic)

  instance GQLType Character where
    type KIND City = UNION
  ```

  ### Scalar types

  To use custom scalar types, you need to provide implementations for `parseValue` and `serialize` respectively.

  ```haskell
  data Odd = Odd Int  deriving (Generic)

  instance GQLScalar Odd where
    parseValue (Int x) = pure $ Odd (...  )
    parseValue (String x) = pure $ Odd (...  )
    serialize  (Odd value) = Int value

  instance GQLType Odd where
    type KIND Odd = SCALAR
  ```

  ### Applicative and Monad instance

  The `Resolver` type has `Applicative` and `Monad` instances that can be used to compose resolvers.

  ### Introspection

  Morpheus converts your schema to a GraphQL introspection automatically. You can use tools like `Insomnia` to take a
  look at the introspection and validate your schema.
  If you need a description for your GQLType inside of the introspection you can define the GQLType instance manually
  and provide an implementation for the `description` function:

  ```haskell
  data Deity = Deity
  { ...
  } deriving (Generic)

  instance GQLType Deity where
    description = const "A supernatural being considered divine and sacred"
  ```

  screenshots from `Insomnia`

  ![alt text](./assets/img/introspection/spelling.png "spelling")
  ![alt text](./assets/img/introspection/autocomplete.png "autocomplete")
  ![alt text](./assets/img/introspection/type.png "type")

  ### Mutations

  In addition to queries, Morpheus also supports mutations. The behave just like regular queries and are defined similarly:
  Just exchange deriving `GQLQuery` for `GQLMutation` and declare them separately at the `GQLRootResolver` definition

  ```haskell
  newtype Mutation = Mutation
    { createDeity :: Form -> IOMutRes Deity
    } deriving (Generic, GQLType)

  createDeityMutation :: Form -> IOMutRes Deity
  createDeityMutation = ...

  rootResolver :: GQLRootResolver IO Query Mutation ()
  rootResolver =
    GQLRootResolver
      { queryResolver = return Query {...}
      , mutationResolver = return Mutation {
         createDeity = createDeityMutation
      }
      , subscriptionResolver = return ()
      }

  gqlApi :: ByteString -> IO ByteString
  gqlApi = interpreter rootResolver
  ```

  ### Subscriptions

  im morpheus subscription and mutation communicating with Events,
  `Event` consists with user defined `Channel` and `Content`.

  every subscription has own Channel by which will be triggered

  ```haskell

  data Channel
    = ChannelA
    | ChannelB

  data Content
    = ContentA Int
    | ContentB Text

  newtype Query = Query
    { deity :: () -> IORes Deity
    } deriving (Generic, GQLType)

  newtype Mutation = Mutation
    { createDeity :: () -> IOMutRes Channel Content Deity
    } deriving (Generic, GQLType)

  newtype Subscription = Subscription
    { newDeity :: () -> IOSubRes Channel Content Deity
    } deriving (Generic, GQLType)

  rootResolver :: GQLRootResolver IO Channel Content Query Mutation Subscription
  rootResolver =
    GQLRootResolver
      { queryResolver = return Query {deity = const fetchDeity}
      , mutationResolver = return Mutation {createDeity}
      , subscriptionResolver = return Subscription {newDeity}
      }
    where
      fetchDeity = resolver $ dbDeity "" Nothing
      createDeity _args = toMutResolver [Event {channels = [ChannelA], content = ContentA 1}] fetchDeity
      newDeity _args = SubResolver {subChannels = [ChannelA], subResolver}
        where
          subResolver (Event [ChannelA] (ContentA _value)) = resolver $ dbDeity "" Nothing -- resolve New State
          subResolver (Event [ChannelA] (ContentB value))  = resolver $ dbDeity value Nothing -- resolve New State
          subResolver _                                    = fetchDeity -- Resolve Old State
  ```

  ## Morpheus `GraphQL Client` with Template haskell QuasiQuotes

  ```haskell
  defineByDocumentFile
      "./schema.gql"
    [gql|
      query GetHero ($byRealm: Realm)
        {
          deity (realm:$byRealm) {
            power
            fullName
          }
        }
    |]
  ```

  will validate query and Generate:

  - response type `GetHero`, `Deity` with `Lens` Instances
  - input types: `GetHeroArgs` , `Realm`
  - instance for `Fetch` typeClass

  so that

  ```haskell
    fetchHero :: Args GetHero -> m (Either String GetHero)
    fetchHero = fetch jsonRes args
        where
          args = GetHeroArgs {byRealm = Just Realm {owner = "Zeus", surface = Just 10}}
          jsonRes :: ByteString -> m ByteString
          jsonRes = <GraphQL APi>
  ```

  resolves well typed response `GetHero`.

  except: `defineByDocumentFile` you can use:

  ```haskell
  defineByIntrospectionFile "./introspection.json"
  ```

  or

  `defineByIntrospection` where you can directly connect it to server

  ## Morpheus CLI for Code Generating

  Generating dummy Morpheus Api from `schema.gql`

  ```
  morpheus build src/schem.gql src/GQLApi.hs
  ```

  this command will generate Haskell API and resolvers,
  resolvers will resolve default values for every object

  # About

  ## The name

  _Morpheus_ is the greek god of sleep and dreams whose name comes from the greek word _μορφή_ meaning form or shape.
  He is said to be able to mimic different forms and GraphQL is good at doing exactly that: Transforming data in the shape
  of many different APIs.

  ## Team

  Morpheus is written and maintained by [_nalchevanidze_](https://github.com/nalchevanidze)

  ## Roadmap

  - Medium future:
    - Stabilize API
    - Specification-isomorphic error handling
  - Long term:
    - Support all possible GQL features
    - Performance optimization
license-name: BSD-3-Clause

homepage: http://justinethier.github.com/husk-scheme
changelog-type: markdown
hash: b0b0d6940f47beb651171b132987cdfadfa73c2a0acd7919e0e41748651eeef0
test-bench-deps: {}
maintainer: Justin Ethier <github.com/justinethier>
synopsis: R5RS Scheme interpreter, compiler, and library.
changelog: "v3.19.4\n--------\n\nBug fixes:\n\n- Incorporated fixes to allow husk
  to build with newer versions of GHC 8.\n\nv3.19.4\n--------\n\nBug fixes:\n\n- Import
  `(scheme)` in SRFI 1, to prevent problems with missing the `receive` macro in compiled
  programs.\n\nv3.19.3\n--------\n\nBug Fixes:\n\n- Fixed compilation errors in `FFI.hs`.\n\nv3.19.2\n--------\n\nNew
  Features:\n\n- Allow a `default` thunk to be passed to `hash-table-ref`.\n- Added
  `hash-table-ref/default`.\n\nBug Fixes:\n\n- Fixed `rational?` to properly handle
  floating-point numbers.\n- Migrated `string-fill!` from a macro to a function. This
  makes it easier to redefine, for example per SRFI 13.\n\nv3.19.1\n--------\n\nBug
  Fixes:\n\n- Allow `real-part` and `imag-part` to work with all types of numbers.
  For example, `(imag-part 2.5)` no longer throws an error.\n- Applied a fix from
  Rohan Drape to allow `Compiler` and `Numerical` modules to build in GHC 7.10.1.\n\n\nv3.19\n--------\n\nNew
  Features:\n\n- Added support for displaying call history when an error is thrown:\n\n
  \       huski> ((lambda () (vector-length \"v\")))\n        Invalid type: expected
  vector, found \"v\"\n\n        Call History:\n        #0: (vector-length \"v\")\n
  \       #1: ((lambda () (vector-length \"v\")))\n\n  Sorry this took so long, as
  it should be a tremendous help for debugging!\n- Print the number of received arguments
  when displaying an \"incorrect number of arguments\" error message. Also unbox any
  objects before displaying the error message.\n- Allow `read-all` to read from `stdin`
  when no arguments are received.\n\nBug Fixes:\n\n- Fixed bugs in `open-input-string`
  and `open-byte-vector` that prevented a variable being passed as the \"input\" argument.
  Thanks to Dan Cecile for the bug report!\n- Fixed a bug that could cause an infinite
  loop during macro expansion. Thanks to Dan Cecile for this report as well.\n- Return
  the empty string from `string-append` if no arguments are received, instead of throwing
  an error.\n- Throw an error when a function that takes a variable number of arguments
  is called without the minimum number of required arguments. For example `(map list)`
  should throw an error because at least 2 arguments are required.\n- Use `System.Process`
  instead of deprecated `System.Cmd`.\n\nv3.18\n--------\n\nNew Features:\n\n- Added
  `exit` from R<sup>7</sup>RS.\n- Added support for [SRFI 28 - Basic Format Strings](http://srfi.schemers.org/srfi-28/srfi-28.html).\n\nBug
  Fixes:\n\n- Fixed bugs with `syntax-rules` where:\n    - A literal identifier may
  not have been matched in a sub-macro if macro hygiene renamed the input.\n    -
  The environment of macro definition may be overwritten during expansion of a `syntax-rules`
  macro contained in another macro. This could cause macros defined in a library -
  but not exported from the library - to incorrectly fail to expand because they are
  not in scope.\n- `for-each` no longer throws an error when an empty list is received.\n-
  In compiled code, the `let-syntax` and `letrec-syntax` forms are now available to
  `eval` at runtime.\n- Added several missing I/O functions to the export list of
  the `(scheme base)` library.\n- bholst added `Unpacker` to the exports from `Language.Scheme.Primitives`,
  as it is required by `unpackEquals`.\n- bholst fixed many comments in the Haddock
  documentation.\n\nv3.17.1\n--------\n\n- Added `call-with-port` from R<sup>7</sup>RS.\n\nRefactoring:\n\n-
  Improved passing of extra arguments within the interpreter by removing the `extraReturnArgs`
  parameter from `Continuation` and adding it as an extra parameter to the `continueEval`
  function. That way a new `Continuation` object does not need to be created each
  time the function is called.\n- Reduced size of compiled code by approximately 10%.\n\nBug
  Fixes:\n\n- Added error checking to many I/O functions to prevent crashes when using
  a port that has already been closed.\n- Added optional start/end arguments to `string->vector`,
  `vector->string`, `vector-copy!`, and `string-copy!`.\n\nv3.17\n--------\n\n- Added
  support for [`define-record-type`](http://justinethier.github.io/husk-scheme/manual/node57.html)
  from R<sup>7</sup>RS and SRFI 9. This syntax allows creation of new disjoint types
  supporting access to multiple fields.\n- Added support for parameter objects from
  R<sup>7</sup>RS and SRFI 39. See [dynamic bindings](http://justinethier.github.io/husk-scheme/manual/node41.html)
  in the user manual for more information.\n- Added a `(scheme process-context)` library
  containing the following functions:\n     - [`emergency-exit`](http://justinethier.github.io/husk-scheme/manual/node86.html#emergency-exit)\n
  \    - [`exit-fail`](http://justinethier.github.io/husk-scheme/manual/node86.html#exit-fail)\n
  \    - [`exit-success`](http://justinethier.github.io/husk-scheme/manual/node86.html#exit-success)\n
  \    - [`get-environment-variable`](http://justinethier.github.io/husk-scheme/manual/node86.html#get-environment-variable)\n
  \    - [`get-environment-variables`](http://justinethier.github.io/husk-scheme/manual/node86.html#get-environment-variables)\n
  \    - [`system`](http://justinethier.github.io/husk-scheme/manual/node86.html#system)\n\nBug
  Fixes:\n\n- Fixed a macro bug where the last element of a pattern's improper list
  may not be matched correctly if there is an ellipsis earlier in the list.\n- Prevent
  infinite recursion when evaluating a pointer that contains a pointer to itself.\n-
  Fixed the compiler to add full support for splicing of `begin` definitions.\n- Updated
  `dynamic-wind` to return the value from the `during` thunk instead of the `after`
  thunk.\n\nv3.16.1\n--------\n\n- Allow import of a library in the same directory
  as a program. For example to import `lib.sld`:\n\n        (import (lib))\n\nBug
  Fixes:\n\n- Husk no longer throws an error during expansion of a library macro that
  references another macro which is not exported from the same library.\n- Fixed a
  bug where a `syntax-rules` macro's literal identifier would not match the input
  when both identifiers are equal and both have no lexical binding.\n\nv3.16\n--------\n\n-
  Improved import of libraries:\n\n    - Husk now detects cyclic dependencies and
  throws an error instead of going into an infinite loop.\n    - Each library is only
  evaluated once during the import process.\n\n- `begin` now has the ability to evaluate
  contained expressions and definitions as if the enclosing `begin` were not present,
  per R<sup>7</sup>RS. For example:\n\n        huski> x\n        Getting an unbound
  variable: x\n        huski> (begin (define x 28) x)\n        28\n        huski>
  x\n        28\n\n- Added the following R<sup>7</sup>RS I/O functions: \n\n    -
  `get-output-bytevector`\n    - `get-output-string`\n    - `open-input-bytevector`\n
  \   - `open-input-string`\n    - `open-output-bytevector`\n    - `open-output-string`\n
  \   - `read-string`\n    - `write-string`\n\n- Added an `-i` command line option
  to `huski`. This option will start the interactive REPL after a file specified on
  the command line is executed, and has no effect if no file is specified.\n\nHaskell
  API:\n\n- The `Port` data type has been extended to include an optional in-memory
  buffer:\n \n        Port Handle (Maybe Knob)\n\n  These changes are isolated in
  husk, but if your code uses any `Port` constructors, you would need to change them,
  EG: `Port _ Nothing`.\n\n\nv3.15.2\n--------\n\nBug fixes:\n\n- The `(husk random)`
  library's `randint` function no longer throws a runtime error when called.\n- The
  `newline` function now accepts a port as an optional second argument, instead of
  throwing an error.\n\nv3.15.1\n--------\n\nThis is a small bug fix release:\n\n-
  Preserve macro hygiene when using code that contains explicit renaming macros contained
  within syntax-rules macros. Previously, the syntax-rules system would not pass renamed
  variables across to the ER system. So an identifier could be renamed by syntax-rules
  but the ER macro would then have no knowledge of the rename and would be unable
  to use `rename` to make the identifier hygienic. For example, the code:\n\n        (let
  ((unquote 'foo)) `(,'bar))\n\n Should evaluate to `((unquote (quote bar)))`.\n\n-
  Added support for multi-line input to `huski`.\n- Fixed GHC compiler warnings when
  building with `-Wall`.\n\nv3.15\n--------\n\nThe big change for this release is
  an online [User Manual](http://justinethier.github.io/husk-scheme/manual/index.html)
  based on the R<sup>7</sup>RS, that documents Husk's Scheme and Haskell APIs, and
  explains the Scheme language as implemented by Husk. This is going to be a work-in-progress
  but is mostly complete, and can be used immediately as a reference.\n\nIn addition,
  many smaller fixes and enhancements are included:\n\n- Improved library support
  so that examples no longer require running in a special mode.\n- Added missing functions
  to `(scheme base)`.\n- Added support for the `(scheme case-lambda)` and `(scheme
  r5rs)` libraries.\n- Added libraries for SRFI 1, 2, and 69 so that these features
  are available via `import`. \n    - For example: `(import (srfi 1))`.\n- Added `exact-integer-sqrt`
  from R<sup>7</sup>RS, using the Chibi scheme reference implementation.\n- Added
  `let-values` and `let*-values` from R<sup>7</sup>RS.\n- Added the following I/O
  functions:\n    - `binary-port?`\n    - `close-port`\n    - `input-port-open?`\n
  \   - `open-binary-input-file`\n    - `open-binary-output-file`\n    - `output-port-open?`\n
  \   - `read-bytevector`\n    - `textual-port?`\n    - `u8-ready?`\n    - `write-bytevector`\n-
  Allow character and string comparison predicates (such as `string=?` and `char=?`)
  to support more than two arguments.\n- Fixed `cond-expand` to support `and` / `or`
  clauses.\n- Renamed `char-upper` and `char-lower` to `char-upcase` and `char-downcase`
  to match the Scheme specs.\n\nv3.14\n--------\n\nMade the following enhancements
  to improve R<sup>7</sup>RS support:\n\n- Updated the parser for strings, symbols,
  and character literals. The reader now understands Unicode hex values, strings and
  symbols now allow mnemonic and numeric escape sequences, and the list of named characters
  has been extended.\n- Added support for the `=>` syntax to the `case` conditional.\n-
  Added `cond-expand` syntax to statically expand different expressions depending
  upon whether features are present in the Scheme implementation. This could help
  allow the same code to work in husk as well as other R<sup>7</sup>RS implementations.\n-
  Added an optional second argument to `log` to allow specifying the base.\n- Added
  the following functions: `nan?`, `finite?`, `infinite?`, `exact-integer?`, `exact?`,
  `inexact?`, `square`, `boolean=?`, `symbol=?`, `read-line`, `flush-output-port`,
  `eof-object`.\n- Added support for `include`, `letrec*`, `syntax-error`, `unless`,
  and `when` syntax.\n\nAdded a library to compute simple random numbers, based on
  [this Stack Overflow answer](http://stackoverflow.com/a/14675103/101258):\n\n    (import
  (husk random))\n    (random num) ; Seed the RNG\n    (random) ; Random number from
  0 to 1\n    (randint lo hi) ; Generate random integer between lo (optional) and
  hi\n\nv3.13\n--------\n\n- Added the command line flag `--revision 7` (or `-r7`
  for short) to allow huski and huskc to start in R<sup>7</sup>RS mode.\n- Added most
  of the standard R<sup>7</sup>RS libraries: `(scheme base)`, `(scheme char)`, etc.\n-
  Extended syntax-rules to allow another identifier to be used to specify the ellipsis
  symbol, per R<sup>7</sup>RS. For example, `:::` could be used instead:\n\n        (define-syntax
  and\n          (syntax-rules ::: ()\n            ((and test1 test2 :::)\n             (if
  test1 (and test2 :::) #f))))\n\n- Added the following functions from R<sup>7</sup>RS:
  `make-list` , `list-copy` , `list-set!` , `vector-copy` , `vector-map` , `vector-for-each`
  , `vector-append` , `string-map` , `string-for-each` , `string->vector` , `vector->string`
  , `vector-copy!` , `string-copy!` \n\nv3.12\n--------\n\nSignificant enhancements
  have been made to the huski REPL:\n\n- Allow using huski to run Scheme scripts from
  the shell, as specified by SRFI 22. The script needs to start with the line `#!
  /usr/bin/env huski` or equivalent, and a `main` function may be defined to receive
  command line arguments. The `examples/scripts` directory contains example programs
  `cat.scm` and `sum.scm` that demonstrate how this works in practice.\n- Add tab
  completion for Scheme variables and special forms. Tab completion will still fill
  in filenames when tab is pressed within double-quotes. This makes it easy to find
  a file in certain cases such as for a `load`.\n- Accept (and ignore) inputs of just
  whitespace. Previously this would display a nasty error message.\n\nThis release
  also includes the following features:\n\n- Added the `(scheme time)` library from
  R<sup>7</sup>RS.\n- Added the `system` function to make system calls from a husk
  program. The syntax is `(system \"command\")`. An integer status code is returned
  with the same value that the executing program returned to the OS.\n\nBug fixes:\n\n-
  Duplicate or otherwise invalid lambda parameters are not allowed, and will throw
  an error. For example: `(lambda (a a 1) a)`\n- It is now a parse error to have a
  form that includes an empty car cell, for example: `'( . 1)`\n- Ensure all of husk's
  exports are included in the Haskell API documentation.\n\nv3.11\n--------\n\nThe
  major change in this release is support for R<sup>7</sup>RS style library syntax
  in the compiler. This enables functionality that was previously only available in
  the interpreter, and sets the stage for husk to begin adding support for R<sup>7</sup>RS.\n\nAPI
  changes:\n\n- The Compiler Haskell API has been reorganized to use a Types module,
  and a new Libraries module has been added to store code for libraries.\n\nBug fixes:\n\n-
  Allow the husk compiler to reference variables that are defined later in the program.
  For example, the following now compiles: `(define (foo) (bar))` `(define (bar) (foo))`\n-
  Fixed `string-set!` to allow an expression to be passed as the character argument.\n-
  Fixed `string-ref` to work when the string argument is passed using a variable.\n\nv3.10\n--------\n\nThis
  release includes many important fixes and enhancements to the compiler:\n\n- Significantly
  reduced the amount of compiled Haskell code generated by huskc, leading to a 40%
  reduction in the code generated by the compiler test suite. Note any actual percentages
  will depend upon the scheme code being compiled.\n- Added `load` as a compiler special
  form, to allow code to be loaded from other files and compiled alongside the main
  program.\n- Added optimizations to evaluate primitive expressions at compile time,
  and to generate more efficient code for functions that are only passed literal arguments.\n-
  Enhanced the compiler to detect undefined variables and report an error at compile
  time, instead of generating code that will throw a runtime error.\n- Fixed an issue
  where the compiler would not cache macro expansions in its local memory when compiling
  function definitions. This bug caused problems for explicit renaming macros, as
  it was possible for the evaluator to evaluate a special form thinking that it was
  a function, resulting in an \"unbound variable\" error.\n- Modified the test suite
  to work with both the interpreter and compiler. Note that some test cases are not
  executed by the compiler because they are not supported (see below).\n- SRFI 1 is
  not supported by the compiler at this time.\n\nv3.9\n--------\n\n- Fixed a syntax
  error that prevented the FFI module from building. Thanks to Ricardo Lanziano for
  bringing this to my attention!\n- Enhanced the compiler to use the name of the source
  file for the compiled Haskell output instead of hardcoding the file to `_tmp.hs`.
  For example, `my-file.scm` will compile to `my-file.hs`.\n- Removed extraneous quotes
  when printing a lambda form.\n\nv3.8\n--------\n\nThis release introduces several
  performance improvements:\n\n- Macro expansions are now cached, significantly improving
  performance when repeatedly calling a function containing macros.\n- A `Pointer`
  type was added in version 3.6 as part of the changes to enhance the variable storage
  model. Unfortunately the initial implementation naively checked for pointers prior
  to calling into any Haskell function. This release eliminates those inefficiencies
  by allowing primitive functions to deal with the Pointer type directly, instead
  of attempting to convert values before passing them to primitive functions.\n- Restructured
  code in the Macro module to eliminate redundant calls to `Data.Map.lookup`.\n\nThe
  example game of life program `examples/game-of-life/life.scm` demonstrates these
  performance improvements, as it now runs over 4.5 times faster than in the previous
  release. \n\nThis release also adds the following library from R<sup>7</sup>RS:\n\n-
  `(scheme r5rs)` - Exposes the full husk R<sup>5</sup>RS environment\n\nAnd, R<sup>5</sup>RS
  versions of the scheme libraries have been relocated to underneath `(scheme r5rs)`.
  Each of these libraries exposes a husk subset of the functions recommended by R<sup>7</sup>RS:\n\n-
  `(scheme r5rs base)`\n- `(scheme r5rs char)`\n- `(scheme r5rs complex)`\n- `(scheme
  r5rs cxr)`\n- `(scheme r5rs eval)`\n- `(scheme r5rs file)`\n- `(scheme r5rs inexact)`\n-
  `(scheme r5rs lazy)`\n- `(scheme r5rs load)`\n- `(scheme r5rs read)`\n- `(scheme
  r5rs write)`\n\nChanges to the Haskell API:\n\n- Introduced a new type of function,
  `CustFunc`, which is now the recommended way to define your own Haskell functions
  when using the Haskell API. This type allows you to avoid having to handle Pointer
  types directly in your Haskell code. If you know what you are doing, though, you
  can handle Pointer types and avoid the overhead of checking for pointers prior to
  calling into your function code.\n- Moved `runIOThrows` into Core, and removed obsolete
  functions `trapError` and `extractValue`.\n\nBug fixes:\n\n- Updated `map` and `for-each`
  to accept multiple list arguments, per R<sup>5</sup>RS.\n\nv3.7\n--------\n\nA major
  change for this release is the introduction of Scheme libraries using R<sup>7</sup>RS
  library syntax. For an example of how to use libraries, see `examples/hello-library/hello.scm`
  in the husk source tree. Note that since R<sup>7</sup>RS is not currently implemented
  by husk, the library system only has the built-in import `(r5rs base)` to allow
  you to import the standard husk R5RS environment. Also, please keep in mind this
  is still a beta feature that is not yet implemented by the compiler.\n\nThis release
  also contains many improvements to the Haskell API:\n\n- Added `r5rsEnv` to the
  Core module to expose the full environment, including functions loaded from the
  Scheme standard library.\n- Added `getDataFileFullPath` to the Core module to allow
  third party code to reference Scheme files such as `stdlib.scm` that are installed
  alongside husk.\n- Modified `NumArgs` to optionally require an explicit number of
  arguments. This helps when writing variable-length functions where specifying a
  single number of arguments may be misleading.\n- Added a new module `Language.Scheme.Util`
  to contain general purpose utility functions.\n\nBug fixes:\n\n- Updated the parser
  to accept floating point numbers that contain only a fractional component, such
  as `.5`.\n- Enhanced numerical comparison operators (`=`, `<`, `<=`, `>`, `>=`)
  to be able to accept an unlimited number of arguments, per R5RS.\n\nv3.6.3\n--------\n\nAdded
  support for R<sup>7</sup>RS bytevectors.\n\nImproved support for using husk as an
  extension language by adding Haskell function `evalLisp'`. This function evaluates
  a lisp data structure and returns the `LispVal` or `LispError` result directly:\n\n
  \   evalLisp' :: Env -> LispVal -> IO (ThrowsError LispVal)\n\nThis makes it much
  easier to retrieve results when using husk as an extension language:\n\n    result
  <- evalLisp' env $ List [Atom \"/\", Number 1, Number 0]\n    case result of\n      Left
  err -> putStrLn $ \"Error: \" ++ (show err)\n      Right val -> putStrLn $ show
  val\n\nFinally, fixed a bug where setting a variable to refer back to itself would
  result in an infinite loop. For example, the last line of the following code would
  cause `huski` to hang:\n\n    (define a '())\n    (define b a)\n    (define a b)\n\nv3.6.2\n--------\nThis
  release adds support for nested quasi-quotation forms, which now respect depth level.
  This was done by replacing the quasi-quotation special form with a macro based on
  the one from chibi scheme. A nice side-benefit is that by removing the special forms,
  quasi-quotation now works in the compiler.\n\nAlso added support for SRFI 2, `and-let*`.
  From the SRFI document:\n\n> Like an ordinary AND, an AND-LET\\* special form evaluates
  its arguments - expressions - one after another in order, until the first one that
  yields #f. Unlike AND, however, a non-#f result of one expression can be bound to
  a fresh variable and used in the subsequent expressions. AND-LET\\* is a cross-breed
  between LET\\* and AND.\n\nAnd added support for environment specifiers, including
  the following functions:\n\n- `(interaction-environment)`\n- `(current-environment)`\n-
  `(make-environment)`\n- `(null-environment version)`\n- `(load filename environment-specifier)`\n-
  `(eval expression environment-specifier)`\n\nThis release also includes the following
  bug fixes:\n\n- Fixed a bug where nested explicit renaming macros may not always
  expand properly.\n- Unfortunately, the storage model changes introduced in 3.6 cause
  problems with hash table literals defined using the `#hash()` syntax. For now, hash
  table literals have been removed to prevent further problems. This feature may be
  added back in the future.\n- Fixed the code for `require-extension` to allow passing
  multiple SRFI numbers in the same call. For example: `(require-extension (srfi 1
  2))`.\n- Improved compiler support by diverting renamed variables back into the
  enclosing environment. Such variables would previously throw a runtime error when
  accessed by the compiled program.\n- Improved compiler support by loading macros
  defined using `define-syntax` so they are available at runtime.\n\nv3.6.1\n--------\nAdded
  support for GHC 7.6.\n\nv3.6\n--------\nEnhanced the variable storage model to correctly
  store references to objects. For example, consider the following:\n\n    (define
  x (list 'a 'b 'c))\n    (define y x)\n    (set-cdr! x 4)\n\nAfter executing this
  code, previous versions of husk assigned `(a b c)` to `y`. With this release, husk
  now evaluates `y` to the expected value of `(a . 4)`.\n\nThe more general problem
  is that certain data types denote a memory location which may be modified by mutator
  functions such as `set-cdr!`. This is discussed specifically in section 3.4 <b>Storage
  Model</b>:\n\n>\n> Variables and objects such as pairs, vectors, and strings implicitly
  denote locations or sequences of locations. A string, for example, denotes as many
  locations as there are characters in the string. (These locations need not correspond
  to a full machine word.) A new value may be stored into one of these locations using
  the string-set! procedure, but the string continues to denote the same locations
  as before.\n> \n\nInternally husk uses Haskell data types, so the husk model differs
  slightly from the one in R<sup>5</sup>RS - references are used instead of individual
  memory locations. This has implications for the `set-car!` and `set-cdr!` special
  forms, where circular lists and similar low-level optimizations are not possible
  as Haskell lists are used instead of raw pointers. However, these issues aside,
  the enhanced storage model is a big step forward to bringing husk's variable support
  closer in line to that of other Schemes.\n\nv3.5.7\n--------\n\nThe major change
  in this release is support for explicit renaming macros. This low-level macro system
  provides the ability to break macro hygiene, if necessary, and offers a macro system
  that is similar to `defmacro`.\n\nIn addition, all of the character functions from
  R<sup>5</sup>RS have been implemented.\n\nv3.5.6\n--------\n\n- Enhanced the compiler
  to accept `load-ffi` as a special form, so a compiled version of a program does
  not have to wait for a module to be dynamically loaded. Instead, the module is included
  at compile time. This offers a nice speed improvement:\n\n  <pre>\n  <code>\n     $
  time huski ffi-cputime.scm \n     Seconds of CPU time spent: 2.756171\n\n     $
  time ./ffi-cputime \n     Seconds of CPU time spent: 2.4001e-2\n  </code>\n  </pre>\n\n-
  Allow a hash table to be defined directly using `#hash(alist)` - for example, `#hash()`
  for an empty table or `#hash((a 1) (b . 2))` for a table with two elements. This
  is not part of R<sup>5</sup>RS but seems less clumsy than the standard way, and
  a similar language feature is provided by Racket.\n- Added support for `hash-table-set!`
  and `hash-table-delete!` to the compiler.\n- Fixed a bug where `integer?` would
  always return false for negative rational numbers. For example, `(integer? -2/2)`
  should evaluate to `#t`.\n\nv3.5.5\n--------\n\n- Added support for SRFI-1 (List
  Library), which can be loaded using `(require-extension (srfi 1))`. Note that linear
  update functions (such as `map!`, `take!`, etc) and circular lists are not supported
  at this time.\n- Added a new LispVal type called `Opaque` for Haskell integration,
  courtesy of Josh Triplett. The Opaque type allows a native Haskell function to package
  an arbitrary Haskell type for use by other native code called by husk. See `examples/ffi/Opaque.hs`
  for an example of how to use this feature.\n- Implemented `file-exists?`, `delete-file`,
  `char-ready?`, `rationalize`, `gcd`, and `lcm`.\n- Enhanced the parser to read numbers
  in scientific notation such as `1e3` and `4.2e1`.\n- Modified `numerator` and `denominator`
  to add support for integers and floating point numbers.\n- Fixed a bug in `set-cdr!`
  where an unsimplified list may be output. For example, `(3 . (2 . (1 . ())))` instead
  of `(3 2 1)`.\n- Allow `apply` to receive multiple arguments, as long as the last
  one is a list.\n\nv3.5.4\n--------\n\n- Enhanced `huski` and `huskc` to print errors
  to console when a runtime exception occurs,\nand to not print any results to console
  unless the user calls an I/O function\nsuch as `write` or `display`.\n- Added a
  special form `expand` that can be used to see the result of a macro\nexpansion,
  for debugging purposes. For example: `(expand (let ((x 1)) x))`.\n- Allow a list
  to be enclosed by matched brackets as well as parentheses. For example: `(+ 1 2
  [+ 3 4])`.\n- Internal change - cleaned up code by using Language pragmas instead
  of explicitly using extensions in the cabal and make files.\n\nv3.5.3.2\n--------\n\n-
  Modified huski to escape baskslashes in the path to the standard library, to guarantee
  stdlib is loaded when husk is installed on a Windows machine.\n\nv3.5.3.1\n--------\n\n-
  Removed an unnecessary dependency on `/dev/null` to allow `huski` to interpret files
  when run on Windows.\n- Prevent divide-by-zero errors when dividing by a single
  number, or processing a rational number with zero as the denominator.\n\nv3.5.3\n------\nThis
  release adds full support for GHC 7.2.2 / 7.4.1 as well as a number of small enhancements.\n\n-
  Fixed the FFI to work in both GHC 7.2.2 and GHC 7.4.1.\n- Implemented SRFI 23, which
  adds error reporting via the `(error)` function.\n- Added support for `let-syntax`,
  `letrec-syntax`, `set-car!`, `set-cdr!`, `vector-set!`, and `lambda` (pair syntax)
  to the huskc compiler.\n- Added the `--dynamic` option to the compiler to use dynamic
  Haskell libraries.\n- Added the `--extra` option to the compiler to allow passing
  of arbitrary arguments directly to ghc.\n- Fixed huski to allow any redefinition
  of `let-syntax` and `letrec-syntax`.\n\nv3.5.2.x\n------\nThis is a series of quick
  bug-fix releases that allows husk to build under GHC 7.4.1.\n\nv3.5.2\n------\n-
  Added an experimental compiler, huskc. For more information see [Issue #62](https://github.com/justinethier/husk-scheme/issues/62).\n-
  Streamlined the cabal file so that each source file is only compiled a single time.\n\nv3.5.1\n------\n-
  Improved support for comparing instances of functions using `eq?`, `eqv?`, etc.\n-
  Reduced variable access time by using a Map to store variables within an environment.
  \n- Various internal changes such as renaming the tests directory and integrating
  R<sup>5</sup>RS pitfalls with the unit tests.\n\nv3.4.4\n------\nThis release continues
  the trend of quick point releases for the 3.4.x series. The key change is support
  for GHC 7.2: \n\n- husk now compiles in GHC 7.2. This ended up being a simple change
  - I had mis-interpreted the value of a pre-processor directive. Sorry about that!\n-
  Replaced the definition of `letrec` with the macro from R<sup>5</sup>RS.\n- Allow
  a continuation to call into another continuation via call/cc - see R<sup>5</sup>RS
  pitfall 1.2\n\nv3.4.3\n------\n- Fixed `let-syntax` and `letrec-syntax` to prevent
  conflicts between identifiers of the same name in the outer scope and within the
  macro body.\n- Per R5RS, `(if <test> <consequent>)` is supposed to evaluate `<consequent>`
  for any value of `<test>` except `#f`. However, husk was only allowing `<test>`
  to pass if it was equal to `#t`. This has been fixed.\n- Modified `(append)` to
  accept an arbitrary number of arguments, per R<sup>5</sup>RS.\n- Replaced the macro
  for `case` with the one from R<sup>5</sup>RS.\n\nv3.4.2\n------\n- Many improvements
  and bug fixes for let-syntax and letrec-syntax.\n- Improved handling of define and
  set! within a macro definition.\n\nv3.4.1\n------\nAdded experimental support for
  let-syntax and letrec-syntax.\n\nBug fixes:\n\n- Fixed a nasty issue where the macro
  pattern matching code would not properly reset itself when transcribing a macro
  containing an ellipsis in the middle of a list. For example: `(a ... b c)`. This
  caused the expanded macro to be incomplete and/or malformed.\n- Fixed a bug that
  would cause the evaluator to terminate if define-syntax was called within a nested
  scope. \n\nv3.4\n----\nThis release adds the first hygienic macro support to husk.
  There are two \"sides\" to macro hygiene:\n\n- Hygiene: Names that are introduced
  by the macro do not clash with names in sub-expressions that are passed from user
  code to it\n- Referential transparency: names that the macro references are coming
  from the lexical context of its definition, rather than the lexical context of its
  use\n\nSupport has been added for both sides, although there are some issues as
  noted in the [Version 3.4.x Milestones](https://github.com/justinethier/husk-scheme/issues?milestone=9&state=open).
  Macro support will continue to improve in future releases.\n\nIn addition, this
  release contains the following bug fixes:\n\n- When searching for a redefinition
  of a special form, the code now\nrecursively examines parent environments instead
  of only inspecting the\ncurrent environment.\n- `(let*)` is now defined in terms
  of the definition from R<sup>5</sup>RS, to\nfix problems with valid inputs not being
  matched by `(let*)`.\n\nv3.3\n----\nThis release includes major improvements to
  the macro module.\nIn particular:\n\n- husk now supports arbitrary nesting levels
  of macro 0-or-many matches (IE: `...`). Previous versions would not handle macros
  that had more than 2 nesting levels of 0-or-more matches.\n- Macros now correctly
  handle improper lists. Previous versions of husk did not respect the fact that the
  trailing item in an improper list may be matched zero or more times. Also, husk
  macros now properly convert the transformed code into improper or proper lists depending
  upon the pattern, input, and transform.\n- (do) is now defined in terms of the macro
  from R<sup>5</sup>RS.\n\nOther changes:\n\n- Updated the parser to simplify improper
  lists; for example the following input: `'(1 2 . (3 . ()))` will now be converted
  to `(1 2 3)`\n- Corrected the order of arguments to (fold). For example, the expression
  (fold (lambda (x y) x) 8 (list 1 2 3)) should yield 3, however in previous releases
  husk would incorrectly yield 8 because of the order of arguments.\n\nv3.2.1\n------\n-
  Added a conditional compilation check to allow husk to build on GHC 6 and GHC 7.\n\nv3.2\n----\n-
  Significant improvements to the parser, including proper handling of whitespace
  and comments. This represents a critical upgrade from the previous releases.\n-
  Added support for nested block comments using `#|` and `|#`, per the R<sup>7</sup>RS
  draft.\n- Added `hash-table-fold`\n\nv3.1\n----\n- Fixed issues with lexical scope,
  where proper scope was not observed for\nspecial forms, including: if, cond, set!,
  begin, define, lambda, set-car!,\nset-cdr!, string-set!, vector-set!, and hash-table-set!
  - For example: \n\n`(let ((if +)) (if 1 2 3))` was 2 instead of 6. Now it eval's
  to 6\n\n- `cond`, `and`, and `or` are now defined using the corresponding macros
  from R<sup>5</sup>RS,\n  to give them the expected semantics.\n- Added a `gensym`
  primitive.\n- Internal change - relocated primitive functions to a new Language.Scheme.Primitives
  module.\n- Marked macro support as non-hygienic since hygiene is not fully supported
  at present.\n\nv3.0\n----\n- Added a foreign function interface (FFI) to allow husk
  to call directly into Haskell code.\n\nv2.4\n----\n- Simplified the core evaluator
  by moving several functions out of eval.\nPractically, this means that the following
  functions are now first-class objects:\napply, call-with-current-continuation, call-with-values,
  eval, and load. \nThey can be called directly, assigned to variables, etc just like
  any\nother first-class value. \n- (call-with-values) now accepts multiple return
  values from the producer function.\n- If (values) is called with multiple arguments
  and is not part of an\nenclosing (call-with-values), the first value is returned
  to the interpreter\ninstead of generating an error.\n- Added additional error handling
  for set! - and related functions - when these\nfunctions are called with the wrong
  number or type of arguments.\n- Added limited support for (dynamic-wind).\n- The
  parser now recognizes rational number components of a complex number.\nFor example:
  1/2+3/4i\n\nv2.3\n----\n- Automatically load the scheme standard library when running
  .scm files.\n- Suppress excess output when running a program by piping it to /dev/null.\n-
  Added missing I/O functions, including display, input-port?, output-port?,\nnewline,
  write-char, read-char, peek-char, current-input-port,\ncurrent-output-port, call-with-input-file,
  and call-with-output-port.\n- Added eval.\n- Added a limited version of (call-with-values)
  that currently only accepts\none argument.\n\nv2.2\n----\n- Added vector support
  to macros.\n- Added an example program to demonstrate file I/O: examples/simple-file-io.scm.\n\nv2.1\n----\n-
  Moved all Haskell code from the 'Scheme' namespace to the 'Language/Scheme'\nnamespace.\n-
  Fixed cases where backquoting of a vector would crash the interpreter.\n- Prevent
  interpreter from crashing when calling (load) if the file does not\nexist.\n- Improved
  support of different numeric types across the numerical functions.\n- Added support
  for binary numbers to (number->string)\n- Implemented (alist->hash-table)\n\nv2.0\n----\n-
  Full implementation of continuations via call/cc. This involved passing a new continuation
  type through all versions of the eval function.\n- Fixed a bug where a macro pattern
  would be incorrectly matched even though a literal identifier in the pattern was
  not present in the input.\n- Added over 100 new Scheme test cases from the R5RS
  language specification.\n- Added set-cdr!\n- Changed the banner text on startup
  to match the new husk logo.\n\nv1.3\n----\n- Added limited support for continuations,
  by adding the call/cc keyword and first-class continuations. This is still a work
  in progress, and only a subset of continuations are supported - continuations can
  only be used as escape procedures from a function (along the lines of a 'return'
  call).\n\nv1.2\n----\n- Fixed an ugly bug where the underlying functions used to
  mutate variabiables in (define), (set!), etc implemented dynamic scoping instead
  of the lexical (static) scoping required by R5RS. [This reference implementation](http://web.mit.edu/kmill/Public/lilscheme.hs)
  written by Kyle Miller was used as a starting point.\n\nv1.1\n----\n- Many improvements
  to quasi-quotation, including support for unquote splicing (,@).\n\nv1.0\n----\n-
  Initial release\n"
basic-deps:
  bytestring: -any
  haskeline: -any
  husk-scheme: -any
  base: '>=2.0 && <5'
  time: -any
  filepath: -any
  process: -any
  parsec: -any
  array: -any
  containers: -any
  ghc-paths: -any
  utf8-string: -any
  mtl: -any
  knob: -any
  transformers: -any
  directory: -any
all-versions:
- '1.0'
- '1.1'
- '1.2'
- '1.3'
- '2.0'
- '2.1'
- '2.2'
- '2.3'
- '2.4'
- '3.0'
- '3.1'
- '3.2'
- 3.2.1
- '3.3'
- '3.4'
- 3.4.1
- 3.4.2
- 3.4.3
- 3.4.4
- 3.5.1
- 3.5.2
- 3.5.2.1
- 3.5.2.2
- 3.5.2.3
- 3.5.3
- 3.5.3.1
- 3.5.3.2
- 3.5.4
- 3.5.5
- 3.5.6
- 3.5.7
- '3.6'
- 3.6.1
- 3.6.2
- 3.6.3
- '3.7'
- '3.8'
- '3.9'
- '3.10'
- '3.11'
- '3.12'
- '3.13'
- '3.14'
- '3.15'
- 3.15.1
- 3.15.2
- '3.16'
- 3.16.1
- '3.17'
- 3.17.1
- '3.18'
- '3.19'
- 3.19.1
- 3.19.2
- 3.19.3
- '3.20'
author: Justin Ethier
latest: '3.20'
description-type: markdown
description: "[<img src=\"https://github.com/justinethier/husk-scheme/raw/master/docs/husk-scheme.png\"
  alt=\"husk-scheme\">](http://justinethier.github.com/husk-scheme)\n\nHusk is a dialect
  of Scheme written in Haskell that implements a superset of the [R<sup>5</sup>RS
  standard](http://www.schemers.org/Documents/Standards/R5RS/HTML/) and a large portion
  of the [R<sup>7</sup>RS-small](r7rs.org) language. Advanced features are provided
  including continuations, hygienic macros, libraries, and a full numeric tower.\n\nHusk
  may be used as either a stand-alone interpreter or as an extension language within
  a larger Haskell application. By closely following the R<sup>5</sup>RS standard,
  the intent is to develop a Scheme that is as compatible as possible with other R<sup>5</sup>RS
  Schemes. Husk is mature enough for use in production applications, however it is
  not optimized for performance-critical applications. \n\nScheme is one of two main
  dialects of Lisp. Scheme follows a minimalist design philosophy: the core language
  consists of a small number of fundamental forms which may be used to implement other
  built-in forms. Scheme is an excellent language for writing small, elegant programs,
  and may also be used to write scripts or embed scripting functionality within a
  larger application.\n\nMore information is available on the [husk website](http://justinethier.github.com/husk-scheme).\n\nInstallation\n------------\n\n1.
  <b>Prerequisites</b>: You will need the [Haskell Platform](http://hackage.haskell.org/platform/)
  if you don't already have a recent copy installed.\n\n2. <b>Install Husk</b> using
  [cabal](http://www.haskell.org/cabal/):\n\n        cabal update\n        cabal install
  husk-scheme\n\n3. <b>Adjust your PATH</b>: Before running Husk you may also need
  to add the cabal executable directory to your path. On Linux this is `~/.cabal/bin`.
  \n\n4. Now you are ready to start up the interpreter:\n\n        justin@my-pc$ huski\n
  \         _               _        __                 _                          \n
  \        | |             | |       \\\\\\               | |                         \n
  \        | |__  _   _ ___| | __     \\\\\\      ___  ___| |__   ___ _ __ ___   ___
  \ \n         | '_ \\| | | / __| |/ /    //\\\\\\    / __|/ __| '_ \\ / _ \\ '_ `
  _ \\ / _ \\ \n         | | | | |_| \\__ \\   <    /// \\\\\\   \\__ \\ (__| | |
  |  __/ | | | | |  __/ \n         |_| |_|\\__,_|___/_|\\_\\  ///   \\\\\\  |___/\\___|_|
  |_|\\___|_| |_| |_|\\___| \n                                                                             \n
  \        http://justinethier.github.com/husk-scheme                              \n
  \        (c) 2010-2014 Justin Ethier                                             \n
  \        Version 3.18 \n                                                                             \n
  \       huski> (define (hello) 'world)\n        (lambda () ...)\n        huski>
  (hello)\n        world\n\nHusk has been tested on Windows, Linux, and FreeBSD.\n\nDocumentation\n-------------\nThe
  online [user manual](http://justinethier.github.io/husk-scheme/manual/index.html)
  provides an overview of the Scheme language as implemented by Husk, including:\n\n
  - A [getting started](http://justinethier.github.io/husk-scheme/manual/getting-started.html)
  guide.\n - [Instructions](http://justinethier.github.io/husk-scheme/manual/haskell-interface.html)
  for using the [Haskell API](http://hackage.haskell.org/package/husk-scheme) \n -
  An alphabetical listing of the [Scheme API](http://justinethier.github.io/husk-scheme/manual/node106.html).\n\n**Directory
  Structure**\n\n - **`docs`** - Documentation has been moved from here to the [`gh-pages`](http://justinethier.github.io/husk-scheme/)
  branch.\n - [**`examples`**](https://github.com/justinethier/husk-scheme/tree/master/examples)
  - Example programs, mostly written in Scheme.\n - [**`extensions`**](https://github.com/justinethier/husk-scheme/tree/master/extensions)
  - Haskell-based extensions to Husk.\n - [**`hs-src`**](https://github.com/justinethier/husk-scheme/tree/master/hs-src)
  - Haskell source code for Husk.\n - [**`lib`**](https://github.com/justinethier/husk-scheme/tree/master/lib)
  - Library portions of Husk written in Scheme.\n - [**`scripts`**](https://github.com/justinethier/husk-scheme/tree/master/scripts)
  - Build scripts for Husk and a basic Emacs integration script.\n - [**`tests`**](https://github.com/justinethier/husk-scheme/tree/master/tests)
  - Functional tests for Husk. These can be run automatically by using `make test`
  from the main Husk directory.\n\n\nLicense\n-------\nCopyright (C) 2010 [Justin
  Ethier](http://github.com/justinethier)\n\nHusk scheme is available under the [MIT
  license](http://www.opensource.org/licenses/mit-license.php).\n\nThe interpreter
  is based on code from the book [Write Yourself a Scheme in 48 Hours](http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours)
  written by Jonathan Tang and hosted / maintained by Wikibooks.\n\n"
license-name: MIT

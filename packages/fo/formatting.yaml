homepage: https://github.com/AJChapman/formatting#readme
changelog-type: markdown
hash: bb38d679387fc8adadf168709b2d3882b42e58fd1ee33940421046cd78b59930
test-bench-deps:
  base: '>=4.11 && <5'
  hspec: -any
  text: '>=0.11.0.8'
  criterion: -any
  ghc-prim: -any
  formatting: -any
  scientific: -any
  QuickCheck: -any
maintainer: alex@farfromthere.net
synopsis: Combinator-based type-safe formatting (like printf() or FORMAT)
changelog: |
  7.1.2

  * Removed direct dependency on integer-gmp, instead using very similar code from the `text` package. This changed the implementation of `build` for `Integer`, which results in better performance in some cases, and no performance degradation. See the benchmarking reports in bench/reports for more details.
  * formatting now compiles on GHCJS (due to the change above).
  * Added some benchmarking, starting based on code from the `string-interpolate` package.
  * Added INLINE pragmas to many very short functions. Results in better performance in the benchmarks.

  7.1.1

  * Added `charsKeptIf` and `charsRemovedIf`.

  7.1.0

  * Added common container formatter combinators: `maybed`, `optioned`, `eithered`, `lefted`, and `righted`.

  7.0.0.2

  * Removed unnecessary dependencies on array and bytestring
  * Actually removed code to support GHC < 8.4

  7.0.0.1

  * Added README.md to extra-source-files so it shows up on Hackage

  7.0.0

  * Introduced `Formatting.Combinators`.
  * Fixed: #62 and #60: incorrect formatting of Integral types that do not have negative values (e.g. Word)
  * Fixed: #59 rendering of floats e.g. 0.01 as "0.01" rather than "1.0e-2"
  * Added dependency of double-conversion to provide fast and correct rendering of floating-point numbers (including the fix for #59).
  * Make compatible with bytestring-0.11.0.0
  * Removed -O2 ghc flag
  * Updated .cabal file version from 1.8 to 2.4
  * Drop support for GHC < 8.4

  6.3.7

  * Introduced instance `Buildable a => Buildable [a]`.

  6.3.6

  * Bring back `int :: Integral a => Format r (a -> r)`

  6.3.5

  * Avoid pointless conversions on Float/Double.

  6.3.3

  * The `Data.Text.Format` hierarchy was reexported as
    `Formatting.Internal.Raw`.

  6.3.1

  * Proper GHC 7.10 -> GHC 8.4 support

  6.3.0

  * Folded the `text-format` package into this package, removed the
    `double-conversion` dependency. Lost the following functions in
    this:
    * `prec`
    * `expt`
  * Added a test suite with regression tests:
    * Fixed: #31
    * Fixed: #28
    * Fixed: https://github.com/bos/text-format/issues/18

  6.2.5

  * Changed microseconds to display as "us" to avoid unicode issues.

  6.2.1

  * Added bytesDecimal

  6.2.0

  * Dropped Holey/HoleyT in favour of simpler Format type.
  * Added Monoid instance.
  * Added back Category instance.
  * Dropped Functor instance.

  6.1.1

  * Add support for GHC 7.10 (time update).

  6.1.0

  * Add formatter for TimeSpec.

  6.0.0

  * Changed the type of `Format`. Now you write `Format r (a -> r)` instead
    of `Format a`.
  * Add `formatToString` function.
basic-deps:
  base: '>=4.11 && <5'
  time: '>=1.5'
  text: '>=0.11.0.8'
  clock: '>=0.4'
  double-conversion: ^>=2.0.2.0
  ghc-prim: -any
  old-locale: -any
  transformers: -any
  scientific: '>=0.3.0.0'
all-versions:
- 3.0.0
- 3.0.1
- 3.0.2
- 3.1.0
- 3.1.1
- 3.1.2
- 3.1.3
- 3.1.4
- '4.0'
- '4.1'
- '5.0'
- '5.1'
- '5.2'
- '5.3'
- '5.4'
- 6.0.0
- 6.1.0
- 6.1.1
- 6.1.2
- 6.2.0
- 6.2.1
- 6.2.2
- 6.2.3
- 6.2.4
- 6.2.5
- 6.3.0
- 6.3.1
- 6.3.2
- 6.3.4
- 6.3.5
- 6.3.6
- 6.3.7
- 7.0.0
- 7.0.0.1
- 7.0.0.2
- 7.1.0
- 7.1.1
- 7.1.2
author: Chris Done, Shachaf Ben-Kiki, Martijn van Steenbergen, Mike Meyer, Bryan O'Sullivan,
  Alex Chapman
latest: 7.1.2
description-type: markdown
description: "# formatting [![Build Status](https://travis-ci.org/AJChapman/formatting.png)](https://travis-ci.org/AJChapman/formatting)
  [![Hackage](https://img.shields.io/hackage/v/formatting.svg?style=flat)](https://hackage.haskell.org/package/formatting)\n\nFormatting
  is a type-safe and flexible library for formatting text from built-in or custom
  data types.\n\n- [Hackage Documentation](https://hackage.haskell.org/package/formatting)\n-
  [The original blog post introducing the library](https://chrisdone.com/posts/formatting/),
  but note that some of the types have changed: `Holey` is no longer used, and `Format`'s
  type has changed to `newtype Format r a = Format {runFormat :: (Builder -> r) ->
  a}`\n\n## Usage\n\nYou will probably need the `OverloadedStrings` language extension,
  and to import `Formatting`:\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\n\nimport
  Formatting\n```\n\nYou may also need some or all of these:\n\n```haskell\nimport
  qualified Data.Text as T\nimport qualified Data.Text.Lazy as TL\nimport qualified
  Data.Text.Lazy.Builder as TLB\n```\n\nNow a simple example:\n\n```haskell\n> format
  (\"Person's name is \" % text % \" and age is \" % int) \"Dave\" 54\n\"Person's
  name is Dave and age is 54\"\n```\n\nIn this example, the formatters are two string
  literals (which take no arguments), and two formatters which take arguments: `text`,
  which takes a lazy `Text`,  and `int` which takes any `Integral`, such as `Int`.\nThey
  are all joined together using the `%` operator, producing a formatter which takes
  two arguments: a lazy `Text` and an `Integral`.\nIt produces a lazy `Text`, because
  we used `format`.\nTo produce other string types, or print the result instead, refer
  to this table:\n\n| To produce a  | use                |\n| ------------- | ------------------
  |\n| `TL.Text`     | [`format`]         |\n| `T.Text`      | [`sformat`]        |\n|
  `Builder`     | [`bformat`]        |\n| `String`      | [`formatToString`] |\n\nTo
  print the values instead, refer to this table:\n\n| To print to                   |
  use           |\n| ----------------------------- | ------------- |\n| `stdout`                      |
  [`fprint`]    |\n| `stdout`, appending a newline | [`fprintLn`]  |\n| a handle                      |
  [`hprint`]    |\n| a handle, appending a newline | [`hprintLn`]  |\n\nApart from
  the `%` operator, formatters can also be joined using the monoid append operator
  (`<>`) to avoid repeating the same argument, they can be chained using `%.`, and
  there are also formatter combinators for composing more advanced combinators.\nMore
  on this below.\n\n### Formatter Quick Reference\n\nBuilt-in formatters:\n\n| To
  format a                            | e.g.                     | as               |
  use                                | short form |\n| --------------------------------------:|
  ------------------------ | ---------------- | ----------------------------------
  | ---------- |\n|                            lazy `Text` | `\"Hello\"`                |
  `\"Hello\"`        | [`text`]                           | [`t`]      |\n|                          strict
  `Text` | `\"World!\"`               | `\"World!\"`       | [`stext`]                          |
  [`st`]     | \n|                               `String` | `\"Goodbye\"`              |
  `\"Goodbye\"`      | [`string`]                         | [`s`]      |\n|                              `Builder`
  | `\"Bathtub\"`              | `\"Bathtub\"`      | [`builder`]                        |
  \           |\n|                          `Show a => a` | `[1, 2, 3]`              |
  `\"[1, 2, 3]\"`    | [`shown`]                          | [`sh`]     |\n|                                 `Char`
  | `'!'`                    | `\"!\"`            | [`char`]                           |
  [`c`]      |\n|                      `Integral a => a` | `23`                     |
  `\"23\"`           | [`int`]                            | [`d`]      |\n|                          `Real
  a => a` | `123.32`                 | `\"123.32\"`       | [`float`]                          |
  [`sf`]     |\n|                          `Real a => a` | `123.32`                 |
  `\"123.320\"`      | [`fixed`] `3`                      | [`f`]      |\n|                           `Scientific`
  | `scientific 60221409 16` | `\"6.0221409e23\"` | [`sci`]                            |
  \           |\n|                           `Scientific` | `scientific 60221409 16`
  | `\"6.022e23\"`     | [`scifmt`] `Exponent (Just 3)`     |            |\n|         `Buildable
  n, Integral n => n` | `123456`                 | `\"12.34.56\"`     | [`groupInt`]
  `2 '.'`               |            |\n|         `Buildable n, Integral n => n` |
  `12000`                  | `\"12,000\"`       | [`commas`]                         |
  \           |\n|                      `Integral n => n` | `32`                     |
  `\"32nd\"`         | [`ords`]                           |            |\n|                     `Num
  a, Eq a => a` | `1`                      | `\"1 ant\"`        | `int <>` [`plural`]
  `\"ant\" \"ants\"` |            |\n|                     `Num a, Eq a => a` | `2`
  \                     | `\"2 ants\"`       | `int <>` [`plural`] `\"ant\" \"ants\"`
  |            |\n|                          `Enum a => a` | `a`                      |
  `\"97\"`           | [`asInt`]                          |            |\n|                      `Integral
  a => a` | `23`                     | `\"10111\"`        | [`bin`]                            |
  [`b`]      |\n|                      `Integral a => a` | `23`                     |
  `\"0b10111\"`      | [`prefixBin`]                      |            |\n|                      `Integral
  a => a` | `23`                     | `\"27\"`           | [`oct`]                            |
  [`o`]      |\n|                      `Integral a => a` | `23`                     |
  `\"0o27\"`         | [`prefixOct`]                      |            |\n|                      `Integral
  a => a` | `23`                     | `\"17\"`           | [`hex`]                            |
  [`x`]      |\n|                      `Integral a => a` | `23`                     |
  `\"0x17\"`         | [`prefixHex`]                      |            |\n|                      `Integral
  a => a` | `23`                     | `\"13\"`           | [`base`] `20`                      |
  \           |\n|                     `Buildable a => a` | `10`                     |
  `\"  10\"`         | [`left`] `4 ' '`                   | [`l`]      |\n|                     `Buildable
  a => a` | `10`                     | `\"10  \"`         | [`right`] `4 ' '`                  |
  [`r`]      |\n|                     `Buildable a => a` | `10`                     |
  `\" 10 \"`         | [`center`] `4 ' '`                 |            |\n|                     `Buildable
  a => a` |  `123456`                | `\"123\"`          | [`fitLeft`] `3`                    |
  \           |\n|                     `Buildable a => a` |  `123456`                |
  `\"456\"`          | [`fitRight`] `3`                   |            |\n|                     `Buildable
  a => a` |  `True`                  | `\"True\"`         | [`build`]                          |
  \           |\n|                                    `a` | `undefined`              |
  `\"gronk!\"`       | [`fconst`] `\"gronk!\"`              |            |\n\n###
  Formatter Combinator Quick Reference\n\nFormatter combinators take a formatter and
  modify it somehow, e.g. by using it to format elements of a list, or changing its
  output.\n\nBuilt-in formatter combinators:\n\n\n| To format a                              |
  e.g.                      | as                                  | use                                      |\n|
  ----------------------------------------:| ------------------------  | -----------------------------------
  | ---------------------------------------- |\n| `Maybe a`                                |
  `Nothing`                 | `\"Goodbye\"`                         | [`maybed`] `\"Goodbye\"
  text`              |\n| `Maybe a`                                | `Just \"Hello\"`
  \           | `\"Hello\"`                           | [`maybed`] `\"Goodbye\" text`
  \             |\n| `Maybe a`                                | `Nothing`                 |
  `\"\"`                                | [`optioned`] `text`                      |\n|
  `Maybe a`                                | `Just \"Hello\"`            | `\"Hello\"`
  \                          | [`optioned`] `text`                      |\n| `Either
  a b`                             | `Left \"Error!\"`           | `\"Error!\"`                          |
  [`eithered`] `text int`                  |\n| `Either a b`                             |
  `Right 69`                | `\"69\"`                              | [`eithered`]
  `text int`                  |\n| `Either a x`                             | `Left
  \"bingo\"`            | `\"bingo\"`                           | [`lefted`] `text`
  \                       |\n| `Either a x`                             | `Right 16`
  \               | `\"\"`                                | [`lefted`] `text`                        |\n|
  `Either x a`                             | `Right \"bingo\"`           | `\"bingo\"`
  \                          | [`righted`] `text`                       |\n| `Either
  x a`                             | `Left 16`                 | `\"\"`                                |
  [`righted`] `text`                       |\n| `Foldable t => t a`                      |
  `[1, 2, 3]`               | `\"1st2nd3rd\"`                       | [`concatenated`]
  `ords`                  |\n| `Foldable t => t a`                      | `[123, 456,
  789]`         | `\"789456123\"`                       | [`joinedWith`] `(mconcat
  . reverse) int` |\n| `Foldable t => t a`                      | `[1, 2, 3]`               |
  `\"1\\|\\|2\\|\\|3\"`                     | [`intercalated`] `\"\\|\\|\" int`            |\n|
  `Foldable t => t a`                      | `[1, 2, 3]`               | `\"1 2 3\"`
  \                          | [`unworded`] `int`                       |\n| `Foldable
  t => t a`                      | `[1, 2, 3]`               | `\"1\\n2\\n3\"`                         |
  [`unlined`] `d`                          |\n| `Foldable t => t a`                      |
  `[1, 2, 3]`               | `\"1 2 3\"`                           | [`spaced`] `int`
  \                        |\n| `Foldable t => t a`                      | `[1, 2,
  3]`               | `\"1,2,3\"`                           | [`commaSep`] `int`                       |\n|
  `Foldable t => t a`                      | `[1, 2, 3]`               | `\"1st, 2nd,
  3rd\"`                   | [`commaSpaceSep`] `ords`                 |\n| `Foldable
  t => t a`                      | `[\"one\", \"two\", \"three\"]` | `\"[one, two,
  three]\"`               | [`list`] `t`                             |\n| `Foldable
  t => t a`                      | `[\"one\", \"two\", \"three\"]` | `\"[\\\"one\\\",
  \\\"two\\\", \\\"three\\\"]\"`   | [`qlist`] `t`                            |\n|
  `[a]`                                    | `[1..]`                   | `\"[1, 10,
  11, 100]\"`                | [`took`] `4 (list bin)`                  |\n| `[a]`
  \                                   | `[1..6]`                  | `\"[4, 5, 6]\"`
  \                      | [`dropped`] `3 (list int)`               |\n| `a`                                      |
  `\"one two\\tthree\\nfour`   | `\"one, two, three, four\"`           | [`splat`]
  `isSpace commaSpaceSep stext`  |\n| `a`                                      | `1234567890`
  \             | `\"[123, 456, 789, 0]\"`              | [`splatWith`] `(chunksOf
  3) list int`    |\n| `a`                                      | `\"one,two,three\"`
  \        | `\"one\\ntwo\\nthree\\n\"`               | [`splatOn`] `\",\" unlined
  t`              |\n| `a`                                      | `\"one  two three
  \ \"`      | `\"[one, two, three]\"`               | [`worded`] `list text`                   |\n|
  `a`                                      | `\"one\\n\\ntwo\\nthree\\n\\n`  | `\"[\"one\",
  \"\", \"two\", \"three\", \"\"]\"` | [`lined`] `qlist text`                   |\n|
  `a`                                      | `123456`                  | `\"654321\"`
  \                         | [`alteredWith`] `TL.reverse int`         |\n| `a`                                      |
  `\"Data.Char.isUpper`      | `\"DCU\"`                             | [`charsKeptIf`]
  `isUpper string`         |\n| `a`                                      | `\"Data.Char.isUpper`
  \     | `\"ata.har.ispper\"`                  | [`charsRemovedIf`] `isUpper string`
  \     |\n| `a`                                      | `\"look and boot\"`         |
  `\"leek and beet\"`                   | [`replaced`] `\"oo\" \"ee\" text`            |\n|
  `a`                                      | `\"look and boot\"`         | `\"LOOK
  AND BOOT\"`                   | [`uppercased`]                           |\n| `a`
  \                                     | `\"Look and Boot\"`         | `\"look and
  boot\"`                   | [`lowercased`]                           |\n| `a`                                      |
  `\"look and boot\"`         | `\"Look And Boot\"`                   | [`titlecased`]
  \                          |\n| `a`                                      | `\"hellos\"`
  \               | `\"he...\"`                           | [`ltruncated`] `5 text`
  \                 |\n| `a`                                      | `\"hellos\"`                |
  `\"h...s\"`                           | [`ctruncated`]                           |\n|
  `a`                                      | `\"hellos\"`                | `\"...os\"`
  \                          | [`rtruncated`] `5 text`                  |\n| `a`                                      |
  `1`                       | `\"  1\"`                             | [`lpadded`]
  `3 int`                      |\n| `a`                                      | `1`
  \                      | `\"1  \"`                             | [`rpadded`] `3
  int`                      |\n| `a`                                      | `1`                       |
  `\" 1 \"`                             | [`cpadded`] `3 int`                      |\n|
  `a`                                      | `123`                     | `\"123 \"`
  \                           | [`lfixed`] `4 int`                       |\n| `a`
  \                                     | `123456`                  | `\"1...\"`                            |
  [`lfixed`] `4 int`                       |\n| `a`                                      |
  `123`                     | `\" 123\"`                            | [`rfixed`] `4
  int`                       |\n| `a`                                      | `123456`
  \                 | `\"...6\"`                            | [`rfixed`] `4 int`                       |\n|
  `a`                                      | `123`                     | `\"  123
  \"`                          | [`cfixed`] `2 1 ' ' int`                 |\n| `a`
  \                                     | `1234567`                 | `\"12...7\"`
  \                         | [`cfixed`] `2 1 ' ' int`                 |\n| `a`                                      |
  `\"Goo\"`                   | `\"McGoo\"`                           | [`prefixed`]
  `\"Mc\" t`                    |\n| `a`                                      | `\"Goo\"`
  \                  | `\"Goosen\"`                          | [`suffixed`] `\"sen\"
  t`                   |\n| `a`                                      | `\"Goo\"`                   |
  `\"McGooMc\"`                         | [`surrounded`] `\"Mc\" t`                  |\n|
  `a`                                      | `\"Goo\"`                   | `\"McGoosen\"`
  \                       | [`enclosed`] `\"Mc\" \"sen\" t`              |\n| `a`
  \                                     | `\"Goo\"`                   | `\"'Goo'\"`
  \                          | [`squoted`] `t`                          |\n| `a`                                      |
  `\"Goo\"`                   | `\"\\\"Goo\\\"\"`                         | [`dquoted`]
  `t`                          |\n| `a`                                      | `\"Goo\"`
  \                  | `\"(Goo)\"`                           | [`parenthesised`] `t`
  \                   |\n| `a`                                      | `\"Goo\"`                   |
  `\"[Goo]\"`                           | [`squared`] `t`                          |\n|
  `a`                                      | `\"Goo\"`                   | `\"{Goo}\"`
  \                          | [`braced`] `t`                           |\n| `a`                                      |
  `\"Goo\"`                   | `\"<Goo>\"`                           | [`angled`]
  `t`                           |\n| `a`                                      | `\"Goo\"`
  \                  | ``\"`Goo`\"``                         | [`backticked`] `t`
  \                      |\n| `a`                                      | `\"Goo\"`
  \                  | `\"   Goo\"`                          | [`indented`] `3 t`
  \                      |\n| `Foldable t => t a`                      | `[1, 2, 3]`
  \              | `\"  1\\n  2\\n  3\"`                   | [`indentedLines`] `2
  d`                  |\n| `a`                                      | `\"1\\n2\\n3\"`
  \              | `\"  1\\n  2\\n  3\"`                   | [`reindented`] `2 t`
  \                    |\n| `Integral i, RealFrac d => d`            | `6.66`                    |
  `\"7\"`                               | [`roundedTo`] `int`                      |\n|
  `Integral i, RealFrac d => d`            | `6.66`                    | `\"6\"`                               |
  [`truncatedTo`] `int`                    |\n| `Integral i, RealFrac d => d`            |
  `6.66`                    | `\"7\"`                               | [`ceilingedTo`]
  `int`                    |\n| `Integral i, RealFrac d => d`            | `6.66`
  \                   | `\"6\"`                               | [`flooredTo`] `int`
  \                     |\n| field through a `Lens' s a`              | `(1, \"goo\")`
  \             | `\"goo\"`                             | [`viewed`] `_2 t`                        |\n|
  field through a record accessor `s -> a` | `(1, \"goo\")`              | `\"1\"`
  \                              | [`accessed`] `fst d`                     |\n| `Integral
  a => a`                        | `4097`                    | `\"0b0001000000000001\"`
  \             | [`binPrefix`] `16`                       |\n| `Integral a => a`
  \                       | `4097`                    | `\"0o0000000000010001\"`              |
  [`octPrefix`] `16`                       |\n| `Integral a => a`                        |
  `4097`                    | `\"0x0000000000001001\"`              | [`hexPrefix`]
  `16`                       |\n| `Ord f, Integral a, Fractional f => a`   | `1024`
  \                   | `\"1KB\"`                             | [`bytes`] `shortest`
  \                    |\n| `Ord f, Integral a, Fractional f => a`   | `1234567890`
  \             | `\"1.15GB\"`                          | [`bytes`] `(fixed 2)`                    |\n\n##
  Composing formatters\n\n`%.` is like `%` but feeds one formatter into another:\n\n```
  haskell\n位> format (left 2 '0' %. hex) 10\n\"0a\"\n```\n\n## Using more than one
  formatter on the same argument\n\n``` haskell\n位> now <- getCurrentTime\n位> format
  (year % \"/\" <> month <> \"/\" % dayOfMonth) now\n\"2015/01/27\"\n```\n\n## The
  Buildable Typeclass\n\nOne of the great things about `formatting` is that it doesn't
  rely on typeclasses: you can define one or more formatters for each of your types.\nBut
  you also have the option of defining a 'default' formatter for a type, by implementing
  the `Buildable` typeclass, which has one method: `build :: p -> Builder`.\nOnce
  this is defined for a type, you can use the `build` formatter (which is distinct
  from the `build` method of `Buildable`!):\n\n```haskell\n> format (\"Int: \" % build
  % \", Text: \" % build) 23 \"hello\"\n\"Int: 23, Text: hello\"\n```\n\nNote that
  while this can be convenient, it also sacrifices some type-safety: there's nothing
  preventing you from putting the arguments in the wrong order, because both `Int`
  and `Text` have a `Buildable` instance.\nNote also that if a type already has a
  `Show` instance then you can use this instead, by using the `shown` formatter.\n\n##
  Understanding the Types\n\nFormatters generally have a type like this:\n\n```haskell\nFormat
  r (a -> r)\n```\n\nThis describes a formatter that will eventually produce some
  string type `r`, and takes an `a` as an argument.\nFor example:\n\n```haskell\nint
  :: Integral a => Format r (a -> r)\n```\n\nThis takes an `Integral a` argument,
  and eventually produces an `r`.\nLet's work through using this with `format`:\n\n```haskell\n--
  format has this type:\nformat :: Format TL.Text a -> a\n\n-- so in 'format int',
  called with an 'Int', 'int's type specialises to:\nint :: Format TL.Text (Int ->
  TL.Text)\n\n-- and 'format's 'a' parameter specialises to 'Int -> TL.Text':\nformat
  :: Format TL.Text (Int -> TL.Text) -> Int -> TL.Text\n\n-- so 'format int' takes
  an Int and produces text:\nformat int :: Int -> TL.Text\n```\n\nWhat can be confusing
  in the above is that `int`'s `a` parameter expands to `Int`, but `format`'s `a`
  parameter expands to `Int -> TL.Text`.\n\nNow let's look at what happens when we
  use the `%` operator to append formatters:\n\n```haskell\n-- Here are the types
  of the functions we will use:\n(%) :: Format r a -> Format r' r -> Format r' a\nint
  :: Format r (Int -> r) -- simplified for this use\nstext :: Format r (T.Text ->
  r)\n\n-- Within the call to '%', in the expression 'int % stext', the type parameters
  expand like this:\n-- r = T.Text -> r'\n-- a = Int -> T.Text -> r'\n-- and so we
  have these types:\nint :: Format (T.Text -> r') (Int -> T.Text -> r')\nstext ::
  Format r' (T.Text -> r')\nint % stext :: Format r' (Int -> T.Text -> r')\n\n-- And
  so when we use 'format' we get a function that takes two arguments and produces
  text:\nformat (int % stext) :: Int -> T.Text -> TL.Text\n```\n\n## Comparison with
  Other Languages\n\nExample:\n\n``` haskell\nformat (\"Person's name is \" % text
  %  \", age is \" % hex) \"Dave\" 54\n```\n\nor with short-names:\n\n``` haskell\nformat
  (\"Person's name is \" % t % \", age is \" % x) \"Dave\" 54\n```\n\nSimilar to C's
  `printf`:\n\n``` c\nprintf(\"Person's name is %s, age is %x\",\"Dave\",54);\n```\n\nand
  Common Lisp's `FORMAT`:\n\n``` lisp\n(format nil \"Person's name is ~a, age is ~x\"
  \"Dave\" 54)\n```\n\n## Formatter Examples\n\n### \"Hello, World!\": Texts\n\n```
  haskell\n> format (text % \"!\") \"Hi!\"\n\"Hi!!\"\n> format (string % \"!\") \"Hi!\"\n\"Hi!!\"\n```\n\n###
  123: Integers\n\n``` haskell\n> format int 23\n\"23\"\n```\n\n### 23.4: Decimals\n\n```
  haskell\n> format (fixed 0) 23.3\n\"23\"\n> format (fixed 2) 23.3333\n\"23.33\"\n>
  format shortest 23.3333\n\"23.3333\"\n> format shortest 0.0\n\"0.0\"\n> format sci
  2.3\n\"2.3\"\n> format (scifmt Fixed (Just 0)) 2.3\n\"2\"\n```\n\n### 1,242: Commas\n\n```
  haskell\n> format commas 123456778\n\"123,456,778\"\n> format commas 1234\n\"1,234\"\n```\n\n###
  1st: Ordinals\n\n``` haskell\n> format ords 1\n\"1st\"\n> format ords 2\n\"2nd\"\n>
  format ords 3\n\"3rd\"\n> format ords 4\n\"4th\"\n```\n\n### 3F: Hex\n\n``` haskell\n>
  format hex 15\n\"f\"\n> format hex 25\n\"19\"\n```\n\n### Monday 1st June: Dates
  & times\n\n``` haskell\n> now <- getCurrentTime\n> later <- getCurrentTime\n> format
  (dayOfMonth % \"/\" % month % \"/\" % year) now now now\n\"16/06/2014\"\n> format
  day now\n\"167\"\n> format hms now\n\"08:24:41\"\n> format tz now\n\"+0000\"\n>
  format datetime now\n\"Mon Jun 16 08:24:41 UTC 2014\"\n> format century now\n\"20\"\n>
  format (dayOfMonthOrd % \" of \" % monthName) now now\n\"16th of June\"\n```\n\n###
  3 years ago: Time spans\n\n``` haskell\n> format (diff False) (diffUTCTime later
  now)\n\"2 seconds\"\n> format (diff True) (diffUTCTime later now)\n\"in 2 seconds\"\n>
  format (diff True) (diffUTCTime now later)\n\"2 seconds ago\"\n> format (seconds
  0 % \" secs\") (diffUTCTime now later)\n\"2 secs\"\n```\n\n``` haskell\n> let Just
  old = parseTime defaultTimeLocale \"%Y\" \"1980\" :: Maybe UTCTime\n> format (years
  0) (diffUTCTime now old)\n\"34\"\n> format (diff True) (diffUTCTime now old)\n\"in
  35 years\"\n> format (diff True) (diffUTCTime old now)\n\"35 years ago\"\n> format
  (days 0) (diffUTCTime old now)\n\"12585\"\n> format (days 0 % \" days\") (diffUTCTime
  old now)\n\"12585 days\"\n```\n\n### File sizes\n\n``` haskell\n> format (bytes
  shortest) 1024\n\"1KB\"\n> format (bytes (fixed 2 % \" \")) (1024*1024*5)\n\"5.00
  MB\"\n```\n\n### Scientific\n\nIf you're using a type which provides its own builder,
  like the\n`Scientific` type:\n\n``` haskell\nimport Data.Text.Lazy.Builder.Scientific\nscientificBuilder
  :: Scientific -> Builder\nformatScientificBuilder :: FPFormat -> Maybe Int -> Scientific
  -> Builder\n```\n\nThen you can use `later` easily:\n\n``` haskell\n> format (later
  scientificBuilder) 23.4\n\"23.4\"\n```\n\nActually, there are now already two handy
  combinators (`sci` and\n`scifmt`) for the `Scientific` type as shown above in the
  Decimals\nsection.\n\n## Writing your own Formatters\n\nYou can include things verbatim
  in the formatter:\n\n``` haskell\n> format (now \"This is printed now.\")\n\"This
  is printed now.\"\n```\n\nAlthough with `OverloadedStrings` you can just use string
  literals:\n\n``` haskell\n> format \"This is printed now.\"\n\"This is printed now.\"\n```\n\nYou
  can handle things later which makes the formatter accept arguments:\n\n``` haskell\n>
  format (later (const \"This is printed later.\")) ()\n\"This is printed later.\"\n```\n\nThe
  type of the function passed to `later` should return an instance\nof `Monoid`.\n\n```
  haskell\nlater :: (a -> Builder) -> Format r (a -> r)\n```\n\nThe function you format
  with (`format`, `bprint`, etc.)\nwill determine the monoid of choice. In the case
  of this library, the\ntop-level formating functions expect you to build a text `Builder`:\n\n```
  haskell\nformat :: Format Text a -> a\n```\n\nBecause builders are efficient generators.\n\nSo
  in this case we will be expected to produce Builders from arguments:\n\n``` haskell\nformat
  . later :: (a -> Builder) -> a -> Text\n```\n\nTo do that for common types you can
  just re-use the formatting library\nand use bprint:\n\n``` haskell\n位> :t bprint\nbprint
  :: Format Builder a -> a\n> :t bprint int 23\nbprint int 23 :: Builder\n```\n\nComing
  back to `later`, we can now use it to build our own printer\ncombinators:\n\n```
  haskell\n> let mint = later (maybe \"\" (bprint int))\n> :t mint\nmint :: Integral
  a => Format r (Maybe a -> r)\n```\n\nNow `mint` is a formatter to show `Maybe Integer`:\n\n```
  haskell\n> format mint (readMaybe \"23\")\n\"23\"\n> format mint (readMaybe \"foo\")\n\"\"\n```\n\nAlthough
  a better, more general combinator might be:\n\n``` haskell\n> let mfmt x f = later
  (maybe x (bprint f))\n```\n\nNow you can use it to maybe format things:\n\n``` haskell\n>
  format (mfmt \"Nope!\" int) (readMaybe \"foo\")\n\"Nope!\"\n```\n\n## Hacking\n\n###
  Building with Nix\n\nSee [README-nix.md](./README-nix.md).\n\n### Running the Tests\n\nFrom
  within your `nix-shell`, run `cabal test`.\n\nThe tests are in `test/Spec.hs`.\n\n###
  Running the Benchmarks\n\nStart `nix-shell` like this: `nix-shell --arg doBenchmark
  true`.\nFrom within your `nix-shell`, run `cabal bench`.\n\nTo build the html benchmarking
  reports, run `cabal bench --benchmark-option=-obench/reports/7.2.0.html > bench/reports/7.2.0.txt`,
  replacing '7.2.0' with the current version.\nThis will output the file `bench.html`
  which you can open in a browser.\n\nThe benchmarks are in `bench/bench.hs`.\n\n[`format`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:format\n[`sformat`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:sformat\n[`bformat`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:bformat\n[`formatToString`]:
  https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:formatToString\n[`fprint`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:fprint\n[`fprintLn`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:fprintLn\n[`hprint`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:hprint\n[`hprintLn`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:hprintLn\n\n[`text`]:
  \          https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:text\n[`stext`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:stext\n[`string`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:string\n[`builder`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:builder\n[`shown`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:shown\n[`char`]:
  \          https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:char\n[`int`]:
  \           https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:int\n[`float`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:float\n[`fixed`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:fixed\n[`sci`]:
  \           https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:sci\n[`scifmt`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:scifmt\n[`groupInt`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:groupInt\n[`commas`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:commas\n[`ords`]:
  \          https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:ords\n[`plural`]:
  \           https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:plural\n[`asInt`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:asInt\n[`bin`]:
  \           https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:bin\n[`prefixBin`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:prefixBin\n[`oct`]:
  \           https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:oct\n[`prefixOct`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:prefixOct\n[`hex`]:
  \           https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:hex\n[`prefixHex`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:prefixHex\n[`base`]:
  \          https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:base\n[`left`]:
  \          https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:left\n[`right`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:right\n[`center`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:center\n[`fitLeft`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:fitLeft\n[`fitRight`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:fitRight\n[`build`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:build\n[`fconst`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:fconst\n[`bytes`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Formatters.html#v:bytes\n\n[`t`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:t\n[`st`]:
  \            https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:st\n[`s`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:s\n[`sh`]:
  \            https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:sh\n[`c`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:c\n[`d`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:d\n[`sf`]:
  \            https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:sf\n[`f`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:f\n[`b`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:b\n[`o`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:o\n[`x`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:x\n[`l`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:l\n[`r`]:
  \             https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-ShortFormatters.html#v:r\n\n[`maybed`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:maybed\n[`optioned`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:optioned\n[`eithered`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:eithered\n[`lefted`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:lefted\n[`righted`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:righted\n[`concatenated`]:
  \  https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting.html#v:concatenated\n[`joinedWith`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:joinedWith\n[`intercalated`]:
  \  https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:intercalated\n[`unworded`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:unworded\n[`unlined`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:unlined\n[`spaced`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:spaced\n[`commaSep`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:commaSep\n[`commaSpaceSep`]:
  \ https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:commaSpaceSep\n[`list`]:
  \          https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:list\n[`qlist`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:qlist\n[`took`]:
  \          https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:took\n[`dropped`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:dropped\n[`splat`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:splat\n[`splatWith`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:splatWith\n[`splatOn`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:splatOn\n[`worded`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:worded\n[`lined`]:
  \         https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:lined\n[`alteredWith`]:
  \   https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:alteredWith\n[`charsKeptIf`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:charsKeptIf\n[`charsRemovedIf`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#vata.har.isppercharsRemovedIf\n[`replaced`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:replaced\n[`uppercased`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:uppercased\n[`lowercased`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:lowercased\n[`titlecased`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:titlecased\n[`ltruncated`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:ltruncated\n[`ctruncated`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:ctruncated\n[`rtruncated`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:rtruncated\n[`lpadded`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:lpadded\n[`rpadded`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:rpadded\n[`cpadded`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:cpadded\n[`lfixed`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:lfixed\n[`rfixed`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:rfixed\n[`cfixed`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:cfixed\n[`prefixed`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:prefixed\n[`suffixed`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:suffixed\n[`surrounded`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:surrounded\n[`enclosed`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:enclosed\n[`squoted`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:squoted\n[`dquoted`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:dquoted\n[`parenthesised`]:
  \ https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:parenthesised\n[`squared`]:
  \       https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:squared\n[`braced`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:braced\n[`angled`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:angled\n[`backticked`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:backticked\n[`indented`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:indented\n[`indentedLines`]:
  \ https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:indentedLines\n[`reindented`]:
  \    https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:reindented\n[`roundedTo`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:roundedTo\n[`truncatedTo`]:
  \   https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:truncatedTo\n[`ceilingedTo`]:
  \   https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:ceilingedTo\n[`flooredTo`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:flooredTo\n[`viewed`]:
  \        https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:viewed\n[`accessed`]:
  \      https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:accessed\n[`binPrefix`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:binPrefix\n[`octPrefix`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:octPrefix\n[`hexPrefix`]:
  \     https://hackage.haskell.org/package/formatting-7.1.1/docs/Formatting-Combinators.html#v:hexPrefix\n"
license-name: BSD-3-Clause

homepage: https://github.com/tfausak/autoexporter#readme
changelog-type: markdown
hash: 2251ccd632aadd2dbb07412804cc44b5bd40d7cf656aeea59d14e59d14b015e1
test-bench-deps: {}
maintainer: Taylor Fausak
synopsis: Automatically re-export modules.
changelog: |
  # Change log

  Autoexporter uses [Semantic Versioning][].
  The change log is available through the [releases on GitHub][].

  [Semantic Versioning]: http://semver.org/spec/v2.0.0.html
  [releases on GitHub]: https://github.com/tfausak/autoexporter/releases
basic-deps:
  Cabal: ! '>=1.24.0 && <1.25 || >=2.0.1 && <2.5 || >=3.0.0 && <3.1'
  base: ! '>=4.9.0 && <4.14'
  filepath: ! '>=1.4.1 && <1.5'
  autoexporter: -any
  directory: ! '>=1.2.6 && <1.4'
all-versions:
- 0.1.1
- 0.1.2
- 0.1.4
- 0.2.0
- 0.2.1
- 0.2.2
- 0.2.3
- 1.0.0
- 1.1.0
- 1.1.1
- 1.1.2
- 1.1.3
- 1.1.4
- 1.1.7
- 1.1.9
- 1.1.10
- 1.1.11
- 1.1.13
- 1.1.14
- 1.1.15
author: ''
latest: 1.1.15
description-type: markdown
description: |
  # [Autoexporter][]

  [![Version badge][]][version]
  [![Build badge][]][build]

  Autoexporter automatically re-exports Haskell modules.

  Let's say you have a module `M` that just exports some other modules. It might
  look like this:

  ``` haskell
  module M
    ( module M.A
    , module M.B
    ) where

  import M.A
  import M.B
  ```

  This code is error-prone. If you add a new module, say `M.C`, you have to
  remember to come back to this file and re-export it. And this code is tedious
  to write. You have to list each module twice. You can do a little better, but
  not much.

  ``` haskell
  module M (module X) where
  import M.A as X
  import M.B as X
  ```

  Now you don't have to write every module twice, but you still have to remember
  to re-export everything. And the generated documentation for this module
  doesn't include anything about the exported modules.

  Autoexporter handles this for you. Instead of either of the above approaches,
  simply drop this into the `M` module:

  ``` haskell
  {-# OPTIONS_GHC -F -pgmF autoexporter #-}
  ```

  That will generate code that looks like this:

  ``` haskell
  module M (
    module M.A,
    module M.B,
  ) where
  import M.A
  import M.B
  ```

  Autoexporter will generally behave as you'd expect, but there are a couple
  things to look out for:

  - You cannot selectively include or exclude any modules.

  - By default, only immediate children will be re-exported. If you use this in
    some module `M`, it won't pull in `M.A.B`. If you need deep re-exporting,
    please pass `--deep` to Autoexporter like this:

    ```haskell
    {-# OPTIONS_GHC -F -pgmF autoexporter -optF --deep #-}
    ```

  [Autoexporter]: https://github.com/tfausak/autoexporter
  [Version badge]: https://www.stackage.org/package/autoexporter/badge/nightly?label=version
  [version]: https://www.stackage.org/nightly/package/autoexporter
  [Build badge]: https://travis-ci.org/tfausak/autoexporter.svg?branch=master
  [build]: https://travis-ci.org/tfausak/autoexporter
license-name: MIT

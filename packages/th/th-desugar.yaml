homepage: https://github.com/goldfirere/th-desugar
changelog-type: markdown
hash: 32a5054fe3c24b5b09690482fb133311415078193df060d26825952b5278f1d6
test-bench-deps:
  base: '>=4 && <5'
  hspec: '>=1.3'
  th-orphans: '>=0.13.9'
  syb: '>=0.4'
  HUnit: '>=1.2'
  th-abstraction: -any
  containers: '>=0.5'
  th-desugar: -any
  mtl: '>=2.1'
  template-haskell: -any
maintainer: Ryan Scott <ryan.gl.scott@gmail.com>
synopsis: Functions to desugar Template Haskell
changelog: "`th-desugar` release notes\r\n==========================\r\n\r\nVersion
  1.15 [2023.03.12]\r\n-------------------------\r\n* Support GHC 9.6.\r\n* The `NewOrData`
  data type has been renamed to `DataFlavor` and extended to\r\n  support `type data`
  declarations:\r\n\r\n  ```diff\r\n  -data NewOrData  = NewType | Data\r\n  +data
  DataFlavor = NewType | Data | TypeData\r\n  ```\r\n\r\n  Desugaring upholds the
  following properties regarding `TypeData`:\r\n\r\n  * A `DDataD` with a `DataFlavor`
  of `TypeData` cannot have any deriving\r\n    clauses or datatype contexts, and
  the `DConFields` in each `DCon` will be a\r\n    `NormalC` where each `Bang` is
  equal to\r\n    `Bang NoSourceUnpackedness NoSourceStrictness`.\r\n  * A `DDataInstD`
  can have a `DataFlavor` of `NewType` or `Data`, but not\r\n    `TypeData`.\r\n*
  The type of `getDataD` has been changed to also include a `DataFlavor`:\r\n\r\n
  \ ```diff\r\n  -getDataD :: DsMonad q => String -> Name -> q ([TyVarBndrUnit], [Con])\r\n
  \ +getDataD :: DsMonad q => String -> Name -> q (DataFlavor, [TyVarBndrUnit], [Con])\r\n
  \ ```\r\n* Local reification can now reify the types of pattern synonym record\r\n
  \ selectors.\r\n* Fix a bug in which the types of locally reified GADT record selectors
  would\r\n  sometimes have type variables quantified in the wrong order.\r\n\r\nVersion
  1.14 [2022.08.23]\r\n-------------------------\r\n* Support GHC 9.4.\r\n* Drop support
  for GHC 7.8 and 7.10. As a consequence of this, the\r\n  `strictToBang` function
  was removed as it no longer serves a useful purpose.\r\n* Desugared lambda expressions
  and guards that bind multiple patterns can now\r\n  have patterns with unlifted
  types. The desugared code uses `UnboxedTuples` to\r\n  make this possible, so if
  you load the desugared code into GHCi on prior to\r\n  GHC 9.2, you will need to
  enable `-fobject-code`.\r\n* `th-desugar` now desugars `PromotedInfixT` and `PromotedUInfixT`,
  which were\r\n  added in GHC 9.4. Mirroring the existing treatment of other `Promoted*`\r\n
  \ `Type`s, `PromotedInfixT` is desugared to an application of a `DConT` applied\r\n
  \ to two arguments, just like `InfixT` is desugared. Similarly, attempting to\r\n
  \ desugar a `PromotedUInfixT` results in an error, just like attempting to\r\n  desugar
  a `UInfixT` would be.\r\n* `th-desugar` now supports `DefaultD` (i.e., `default`
  declarations) and\r\n  `OpaqueP` (i.e., `OPAQUE` pragmas), which were added in GHC
  9.4.\r\n* `th-desugar` now desugars `LamCasesE` (i.e., `\\cases` expressions), which
  was\r\n  added in GHC 9.4. A `\\cases` expression is desugared to an ordinary lambda\r\n
  \ expression, much like `\\case` is currently desugared.\r\n* Fix an inconsistency
  which caused non-exhaustive `case` expressions to be\r\n  desugared into uses of
  `EmptyCase`. Non-exhaustive `case` expressions are now\r\n  desugared into code
  that throws a \"`Non-exhaustive patterns in...`\" error at\r\n  runtime, just as
  all other forms of non-exhaustive expressions are desugared.\r\n* Fix a bug in which
  `expandType` would not expand closed type families when\r\n  applied to arguments
  containing type variables.\r\n\r\nVersion 1.13.1 [2022.05.20]\r\n---------------------------\r\n*
  Allow building with `mtl-2.3.*`.\r\n\r\nVersion 1.13 [2021.10.30]\r\n-------------------------\r\n*
  Support GHC 9.2.\r\n* Add support for visible type application in data constructor
  patterns. As a\r\n  result of these changes, the `DConP` constructor now has an
  extra field to\r\n  represent type arguments:\r\n\r\n  ```diff\r\n   data DPat\r\n
  \    = ...\r\n  -  | DConP Name         [DPat] -- fun (Just    x) = ...\r\n  +  |
  DConP Name [DType] [DPat] -- fun (Just @t x) = ...\r\n     | ...\r\n  ```\r\n* Add
  support for the `e.field` and `(.field)` syntax from the\r\n  `OverloadedRecordDot`
  language extension.\r\n* The `Maybe [DTyVarBndrUnit]` fields in `DInstanceD` and
  `DStandaloneDerivD`\r\n  are no longer used when sweetening. Previously, `th-desugar`
  would attempt to\r\n  sweeten these `DTyVarBndrUnit`s by turning them into a nested
  `ForallT`, but\r\n  GHC 9.2 or later no longer allow this, as they forbid nested
  `forall`s in\r\n  instance heads entirely. As a result, the `Maybe [DTyVarBndrUnit]`
  fields are\r\n  now only useful for functions that consume `DDec`s directly.\r\n*
  Fix a bug in which desugared GADT constructors would sometimes incorrectly\r\n  claim
  that they were declared infix, despite this not being the case.\r\n\r\nVersion 1.12
  [2021.03.12]\r\n-------------------------\r\n* Support GHC 9.0.\r\n* Add support
  for explicit specificity. As part of this change,\r\n  the way `th-desugar` represents
  type variable binders has been overhauled:\r\n  * The `DTyVarBndr` data type is
  now parameterized by a `flag` type parameter:\r\n\r\n    ```hs\r\n    data DTyVarBndr
  flag\r\n      = DPlainTV Name flag\r\n      | DKindedTV Name flag DKind\r\n    ```\r\n\r\n
  \   This can be instantiated to `Specificity` (for type variable binders that\r\n
  \   can be specified or inferred) or `()` (for type variable binders where\r\n    specificity
  is irrelevant). `DTyVarBndrSpec` and `DTyVarBndrUnit` are also\r\n    provided as
  type synonyms for `DTyVarBndr Specificity` and `DTyVarBndr ()`,\r\n    respectively.\r\n
  \ * In order to interface with `TyVarBndr` (the TH counterpart to `DTyVarBndr`)\r\n
  \   in a backwards-compatible way, `th-desugar` now depends on the\r\n    `th-abstraction`
  library.\r\n  * The `ForallVisFlag` has been removed in favor of the new `DForallTelescope`\r\n
  \   data type, which not only distinguishes between invisible and visible\r\n    `forall`s
  but also uses the correct type variable flag for invisible type\r\n    variables
  (`Specificity`) and visible type variables (`()`).\r\n  * The type of the `dsTvb`
  is now different on pre-9.0 versions of GHC:\r\n\r\n    ```hs\r\n    #if __GLASGOW_HASKELL__
  >= 900\r\n    dsTvb :: DsMonad q => TyVarBndr flag -> q (DTyVarBndr flag)\r\n    #else\r\n
  \   dsTvb :: DsMonad q => flag -> TyVarBndr -> q (DTyVarBndr flag)\r\n    #endif\r\n
  \   ```\r\n\r\n    This is unfortunately required by the fact that prior to GHC
  9.0, there is\r\n    no `flag` information stored anywhere in a `TyVarBndr`. If
  you need to use\r\n    `dsTvb` in a backward-compatible way, `L.H.TH.Desugar` now
  provides\r\n    `dsTvbSpec` and `dsTvbUnit` functions which specialise `dsTvb` to\r\n
  \   particular `flag` types:\r\n\r\n    ```hs\r\n    dsTvbSpec :: DsMonad q => TyVarBndrSpec
  -> q DTyVarBndrSpec\r\n    dsTvbUnit :: DsMonad q => TyVarBndrUnit -> q DTyVarBndrUnit\r\n
  \   ```\r\n* The type of the `getRecordSelectors` function has changed:\r\n\r\n
  \ ```diff\r\n  -getRecordSelectors :: DsMonad q => DType -> [DCon] -> q [DLetDec]\r\n
  \ +getRecordSelectors :: DsMonad q =>          [DCon] -> q [DLetDec]\r\n  ```\r\n\r\n
  \ The old type signature had a `DType` argument whose sole purpose was to help\r\n
  \ determine which type variables were existential, as this information was used\r\n
  \ to filter out \"naughty\" record selectors, like the example below:\r\n\r\n  ```hs\r\n
  \ data Some :: (Type -> Type) -> Type where\r\n    MkSome :: { getSome :: f a }
  -> Some f\r\n  ```\r\n\r\n  The old implementation of `getRecordSelectors` would
  not include `getSome` in\r\n  the returned list, as its type `f a` mentions an existential
  type variable,\r\n  `a`, that is not mentioned in the return type `Some f`. The
  new\r\n  implementation of `getRecordSelectors`, on the other hand, makes no attempt\r\n
  \ to filter out naughty record selectors, so it would include `getSome`.\r\n\r\n
  \ This reason for this change is ultimately because determining which type\r\n  variables
  are existentially quantified in the context of Template\r\n  Haskell is rather challenging
  in the general case. There are heuristics we\r\n  could employ to guess which variables
  are existential, but we have found\r\n  these heuristics difficult to predict (let
  alone specify). As a result, we\r\n  take the slightly less correct (but much easier
  to explain) approach of\r\n  returning all record selectors, regardless of whether
  they are naughty or not.\r\n* The `conExistentialTvbs` function has been removed.
  It was horribly buggy,\r\n  especially in the presence of GADT constructors. Moreover,
  this function was\r\n  used in the implementation of `getRecordSelectors` function,
  so bugs in\r\n  `conExistentialTvbs` often affected the results of `getRecordSelectors`.\r\n*
  The types of `decToTH`, `letDecToTH`, and `pragmaToTH` have changed:\r\n\r\n  ```diff\r\n
  \ -decToTH :: DDec -> [Dec]\r\n  +decToTH :: DDec -> Dec\r\n\r\n  -letDecToTH ::
  DLetDec -> Maybe Dec\r\n  +letDecToTH :: DLetDec -> Dec\r\n\r\n  -pragmaToTH ::
  DPragma -> Maybe Pragma\r\n  +pragmaToTH :: DPragma -> Pragma\r\n  ```\r\n\r\n  The
  semantics of `pragmaToTH` have changed accordingly. Previously,\r\n  `pragmaToTH`
  would return `Nothing` when the argument is a `DPragma` that is\r\n  not supported
  on an old version of GHC, but now an error will be thrown\r\n  instead. `decToTH`
  and `letDecToTH`, which transitively invoke `pragmaToTH`,\r\n  have had their types
  updated to accommodate `pragmaToTH`'s type change.\r\n* The type of the `substTyVarBndrs`
  function has been simplified to avoid the\r\n  needless use of continuation-passing
  style:\r\n\r\n  ```diff\r\n  -substTyVarBndrs :: Quasi q => DSubst -> [DTyVarBndr
  flag] -> (DSubst -> [DTyVarBndr flag] -> q a) -> q a\r\n  +substTyVarBndrs :: Quasi
  q => DSubst -> [DTyVarBndr flag] -> q (DSubst, [DTyVarBndr flag])\r\n  ```\r\n*
  `mkDLamEFromDPats` has now generates slightly more direct code for certain\r\n  lambda
  expressions with `@`-patterns. For example, `\\x@y -> f x y` would\r\n  previously
  desugar to `\\arg -> case arg of { y -> let x = y in f x y }`, but\r\n  it now desugars
  to `\\y -> let x = y in f x y`.\r\n* `mkDLamEFromDPats` now requires only a `Quasi`
  context instead of `DsMonad`.\r\n\r\nVersion 1.11 [2020.03.25]\r\n-------------------------\r\n*
  Support GHC 8.10.\r\n* Add support for visible dependent quantification. As part
  of this change,\r\n  the way `th-desugar` represents `forall` and constraint types
  has been\r\n  overhauled:\r\n  * The existing `DForallT` constructor has been split
  into two smaller\r\n    constructors:\r\n\r\n    ```diff\r\n     data DType\r\n
  \      = ...\r\n    -  | DForallT [DTyVarBndr] DCxt DType\r\n    +  | DForallT ForallVisFlag
  [DTyVarBndr] DType\r\n    +  | DConstrainedT DCxt DType\r\n       | ...\r\n\r\n
  \   +data ForallVisFlag\r\n    +  = ForallVis\r\n    +  | ForallInvis\r\n    ```\r\n\r\n
  \   The previous design combined `forall`s and constraints into a single\r\n    constructor,
  while the new design puts them in distinct constructors\r\n    `DForallT` and `DConstrainedT`,
  respectively. The new `DForallT`\r\n    constructor also has a `ForallVisFlag` field
  to distinguish invisible\r\n    `forall`s (e.g., `forall a. a`) from visible `forall`s
  (e.g.,\r\n    `forall a -> a`).\r\n  * The `unravel` function has been renamed to
  `unravelDType` and now returns\r\n    `(DFunArgs, DType)`, where `DFunArgs` is a
  data type that represents\r\n    the possible arguments in a function type (see
  the Haddocks for `DFunArgs`\r\n    for more details). There is also an `unravelDType`
  counterpart for `Type`s\r\n    named `unravelType`, complete with its own `FunArgs`
  data type.\r\n\r\n    `{D}FunArgs` also have some supporting operations, including\r\n
  \   `filter{D}VisFunArgs` (to obtain only the visible arguments) and\r\n    `ravel{D}Type`
  (to construct a function type using `{D}FunArgs` and\r\n    a return `{D}Type`).\r\n*
  Support standalone kind signatures by adding a `DKiSigD` constructor to\r\n  `DDec`.\r\n*
  Add `dsReifyType`, `reifyTypeWithLocals_maybe`, and `reifyTypeWithLocals`,\r\n  which
  allow looking up the types or kinds of locally declared entities.\r\n* Fix a bug
  in which `reifyFixityWithLocals` would not look into local fixity\r\n  declarations
  inside of type classes.\r\n* Fix a bug in which `reifyFixityWithLocals` would return
  incorrect results\r\n  for classes with associated type family defaults.\r\n\r\nVersion
  1.10\r\n------------\r\n* Support GHC 8.8. Drop support for GHC 7.6.\r\n* Add support
  for visible kind application, type variable `foralls` in `RULES`,\r\n  and explicit
  `forall`s in type family instances. Correspondingly,\r\n  * There is now a `DAppKindT`
  constructor in `DType`.\r\n  * Previously, the `DDataInstD` constructor had fields
  of type `Name` and\r\n    `[DType]`. Those have been scrapped in favor of a single
  field of type\r\n    `DType`, representing the application of the data family name
  (which was\r\n    previously the `Name`) to its arguments (which was previously
  the\r\n    `[DType]`).\r\n\r\n    `DDataInstD` also has a new field of type `Maybe
  [DTyVarBndr]` to represent\r\n    its explicitly quantified type variables (if present).\r\n
  \ * Previously, the `DTySynEqn` constructor had a field of type `[DType]`.\r\n    That
  has been scrapped in favor of a field of type `DType`, representing\r\n    the application
  of the type family name (which `DTySynEqn` did not used to\r\n    contain!) to its
  arguments (which was previously the `[DType]`).\r\n\r\n    `DTySynEqn` also has
  a new field of type `Maybe [DTyVarBndr]` to represent\r\n    its explicitly quantified
  type variables (if present).\r\n  * `DTySynInstD` no longer has a field of type
  `Name`, as that is redundant\r\n    now that each `DTySynEqn` contains the same
  `Name`.\r\n  * There is now a field of type `Maybe [DTyVarBndr]` in the `DRuleP`\r\n
  \   constructor to represent bound type variables in `RULES` (if present).\r\n*
  Add a field of type `Maybe [DTyVarBndr]` to `DInstanceD` and\r\n  `DStandaloneDerivD`
  for optionally quantifying type variables explicitly.\r\n  If supplied with a `Just`,
  this sweetens the instance type to use a `ForallT`\r\n  to represent the explicit
  quantification. This trick is not supported for\r\n  `InstanceD` on GHC 8.0 and
  for `StandaloneDerivD` on GHC 7.10 or 8.0, so be\r\n  aware of this limitation if
  you supply `Just` for this field.\r\n* Add support for desugaring implicit params.
  This does not involve any changes\r\n  to the `th-desugar` AST, as:\r\n  * `(?x
  :: a) => ...` is desugared to `IP \"x\" a => ...`.\r\n  * `id ?x` is desugared to
  `id (ip @\"x\")`.\r\n  * `let ?x = 42 in ...` is desugared to\r\n    `let new_x_val
  = 42 in bindIP @\"x\" new_x_val ...` (where `bindIP` is a new\r\n    utility function
  exported by `Language.Haskell.TH.Desugar` on GHC 8.0 or\r\n    later).\r\n\r\n  In
  order to support this desugaring, the type signatures of `dsLetDec` and\r\n  `dsLetDecs`
  now return `([DLetDec], DExp -> DExp)` instead of just\r\n  `[DLetDec]`, where `DExp
  -> DExp` is the expression which binds the values of\r\n  implicit params (e.g.,
  `\\z -> bindIP @\"x\" new_x_val z`) if any are bound.\r\n  (If none are bound, this
  is simply the `id` function.)\r\n* Fix a bug in which `toposortTyVarsOf` would error
  at runtime if given types\r\n  containing `forall`s as arguments.\r\n* Fix a bug
  in which `fvDType` would return incorrect results if given a type\r\n  containing
  quantified constraints.\r\n* Fix a bug in which `expandType` would not expand type
  synonyms in the kinds\r\n  of type variable binders in `forall`s.\r\n* Fix a bug
  in which `getRecordSelectors` would omit record selectors from\r\n  GADT constructors.\r\n*
  Fix a bug in which `toposortTyVarsOf` would sometimes not preserve\r\n  the left-to-right
  ordering of `Name`s generated with `qNewName`.\r\n* Locally reified class methods,
  data constructors, and record selectors now\r\n  quantify kind variables properly.\r\n*
  Desugared ADT constructors now quantify kind variables properly.\r\n* Remove `DPred`,
  as it has become too similar to `DType`. This also means\r\n  that the `DPat` constructors,
  which previously ended with the suffix `Pa`,\r\n  can now use the suffix `P`, mirroring
  TH.\r\n* The type of `applyDType` has changed from `DType -> [DType] -> DType` to\r\n
  \ `DType -> [DTypeArg] -> DType`, where `DTypeArg` is a new data type that\r\n  encodes
  whether an argument is a normal type argument (e.g., the `Int` in\r\n  `Maybe Int`)
  or a visible kind argument (e.g., the `@Type` in\r\n  `Proxy @Type Char`). A `TypeArg`
  data type (which is like `DTypeArg`, but\r\n  with `Type`s/`Kind`s instead of `DType`s/`DKind`s)
  is also provided.\r\n\r\n  A handful of utility functions for manipulating `TypeArg`s
  and `DTypeArg`s\r\n  are also exported.\r\n* `th-desugar` functions that compute
  free variables (e.g., `fvDType`) now\r\n  return an `OSet`, a variant of `Set` that
  remembers the order in which\r\n  elements were inserted. A consequence of this
  change is that it fixes a bug\r\n  that causes free variables to be computed in
  different orders depending on\r\n  which unique numbers GHC happened to generate
  internally.\r\n* Substition and type synonym expansion are now more efficient by
  avoiding\r\n  the use of `syb` in inner loops.\r\n\r\nVersion 1.9\r\n-----------\r\n*
  Suppose GHC 8.6.\r\n\r\n* Add support for `DerivingVia`. Correspondingly, there
  is now a\r\n  `DDerivStrategy` data type.\r\n\r\n* Add support for `QuantifiedConstraints`.
  Correspondingly, there is now a\r\n  `DForallPr` constructor in `DPred` to represent
  quantified constraint types.\r\n\r\n* Remove the `DStarT` constructor of `DType`
  in favor of `DConT ''Type`.\r\n  Two utility functions have been added to `Language.Haskell.TH.Desugar`
  to\r\n  ease this transition:\r\n\r\n  * `isTypeKindName`: returns `True` if the
  argument `Name` is that\r\n    of `Type` or `★` (or `*`, to support older GHCs).\r\n
  \ * `typeKindName`: the name of `Type` (on GHC 8.0 or later) or `*` (on older\r\n
  \   GHCs).\r\n\r\n* `th-desugar` now desugars all data types to GADT syntax. The
  most significant\r\n  API-facing changes resulting from this new design are:\r\n\r\n
  \ * The `DDataD`, `DDataFamilyD`, and `DDataFamInstD` constructors of `DDec`\r\n
  \   now have `Maybe DKind` fields that either have `Just` an explicit return\r\n
  \   kind (e.g., the `k -> Type -> Type` in `data Foo :: k -> Type -> Type`)\r\n
  \   or `Nothing` (if lacking an explicit return kind).\r\n  * The `DCon` constructor
  previously had a field of type `Maybe DType`, since\r\n    there was a possibility
  it could be a GADT (with an explicit return type)\r\n    or non-GADT (without an
  explicit return type) constructor. Since all data\r\n    types are desugared to
  GADTs now, this field has been changed to be simply\r\n    a `DType`.\r\n  * The
  type signature of `dsCon` was previously:\r\n\r\n    ```haskell\r\n    dsCon ::
  DsMonad q => Con -> q [DCon]\r\n    ```\r\n\r\n    However, desugaring constructors
  now needs more information than before,\r\n    since GADT constructors have richer
  type signatures. Accordingly, the type\r\n    of `dsCon` is now:\r\n\r\n    ```haskell\r\n
  \   dsCon :: DsMonad q\r\n          => [DTyVarBndr] -- ^ The universally quantified
  type variables\r\n                          --   (used if desugaring a non-GADT
  constructor)\r\n          -> DType        -- ^ The original data declaration's type\r\n
  \                         --   (used if desugaring a non-GADT constructor).\r\n
  \         -> Con -> q [DCon]\r\n    ```\r\n\r\n    The `instance Desugar [Con] [DCon]`
  has also been removed, as the previous\r\n    implementation of `desugar` (`concatMapM
  dsCon`) no longer has enough\r\n    information to work.\r\n\r\n  Some other utility
  functions have also been added as part of this change:\r\n\r\n  * A `conExistentialTvbs`
  function has been introduced to determine the\r\n    existentially quantified type
  variables of a `DCon`. Note that this\r\n    function is not 100% accurate—refer
  to the documentation for\r\n    `conExistentialTvbs` for more information.\r\n\r\n
  \ * A `mkExtraDKindBinders` function has been introduced to turn a data type's\r\n
  \   return kind into explicit, fresh type variable binders.\r\n\r\n  * A `toposortTyVarsOf`
  function, which finds the free variables of a list of\r\n    `DType`s and returns
  them in a well scoped list that has been sorted in\r\n    reverse topological order.\r\n\r\n*
  `th-desugar` now desugars partial pattern matches in `do`-notation and\r\n  list/monad
  comprehensions to the appropriate invocation of `fail`.\r\n  (Previously, these
  were incorrectly desugared into `case` expressions with\r\n  incomplete patterns.)\r\n\r\n*
  Add a `mkDLamEFromDPats` function for constructing a `DLamE` expression using\r\n
  \ a list of `DPat` arguments and a `DExp` body.\r\n\r\n* Add an `unravel` function
  for decomposing a function type into its `forall`'d\r\n  type variables, its context,
  its argument types, and its result type.\r\n\r\n* Export a `substTyVarBndrs` function
  from `Language.Haskell.TH.Desugar.Subst`,\r\n  which substitutes over type variable
  binders in a capture-avoiding fashion.\r\n\r\n* `getDataD`, `dataConNameToDataName`,
  and `dataConNameToCon` from\r\n  `Language.Haskell.TH.Desugar.Reify` now look up
  local declarations. As a\r\n  result, the contexts in their type signatures have
  been strengthened from\r\n  `Quasi` to `DsMonad`.\r\n\r\n* Export a `dTyVarBndrToDType`
  function which converts a `DTyVarBndr` to a\r\n  `DType`, which preserves its kind.\r\n\r\n*
  Previously, `th-desugar` would silently accept illegal uses of record\r\n  construction
  with fields that did not belong to the constructor, such as\r\n  `Identity { notAField
  = \"wat\" }`. This is now an error.\r\n\r\nVersion 1.8\r\n-----------\r\n* Support
  GHC 8.4.\r\n\r\n* `substTy` now properly substitutes into kind signatures.\r\n\r\n*
  Expose `fvDType`, which computes the free variables of a `DType`.\r\n\r\n* Incorporate
  a `DDeclaredInfix` field into `DNormalC` to indicate if it is\r\n  a constructor
  that was declared infix.\r\n\r\n* Implement `lookupValueNameWithLocals`, `lookupTypeNameWithLocals`,\r\n
  \ `mkDataNameWithLocals`, and `mkTypeNameWithLocals`, counterparts to\r\n  `lookupValueName`,
  `lookupTypeName`, `mkDataName`, and `mkTypeName` which\r\n  have access to local
  Template Haskell declarations.\r\n\r\n* Implement `reifyNameSpace` to determine
  a `Name`'s `NameSpace`.\r\n\r\n* Export `reifyFixityWithLocals` from `Language.Haskell.TH.Desugar`.\r\n\r\n*
  Export `matchTy` (among other goodies) from new module `Language.Haskell.TH.Subst`.\r\n
  \ This function matches a type template against a target.\r\n\r\nVersion 1.7\r\n-----------\r\n*
  Support for TH's support for `TypeApplications`, thanks to @RyanGlScott.\r\n\r\n*
  Support for unboxed sums, thanks to @RyanGlScott.\r\n\r\n* Support for `COMPLETE`
  pragmas.\r\n\r\n* `getRecordSelectors` now requires a list of `DCon`s as an argument.
  This\r\n  makes it easier to return correct record selector bindings in the event
  that\r\n  a record selector appears in multiple constructors. (See\r\n  [goldfirere/singletons#180](https://github.com/goldfirere/singletons/issues/180)\r\n
  \ for an example of where the old behavior of `getRecordSelectors` went wrong.)\r\n\r\n*
  Better type family expansion (expanding an open type family with variables works
  now).\r\n\r\nVersion 1.6\r\n-----------\r\n* Work with GHC 8, with thanks to @christiaanb
  for getting this change going.\r\n  This means that several core datatypes have
  changed: partcularly, we now have\r\n  `DTypeFamilyHead` and fixities are now reified
  separately from other things.\r\n\r\n* `DKind` is merged with `DType`.\r\n\r\n*
  `Generic` instances for everything.\r\n\r\nVersion 1.5.5\r\n-------------\r\n\r\n*
  Fix issue #34. This means that desugaring (twice) is idempotent over\r\nexpressions,
  after the second time. That is, if you desugar an expression,\r\nsweeten it, desugar
  again, sweeten again, and then desugar a third time, you\r\nget the same result
  as when you desugared the second time. (The extra\r\nround-trip is necessary there
  to make the output smaller in certain common\r\ncases.)\r\n\r\nVersion 1.5.4.1\r\n---------------\r\n*
  Fix issue #32, concerning reification of classes with default methods.\r\n\r\nVersion
  1.5.4\r\n-------------\r\n* Added `expandUnsoundly`\r\n\r\nVersion 1.5.3\r\n-------------\r\n*
  More `DsMonad` instances, thanks to David Fox.\r\n\r\nVersion 1.5.2\r\n-------------\r\n*
  Sweeten kinds more, too.\r\n\r\nVersion 1.5.1\r\n-------------\r\n* Thanks to David
  Fox (@ddssff), sweetening now tries to use more of TH's `Type`\r\nconstructors.\r\n\r\n*
  Also thanks to David Fox, depend usefully on the th-orphans package.\r\n\r\nVersion
  1.5\r\n-----------\r\n* There is now a facility to register a list of `Dec` that
  internal reification\r\n  should use when necessary. This avoids the user needing
  to break up their\r\n  definition across different top-level splices. See `withLocalDeclarations`.\r\n
  \ This has a side effect of changing the `Quasi` typeclass constraint on many\r\n
  \ functions to be the new `DsMonad` constraint. Happily, there are `DsMonad`\r\n
  \ instances for `Q` and `IO`, the two normal inhabitants of `Quasi`.\r\n\r\n* \"Match
  flattening\" is implemented! The functions `scExp` and `scLetDec` remove\r\n  any
  nested pattern matches.\r\n\r\n* More is now exported from `Language.Haskell.TH.Desugar`
  for ease of use.\r\n\r\n* `expand` can now expand closed type families! It still
  requires that the\r\n  type to expand contain no type variables.\r\n\r\n* Support
  for standalone-deriving and default signatures in GHC 7.10.\r\n  This means that
  there are now two new constructors for `DDec`.\r\n\r\n* Support for `static` expressions,
  which are new in GHC 7.10.\r\n\r\nVersion 1.4.2\r\n-------------\r\n* `expand` functions
  now consider open type families, as long as the type\r\n   to be expanded has no
  free variables.\r\n\r\nVersion 1.4.1\r\n-------------\r\n* Added `Language.Haskell.TH.Desugar.Lift`,
  which provides `Lift` instances\r\nfor all of the th-desugar types, as well as several
  Template Haskell types.\r\n\r\n* Added `applyDExp` and `applyDType` as convenience
  functions.\r\n\r\nVersion 1.4.0\r\n-------------\r\n* All `Dec`s can now be desugared,
  to the new `DDec` type.\r\n\r\n* Sweetening `Dec`s that do not exist in GHC 7.6.3-
  works on a \"best effort\" basis:\r\nclosed type families are sweetened to open
  ones, and role annotations are dropped.\r\n\r\n* `Info`s can now be desugared. Desugaring
  takes into account GHC bug #8884, which\r\nmeant that reifying poly-kinded type
  families in GHC 7.6.3- was subtly wrong.\r\n\r\n* There is a new function `flattenDValD`
  which takes a binding like\r\n  `let (a,b) = foo` and breaks it apart into separate
  assignments for `a` and `b`.\r\n\r\n* There is a new `Desugar` class with methods
  `desugar` and `sweeten`. See\r\nthe documentation in `Language.Haskell.TH.Desugar`.\r\n\r\n*
  Variable names that are distinct in desugared code are now guaranteed to\r\nhave
  distinct answers to `nameBase`.\r\n\r\n* Added a new function `getRecordSelectors`
  that extracts types and definitions\r\nof record selectors from a datatype definition.\r\n\r\nVersion
  1.3.1\r\n-------------\r\n* Update cabal file to include testing files in sdist.\r\n\r\nVersion
  1.3.0\r\n-------------\r\n* Update to work with `type Pred = Type` in GHC 7.9. This
  changed the\r\n`DPred` type for all GHC versions, though.\r\n\r\nVersion 1.2.0\r\n-------------\r\n*
  Generalized interface to allow any member of the `Qausi` class, instead of\r\n  just
  `Q`.\r\n\r\nVersion 1.1.1\r\n-------------\r\n* Made compatible with HEAD after
  change in role annotation syntax.\r\n\r\nVersion 1.1\r\n-----------\r\n* Added module
  `Language.Haskell.TH.Desugar.Expand`, which allows for expansion\r\n  of type synonyms
  in desugared types.\r\n* Added `Show`, `Typeable`, and `Data` instances to desugared
  types.\r\n* Fixed bug where an as-pattern in a `let` statement was scoped incorrectly.\r\n*
  Changed signature of `dsPat` to be more specific to as-patterns; this allowed\r\n
  \ for fixing the `let` scoping bug.\r\n* Created new functions `dsPatOverExp` and
  `dsPatsOverExp` to allow for easy\r\n  desugaring of patterns.\r\n* Changed signature
  of `dsLetDec` to return a list of `DLetDec`s.\r\n* Added `dsLetDecs` for convenience.
  Now, instead\r\n  of using `mapM dsLetDec`, you should use `dsLetDecs`.\r\n\r\nVersion
  1.0\r\n-----------\r\n\r\n* Initial release\r\n"
basic-deps:
  base: '>=4.9 && <5'
  th-orphans: '>=0.13.7'
  syb: '>=0.4'
  ordered-containers: '>=0.2.2'
  th-abstraction: '>=0.5 && <0.7'
  containers: '>=0.5'
  ghc-prim: -any
  mtl: '>=2.1 && <2.4'
  template-haskell: '>=2.11 && <2.21'
  transformers-compat: '>=0.6.3'
all-versions:
- 1.0.0
- 1.1.0
- 1.1.1
- 1.2.0
- 1.2.1
- 1.3.0
- 1.3.1
- 1.4.0
- 1.4.1
- 1.4.2
- 1.4.2.1
- '1.5'
- 1.5.1
- 1.5.2
- 1.5.3
- 1.5.4
- 1.5.4.1
- 1.5.5
- '1.6'
- '1.7'
- '1.8'
- '1.9'
- '1.10'
- '1.11'
- '1.12'
- '1.13'
- 1.13.1
- '1.14'
- '1.15'
author: Richard Eisenberg <rae@cs.brynmawr.edu>
latest: '1.15'
description-type: markdown
description: "`th-desugar` Package\r\n====================\r\n\r\n[![Hackage](https://img.shields.io/hackage/v/th-desugar.svg)](http://hackage.haskell.org/package/th-desugar)\r\n[![Build
  Status](https://github.com/goldfirere/th-desugar/workflows/Haskell-CI/badge.svg)](https://github.com/goldfirere/th-desugar/actions?query=workflow%3AHaskell-CI)\r\n\r\nThis
  package provides the `Language.Haskell.TH.Desugar` module, which desugars\r\nTemplate
  Haskell's rich encoding of Haskell syntax into a simpler encoding.\r\nThis desugaring
  discards surface syntax information (such as the use of infix\r\noperators) but
  retains the original meaning of the TH code. The intended use\r\nof this package
  is as a preprocessor for more advanced code manipulation\r\ntools. Note that the
  input to any of the `ds...` functions should be produced\r\nfrom a TH quote, using
  the syntax `[| ... |]`. If the input to these functions\r\nis a hand-coded TH syntax
  tree, the results may be unpredictable. In\r\nparticular, it is likely that promoted
  datatypes will not work as expected.\r\n\r\nOne explicit goal of this package is
  to reduce the burden of supporting multiple\r\nGHC / TH versions. Thus, the desugared
  language is the same across all GHC versions,\r\nand any inconsistencies are handled
  internally.\r\n\r\nThe package was designed for use with the `singletons` package,
  so some design\r\ndecisions are based on that use case, when more than one design
  choice was\r\npossible.\r\n\r\nI will try to keep this package up-to-date with respect
  to changes in GHC.\r\nThe minimum supported version of GHC is 8.0, which was chosen
  to avoid various\r\nTemplate Haskell bugs in older GHC versions that affect how
  this library\r\ndesugars code. If this choice negatively impacts you, please submit
  a bug\r\nreport.\r\n\r\nKnown limitations\r\n-----------------\r\n\r\n## Limited
  support for kind inference\r\n\r\n`th-desugar` sometimes has to construct types
  for certain Haskell entities.\r\nFor instance, `th-desugar` desugars all Haskell98-style
  constructors to use\r\nGADT syntax, so the following:\r\n\r\n```haskell\r\ndata
  T (a :: k) = MkT (Proxy a)\r\n```\r\n\r\nWill be desugared to something like this:\r\n\r\n```haskell\r\ndata
  T (a :: k) where\r\n  MkT :: forall k (a :: k). Proxy a -> T (a :: k)\r\n```\r\n\r\nNotice
  that `k` is explicitly quantified in the type of `MkT`. This is due to\r\nan additional
  pass that `th-desugar` performs over the type variable binders\r\nof `T` to extract
  all implicitly quantified variables and make them explicit.\r\nThis makes the desugared
  types forwards-compatible with a\r\n[future version of GHC](https://github.com/goldfirere/ghc-proposals/blob/bbefbee6fc0cddb10bbacc85f79e66c2706ce13f/proposals/0000-no-kind-vars.rst)\r\nthat
  requires all kind variables in a top-level `forall` to be explicitly\r\nquantified.\r\n\r\nThis
  process of extracting all implicitly quantified kind variables is not\r\nperfect,
  however. There are some obscure programs that will cause `th-desugar`\r\nto produce
  type variable binders that are ill scoped. Here is one example:\r\n\r\n```haskell\r\ndata
  P k (a :: k)\r\ndata Foo (a :: Proxy j) (b :: k) c = MkFoo c (P k j)\r\n```\r\n\r\nIf
  you squint hard at `MkFoo`, you'll notice that `j :: k`. However, this\r\nrelationship
  is not expressed _syntactically_, which means that `th-desugar`\r\nwill not be aware
  of it. Therefore, `th-desugar` will desugar `Foo` to:\r\n\r\n```haskell\r\ndata
  Foo (a :: Proxy j) (b :: k) c where\r\n  MkFoo :: forall j k (a :: Proxy j) (b ::
  k) c.\r\n           c -> P k j -> Foo (a :: Proxy j) (b :: k) c\r\n```\r\n\r\nThis
  is incorrect since `k` must come before `j` in order to be well scoped.\r\nThere
  is a workaround to this issue, however: add more explicit kind\r\ninformation. If
  you had instead written this:\r\n\r\n```haskell\r\ndata Foo (a :: Proxy (j :: k))
  (b :: k) c = MkFoo c (P k j)\r\n```\r\n\r\nThen the fact that `j :: k` is expressed
  directly in the AST, so `th-desugar`\r\nis able to pick up on it and pick `forall
  k j (a :: Proxy j) (b :: k) c. <...>`\r\nas the telescope for the type of `MkFoo`.\r\n\r\nThe
  following constructs are known to be susceptible to this issue:\r\n\r\n1. Desugared
  Haskell98-style constructors\r\n2. Locally reified class methods\r\n3. Locally reified
  record selectors\r\n4. Locally reified data constructors\r\n5. Locally reified type
  family instances (on GHC 8.8 and later, in which the\r\n   Template Haskell AST
  supports explicit `foralls` in type family equations)\r\n\r\n## Limited support
  for linear types\r\n\r\nCurrently, the `th-desugar` AST deliberately makes it impossible
  to represent\r\nlinear types, and desugaring a linear function arrow will simply
  turn into a\r\nnormal function arrow `(->)`. This choice is partly motivated by
  issues in the\r\nway that linear types interact with Template Haskell, which sometimes
  make it\r\nimpossible to tell whether a reified function type is linear or not.
  See, for\r\ninstance, [GHC#18378](https://gitlab.haskell.org/ghc/ghc/-/issues/18378).\r\n"
license-name: BSD-3-Clause

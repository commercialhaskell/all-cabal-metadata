homepage: https://github.com/LeapYear/th-test-utils#readme
changelog-type: markdown
hash: f636044afb84810b4ec134ac4dc98a4b1826a51002580f1ecad8b3a325804ed4
test-bench-deps:
  base: ! '>=4.9 && <5'
  th-test-utils: -any
  tasty-hunit: ! '>=0.9.2 && <0.10.1'
  transformers: ! '>=0.5.2 && <0.5.7'
  tasty: ! '>=0.11.3 && <1.3'
  template-haskell: ! '>=2.11.1.0 && <2.15'
maintainer: Brandon Chinn <brandon@leapyear.io>
synopsis: Utility functions for testing Template Haskell code
changelog: |
  ## Upcoming

  ## 1.0.0

  Initial release:

  * Add `tryQ`, `tryQErr`, `tryQErr'` functions
basic-deps:
  base: ! '>=4.9 && <5'
  transformers: ! '>=0.5.2 && <0.5.7'
  template-haskell: ! '>=2.11.1.0 && <2.15'
all-versions:
- 1.0.0
author: Brandon Chinn <brandon@leapyear.io>
latest: 1.0.0
description-type: markdown
description: |
  # th-test-utils

  ![CircleCI](https://img.shields.io/circleci/build/github/LeapYear/th-test-utils.svg)
  ![Hackage](https://img.shields.io/hackage/v/th-test-utils.svg)

  This package contains utility functions for testing Template Haskell code.

  Currently, this package only exposes a single function, `tryQ` (and derivatives),
  that allows testing whether a given Template Haskell expression fails.

  ## Usage

  ```haskell
  -- e.g. $(qConcat ["hello", "world"]) generates "helloworld" at compile time
  qConcat :: [String] -> Q Exp
  qConcat [] = fail "Cannot concat empty list"
  qConcat xs = ...

  -- e.g. [numberify| one |] generates `1` at compile time
  numberify :: QuasiQuoter
  numberify = ...
  ```

  ```haskell
  -- example using tasty-hunit
  main :: IO ()
  main = defaultMain $ testGroup "my-project"
    [ testCase "qConcat 1" $
        $(tryQ $ qConcat ["hello", "world"]) @?= (Right "helloworld" :: Either String String)
    , testCase "qConcat 2" $
        $(tryQ $ qConcat [])                 @?= (Left "Cannot concat empty list" :: Either String String)
    , testCase "numberify 1" $
        $(tryQ $ quoteExp numberify "one")   @?= (Right 1 :: Either String Int)
    , testCase "numberify 2" $
        $(tryQ $ quoteExp numberify "foo")   @?= (Left "not a number" :: Either String Int)

    -- can also return error message as `Maybe String` or `String` (which errors
    -- if the function doesn't error)
    , testCase "numberify 3" $
        $(tryQErr $ quoteExp numberify "foo") @?= Just "not a number"
    , testCase "numberify 4" $
        $(tryQErr' $ quoteExp numberify "foo") @?= "not a number"
    ]
  ```
license-name: BSD-3-Clause

homepage: https://github.com/dustin/mqtt-hs#readme
changelog-type: markdown
hash: 53b3a0998ba6d50baa28c9a8f4b4d7dba717f1171bf65ce10ed4ecc7e5f93d94
test-bench-deps:
  bytestring: ! '>=0.10.8 && <0.11'
  stm: ! '>=2.5.0 && <2.6'
  base: ! '>=4.7 && <5'
  text: ! '>=1.2.3 && <1.3'
  network-conduit-tls: ! '>=1.3.2 && <1.4'
  async: ! '>=2.2.1 && <2.3'
  conduit: ! '>=1.3.1 && <1.4'
  HUnit: -any
  conduit-extra: ! '>=1.3.0 && <1.4'
  containers: ! '>=0.6.0 && <0.7'
  binary: ! '>=0.8.6 && <0.9'
  tasty-quickcheck: -any
  network-uri: ! '>=2.6.1 && <2.7'
  tasty-hunit: -any
  attoparsec: ! '>=0.13.2 && <0.14'
  tasty: -any
  QuickCheck: -any
  net-mqtt: -any
maintainer: dustin@spy.net
synopsis: An MQTT Protocol Implementation.
changelog: |+
  # Changelog for net-mqtt

  ## 0.2.4.2

  Don't set a message ID of 0.

  This had been working fine for a while, but starting in mosquitto 1.6,
  the server would just hang up on a subscribe request with a message ID
  of zero.

  ## 0.2.4.1

  Link QoS2 completion thread on subscriber.

  An exception from a subscriber callback could be silently dropped
  without completing the handshake which would then cause the MQTT
  broker to just stop sending messages to the subscriber.
  Unfortunately, the broker (at least mosquitto) still responds to pings
  and doesn't give any useful notification that it's no longer sending
  messages.

  ## 0.2.4.0

  Introduced `Filter` type alias to distinguish from `Topic`.

  Reintroduced timeout management at the protocol layer, dropping a
  connection when a pong response hasn't come in in a while (~3x longer
  than the current 30s ping rate).  This was mostly after noticing
  mosquitto do really weird things where it seemed to just forget about
  all my active connections (other clients figured that out and dropped
  and reconnected).

  ## 0.2.3.1

  Fixed up github links.

  ## 0.2.3.0

  Added Network.MQTT.Topic with `match` to test `Topic`s against wildcards.

  ## 0.2.2.0

  Added connectURI to make it easier to connect to mqtt or mqtts via
  URI.

  ## 0.2.1.0

  No externally visible changes, but a few bug fixes I found when
  writing an application that published in QoS < 2.  QoS 0 would likely
  not transmit (which is probably fine according to the spec, but not
  very desirable) and QoS1 didn't check its ACKs, so it would continue
  to retry after the server ACKd the message.

  ## 0.2.0.0

  ### API Change

  Subscriber callbacks now include the MQTT client as the first
  argument.  This breaks a circular dependency that prevented callbacks
  from being able to publish messages easily.

  ### Other

  Updated to stackage LTS 13.2

basic-deps:
  bytestring: ! '>=0.10.8 && <0.11'
  stm: ! '>=2.5.0 && <2.6'
  base: ! '>=4.7 && <5'
  text: ! '>=1.2.3 && <1.3'
  network-conduit-tls: ! '>=1.3.2 && <1.4'
  async: ! '>=2.2.1 && <2.3'
  conduit: ! '>=1.3.1 && <1.4'
  conduit-extra: ! '>=1.3.0 && <1.4'
  containers: ! '>=0.6.0 && <0.7'
  binary: ! '>=0.8.6 && <0.9'
  network-uri: ! '>=2.6.1 && <2.7'
  attoparsec: ! '>=0.13.2 && <0.14'
  net-mqtt: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
- 0.2.3.0
- 0.2.3.1
- 0.2.4.0
- 0.2.4.1
- 0.2.4.2
author: Dustin Sallings
latest: 0.2.4.2
description-type: markdown
description: |
  # mqtt

  An [MQTT][mqtt] protocol implementation for Haskell.

  ## Client Examples

  ### Publish

  ```haskell
  main :: IO
  main = do
    mc <- runClient mqttConfig{}
    publish mc "tmp/topic" "hello!" False
  ```

  ### Subscribe

  ```haskell
  main :: IO
  main = do
    mc <- runClient mqttConfig{_msgCB=Just msgReceived}
    print =<< subscribe mc [("tmp/topic1", QoS0), ("tmp/topic2", QoS0)]
    print =<< waitForClient mc   -- wait for the the client to disconnect

    where
      msgReceived _ t m = print (t,m)
  ```

  [mqtt]: http://mqtt.org/
license-name: BSD-3-Clause

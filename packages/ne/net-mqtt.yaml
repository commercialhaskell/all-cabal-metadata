homepage: https://github.com/dustin/mqtt#readme
changelog-type: markdown
hash: 2ec043277ac96775405ab19765da3147c3d0def0157e141ddb796992961f4fcd
test-bench-deps:
  bytestring: ! '>=0.10.8 && <0.11'
  stm: ! '>=2.5.0 && <2.6'
  base: ! '>=4.7 && <5'
  text: ! '>=1.2.3 && <1.3'
  network-conduit-tls: ! '>=1.3.2 && <1.4'
  async: ! '>=2.2.1 && <2.3'
  conduit: ! '>=1.3.1 && <1.4'
  HUnit: -any
  conduit-extra: ! '>=1.3.0 && <1.4'
  containers: ! '>=0.6.0 && <0.7'
  binary: ! '>=0.8.6 && <0.9'
  tasty-quickcheck: -any
  network-uri: ! '>=2.6.1 && <2.7'
  tasty-hunit: -any
  attoparsec: ! '>=0.13.2 && <0.14'
  tasty: -any
  QuickCheck: -any
  net-mqtt: -any
maintainer: dustin@spy.net
synopsis: An MQTT Protocol Implementation.
changelog: |+
  # Changelog for net-mqtt

  ## 0.2.2.0

  Added connectURI to make it easier to connect to mqtt or mqtts via
  URI.

  ## 0.2.1.0

  No externally visible changes, but a few bug fixes I found when
  writing an application that published in QoS < 2.  QoS 0 would likely
  not transmit (which is probably fine according to the spec, but not
  very desirable) and QoS1 didn't check its ACKs, so it would continue
  to retry after the server ACKd the message.

  ## 0.2.0.0

  ### API Change

  Subscriber callbacks now include the MQTT client as the first
  argument.  This breaks a circular dependency that prevented callbacks
  from being able to publish messages easily.

  ### Other

  Updated to stackage LTS 13.2

basic-deps:
  bytestring: ! '>=0.10.8 && <0.11'
  stm: ! '>=2.5.0 && <2.6'
  base: ! '>=4.7 && <5'
  text: ! '>=1.2.3 && <1.3'
  network-conduit-tls: ! '>=1.3.2 && <1.4'
  async: ! '>=2.2.1 && <2.3'
  conduit: ! '>=1.3.1 && <1.4'
  conduit-extra: ! '>=1.3.0 && <1.4'
  containers: ! '>=0.6.0 && <0.7'
  binary: ! '>=0.8.6 && <0.9'
  network-uri: ! '>=2.6.1 && <2.7'
  attoparsec: ! '>=0.13.2 && <0.14'
  net-mqtt: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
author: Dustin Sallings
latest: 0.2.2.0
description-type: markdown
description: |
  # mqtt

  An [MQTT][mqtt] protocol implementation for Haskell.

  ## Client Examples

  ### Publish

  ```haskell
  main :: IO
  main = do
    mc <- runClient mqttConfig{}
    publish mc "tmp/topic" "hello!" False
  ```

  ### Subscribe

  ```haskell
  main :: IO
  main = do
    mc <- runClient mqttConfig{_msgCB=Just msgReceived}
    print =<< subscribe mc [("tmp/topic1", QoS0), ("tmp/topic2", QoS0)]
    print =<< waitForClient mc   -- wait for the the client to disconnect

    where
      msgReceived _ t m = print (t,m)
  ```

  [mqtt]: http://mqtt.org/
license-name: BSD-3-Clause

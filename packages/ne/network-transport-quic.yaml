all-versions:
- 0.1.0
- 0.1.1
author: Laurent P. René de Cotret
basic-deps:
  async: '>=2.2 && <2.3'
  base: '>=4.14 && <5'
  binary: '>=0.8 && <0.10'
  bytestring: '>=0.11 && <0.13'
  containers: '>=0.6 && <0.9'
  microlens-platform: ^>=0.4
  network: '>=3.1 && <3.3'
  network-transport: '>=0.5 && <0.6'
  quic: '>=0.2.20 && <0.3'
  stm: '>=2.4 && <2.6'
  tls: '>=2.1 && <2.3'
  tls-session-manager: '>=0.0.5 && <0.1'
changelog: |2

  2026-01-01  Laurent P. René de Cotret <laurent.decotret@outlook.com> 0.1.1

  * Documentation and packaging improvements.

  2026-01-01  Laurent P. René de Cotret <laurent.decotret@outlook.com> 0.1.0

  * Initial release.
changelog-type: markdown
description: "# `network-transport-quic`\n\nThis package provides an implementation
  of the `network-transport` interface, where networking is done via the QUIC protocol.
  The primary use-case for this package is as a Cloud Haskell backend.\n\nQUIC has
  many advantages over TCP, including:\n\n* No head-of-line blocking. Independent
  streams mean packet loss on one stream doesn't stall others;\n* Connection migration.
  Connections survive IP address changes, which is important when a device switches
  from e.g. WIFI to 5G;\n* Built-in encryption via TLS 1.3;\n\nIn benchmarks, `network-transport-quic`
  performs better than `network-transport-tcp` in dense network topologies. For example,
  if every `EndPoint` in your network connects to every other `EndPoint`, you might
  benefit greatly from switching to `network-transport-quic`! \n\n## Usage example\n\nProvided
  you have a TLS 1.3 certificate, you can create a `Transport` like so:\n\n```haskell\nimport
  Data.List.NonEmpty qualified as NonEmpty\nimport Network.Transport.QUIC (QUICTransportConfig(..),
  createTransport, credentialLoadX509)\n\nmain = do\n    let certificate = \"path/to/cert.crt\"\n
  \       key = \"path/to/cert.key\"\n\n    creds <- credentialLoadX509 certificate
  key\n    case creds of\n        Left error_message -> error error_message\n        Right
  credential -> do\n            let config = QUICTransportConfig\n                            {
  hostName = \"my.hostname.com\" -- or some IP address\n                            ,
  serviceName = \"https\" -- alternatively, some port number\n                            ,
  credentials = NonEmpty.singleton credential\n                            , validateCredentials
  = True -- should be 'False' for self-signed certificate\n                            }\n
  \           transport <- createTransport config\n            ...\n```\n\nThere are
  tools online to help create self-signed TLS 1.3 certificates.\n"
description-type: markdown
hash: e851ac4adbbb037060f104c5cb4dac8c942276555704dc2a31edb971453ea96a
homepage: https://haskell-distributed.github.io
latest: 0.1.1
license-name: BSD-3-Clause
maintainer: The Distributed Haskell team
synopsis: Networking layer for Cloud Haskell based on QUIC
test-bench-deps:
  async: '>=0'
  base: '>=4.14 && <5'
  bytestring: '>=0'
  filepath: '>=0'
  hedgehog: '>=0'
  network: '>=0'
  network-transport: '>=0'
  network-transport-quic: '>=0'
  network-transport-tcp: '>=0'
  network-transport-tests: '>=0'
  tasty: '>=1.5 && <1.6'
  tasty-bench: '>=0.4'
  tasty-flaky: ^>=0.1.3
  tasty-hedgehog: '>=0'
  tasty-hunit: '>=0'

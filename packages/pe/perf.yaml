homepage: https://github.com/tonyday567/perf#readme
changelog-type: markdown
hash: c95979d863055d193b975cb387f5d759dab6621011bc7c5a5a1aeade768c144d
test-bench-deps:
  base: '>=4.7 && <5'
  perf: -any
maintainer: tonyday567@gmail.com
synopsis: Low-level run time measurement.
changelog: |
  0.12.0.0
  ===
  * added reportMain and support for executable development.
  * refactored app/perf-explore
  * created app/perf-bench and aded as a `cabal bench` thing.

  0.11.0.0
  ===
  * added Perf.Count
  * GHC 9.6.2 support

  0.10.0
  ===
  * GHC 9.2.1 support
  * inclusion of BigO

  0.9.0
  ===
  * Removed deepseq dependency

  0.8.0
  ===
  * GHC 9.0.1 support
  * internal fixes to remove numhask dependency
basic-deps:
  rdtsc: '>=1.3 && <1.4'
  base: '>=4.7 && <5'
  formatn: '>=0.2.1 && <0.4'
  time: '>=1.9 && <1.13'
  text: '>=1.2 && <2.1'
  numhask-space: '>=0.10 && <0.12'
  perf: -any
  gauge: ^>=0.2.5
  containers: ==0.6.*
  mtl: '>=2.2.2 && <2.4'
  optparse-applicative: '>=0.17 && <0.19'
  deepseq: '>=1.4.4 && <1.6'
  recursion-schemes: ^>=5.2.2
  vector: '>=0.12.3 && <0.14'
all-versions:
- 0.1.1
- 0.1.2
- 0.2.0
- 0.3.0
- 0.3.1.0
- 0.3.1.1
- 0.4.0.0
- 0.4.0.1
- 0.4.1.0
- 0.5.0.0
- 0.6.0
- 0.7.0
- 0.8.0
- 0.9.0
- 0.10.0
- 0.10.1
- 0.10.2
- 0.10.3
- 0.11.0.0
- 0.12.0.0
author: Tony Day, Marco Zocca
latest: 0.12.0.0
description-type: text
description: "#+TITLE: perf\n#+PROPERTY: header-args :exports both\n#+PROPERTY: header-args
  :eval no-export\n\n[[https://hackage.haskell.org/package/perf][file:https://img.shields.io/hackage/v/perf.svg]]
  [[https://github.com/tonyday567/perf/actions?query=workflow%3Ahaskell-ci][file:https://github.com/tonyday567/perf/workflows/haskell-ci/badge.svg]]\n\n*
  Introduction\n\n~perf~ provides some ideas, code and a library for low-level performance
  measurement for Haskell hacking. The library:\n\n- provides a monad transformer,
  ~PerfT~, as a light-weight wrapper for use on existing code. ~PerfT~ modifications
  can be included in code bases, as opposed to performance being separated code and
  \ process, with any effects able to be erased at compile time with ~evalPerfT~.\n\n-
  focuses on using the [[https://en.wikipedia.org/wiki/Time_Stamp_Counter][rdtsc]]
  instruction set that comes with the x86 chip to measure accurate time performance
  as number of clock cycles.\n\n- abstracts the concept of what is being measured,
  so that concepts such as counters, debug checks, time and space performance can
  be treated equivalently.\n\n* Setup\n\nNote that running this readme.org is very
  slow compared with an external process which accesses the compiled version of the
  library.\n\n#+begin_src haskell :results output\n:r\n:set prompt \"> \"\n:set -Wno-type-defaults\n:set
  -Wno-unused-do-bind\n:set -Wno-name-shadowing\n:set -XOverloadedStrings\n:set -XOverloadedLabels\nimport
  Perf\nimport Data.FormatN\nimport qualified Data.Text as Text\nimport qualified
  Data.Text.IO as Text\nimport qualified Data.Map.Strict as Map\nimport Control.Monad\nimport
  Data.Bifunctor\nputStrLn \"ok\"\n#+end_src\n\n#+RESULTS:\n#+begin_example\nPreprocessing
  library for perf-0.12.0.0..\nBuilding library for perf-0.12.0.0..\n[ 7 of 10] Compiling
  Perf.Report      ( src/Perf/Report.hs, /Users/tonyday/haskell/perf/dist-newstyle/build/x86_64-osx/ghc-9.6.2/perf-0.12.0.0/build/Perf/Report.o,
  /Users/tonyday/haskell/perf/dist-newstyle/build/x86_64-osx/ghc-9.6.2/perf-0.12.0.0/build/Perf/Report.dyn_o
  ) [Source file changed]\n[10 of 10] Compiling Perf             ( src/Perf.hs, /Users/tonyday/haskell/perf/dist-newstyle/build/x86_64-osx/ghc-9.6.2/perf-0.12.0.0/build/Perf.o,
  /Users/tonyday/haskell/perf/dist-newstyle/build/x86_64-osx/ghc-9.6.2/perf-0.12.0.0/build/Perf.dyn_o
  ) [Source file changed]\nPreprocessing benchmark 'perf-bench' for perf-0.12.0.0..\nGHCi,
  version 9.6.2: https://www.haskell.org/ghc/  :? for help\nLoaded GHCi configuration
  from /Users/tonyday/haskell/perf/.ghci\n[1 of 2] Compiling Main             ( app/bench.hs,
  interpreted )\nOk, one module loaded.\n> [1 of 2] Compiling Main             ( app/bench.hs,
  interpreted )\nOk, one module loaded.\n>\n>\nok\n#+end_example\n\n* Time\n** What
  is a tick?\n\nThe fundamental operation of Perf.Time is tick, which sandwiches a
  (strict) function application between two readings of the rdstc chip.\n\n#+begin_src
  haskell :results output :exports both\n:t tick\n#+end_src\n\n#+RESULTS:\n: tick
  :: (a -> b) -> a -> IO (Cycles, b)\n\ntick returns in the IO monad, because reading
  a cycle counter is an IO effect. The trivial but fundamental point is that performance
  measurement effects the computation being measured.\n\nUnlike benchmarking-style
  libraries, such as criterion, the result of the computation is passed through along
  with the cycle count. In this way, the `Perf` monad can be inserted into the midst
  of a computation in an attempt to measure performance in-situ as opposed to sitting
  off in a separate and perhaps unrepresentative process.\n\n** tick_\n\ntick_ measures
  the number of cycles between two clock reads.\n\n#+begin_src haskell :results output
  :exports both\n:t tick_\n#+end_src\n\n#+RESULTS:\n: tick_ :: IO Cycles\n\n#+begin_src
  haskell :results output :exports both\nfmap word <$> replicateM 10 tick_\n#+end_src\n\n#+RESULTS:\n:
  [1722,788,630,606,608,620,596,638,596,598]\n\n** multiple ticks\n\n#+begin_src haskell
  :results output :exports both\nfmap (fmap (word . fst)) . replicateM 10 $ tick (const
  ()) ()\n#+end_src\n\n#+RESULTS:\n: [6180,3282,2736,2712,2676,2670,2660,2634,2926,2656]\n\nHere,
  ~const () ()~ was evaluated and took 6.1k cycles for the first effect, reducing
  down to 2.6k after 10 effects. What it did in that time we will never know, really,
  at least from usage of ~perf~. 2.2k cycles is, on my 2.5GHz machine equal to 2200
  / 2.5e9 = 8.8e-7 of a second or 880 nanoseconds.\n\n** tickIO\n\n~tickIO~ measures
  the evaluation of an IO value.\n\n#+begin_src haskell :results output :exports both\n:t
  tickIO\n#+end_src\n\n#+RESULTS:\n: tickIO :: IO a -> IO (Cycles, a)\n\n#+begin_src
  haskell :results output :exports both\nfmap (fmap (word . fst)) . replicateM 10
  $ tickIO (pure ())\n#+end_src\n\n#+RESULTS:\n: [5508,1632,1378,1210,1576,1214,1160,1174,1176,1176]\n\n**
  sum example\n\n#+begin_src haskell :exports both\nfmap (expt (Just 2) . fromIntegral)
  . fst <$> ticks 10 sum ([1..10000] :: [Double])\n#+end_src\n\n#+RESULTS:\n| 2.0e6
  | 1.3e6 | 1.2e6 | 6.1e6 | 1.5e6 | 1.7e6 | 3.0e6 | 6.4e5 | 6.2e5 | 1.7e6 |\n\n\n#+begin_src
  haskell :results output :exports both\nts <- ticks 10000 sum ([1..1000] :: [Double])\nprint
  $ average (fmap fromIntegral $ fst ts)\n#+end_src\n\n#+RESULTS:\n:\n: 54619.4812\n\n*
  PerfT\n\n~PerfT~ allows for multiple measurement points and is polymorphic in what
  is being measured. It returns a Map of results held in State.\n\nCompare a lower-level
  usage of ticks, measuring the average of summing to one thousand over one thousand
  trials:\n\n#+begin_src haskell :results output :exports both\nfirst (average . fmap
  fromIntegral) <$> ticks 1000 sum [1..1000]\n#+end_src\n\n#+RESULTS:\n: (73752.368,500500)\n\n...
  with PerfT usage\n\n#+begin_src haskell :results output :exports both\nsecond (fmap
  (average . fmap fromIntegral)) <$> runPerfT (times 1000) (sum |$| [1..1000])\n#+end_src\n\n#+RESULTS:\n:
  (500500,fromList [(\"\",62706.844)])\n\nComparing performance of sum versus a list
  fusion approach:\n\n#+begin_src haskell :results output :exports both\nfmap (average
  . fmap fromIntegral) <$> (execPerfT (times 1000) $ do; (fap \"sum\" sum [1..1000]);
  (fap \"fusion\" (\\x -> sum [1..x]) 1000))\n#+end_src\n\n#+RESULTS:\n: fromList
  [(\"fusion\",114013.79),(\"sum\",63906.848)]\n\nAn IO example\n\n#+begin_src haskell\nexampleIO'
  :: IO ()\nexampleIO' = do\n  txt <- Text.readFile \"src/Perf.hs\"\n  let n = Text.length
  txt\n  Text.putStrLn $ \"length of file is: \" <> Text.pack (show n)\n#+end_src\n\n#+begin_src
  haskell :results output :exports both\nexampleIO = execPerfT time (do\n  txt <-
  fam \"file_read\" (Text.readFile \"src/Perf.hs\")\n  n <- fap \"length\" Text.length
  txt\n  fam \"print_result\" (Text.putStrLn $ \"length of file is: \" <> Text.pack
  (show n)))\n#+end_src\n\n#+begin_src sh :results output :exports both\nperf-explore
  --exampleIO --record --check\n#+end_src\n\n#+RESULTS:\n#+begin_example\nlength of
  file is: 1751\nlength of file is: 1751\n\nlabel1              label2              label3
  \             old_result          new_result          status\n\nnormal              file-read
  \          time                4.28e5              4.19e5\nnormal              length
  \             time                5.61e3              5.64e3\nnormal              print-result
  \       time                5.47e4              5.38e4\nouter               file-read
  \          time                9.37e4              9.46e4\nouter               length
  \             time                5.38e3              5.40e3\nouter               outer-total
  \        time                1.11e5              1.12e5\nouter               print-result
  \       time                5.46e3              5.55e3\n#+end_example\n\n* perf-explore\n\n~perf-explore~
  contains some exploratory routines used to develop =perf=\n\n#+begin_src sh :results
  output :exports both\nperf-explore --help\n#+end_src\n\n#+RESULTS:\n#+begin_example\nexamples
  of perf usage\n\nUsage: perf-explore [-n|--runs ARG]\n                    [--best
  | --median | --average | --averagesecs]\n                    [--time | --space |
  --spacetime | --allocation | --count]\n                    [-g|--golden ARG] [--nocheck]
  [-r|--record]\n                    [--header | --noheader] [--error ARG] [--warning
  ARG]\n                    [--improved ARG]\n                    [--sums | --lengths
  | --nub | --examples | --example |\n                      --exampleIO | --noops
  | --ticks | --gauge]\n                    [-l|--length ARG]\n                    [--sumFuse
  | --sum | --lengthF | --constFuse | --mapInc |\n                      --noOp]\n\n
  \ perf exploration\n\nAvailable options:\n  -n,--runs ARG            number of runs
  to perform\n  --best                   report upper decile\n  --median                 report
  median\n  --average                report average\n  --averagesecs            report
  average in seconds\n  --time                   measure time performance\n  --space
  \                 measure space performance\n  --spacetime              measure
  both space and time performance\n  --allocation             measure bytes allocated\n
  \ --count                  measure count\n  -g,--golden ARG          golden file
  name\n  --nocheck                do not check versus the golden file\n  -r,--record
  \             record the result to the golden file\n  --header                 include
  headers\n  --noheader               dont include headers\n  --error ARG              error
  level\n  --warning ARG            warning level\n  --improved ARG           improved
  level\n  --sums                   run on sum algorithms\n  --lengths                run
  on length algorithms\n  --nub                    nub test\n  --examples               run
  on example algorithms\n  --example                run on the example algorithm\n
  \ --exampleIO              exampleIO test\n  --noops                  noops test\n
  \ --ticks                  tick test\n  --gauge                  gauge runs on exmaple
  for comparison\n  -l,--length ARG          length of list\n  --sumFuse                fused
  sum pipeline\n  --sum                    sum\n  --lengthF                foldr id
  length\n  --constFuse              fused const pipeline\n  --mapInc                 fmap
  (+1)\n  --noOp                   const ()\n  -h,--help                Show this
  help text\n#+end_example\n\n#+begin_src haskell :results output :exports both\nfmap
  averageI <$> execPerfT (times 10000) (sum |$| [1..1000])\n#+end_src\n\n#+RESULTS:\n:
  fromList [(\"\",54874.5718)]\n\nThe equivalent to the above code is:\n\n#+begin_src
  sh :results output :exports both\nperf-explore -n 10000 -l 1000 --sum\n#+end_src\n\n#+RESULTS:\n:
  label1              label2              results\n:\n: sum                 time                1.46e4\n\n**
  noops\n\nThis no-op experiment is useful to understand the pure time performance
  of the machinery around measurement. It can be (re)run with:\n\n#+begin_src sh :results
  output :exports both\nperf-explore --noops\n#+end_src\n\n#+RESULTS:\n#+begin_example\nlabel1
  \             label2              label3              results\n\nconst               1st
  \                time                4.46e2\nconst               2nd                 time
  \               2.20e1\nconst               3rd                 time                2.20e1\nconst
  \              4th                 time                2.20e1\nconst               average
  \            time                2.22e1\nconst               best                time
  \               2.10e1\nconst               median              time                2.19e1\npure
  \               1st                 time                1.46e2\npure                2nd
  \                time                3.40e1\npure                3rd                 time
  \               2.40e1\npure                4th                 time                2.40e1\npure
  \               average             time                2.41e1\npure                best
  \               time                1.86e1\npure                median              time
  \               2.42e1\n#+end_example\n\n** measurement context\n\nExploration of
  how the code surrounding measurement effects performance.\n\n#+begin_src sh :results
  drawer :exports both\nperf-explore -n 1000 -l 1000 --ticks\n#+end_src\n\n#+RESULTS:\n:results:\n|
  \              | stepTime |   tick | tickForce | tickForceArgs | tickLazy | tickWHNF
  |  times |\n| sumAux        |   1.49e4 | 1.46e4 |    1.46e4 |        1.98e4 |   1.99e1
  |   1.45e4 | 1.44e4 |\n| sumCata       |   1.45e4 | 1.44e4 |    1.46e4 |        1.46e4
  |   1.99e1 |   1.44e4 | 1.44e4 |\n| sumCo         |   1.64e4 | 2.06e4 |    1.46e4
  |        1.45e4 |   2.31e1 |   1.85e4 | 2.10e4 |\n| sumCoCase     |   1.30e4 | 2.18e4
  |    1.01e4 |        1.39e4 |   1.99e1 |   1.02e4 | 1.08e4 |\n| sumCoGo       |
  \  1.92e4 | 1.68e4 |    1.45e4 |        1.71e4 |   1.98e1 |   1.45e4 | 1.54e4 |\n|
  sumF          |   1.33e4 | 1.34e4 |    1.34e4 |        1.34e4 |   1.97e1 |   1.34e4
  | 1.34e4 |\n| sumFlip       |   1.34e4 | 1.33e4 |    1.66e4 |        1.55e4 |   1.98e1
  |   1.33e4 | 1.34e4 |\n| sumFlipLazy   |   1.33e4 | 1.37e4 |    1.88e4 |        1.40e4
  |   1.97e1 |   1.34e4 | 1.35e4 |\n| sumFoldr      |   1.45e4 | 1.59e4 |    1.58e4
  |        1.48e4 |   2.12e1 |   1.52e4 | 1.44e4 |\n| sumFuse       |   2.01e3 | 1.80e3
  |    1.81e3 |        1.54e3 |   1.97e1 |   2.04e3 | 1.65e3 |\n| sumFuseFoldl' |
  \  2.14e3 | 1.80e3 |    1.92e3 |        1.71e3 |   1.97e1 |   1.98e3 | 1.66e3 |\n|
  sumFuseFoldr  |   8.58e3 | 5.43e3 |    5.13e3 |        5.84e3 |   1.97e1 |   5.26e3
  | 7.13e3 |\n| sumFusePoly   |   1.92e3 | 1.93e3 |    1.96e3 |        1.58e3 |   2.00e1
  |   1.60e3 | 1.94e3 |\n| sumLambda     |   1.34e4 | 1.34e4 |    1.35e4 |        1.33e4
  |   2.05e1 |   1.34e4 | 1.34e4 |\n| sumMono       |   1.35e4 | 1.34e4 |    1.34e4
  |        1.34e4 |   1.98e1 |   1.33e4 | 1.38e4 |\n| sumPoly       |   2.90e4 | 1.34e4
  |    5.43e4 |        2.90e4 |   2.01e1 |   1.34e4 | 2.90e4 |\n| sumSum        |
  \  1.33e4 | 1.34e4 |    1.33e4 |        1.34e4 |   1.96e1 |   1.34e4 | 1.34e4 |\n|
  sumTail       |   1.47e4 | 1.59e4 |    1.34e4 |        1.81e4 |   2.02e1 |   1.34e4
  | 1.33e4 |\n| sumTailLazy   |   1.35e4 | 1.39e4 |    1.37e4 |        1.34e4 |   2.18e1
  |   1.38e4 | 1.36e4 |\n:end:\n\n\n#+begin_src sh :results drawer :exports both\nperf-explore
  -n 100000 -l 1000 --ticks\n#+end_src\n\n#+RESULTS:\n:results:\n|               |
  stepTime |   tick | tickForce | tickForceArgs | tickLazy | tickWHNF |  times |\n|
  sumAux        |   1.83e4 | 1.83e4 |    1.81e4 |        1.81e4 |   1.75e1 |   1.81e4
  | 1.86e4 |\n| sumCata       |   2.16e4 | 2.16e4 |    2.08e4 |        2.09e4 |   1.75e1
  |   2.11e4 | 2.09e4 |\n| sumCo         |   1.83e4 | 1.82e4 |    1.82e4 |        1.88e4
  |   1.74e1 |   1.81e4 | 1.81e4 |\n| sumCoCase     |   1.59e4 | 1.87e4 |    1.54e4
  |        1.57e4 |   1.76e1 |   1.83e4 | 1.54e4 |\n| sumCoGo       |   2.06e4 | 2.07e4
  |    2.07e4 |        2.11e4 |   1.74e1 |   2.07e4 | 2.12e4 |\n| sumF          |
  \  8.87e3 | 9.05e3 |    8.61e3 |        8.73e3 |   1.73e1 |   8.66e3 | 8.84e3 |\n|
  sumFlip       |   8.57e3 | 8.66e3 |    8.49e3 |        8.65e3 |   1.74e1 |   8.70e3
  | 8.80e3 |\n| sumFlipLazy   |   5.60e3 | 8.68e3 |    8.74e3 |        5.91e3 |   1.75e1
  |   8.91e3 | 5.53e3 |\n| sumFoldr      |   2.14e4 | 2.10e4 |    2.08e4 |        2.08e4
  |   1.75e1 |   2.09e4 | 2.12e4 |\n| sumFuse       |   2.23e3 | 2.13e3 |    2.11e3
  |        2.02e3 |   1.69e1 |   1.98e3 | 2.15e3 |\n| sumFuseFoldl' |   2.14e3 | 2.03e3
  |    2.20e3 |        1.97e3 |   1.76e1 |   2.22e3 | 2.14e3 |\n| sumFuseFoldr  |
  \  1.22e4 | 1.28e4 |    1.23e4 |        1.28e4 |   1.69e1 |   1.26e4 | 1.23e4 |\n|
  sumFusePoly   |   1.67e3 | 1.47e3 |    1.46e3 |        1.47e3 |   1.71e1 |   1.42e3
  | 1.65e3 |\n| sumLambda     |   9.04e3 | 8.75e3 |    8.70e3 |        8.80e3 |   1.77e1
  |   8.70e3 | 9.09e3 |\n| sumMono       |   5.97e3 | 5.96e3 |    5.82e3 |        6.26e3
  |   1.85e1 |   5.69e3 | 5.91e3 |\n| sumPoly       |   8.74e3 | 8.85e3 |    8.70e3
  |        8.73e3 |   1.76e1 |   8.64e3 | 8.76e3 |\n| sumSum        |   5.90e3 | 6.36e3
  |    5.78e3 |        5.78e3 |   1.81e1 |   6.05e3 | 5.88e3 |\n| sumTail       |
  \  1.21e4 | 6.48e3 |    5.85e3 |        1.19e4 |   1.76e1 |   5.86e3 | 1.22e4 |\n|
  sumTailLazy   |   6.05e3 | 8.40e3 |    6.02e3 |        5.74e3 |   1.75e1 |   5.91e3
  | 5.94e3 |\n:end:\n\n*** short list\n#+begin_src sh :results drawer :exports both\nperf-explore
  -n 10000 -l 10 --best --ticks\n#+end_src\n\n#+RESULTS:\n:results:\n|               |
  stepTime |   tick | tickForce | tickForceArgs | tickLazy | tickWHNF |  times |\n|
  sumAux        |   8.94e1 | 9.30e1 |    9.15e1 |        8.97e1 |   1.54e1 |   9.14e1
  | 8.96e1 |\n| sumCata       |   9.74e1 | 9.79e1 |    9.78e1 |        9.81e1 |   1.55e1
  |   9.77e1 | 9.62e1 |\n| sumCo         |   9.11e1 | 1.16e2 |    9.15e1 |        9.13e1
  |   1.51e1 |   9.11e1 | 8.92e1 |\n| sumCoCase     |   9.05e1 | 9.21e1 |    9.18e1
  |        9.18e1 |   1.53e1 |   8.99e1 | 8.90e1 |\n| sumCoGo       |   9.76e1 | 9.90e1
  |    9.76e1 |        9.84e1 |   1.54e1 |   9.76e1 | 9.70e1 |\n| sumF          |
  \  7.54e1 | 7.94e1 |    7.75e1 |        7.78e1 |   1.53e1 |   7.73e1 | 7.56e1 |\n|
  sumFlip       |   7.72e1 | 8.07e1 |    7.75e1 |        7.75e1 |   1.51e1 |   7.78e1
  | 7.55e1 |\n| sumFlipLazy   |   7.74e1 | 7.93e1 |    7.72e1 |        7.78e1 |   1.55e1
  |   7.62e1 | 7.55e1 |\n| sumFoldr      |   9.75e1 | 9.88e1 |    9.70e1 |        9.77e1
  |   1.52e1 |   9.78e1 | 9.71e1 |\n| sumFuse       |   3.59e1 | 3.53e1 |    3.52e1
  |        3.22e1 |   1.49e1 |   3.33e1 | 3.22e1 |\n| sumFuseFoldl' |   3.52e1 | 3.50e1
  |    3.52e1 |        3.30e1 |   1.50e1 |   3.33e1 | 3.27e1 |\n| sumFuseFoldr  |
  \  5.00e1 | 4.99e1 |    5.06e1 |        4.91e1 |   1.50e1 |   4.91e1 | 4.94e1 |\n|
  sumFusePoly   |   4.42e1 | 4.39e1 |    4.36e1 |        4.19e1 |   1.51e1 |   4.15e1
  | 4.31e1 |\n| sumLambda     |   7.93e1 | 8.10e1 |    7.94e1 |        7.93e1 |   1.54e1
  |   7.92e1 | 7.73e1 |\n| sumMono       |   6.33e1 | 6.56e1 |    6.36e1 |        6.36e1
  |   1.53e1 |   6.35e1 | 6.31e1 |\n| sumPoly       |   7.93e1 | 8.01e1 |    7.92e1
  |        7.93e1 |   1.53e1 |   7.93e1 | 7.73e1 |\n| sumSum        |   7.93e1 | 7.98e1
  |    7.95e1 |        7.95e1 |   1.52e1 |   7.93e1 | 7.73e1 |\n| sumTail       |
  \  6.75e1 | 6.99e1 |    6.80e1 |        6.78e1 |   1.56e1 |   6.70e1 | 6.72e1 |\n|
  sumTailLazy   |   6.80e1 | 7.18e1 |    6.80e1 |        6.89e1 |   1.52e1 |   6.85e1
  | 6.72e1 |\n:end:\n\n*** long list\n#+begin_src sh :results drawer :exports both\nperf-explore
  -n 100 -l 100000 --best --ticks\n#+end_src\n\n#+RESULTS:\n:results:\n|               |
  stepTime |   tick | tickForce | tickForceArgs | tickLazy | tickWHNF |  times |\n|
  sumAux        |   2.26e6 | 2.28e6 |    2.28e6 |        2.25e6 |   1.68e1 |   2.31e6
  | 2.26e6 |\n| sumCata       |   2.84e6 | 2.82e6 |    2.81e6 |        3.21e6 |   1.56e1
  |   2.82e6 | 2.81e6 |\n| sumCo         |   2.26e6 | 2.27e6 |    5.02e6 |        2.27e6
  |   1.66e1 |   2.28e6 | 2.28e6 |\n| sumCoCase     |   2.28e6 | 2.30e6 |    2.32e6
  |        2.28e6 |   1.48e1 |   2.97e6 | 2.30e6 |\n| sumCoGo       |   2.84e6 | 2.80e6
  |    2.84e6 |        2.85e6 |   1.51e1 |   2.81e6 | 2.81e6 |\n| sumF          |
  \  7.76e5 | 7.78e5 |    7.80e5 |        7.81e5 |   1.51e1 |   9.76e5 | 7.05e5 |\n|
  sumFlip       |   7.48e5 | 9.04e5 |    7.46e5 |        7.43e5 |   1.68e1 |   7.48e5
  | 7.44e5 |\n| sumFlipLazy   |   1.21e6 | 1.22e6 |    1.19e6 |        1.19e6 |   1.61e1
  |   1.20e6 | 1.20e6 |\n| sumFoldr      |   3.63e6 | 2.87e6 |    3.25e6 |        2.81e6
  |   1.45e1 |   5.89e6 | 2.81e6 |\n| sumFuse       |   1.92e5 | 1.92e5 |    1.92e5
  |        1.92e5 |   1.47e1 |   1.92e5 | 1.92e5 |\n| sumFuseFoldl' |   1.92e5 | 1.92e5
  |    1.92e5 |        1.92e5 |   1.52e1 |   1.92e5 | 1.92e5 |\n| sumFuseFoldr  |
  \  1.68e6 | 1.64e6 |    1.65e6 |        1.65e6 |   1.50e1 |   1.65e6 | 1.65e6 |\n|
  sumFusePoly   |   1.32e5 | 1.28e5 |    1.28e5 |        1.28e5 |   1.48e1 |   1.32e5
  | 1.28e5 |\n| sumLambda     |   7.90e5 | 8.01e5 |    7.93e5 |        7.92e5 |   1.57e1
  |   7.93e5 | 7.92e5 |\n| sumMono       |   7.86e5 | 8.04e5 |    7.87e5 |        7.83e5
  |   1.48e1 |   7.99e5 | 7.88e5 |\n| sumPoly       |   7.99e5 | 8.18e5 |    8.06e5
  |        8.00e5 |   1.64e1 |   8.10e5 | 8.00e5 |\n| sumSum        |   7.82e5 | 7.92e5
  |    7.85e5 |        7.82e5 |   1.66e1 |   7.88e5 | 7.87e5 |\n| sumTail       |
  \  7.43e5 | 7.84e5 |    8.23e5 |        8.18e5 |   1.61e1 |   7.89e5 | 7.38e5 |\n|
  sumTailLazy   |   1.35e6 | 1.37e6 |    1.34e6 |        1.33e6 |   1.58e1 |   1.35e6
  | 1.34e6 |\n:end:\n\n** sums\n\n#+begin_src sh :output drawer :exports both\nperf-explore
  -n 1000 -l 1000 --sums\n#+end_src\n\n#+RESULTS:\n| label1        | label2 | results
  |\n|               |        |         |\n| sumAux        | time   | 16200.0 |\n|
  sumCata       | time   | 15600.0 |\n| sumCo         | time   | 19100.0 |\n| sumCoCase
  \    | time   | 16300.0 |\n| sumCoGo       | time   | 15700.0 |\n| sumF          |
  time   | 10500.0 |\n| sumFlip       | time   | 10500.0 |\n| sumFlipLazy   | time
  \  |  6130.0 |\n| sumFoldr      | time   | 16900.0 |\n| sumFuse       | time   |
  \ 1950.0 |\n| sumFuseFoldl' | time   |  1950.0 |\n| sumFuseFoldr  | time   | 14600.0
  |\n| sumFusePoly   | time   |  1400.0 |\n| sumLambda     | time   |  9780.0 |\n|
  sumMono       | time   | 11200.0 |\n| sumPoly       | time   | 11500.0 |\n| sumSum
  \       | time   | 11100.0 |\n| sumTail       | time   | 11000.0 |\n| sumTailLazy
  \  | time   | 11100.0 |\n\n** lengths\n\n#+begin_src sh :exports both\nperf-explore
  -n 1000 -l 1000 --lengths\n#+end_src\n\n#+RESULTS:\n| label1           | label2
  | results |\n|                  |        |         |\n| lengthAux        | time
  \  | 11000.0 |\n| lengthCo         | time   | 11100.0 |\n| lengthCoCase     | time
  \  | 10500.0 |\n| lengthF          | time   |  9540.0 |\n| lengthFMono      | time
  \  |  9190.0 |\n| lengthFlip       | time   |  9770.0 |\n| lengthFlipLazy   | time
  \  |  4830.0 |\n| lengthFoldr      | time   | 10100.0 |\n| lengthFoldrConst | time
  \  | 11100.0 |\n| lengthTail       | time   |  9830.0 |\n| lengthTailLazy   | time
  \  |  9540.0 |\n\n** Gauge comparison\n\n#+begin_src sh :results output :exports
  both\nperf-explore -n 1000 -l 1000 --average --gauge\n#+end_src\n\n#+RESULTS:\n#+begin_example\nsumFuse\nbenchmarking
  function ... \rfunction                                 time                 849.4
  ns\n\nbenchmarking function ... \rfunction                                 time
  \                848.6 ns\n\nsum\nbenchmarking function ... \rfunction                                 time
  \                3.786 μs\n\nbenchmarking function ... \rfunction                                 time
  \                3.791 μs\n\nlengthF\nbenchmarking function ... \rfunction                                 time
  \                1.863 μs\n\nbenchmarking function ... \rfunction                                 time
  \                1.872 μs\n\nconstFuse\nbenchmarking function ... \rfunction                                 time
  \                571.0 ns\n\nbenchmarking function ... \rfunction                                 time
  \                1.080 μs\n\nmapInc\nbenchmarking function ... \rfunction                                 time
  \                9.203 ns\n\nbenchmarking function ... \rfunction                                 time
  \                15.99 μs\n\nnoop\nbenchmarking function ... \rfunction                                 time
  \                5.770 ns\n\nbenchmarking function ... \rfunction                                 time
  \                4.740 ns\n\n#+end_example\n\n** Space\n\nData is collected from
  GHCStats\n\n- allocated_bytes\n- gcs\n- gcdetails_live_bytes\n- max_live_bytes\n-
  max_mem_in_use_bytes\n\n#+begin_src sh :results ouput :exports both\nperf-explore
  -n 10 -l 100000 --space +RTS -T -RTS\n#+end_src\n\n#+RESULTS:\n| label1 | label2
  \      |  results |\n|        |              |          |\n| sum    | MaxMem       |
  839000.0 |\n| sum    | allocated    | 416000.0 |\n| sum    | gcLiveBytes  | 220000.0
  |\n| sum    | gcollects    |      0.1 |\n| sum    | maxLiveBytes |      0.0 |\n\n*
  Perf.BigO\n\nPerf.BigO represents functionality to determine the complexity order
  for a computation.\n\nWe could do a regression and minimise the error term, but
  we know that the largest run contains the most information; we would need to weight
  the simulations according to some heuristic.\n\nInstead, we:\n\n- estimate the order
  factor for each possible Order, from N3 to N0, setting the highest n run constant
  factor to zero,\n- pick the order based on lowest absolute error result summed across
  all the runs,\n\n#+begin_src haskell :results output :exports both\nimport qualified
  Prelude as P\nimport Data.List (nub)\nestOrder (\\x -> sum $ nub [1..x]) 10 [1,10,100,1000]\n#+end_src\n\n#+RESULTS:\n:
  BigOrder {bigOrder = N2, bigFactor = 13.545801, bigConstant = 0.0}\n\n* References\n\n[[https://github.com/haskell-perf/checklist][The
  Haskell performance checklist]]\n\n[[https://github.com/ndmitchell/spaceleak][ndmitchell/spaceleak:
  Notes on space leaks]]\n\n** Core\n\n[[https://ghc.gitlab.haskell.org/ghc/doc/users_guide/debugging.html#options-debugging][5.13.
  Debugging the compiler]]\n\n#+begin_src sh\nghc app/speed.hs -ddump-simpl -ddump-to-file
  -fforce-recomp -dlint -O\n#+end_src\n\n[[https://wiki.haskell.org/Performance/GHC#Looking_at_the_Core][haskell
  wiki: Looking at the Core]]\n\n[[https://godbolt.org/][godbolt]]\n\n[[https://gitlab.haskell.org/ghc/ghc/-/issues/15185][ghc
  issue 15185: Enum instance for IntX / WordX are inefficient]]\n\n[[https://fixpt.de/blog/2017-12-04-strictness-analysis-part-1.html][fixpt
  - All About Strictness Analysis (part 1)]]\n\n** Profiling\n*** setup\n[[https://ghc.gitlab.haskell.org/ghc/doc/users_guide/profiling.html#prof-heap][8.
  Profiling]]\n\nA typical configuration step for profiling:\n\n#+begin_src sh :results
  output\ncabal configure --enable-library-profiling --enable-executable-profiling
  -fprof-auto -fprof -write-ghc-environment-files=always\n#+end_src\n\nA cabal.project.local
  with profiling enabled:\n\n#+begin_quote\nwrite-ghc-environment-files: always\nignore-project:
  False\nflags: +prof +prof-auto\nlibrary-profiling: True\nexecutable-profiling: True\n#+end_quote\n\nExamples
  from markup-parse R&D:\n\nExecutable compilation:\n\n#+begin_src sh :results output\nghc
  -prof -fprof-auto -rtsopts app/speed0.hs -threaded -fforce-recomp\n#+end_src\n\nExecutable
  run:\n\n#+begin_src sh :results output\napp/speed0 +RTS -s -p -hc -l -RTS\n#+end_src\n\n***
  Space usage output (-s)\n\n#+begin_example\n885,263,472 bytes allocated in the heap\n
  \      8,507,448 bytes copied during GC\n         163,200 bytes maximum residency
  (4 sample(s))\n          27,752 bytes maximum slop\n               6 MiB total memory
  in use (0 MiB lost due to fragmentation)\n\n                                     Tot
  time (elapsed)  Avg pause  Max pause\n  Gen  0       207 colls,     0 par    0.009s
  \  0.010s     0.0001s    0.0002s\n  Gen  1         4 colls,     0 par    0.001s
  \  0.001s     0.0004s    0.0005s\n\n  TASKS: 4 (1 bound, 3 peak workers (3 total),
  using -N1)\n\n  SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)\n\n
  \ INIT    time    0.006s  (  0.006s elapsed)\n  MUT     time    0.367s  (  0.360s
  elapsed)\n  GC      time    0.010s  (  0.011s elapsed)\n  RP      time    0.000s
  \ (  0.000s elapsed)\n  PROF    time    0.000s  (  0.000s elapsed)\n  EXIT    time
  \   0.001s  (  0.001s elapsed)\n  Total   time    0.384s  (  0.380s elapsed)\n#+end_example\n\n***
  Cost center profile (-p)\n\nDumped to speed0.prof\n\n#+begin_example\nCOST CENTRE
  MODULE                SRC                                            %time %alloc\n\ntoken
  \      MarkupParse           src/MarkupParse.hs:(259,1)-(260,20)             50.2
  \  50.4\nwrappedQ'   MarkupParse.FlatParse src/MarkupParse/FlatParse.hs:(215,1)-(217,78)
  \  20.8   23.1\nws_         MarkupParse.FlatParse src/MarkupParse/FlatParse.hs:(135,1)-(146,4)
  \   14.3    5.5\neq          MarkupParse.FlatParse src/MarkupParse/FlatParse.hs:243:1-30
  \          10.6   11.1\ngather      MarkupParse           src/MarkupParse.hs:(420,1)-(428,100)
  \            2.4    3.7\nrunParser   FlatParse.Basic       src/FlatParse/Basic.hs:(217,1)-(225,24)
  \         1.0    6.0\n#+end_example\n\n*** heap analysis (-hc -l)\n\n#+begin_src
  sh :results output\neventlog2html speed0.eventlog\n#+end_src\n\nProduces speed0.eventlog.html
  which contains heap charts.\n\n** Cache speed\n\nThe average cycles per + operation
  can get down to about 0.7 cycles, and there are about 4 cache registers per cycle,
  so a sum pipeline uses 2.8 register instructions per +.\n\n| Cache             |
  Cycles         |\n|-------------------|----------------|\n| register          |
  4 per cycle    |\n| L1 Cache access   | 3-4 cycles     |\n| L2 Cache access   |
  11-12 cycles   |\n| L3 unified access | 30 - 40        |\n| DRAM hit          |
  195 cycles     |\n| L1 miss           | 40 cycles      |\n| L2 miss           |
  >600 cycles     |\n\n\n"
license-name: BSD-3-Clause

all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
- 0.3.0
author: Takahiro HIMURA
basic-deps:
  array: '>=0'
  base: '>=4.9 && <5'
  conduit: '>=1.3.0'
  containers: '>=0'
  mtl: '>=0'
  names-th: '>=0'
  persistable-record: '>=0.6'
  persistent: '>=2.5'
  relational-query: '>=0.12.0.0'
  resourcet: '>=1.1'
  template-haskell: '>=2.11'
  text: '>=0.8'
changelog: |
  ## 0.3.0

  - Switched to Generics & OverloadedLabels based implementation.
  - Remove defineTableFromPersistent. The table data types and Pi Projection variables generated by HRR are no longer supported.
  - Drop support: GHC < 8, relational-query < 0.12, persistent < 2.5

  ## 0.2.0

  - Support relational-query >= 0.12.0.0 and conduit-1.3.0

  ## 0.1.2.0

  - Support relational-query >= 0.10.0

  ## 0.1.1.0

  - Support persistable-record >= 0.5.0
  - Tested with GHC 8.0.2

  ## 0.1.0.0

  - Initial release
changelog-type: markdown
description: |
  persistent-relational-record
  ============================

  [![Travis](https://img.shields.io/travis/himura/persistent-relational-record/master.svg)](https://travis-ci.org/himura/persistent-relational-record)
  [![Hackage-Deps](https://img.shields.io/hackage-deps/v/persistent-relational-record.svg)](http://packdeps.haskellers.com/feed?needle=persistent-relational-record)

  ## About ##

  persistent-relational-record build a bridge between [Haskell Relational Record](https://hackage.haskell.org/package/relational-query)
  and [Persistent](http://hackage.haskell.org/package/persistent).
  It uses the persistent entities definition instead of obtaining schema from DB at compilation time.

  ## Getting Started ##

  If you already define an entities in persistent's manner, then you are almost ready to use this module.
  The entities definition in the style of persistent-relational-record are shown below:

  Model.hs:

  ```Haskell
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE DeriveGeneric #-}
  {-# LANGUAGE FlexibleInstances #-}
  {-# LANGUAGE GADTs #-}
  {-# LANGUAGE GeneralizedNewtypeDeriving #-}
  {-# LANGUAGE MultiParamTypeClasses #-}
  {-# LANGUAGE QuasiQuotes #-}
  {-# LANGUAGE StandaloneDeriving #-}
  {-# LANGUAGE TemplateHaskell #-}
  {-# LANGUAGE TypeFamilies #-}

  module Model where

  import Data.Text (Text)
  import Database.Persist.Relational
  import Database.Persist.TH
  import GHC.Generics

  share [mkPersist sqlSettings, mkMigrate "migrateAll", mkHrr, deriveGenericForEntityId] [persistLowerCase|
  User
      email       Text
      name        Text

      UniqueUserEmail email
      deriving Show Eq Generic

  UserGroup
      name        Text
      pageUrl     Text Maybe

      UniqueUserGroupName  name
      deriving Show Eq Generic

  Membership
      userId      UserId
      userGroupId UserGroupId

      UniqueImageTag userId userGroupId
      deriving Show Eq Generic
  |]
  ```

  The main difference from the persistent version is that `mkHrr` are added to the 1st argument of the `share` function.
  `mkHrr` generates various instances and helper functions from the entities definition to cooperate with HRR.

  NOTE: `deriveGenericForEntityId` is also appended to the list in above example.
  Currently, persistent does not generate `Generic` instances for EntityID types (`UserId`, `UserGroupId`, and `MembershipId` in above example).
  Haskell Relational Record rely on the Generic instance of record types, so persistent-relational-record provides `deriveGenericForEntityId` for convenience to derive `Generic` instance via `StandaloneDeriving`

  Now, you can build queries in manner of HRR:

  ```Haskell
  {-# LANGUAGE OverloadedLabels #-}

  module Query where

  import Data.Text (Text)
  import Database.Persist (Entity)
  import Database.Relational

  import Model

  -- ^ query users by UserGroup name list
  --
  -- @
  -- SELECT
  --   user.*
  -- FROM user
  -- INNER JOIN (
  --   -- built by userIdFromUserGroupNameList
  --   SELECT
  --     user_id
  --   FROM membership
  --   INNER JOIN userGroup ON userGroup.id = membership.userGroup_id
  --   WHERE userGroup.name IN (<<userGroupNames>>)
  --   GROUP BY membership.user_id
  --   HAVING COUNT(membership.user_id) = <<length userGroupNames>>
  -- ) uid
  -- ON user.id = uid.user_id
  -- @
  selectUserByUserGroupNameList
      -> [Text] -- ^ list of UserGroup name
      -> Relation () (Entity User)
  selectUserByUserGroupNameList userGroupNames =
      relation $ do
          user <- query userTable
          userId <- query $ userIdFromUserGroupNameList userGroupNames
          on $ #id user .=. userId
          return user

  -- ^ query user_id by UserGroup name list
  --
  -- @
  -- SELECT
  --   user_id
  -- FROM membership
  -- INNER JOIN userGroup ON userGroup.id = membership.userGroup_id
  -- WHERE userGroup.name IN (<<userGroupNames>>)
  -- GROUP BY membership.user_id
  -- HAVING COUNT(membership.user_id) = <<length userGroupNames>>
  -- @
  userIdFromUserGroupNameList
      :: [Text] -- ^ list of userGroup name
      -> Relation () UserId
  userIdFromUserGroupNameList userGroupNames =
      aggregateRelation $ do
          membership <- query membershipTable
          userGroup <- query userGroupTable
          on $ #id userGroup .=. #userGroupId membership
          wheres $ #name userGroup `in'` values userGroupNames
          g <- groupBy $ #userId membership
          let c = count $ (#userGroupId membership)
          having $ c .=. value (fromIntegral . length $ userGroupNames)
          return g
  ```

  Finally, we can execute a query by runQuery:

  ```Haskell
  {-# LANGUAGE OverloadedStrings #-}

  import Control.Monad.IO.Class
  import Control.Monad.Logger
  import Control.Monad.Trans.Resource
  import Data.Conduit
  import qualified Data.Conduit.List as CL
  import Database.Persist.MySQL
  import Database.Persist.Relational
  import Database.Relational

  import Model
  import Query

  sample :: SqlPersistT (LoggingT IO) [Entity User]
  sample = runResourceT . runConduit $ runQuery (relationalQuery $ selectUserByUserGroupNameList True ["tokyo", "haskell"]) () .| CL.consume

  main :: IO ()
  main = runStderrLoggingT $ withMySQLPool defaultConnectInfo 10 $ runSqlPool $ do
      mapM_ (liftIO . print) =<< sample
  ```

  `runQuery` run the HRR `Query` and gives the result as conduit `Source`.

  For a full runnable example, see [examples](https://github.com/himura/persistent-relational-record/tree/master/examples/) directory.
description-type: markdown
hash: e5d3436ec5df69b440e1526b9ffb6cf96bc21d681f6464a5ffb7b20171048cce
homepage: http://github.com/himura/persistent-relational-record
latest: 0.3.0
license-name: BSD-3-Clause
maintainer: taka@himura.jp
synopsis: relational-record on persisten backends.
test-bench-deps:
  HUnit: '>=0'
  base: '>=0'
  hlint: '>=1.7'
  persistent-relational-record: '>=0'
  persistent-template: '>=0'
  relational-query: '>=0'
  test-framework: '>=0'
  test-framework-hunit: '>=0'
  test-framework-th: '>=0'
  text: '>=0'
  time: '>=0'

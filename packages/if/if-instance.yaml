homepage: https://github.com/sheaf/if-instance
changelog-type: markdown
hash: b346e48d9ae418ddb7d0056ffb447c186284455eae042b4dc3a1c9094109466b
test-bench-deps:
  ghc: '>=9.0 && <9.6'
  base: '>=4.15.0 && <4.18'
  if-instance: -any
maintainer: Sam Derbyshire
synopsis: Branch on whether a constraint is satisfied
changelog: "\r\n# Version 0.3.0.0 (2021-09-01)\r\n\r\n- Add the `(||)` constraint
  disjunction mechanism, with\r\n\r\n```haskell\r\ndispatch :: ( c || d ) => ( c =>
  r ) -> ( d => r ) -> r\r\n```\r\n\r\nThis allows users to select between two different
  constraints.\r\nThis is more general than `ifCt`, as it allows extra constraints\r\nin
  the fallback branch.\r\n\r\n- Implement `IfCt`, `ifCt` in terms of `(||)` and `dispatch`.\r\n
  \ `IfCt` becomes a type synonym, which means that it no longer\r\n  bundles `ifCt`.\r\n\r\n#
  Version 0.2.1.1 (2021-08-31)\r\n\r\n- Minor documentation improvements.\r\n\r\n#
  Version 0.2.1.0 (2021-08-31)\r\n\r\n- Require `ghc-tcplugin-api >= 0.5.1.0`.\r\n\r\n#
  Version 0.2.0.0 (2021-08-31)\r\n\r\n- Add a type family `IsSat :: Constraint ->
  Bool`\r\n  that computes whether a type-family is satisfied in\r\n  the current
  context.\r\n\r\n- Rename `IfCt` to `IfSat`.\r\n\r\n# Version 0.1.0.0 (2021-08-30)\r\n\r\nInitial
  release.\r\n"
basic-deps:
  ghc: '>=9.0 && <9.6'
  base: '>=4.15.0 && <4.18'
  ghc-tcplugin-api: '>=0.5.1.0 && <0.6'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.3.0.0
author: Sam Derbyshire
latest: 0.3.0.0
description-type: haddock
description: |-
  This library provides a mechanism that can be used to branch on
  whether a constraint is satisfied (not limited to typeclass instances).

  Usage example:

  @

  {-# OPTIONS_GHC -fplugin=IfSat.Plugin #-}

  module MyModule where

  import Data.Constraint.If ( IfSat(ifSat) )

  hypot :: forall a. ( Floating a, IfSat (FMA a) ) => a -> a -> a
  hypot = ifSat @(FMA a) withFMA withoutFMA
    where
      withFMA :: FMA a => a -> a -> a
      withFMA x y =
        let
          h = sqrt $ fma x x (y * y)
          h² = h * h
          x² = x * x
          u = fma (-y) y (h² - x²) + fma h h (-h²) - fma x x (-x²)
        in
          h - u / ( 2 * h )
      withoutFMA :: a -> a -> a
      withoutFMA x y = sqrt ( x * x + y * y )

  @

  Here we select between two ways of computing the hypotenuse function
  based on whether we have access to the fused multiply-add operation

  @ fma :: FMA a => a -> a -> a -> a @

  which computes @ \\ x y z -> ( x * y ) + z @ in a single instruction,
  providing stronger guarantees about precision of the result.

  A call of the form @hypot \@MyNumberType@ will either use the robust @withFMA@
  function when an @FMA MyNumberType@ instance is available, or will fallback
  to the simple @withoutFMA@ implementation when no such instance can be found.
license-name: BSD-3-Clause

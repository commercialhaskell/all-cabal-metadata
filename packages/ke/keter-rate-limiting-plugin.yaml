all-versions:
- 0.2.0.2
author: Oleksandr Zhabenko
basic-deps:
  aeson: '>=1.4'
  base: '>=4.7 && <5'
  bytestring: '>=0.10'
  cache: '>=0.1'
  case-insensitive: '>=1.2.1.0'
  clock: '>=0.8.3 && <1'
  cookie: '>=0'
  deepseq: '>=0'
  directory: '>=1.3.4.0 && <1.4'
  focus: '>=1.0.3'
  hashable: '>=1.4.2.0 && <2'
  http-types: '>=0.12.3 && <0.13'
  iproute: '>=1.7.10'
  list-t: '>=1.0.5 && <2'
  network: '>=3.1.2 && <3.2 || ^>=3.2.0'
  stm: '>=2.5.0 && <2.6'
  stm-containers: '>=1.2 && <2'
  text: '>=1.2'
  time: '>=1.9'
  unordered-containers: '>=0.2.17 && <0.3'
  wai: '>=3.2.3 && <3.3'
changelog: "# Revision history for keter-rate-limiting-plugin\n\n## 0.1.0.0 -- 2025-08-08\n\n*
  First version. Released on an unsuspecting world.\n\n## 0.1.0.1 -- 2025-08-08\n\n*
  First version revised A. Fixed description and some cleaning up.\n\n## 0.1.0.2 --
  2025-08-08\n\n* First version revised B. Fixed some documentation issues.\n\n##
  0.1.1.0 -- 2025-08-11\n\n* First version revised C. Added new functions to support
  more middleware functionality for better keter integration. Changed api for some
  functions because of the necessity to take into account also throttle names for
  every request (especially important for multiple throttles per zone/user etc). Improved
  documentation. Added more tests and some dependencies (most of them are already
  dependencies — at least indirect — of keter) and removed not used any more dependency
  on containers. \n\n## 0.1.2.0 -- 2025-08-18\n\n* First version revised D. Changed
  Keter.RateLimiter.WAI module to more declaraive approach recommended by @jappeace
  for keter integration. Reflected the changes in the README.md file.\n\n## 0.2.0.0
  -- 2025-08-24\n\n* Second version. Changed Keter.RateLimiter.WAI module to remove
  multiple times computed data while working on the advice of @jappeace for keter
  integration and to prevent potential memory leak when keter reloads configuration.
  \n\n## 0.2.0.1 -- 2025-09-28\n\n* Second version revised A. Updated documentation
  in README.md to include basic information on keter integration (expected in the
  keter-2.3.0). \n\n## 0.2.0.2 -- 2025-10-07\n\n* Second version revised B. Updated
  documentation in README.md. Fixed mixed stdout and stderr output in nix integration
  tests that could lead to failures.\n\n"
changelog-type: markdown
description: "# keter-rate-limiting-plugin\n\n**keter-rate-limiting-plugin** is a
  modern, high-performance, and highly customizable rate-limiting plugin for [Keter](https://github.com/snoyberg/keter).
  It addresses [issue \\#301](https://github.com/snoyberg/keter/issues/301) and brings
  robust, production-grade request throttling to Haskell web applications, featuring
  efficient in-memory caching with HashMap-based lookups and IP zone isolation.\n\nThis
  library is inspired by [rack-attack](https://github.com/rack/rack-attack) and [Ruby
  on Rails](https://github.com/rails/rails) (for Keter.RateLimiter.Notifications)
  and provides a powerful middleware for Keter-managed applications, though it can
  be integrated with any WAI-compatible Haskell web stack.\n\n## Features\n\n- **Five
  window algorithms**:\n    - Fixed Window\n    - Sliding Window\n    - Token Bucket\n
  \   - Leaky Bucket\n    - TinyLRU (Least Recently Used)\n- **IP Zone Support**:
  Isolate caches and throttling policies per IP zone, customer segment, or any other
  logical grouping with efficient HashMap-based zone lookups.\n- **Declarative Configuration**:
  Define throttling rules using JSON/YAML configuration with automatic serialization
  support.\n- **Flexible Client Identification**: Multiple strategies for identifying
  clients (IP, headers, cookies, combinations).\n- **Configurable Zone Derivation**:
  Flexible strategies for deriving IP zones from requests.\n- **WAI Middleware**:
  Integrates seamlessly as a middleware into any WAI application.\n- **Convenient
  and Customizable API**:\n    - Use declarative configuration for common scenarios
  with automatic setup.\n    - Or, for advanced use, fully control cache key structure
  and throttling logic.\n- **Memory-efficient**: Designed for large-scale, high-traffic
  deployments with automatic cleanup of expired entries and HashMap-based O(1) average-case
  lookups.\n- **Easy Integration**: Minimal code changes are required to get started.\n\n##
  Why Use This Plugin?\n\n- **Scalability**: Per-zone caches with HashMap-based storage
  and flexible throttling allow you to scale from single-user apps to multi-tenant
  platforms.\n- **Performance**: The in-memory backend is built on efficient STM-based
  containers with HashMap optimizations for high-concurrency workloads.\n- **Security**:
  Protects your application from abusive clients and denial-of-service attacks.\n-
  **Flexibility**: Choose between declarative configuration and full programmatic
  customization.\n- **Production-Ready**: Inspired by industry-standard tools, thoroughly
  documented, and designed for reliability with efficient data structures.\n- **Open
  Source**: MIT licensed and community-friendly.\n\n## Installation\n\nAdd the package
  to your `build-depends` in your project's `.cabal` file or `package.yaml`.\n\n**For
  Cabal:**\n\n```cabal\nbuild-depends:\n  , keter-rate-limiting-plugin\n```\n\n**For
  Stack (`package.yaml`):**\n\n```yaml\ndependencies:\n- keter-rate-limiting-plugin\n```\n\nThen,
  rebuild your project. No external C libraries are required.\n\n## Quick Start\n\n###
  Declarative Configuration (Recommended)\n\nThe recommended approach uses declarative
  configuration that can be loaded from JSON or YAML files:\n\n```haskell\n{-# LANGUAGE
  OverloadedStrings #-}\n\nimport Keter.RateLimiter.WAI\nimport Keter.RateLimiter.Cache
  (Algorithm(..))\nimport Network.Wai (responseLBS, Application)\nimport Network.HTTP.Types
  (status200)\nimport Network.Wai.Handler.Warp (run)\n\n-- A simple application that
  runs behind the middleware.\nmyApp :: Application\nmyApp _ respond = respond $ responseLBS
  status200 [] \"Hello, you are not rate limited!\"\n\nmain :: IO ()\nmain = do\n
  \ -- 1. Define declarative configuration\n  let config = RateLimiterConfig\n        {
  rlZoneBy = ZoneIP  -- Separate zones by client IP\n        , rlThrottles = \n            [
  RLThrottle \"api\"   100 3600 FixedWindow IdIP Nothing        -- 100 requests/hour
  by IP\n            , RLThrottle \"login\" 5   300  TokenBucket  IdIP (Just 600)
  \   -- 5 login attempts/5min by IP with 10min idle timeout\n            ]\n        }\n\n
  \ -- 2. Build middleware from configuration\n  middleware <- buildRateLimiter config\n\n
  \ -- 3. Apply middleware to your application\n  let appWithMiddleware = middleware
  myApp\n\n  putStrLn \"Server starting on port 8080...\"\n  run 8080 appWithMiddleware\n```\n\n###
  JSON Configuration\n\nYou can also load configuration from JSON files:\n\n```json\n{\n
  \ \"zone_by\": \"ip\",\n  \"throttles\": [\n    {\n      \"name\": \"api\",\n      \"limit\":
  100,\n      \"period\": 3600,\n      \"algorithm\": \"fixed_window\",\n      \"identifier_by\":
  \"ip\"\n    },\n    {\n      \"name\": \"login\",\n      \"limit\": 5,\n      \"period\":
  300,\n      \"algorithm\": \"token_bucket\",\n      \"identifier_by\": \"ip\",\n
  \     \"token_bucket_ttl\": 600\n    }\n  ]\n}\n```\n\n### Advanced Programmatic
  Configuration\n\nFor more control, you can build the environment programmatically:\n\n```haskell\nimport
  Keter.RateLimiter.WAI\nimport Keter.RateLimiter.Cache (Algorithm(..))\nimport Keter.RateLimiter.IPZones
  (defaultIPZone)\nimport Data.Text.Encoding (encodeUtf8)\nimport Network.HTTP.Types
  (hHost)\n\nmain :: IO ()\nmain = do\n  -- 1. Initialize environment with custom
  zone logic\n  env <- initConfig $ \\req -> \n    case lookup hHost (requestHeaders
  req) of\n      Just \"api.example.com\" -> \"api_zone\"\n      Just \"admin.example.com\"
  -> \"admin_zone\"\n      _ -> defaultIPZone\n\n  -- 2. Add throttle configurations\n
  \ let apiThrottle = ThrottleConfig\n        { throttleLimit      = 1000\n        ,
  throttlePeriod     = 3600\n        , throttleAlgorithm  = FixedWindow\n        ,
  throttleIdentifierBy = IdIP\n        , throttleTokenBucketTTL = Nothing\n        }\n\n
  \ let loginThrottle = ThrottleConfig\n        { throttleLimit      = 5\n        ,
  throttlePeriod     = 300\n        , throttleAlgorithm  = TokenBucket\n        ,
  throttleIdentifierBy = IdIP\n        , throttleTokenBucketTTL = Just 600\n        }\n\n
  \ env' <- addThrottle env \"api\" apiThrottle\n  env'' <- addThrottle env' \"login\"
  loginThrottle\n\n  -- 3. Create middleware\n  let middleware = buildRateLimiterWithEnv
  env''\n      appWithMiddleware = middleware myApp\n\n  putStrLn \"Server starting
  on port 8080...\"\n  run 8080 appWithMiddleware\n```\n\n## Configuration Reference\n\n###
  Client Identification Strategies (`IdentifierBy`)\n\n- `IdIP` - Identify by client
  IP address\n- `IdIPAndPath` - Identify by IP address and request path\n- `IdIPAndUA`
  - Identify by IP address and User-Agent header\n- `IdHeader headerName` - Identify
  by custom header value\n- `IdCookie \"session_id\"` - Identify by cookie value\n-
  `IdHeaderAndIP headerName` - Identify by header value combined with IP\n\n### Zone
  Derivation Strategies (`ZoneBy`)\n\n- `ZoneDefault` - All requests use the same
  cache (no zone separation)\n- `ZoneIP` - Separate zones by client IP address\n-
  `ZoneHeader headerName` - Separate zones by custom header value\n\n### Rate Limiting
  Algorithms\n\n- **`FixedWindow`** - Traditional fixed-window counting\n- **`SlidingWindow`**
  - Precise sliding-window with timestamp tracking\n- **`TokenBucket`** - Allow bursts
  up to capacity, refill over time\n- **`LeakyBucket`** - Smooth rate limiting with
  configurable leak rate\n- **`TinyLRU`** - Least-recently-used eviction for memory
  efficiency\n\n## Example Usage\n\n## For the Keter Users (is expected to be introduced
  in keter-2.3.0, see the README there and / or Changelog file)\n\n### Important notes\n\nConfigure
  middleware in app bundles (config/keter.yaml), \nnot in the global Keter daemon
  config. The global keter-config.yaml \nremains for listeners, TLS, ip-from-header,
  healthcheck-path, etc. \nRequests to healthcheck-path are never rate-limited.\n\n###
  Quick Start\n\nAttach a rate-limiter to any stanza via a middleware list.\n\nExample
  bundle config (config/keter.yaml):\n\n```yaml\nstanzas:\n  - type: webapp\n    exec:
  ./my-app\n    hosts: [\"www.example.com\"]\n    middleware:\n      - rate-limiter:\n
  \         zone_by: default\n          throttles:\n            - name: \"ip-basic\"\n
  \             limit: 100\n              period: 60\n              algorithm: FixedWindow\n
  \             identifier_by: ip\n\n  - type: reverse-proxy\n    hosts: [\"api.example.com\"]\n
  \   to: \"http://127.0.0.1:9000\"\n    middleware:\n      - rate-limiter:\n          zone_by:
  { header: \"X-Tenant-ID\" }\n          throttles:\n            - name: \"tenant-api\"\n
  \             limit: 1000\n              period: 3600\n              algorithm:
  SlidingWindow\n              identifier_by: { header: \"X-Api-Key\" }\n\n  - type:
  static-files\n    hosts: [\"static.example.com\"]\n    root: ./static\n    middleware:\n
  \     - rate-limiter:\n          zone_by: ip\n          throttles:\n            -
  name: \"static-ip\"\n              limit: 300\n              period: 60\n              algorithm:
  LeakyBucket\n              identifier_by: ip\n```\n\nTip: You can stack multiple
  middleware blocks if you need \ndifferent protections. They run in order.\n\n###
  Field Reference\n\n* `rate-limiter`: top-level middleware key.\n* `zone_by`:\n  1.
  `\"default\"`: counters are isolated per vhost (Host header). Good per-domain isolation.\n
  \ 2. `\"ip\"`: counters are isolated per client IP zone. Good for IP fairness.\n
  \ 3. `{ \"header\": \"X-Header\" }`: per-tenant/customer isolation via a header
  value.\n* `throttles`: list of rules. Each rule:\n  1. `name`: a label for logs/metrics.\n
  \ 2. `limit`: integer capacity or max requests.\n  3. `period`: seconds (window
  or refill/leak interval depending on algorithm).\n  4. `algorithm`: one of `FixedWindow
  | SlidingWindow | TokenBucket | LeakyBucket | TinyLRU`.\n  5. `identifier_by`:\n
  \    * `\"ip\"`: identify by client IP (honors global ip-from-header).\n     * `\"ip+path\"`:
  combine IP and path for path-specific throttles (e.g., /login).\n     * `\"ip+ua\"`:
  combine IP and User-Agent.\n     * `{ \"header\": \"X-User\" }`: identify by a header
  value.\n     * `{ \"cookie\": \"session\" }`: identify by a cookie value.\n     *
  `{ \"header+ip\": \"X-Key\" }`: combine header and IP.\n  6. `token_bucket_ttl`:
  optional seconds; TokenBucket only (evicts idle buckets).\n\n### Choosing Algorithms\n\nRule
  of thumb for common scenarios:\n\n* **FixedWindow**\n  1. When: Simple quotas (e.g.,
  100 req/min per IP).\n  2. Pros: Simple, low overhead.\n  3. Cons: Window boundary
  bursts possible.\n  4. Use for: Public pages, basic protections.\n\n* **SlidingWindow**\n
  \ 1. When: Smoother enforcement over time; avoid boundary spikes.\n  2. Pros: More
  accurate rolling rate.\n  3. Cons: More state churn than FixedWindow.\n  4. Use
  for: API endpoints where fairness matters.\n\n* **TokenBucket**\n  1. When: Allow
  short bursts but control average rate.\n  2. Pros: Classic API limiter; bursty but
  bounded.\n  3. Cons: Requires sensible period; consider TTL for idle buckets.\n
  \ 4. Use for: Developer APIs, webhook receivers.\n  5. Tip: Set token_bucket_ttl
  (e.g., 1800s) to evict idle buckets.\n\n* **LeakyBucket**\n  1. When: Smooth out
  bursts to a steady outflow.\n  2. Pros: Predictable, backpressure-like effect.\n
  \ 3. Cons: Tuning capacity vs leak rate.\n  4. Use for: Form submissions, login
  attempts.\n\n* **TinyLRU**\n  1. When: Lightweight micro-throttling with tiny memory
  footprint.\n  2. Pros: Very small, simple.\n  3. Cons: Coarser control than others.\n
  \ 4. Use for: Edge micro-protection, complementary limits.\n\n### Practical Patterns\n\n*
  Path-specific throttles (e.g., login):\n\n```yaml\nmiddleware:\n  - rate-limiter:\n
  \     zone_by: default\n      throttles:\n        - name: \"login\"\n          limit:
  5\n          period: 60\n          algorithm: SlidingWindow\n          identifier_by:
  ip+path\n```\n\n* API key quotas per tenant:\n\n```yaml\nmiddleware:\n  - rate-limiter:\n
  \     zone_by: { header: \"X-Tenant-ID\" }\n      throttles:\n        - name: \"tenant-quota\"\n
  \         limit: 1000\n          period: 3600\n          algorithm: TokenBucket\n
  \         identifier_by: { header: \"X-Api-Key\" }\n          token_bucket_ttl:
  1800\n```\n\n* Mixed protections on the same host:\n\n```yaml\nmiddleware:\n  -
  rate-limiter:\n      zone_by: default\n      throttles:\n        - { name: \"global-ip\",
  limit: 600, period: 600, algorithm: FixedWindow, identifier_by: ip }\n  - rate-limiter:\n
  \     zone_by: default\n      throttles:\n        - { name: \"login\", limit: 5,
  period: 60, algorithm: SlidingWindow, identifier_by: ip+path }\n```\n\n* Static
  assets fairness:\n\n```yaml\n- type: static-files\n  hosts: [\"cdn.example.com\"]\n
  \ root: ./public\n  middleware:\n    - rate-limiter:\n        zone_by: ip\n        throttles:\n
  \         - { name: \"cdn-ip\", limit: 300, period: 60, algorithm: LeakyBucket,
  identifier_by: ip }\n```\n\n### Global keter daemon settings impacting behavior
  (keter-config.yaml):\n\n* `ip-from-header`: influences throttles with `identifier_by:
  ip`.\n* `healthcheck-path`: this path is always allowed and never rate-limited.\n\n\n###
  Operational Tips\n\n* Start with SlidingWindow or TokenBucket for APIs; FixedWindow
  \nfor simple pages; add a strict path-specific rule for sensitive \nendpoints (/login,
  /password-reset).\n* Tune limit/period to real traffic; prefer longer periods with
  \nproportionally larger limits for smoother behavior.\n* If behind a load balancer/proxy,
  set ip-from-header: true \nin keter-config.yaml to honor X-Forwarded-For.\n* Keep
  healthcheck-path simple (e.g., /keter-health); it's always \nbypassed by the limiter.\n*
  For multi-tenant apps, use zone_by: { header: \"X-Tenant-ID\" } \nso each tenant's
  counters are isolated; pair with header/cookie \nidentifiers that match your auth.\n*
  Use token_bucket_ttl to bound memory for TokenBucket.\n* Stacking throttles is common;
  the most restrictive one effectively \ngoverns.\n* Consider integrating limiter
  notifications with your logging/metrics.\n\n### FAQ\n\n* **Should I configure middleware
  in the global Keter config?**\n\nNo. Middleware is per-app in bundles (config/keter.yaml).
  The global file \nconfigures listeners, TLS, ip-from-header, and healthcheck-path.\n\n*
  **Does it work with HTTPS and multiple listeners?**\n\nYes. The middleware is applied
  uniformly; rate limiting is agnostic \nto scheme.\n\n* **How do vhosts interact
  with rate limits?**\n\nWith zone_by: default, counters are isolated per Host. Different
  hosts \npointing to the same backend port don't share counters.\n\nIf you'd like
  help choosing safe defaults for your workloads, open \nan issue with a brief description
  of your traffic patterns and endpoints.\n\n## Using the Convenient API\n\nThe `CacheWithZone`
  module provides helpers that automatically compose cache keys from the algorithm,
  zone, and user key, simplifying common use cases while leveraging efficient HashMap-based
  zone lookups.\n\n```haskell\nimport Keter.RateLimiter.Cache\nimport Keter.RateLimiter.CacheWithZone\n\n--
  Create a store and cache for the Fixed Window algorithm\nfixedWindowStore <- createInMemoryStore
  @'FixedWindow\nlet cache = newCache FixedWindow fixedWindowStore\n\n-- Increment
  a counter for a user in a specific zone.\n-- The key \"rate_limiter:zoneX:userX\"
  is created automatically.\n-- The request is allowed if the count is within the
  limit.\n-- Zone lookup uses HashMap for O(1) average performance.\nisAllowed <-
  allowFixedWindowRequest cache \"zoneX\" \"userX\" 100 3600 -- 100 requests per hour\n```\n\n##
  Using the Customizable API\n\nFor more complex scenarios, you can manually construct
  cache keys and interact directly with the `Cache` module. This gives you full control
  over the key structure while still benefiting from HashMap-optimized storage.\n\n```haskell\nimport
  Keter.RateLimiter.Cache\n\n-- Use the same cache from the previous example.\nlet
  customKey = \"rate_limiter:fixed_window:logins:zoneY:userY\"\n\n-- Manually increment
  the counter for the custom key.\nnewCount <- incrementCache cache customKey 60 --
  TTL of 60 seconds\n\n-- Manually read the value.\nmVal <- readCache cache customKey
  :: IO (Maybe Int)\n```\n\n### Multi-Algorithm Configuration Example\n\n```haskell\nlet
  config = RateLimiterConfig\n      { rlZoneBy = ZoneHeader (hdr \"X-Tenant-ID\")
  \ -- Separate by tenant\n      , rlThrottles = \n          [ RLThrottle \"api_burst\"
  \    100  60   TokenBucket   IdIP              (Just 300)\n          , RLThrottle
  \"api_sustained\" 1000 3600 FixedWindow   IdIP              Nothing\n          ,
  RLThrottle \"login\"         5    300  LeakyBucket   IdIP              Nothing\n
  \         , RLThrottle \"admin\"         50   3600 SlidingWindow (IdHeader (hdr
  \"X-Admin-Key\")) Nothing\n          , RLThrottle \"lru_cache\"     1000 60   TinyLRU
  \      IdIPAndPath       Nothing\n          ]\n      }\n```\n\n## Performance Characteristics\n\nThis
  library is optimized for high-performance scenarios:\n\n- **HashMap-based zone caches**:
  O(1) average-case lookup for IP zone cache resolution\n- **HashMap-based throttle
  storage**: O(1) average-case retrieval of throttle configurations\n- **STM-based
  concurrent access**: Thread-safe operations with minimal contention\n- **Memory-efficient
  algorithms**: Automatic cleanup of expired entries across all rate limiting algorithms\n-
  **Scalable architecture**: Designed to handle thousands of concurrent requests with
  minimal overhead\n\n## Testing\n\nThis package includes an extensive test suite
  covering all supported rate-limiting algorithms, IP zone isolation, cache management,
  and HashMap-based performance optimizations.\n\nTo run the tests:\n\n```bash\ncabal
  test\n```\n\nor\n\n```bash\nstack test\n```\n\n## When to Use This Library\n\n-
  You need robust and efficient request throttling for your Haskell web application.\n-
  You want to protect your service from abuse and DoS attacks.\n- You require per-zone
  or per-user isolation of throttling policies with efficient lookups.\n- You value
  both declarative configuration and the ability to customize behavior as needed.\n-
  You need high-performance rate limiting that can scale to handle large numbers of
  concurrent requests and zones.\n\n## Migration from Earlier Versions\n\nIf you're
  upgrading from an earlier version that used the programmatic API, the declarative
  configuration approach is now recommended:\n\n**Old approach:**\n```haskell\nenv
  <- initConfig getZoneFunction\nenv' <- addThrottle env \"api\" throttleConfig\nlet
  middleware = attackMiddleware env'\n```\n\n**New recommended approach:**\n```haskell\nlet
  config = RateLimiterConfig { ... }\nmiddleware <- buildRateLimiter config\n```\n\nThe
  old programmatic API is still fully supported for advanced use cases via `buildRateLimiterWithEnv`
  and related functions.\n\n## License\n\nMIT License © 2025 Oleksandr Zhabenko\n\n##
  References\n\n- [rack-attack (Ruby)](https://github.com/rack/rack-attack)\n- [keter
  (Haskell)](https://github.com/snoyberg/keter)\n"
description-type: markdown
hash: 6acaa5d02305ef9be93c61541f47c459e5f9d062befeb88ddcac58f39f35a5c1
homepage: https://github.com/Oleksandr-Zhabenko/keter-rate-limiting-plugin
latest: 0.2.0.2
license-name: MIT
maintainer: oleksandr.zhabenko@yahoo.com
synopsis: Simple Keter rate limiting plugin.
test-bench-deps:
  HUnit: '>=0'
  QuickCheck: '>=0'
  aeson: '>=1.4'
  async: '>=2.2.4 && <2.3'
  base: '>=4 && <5'
  bytestring: '>=0.10'
  cache: '>=0.1'
  case-insensitive: '>=1.2.1.0'
  clock: '>=0.8.3 && <1'
  containers: '>=0.6'
  cookie: '>=0'
  directory: '>=1.3.4.0 && <1.4'
  filepath: '>=1.4.2 && <1.6'
  hashable: '>=1.4.2.0 && <2'
  http-types: '>=0.12.3 && <0.13'
  keter-rate-limiting-plugin: '>=0'
  network: '>=3.1.2 && <3.2 || ^>=3.2.0'
  random: '>=1.2.1 && <1.4'
  stm: '>=2.5.0 && <2.6'
  stm-containers: '>=1.2 && <2'
  tasty: '>=1.4 && <1.6'
  tasty-hunit: '>=0.10 && <0.11'
  tasty-quickcheck: '>=0'
  temporary: '>=1.3 && <1.4'
  text: '>=1.2.5 && <3.0'
  time: '>=1.9'
  unordered-containers: '>=0.2.17 && <0.3'
  wai: '>=3.2.3 && <3.3'
  wai-extra: '>=3.0.3 && <3.2'

homepage: https://github.com/cronburg/antlr-haskell#readme
changelog-type: markdown
hash: ded70560d9e37467a71dad7cb206f60626b10bb3662bdaf5415b52e9af530ef3
test-bench-deps:
  test-framework-hunit: ==0.3.*
  test-framework: ==0.8.*
  base: ! '>=4.11 && <5'
  unordered-containers: ==0.2.*
  text: ==1.2.*
  test-framework-quickcheck2: ==0.3.*
  HUnit: ==1.6.*
  containers: ==0.6.*
  antlr-haskell: -any
  mtl: ==2.2.*
  hashable: ==1.2.*
  transformers: ==0.5.*
  deepseq: ==1.4.*
  QuickCheck: ==2.11.*
  haskell-src-meta: ==0.8.*
  th-lift: ! '>=0.7.11 && <0.8'
  template-haskell: ==2.14.*
  call-stack: ==0.1.*
maintainer: karl@cs.tufts.edu
synopsis: A Haskell implementation of the ANTLR top-down parser generator
changelog: ! "# Change Log\n\n* April 14, 2018: Moved to hpack's package.yaml format
  instead of native cabal\n  file.\n\n"
basic-deps:
  base: ! '>=4.11 && <5'
  unordered-containers: ==0.2.*
  text: ==1.2.*
  containers: ==0.6.*
  mtl: ==2.2.*
  hashable: ==1.2.*
  transformers: ==0.5.*
  deepseq: ==1.4.*
  haskell-src-meta: ==0.8.*
  th-lift: ! '>=0.7.11 && <0.8'
  template-haskell: ==2.14.*
all-versions:
- 0.1.0.0
author: Karl Cronburg & Matthew Ahrens
latest: 0.1.0.0
description-type: markdown
description: ! "# antlr-haskell\nA Haskell implementation of ANTLR.\n\nIn implementing
  ANTLR we referenced the behavior of the original Java version\n(ANTLR4):\n[The definitive
  ANTLR4 Reference.](https://pragprog.com/book/tpantlr2/the-definitive-antlr-4-reference)\nHowever
  we have taken much liberty in the design of this library compared to the\nworkflow
  of the original Java version. In particular in implementing ANTLR for\nHaskell we
  have followed the following principles:\n\n- Parsing backends should be interchangeable\n
  \ - GLR, LR, SLR, LL, ALL(\\*)\n- Code should be first class and declarative\n  -
  The implementation of G4 is metacircular\n  - Regular expressions are interpreted\n-
  Implement algorithms from first principles\n  - Set notation is used in implementing
  LL and LR algorithms.\n  - Pure functional implementations of parsing algorithms
  can eventually support\n    embedding of arbitrary (including IO) actions without
  breaking the predictive\n    parsing abstraction.\n\n## Build instructions\n\nThe
  library can be built with:\n\n```\nstack build # stack version 1.9.1.1\nstack test
  antlr-haskell:simpl\n```\n\nOr with cabal-2.4.0.1 like:\n\n```\ncabal configure\ncabal
  install --only-dependencies --enable-tests\ncabal build\ncabal test sexpression\n```\n\n###
  sample grammar for ALL(\\*)\n\nS -> Ac | Ad\n\nA -> aA | b\n\n#### ALL(\\*) Input/output
  examples\n\n```haskell\n*Test.AllStarTests> parse ['a', 'b', 'c'] (NT 'S') atnEnv\n(Just
  True, Node 'S' [Node 'A' [Leaf 'a', Node 'A' [Leaf 'b']], Leaf 'c'])\n```\n\n```haskell\n*Test.AllStarTests>
  parse ['b', 'd'] (NT 'S') atnEnv\n(Just True, Node 'S' [Node 'A' [Leaf 'b'], Leaf
  'd'])\n```\n\n```haskell\n*Test.AllStarTests> parse ['a', 'a', 'a', 'a', 'b', 'c']
  (NT 'S') atnEnv\n(Just True, Node 'S' [Node 'A' [Leaf 'a', Node 'A' [Leaf 'a', Node
  'A' [Leaf 'a', Node 'A' [Leaf 'a', Node 'A' [Leaf 'b']]]]], Leaf 'c'])\n```\n\n"
license-name: BSD-3-Clause

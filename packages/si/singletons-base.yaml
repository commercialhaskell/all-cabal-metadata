homepage: http://www.github.com/goldfirere/singletons
changelog-type: markdown
hash: 168f35aa2d53f5b505b1fbfe5305436d58c8b879bf03edfdd0e27dd96612bafa
test-bench-deps:
  bytestring: '>=0.10.9'
  base: '>=4.18 && <4.19'
  tasty-golden: '>=2.2'
  text: '>=1.2'
  filepath: '>=1.3'
  process: '>=1.1'
  turtle: '>=1.5'
  singletons-base: -any
  tasty: '>=1.2'
  deepseq: '>=1.4.4'
maintainer: Ryan Scott <ryan.gl.scott@gmail.com>
synopsis: A promoted and singled version of the base library
changelog: "Changelog for the `singletons-base` project\r\n===========================================\r\n\r\n3.2
  [2023.03.12]\r\n----------------\r\n* Require building with GHC 9.6.\r\n* The kinds
  of the promoted `Error` and `ErrorWithoutStackTrace` functions have\r\n  been monomorphized
  to `Symbol`. A previous release generalized the kinds of\r\n  these arguments to
  allow passing arguments besides `Symbol`s, but this change\r\n  introduces ambiguity
  in derived code when `OverloadedString`s is enabled.\r\n  See [#89](https://github.com/goldfirere/singletons/issues/89)
  for the full\r\n  story.\r\n\r\n  If you were relying on the previous, kind-polymorphic
  behavior of `Error`, you\r\n  can instead use the new `Data.Singletons.Base.PolyError`
  module that provides\r\n  `PolyError`, a version of `Error` with a kind-polymorphic
  argument.\r\n* `Data.Ord.Singletons` and `Data.Singletons.Base.TH` no longer define
  a\r\n  `thenCmp :: Ordering -> Ordering -> Ordering` function, as this is not\r\n
  \ something that has ever existed in `base`. The existence of a `thenCmp`\r\n  function
  was solely motivated by the code generated by derived `Ord`\r\n  instances, but
  `singletons-base` now uses `(<>) @Ordering` instead.\r\n* `GHC.TypeLits.Singletons`
  now re-exports the `SChar`, `SNat`, and `SSymbol`\r\n  singleton types offered by
  `GHC.TypeLits` in `base-4.18.0.0` rather than\r\n  defining its own versions. The
  versions of `SChar`, `SNat`, and `SSymbol`\r\n  offered by `GHC.TypeLits` are nearly
  identical, minus some minor cosmetic\r\n  changes (e.g., `GHC.TypeLits` defines
  pattern synonyms for `SNat` _et a._\r\n  instead of data constructors).\r\n* `GHC.TypeLits.Singletons`
  now re-exports the `SSymbol` pattern synonym\r\n  from `GHC.TypeLits`. `GHC.TypeLits.Singletons`
  also continues to export `SSym`\r\n  for backwards compatibility.\r\n* `Prelude.Singletons`
  now re-exports `LiftA2` and `sLiftA2`, mirroring the\r\n  fact that `Prelude` now
  re-exports `liftA2` in `base-4.18.0.0`.\r\n* Provide `TestEquality` and `TestCoercion`
  instances for `SNat, `SSymbol`, and\r\n  `SChar`.\r\n\r\n3.1.1 [2022.08.23]\r\n------------------\r\n*
  Require building with GHC 9.4.\r\n\r\n3.1 [2021.10.30]\r\n----------------\r\n*
  Require building with GHC 9.2.\r\n* `singletons-base` now supports type-level `Char`s,
  a feature added in\r\n  GHC 9.2. In particular:\r\n\r\n  * Promoting and singling
  character literal expressions (e.g., `f = 'a'`) is\r\n    now supported. Promoting
  (but not singling) character patterns\r\n    (e.g., `g 'a' = ()`) is also supported.\r\n
  \ * `GHC.TypeLits.Singletons` now offers singled versions of the `ConsSymbol`,\r\n
  \   `UnconsSymbol`, `CharToNat`, and `NatToChar` type families that were\r\n    introduced
  to `GHC.TypeLits` in GHC 9.2.\r\n  * `Text.Show.Singletons` now makes use of type-level
  `Char`s, a feature added\r\n    in GHC 9.2. As a result, there is no longer any
  need for the `SChar` type\r\n    synonym, so it has been removed.\r\n  * The `PShow`
  and `SShow` instances for `Symbol` now display escape characters\r\n    properly
  rather than returning the input `Symbol` unchanged.\r\n\r\n* In GHC 9.2, `Nat` is
  now a synonym for `Natural`. As a result, the bogus\r\n  `Num`, `Eq`, `Ord`, `Enum`,
  and `Show` instances for `Nat` in\r\n  `GHC.TypeLits.Singletons` have been removed,
  as they have replaced by the\r\n  corresponding instances for `Natural`.\r\n* Add
  `Data.Functor.{Compose,Product,Sum}.Singletons`.\r\n* The types of various entities
  in `Data.Functor.Const.Singletons` and\r\n  `Data.Proxy.Singletons` have been tweaked
  slightly such that their\r\n  specificities match their term-level counterparts:\r\n\r\n
  \ ```diff\r\n  -SConst :: forall {k} {a} {b :: k} (x :: a). Sing x -> Sing ('Const
  @a @b x)\r\n  +SConst :: forall {k}  a  (b :: k) (x :: a). Sing x -> Sing ('Const
  @a @b x)\r\n\r\n  -type ConstSym0 :: forall  k  a (b :: k). a ~> Const a b\r\n  +type
  ConstSym0 :: forall {k} a (b :: k). a ~> Const a b\r\n\r\n  -type ConstSym1 :: forall
  \ k a  (b :: k). a -> Const a b\r\n  +type ConstSym1 :: forall {k} a (b :: k). a
  -> Const a b\r\n\r\n  -type ProxySym0 :: forall  k  (t :: k). Proxy t\r\n  +type
  ProxySym0 :: forall {k} (t :: k). Proxy t\r\n  ```\r\n* Define instances of `SingI1`
  and `SingI2` when possible.\r\n\r\n3.0 [2021.03.12]\r\n----------------\r\n* The
  `singletons` library has been split into three libraries:\r\n\r\n  * The new `singletons`
  library is now a minimal library that only provides\r\n    `Data.Singletons`, `Data.Singletons.Decide`,
  `Data.Singletons.Sigma`, and\r\n    `Data.Singletons.ShowSing` (if compiled with
  GHC 8.6 or later).\r\n    `singletons` now supports building GHCs back to GHC 8.0,
  as well as GHCJS.\r\n  * The `singletons-th` library defines Template Haskell functionality
  for\r\n    promoting and singling term-level definitions, but but nothing else.
  This\r\n    library continues to require the latest stable release of GHC.\r\n  *
  The `singletons-base` library defines promoted and singled versions of\r\n    definitions
  from the `base` library, including the `Prelude`. This library\r\n    continues
  to require the latest stable release of GHC.\r\n\r\n  Consult the changelogs for
  `singletons` and `singletons-th` for changes\r\n  specific to those libraries. For
  more information on this split, see the\r\n  [relevant GitHub discussion](https://github.com/goldfirere/singletons/issues/420).\r\n*
  Require building with GHC 9.0.\r\n* The modules in `singletons-base` have been renamed
  to better reflect the\r\n  modules from `base` from which they take inspiration.
  In particular, the\r\n  following module renamings have been applied:\r\n\r\n  *
  `Data.Singletons.CustomStar`            -> `Data.Singletons.Base.CustomStar`\r\n
  \ * `Data.Singletons.Prelude`               -> `Prelude.Singletons`\r\n  * `Data.Singletons.Prelude.Applicative`
  \  -> `Control.Applicative.Singletons`\r\n  * `Data.Singletons.Prelude.Bool`          ->
  `Data.Bool.Singletons`\r\n  * `Data.Singletons.Prelude.Const`         -> `Data.Functor.Const.Singletons`\r\n
  \ * `Data.Singletons.Prelude.Either`        -> `Data.Either.Singletons`\r\n  * `Data.Singletons.Prelude.Enum`
  \         -> `Data.Singletons.Base.Enum`\r\n  * `Data.Singletons.Prelude.Eq`            ->
  `Data.Eq.Singletons`\r\n  * `Data.Singletons.Prelude.Foldable`      -> `Data.Foldable.Singletons`\r\n
  \ * `Data.Singletons.Prelude.Function`      -> `Data.Function.Singletons`\r\n  *
  `Data.Singletons.Prelude.Functor`       -> `Data.Functor.Const.Singletons`\r\n  *
  `Data.Singletons.Prelude.Identity`      -> `Data.Functor.Identity.Singletons`\r\n
  \ * `Data.Singletons.Prelude.IsString`      -> `Data.String.Singletons`\r\n  * `Data.Singletons.Prelude.Ord`
  \          -> `Data.Ord.Singletons`\r\n  * `Data.Singletons.Prelude.List`          ->
  `Data.List.Singletons`\r\n  * `Data.Singletons.Prelude.List.NonEmpty` -> `Data.List.NonEmpty.Singletons`\r\n
  \ * `Data.Singletons.Prelude.Maybe`         -> `Data.Maybe.Singletons`\r\n  * `Data.Singletons.Prelude.Monad`
  \        -> `Control.Monad.Singletons`\r\n  * `Data.Singletons.Prelude.Monad.Fail`
  \   -> `Control.Monad.Fail.Singletons`\r\n  * `Data.Singletons.Prelude.Monad.Zip`
  \    -> `Control.Monad.Zip.Singletons`\r\n  * `Data.Singletons.Prelude.Monoid`        ->
  `Data.Monoid.Singletons`\r\n  * `Data.Singletons.Prelude.Proxy`         -> `Data.Proxy.Singletons`\r\n
  \ * `Data.Singletons.Prelude.Semigroup`     -> `Data.Semigroup.Singletons`\r\n  *
  `Data.Singletons.Prelude.Show`          -> `Data.Show.Singletons`\r\n  * `Data.Singletons.Prelude.Traversable`
  \  -> `Data.Traversable.Singletons`\r\n  * `Data.Singletons.Prelude.Tuple`         ->
  `Data.Tuple.Singletons`\r\n  * `Data.Singletons.Prelude.Void`          -> `Data.Void.Singletons`\r\n
  \ * `Data.Singletons.TH`                    -> `Data.Singletons.Base.TH`\r\n  *
  `Data.Singletons.TypeError`             -> `Data.Singletons.Base.TypeError`\r\n
  \ * `Data.Singletons.TypeLits`              -> `GHC.TypeLits.Singletons`\r\n  *
  `Data.Singletons.TypeRepTYPE`           -> `Data.Singletons.Base.TypeRepTYPE`\r\n\r\n
  \ Note that modules that do not correspond to any particular module in `base`\r\n
  \ now have the prefix `Data.Singletons.Base.*`. This includes\r\n  `Data.Singletons.Base.Enum`,
  a special module that exists to provide a\r\n  home for the `Succ` and `Pred` promoted
  type families that is separate from\r\n  `Prelude.Singletons` (which exports everything
  from `PEnum` _except_ `Succ`\r\n  and `Pred`). This is done in an effort to make
  importing `Prelude.Singletons`\r\n  less likely to induce name clashes with code
  that works over unary natural\r\n  numbers, which often use the names \"`Succ`\"
  and \"`Pred`\".\r\n* An effort has been made to make the API of `Prelude.Singletons`
  more closely\r\n  mirror that of the `Prelude` in `base`. As a result, `Prelude.Singletons`
  now\r\n  exports some different functions than it used to. In particular, it now\r\n
  \ exports the following:\r\n\r\n  * `Until`/`sUntil`/`UntilSym{N}`\r\n  * `type
  (++@#@$$$)`\r\n  * `type (.@#@$$$$)`\r\n  * `FlipSym3`\r\n  * `type (!!)`/`(%!!)`/`type
  (!!@#@{$})`\r\n  * `Length`/`sLength`/`LengthSym{N}`\r\n  * `DropWhile`/`sDropWhile`\r\n
  \ * `LookupSym{N}`\r\n  * `Unzip3Sym{N}`\r\n\r\n  `Prelude.Singletons` also used
  to export some things that were _not_ exported\r\n  by the `Prelude`. Accordingly,
  these exports have been removed from\r\n  `Prelude.Singletons`. They are:\r\n\r\n
  \ * `(^)`/`(%^)`/`type (^@#@{$})`. Although the `Prelude` does define a\r\n    function
  named `(^)`, it is more general than the one defined in\r\n    `singletons-base`,
  which only works on `Nat`s. Import\r\n    `GHC.TypeLits.Singletons` if you wish
  to use the `Nat`-specific versions.\r\n  * `DefaultEq`, which has no counterpart
  in the `Prelude`.\r\n    Import `Data.Eq.Singletons` if you wish to use this.\r\n
  \ * `bool_`, which has no counterpart in the `Prelude`.\r\n    Import `Data.Bool.Singletons`
  if you wish to use this.\r\n* Two previously public-facing modules—`Data.Singletons.Prelude.Base`
  and\r\n  `Data.Singletons.Prelude.Num`—have been turned into internal modules. The\r\n
  \ contents of these modules are re-exported from `Prelude.Singletons`, so that\r\n
  \ can be used instead.\r\n* Due to the `singletons` package split, the `Eq`, `Ord`,
  etc. instances for\r\n  `SomeSing` are no longer provided in the `Data.Singletons`
  module in the\r\n  `singletons` library. Instead, they are now provided in a new\r\n
  \ `Data.Singletons.Base.SomeSing` module, which defines `Eq`, `Ord`, etc.\r\n  instances
  for `SomeSing` as orphans.\r\n* The `PEq` class no longer uses `DefaultEq` as its
  default implementation for\r\n  `(==)`. `DefaultEq`, despite its name, is actually
  not a suitable\r\n  implementation for `(==)` for a good majority of singleton types\r\n
  \ (see the discussion in\r\n  [this GitHub issue](https://github.com/goldfirere/singletons/issues/457)\r\n
  \ for more information). `(==)`'s default is now defined in terms of `(/=)`,\r\n
  \ just like its term-level counterpart in the `Eq` class.\r\n* Since `base-4.15.0.0`
  now deprecates `Data.Singletons.Option` (in\r\n  anticipation of its removal in
  a future version of `base`), this library no\r\n  longer offers a singleton type
  for `Option`. Accordingly, the `option_`\r\n  function has also been removed.\r\n"
basic-deps:
  base: '>=4.18 && <4.19'
  text: '>=1.2'
  singletons: ==3.0.*
  th-desugar: '>=1.15 && <1.16'
  singletons-th: '>=3.2 && <3.3'
  pretty: -any
  template-haskell: '>=2.20 && <2.21'
all-versions:
- '3.0'
- '3.1'
- 3.1.1
- '3.2'
author: Richard Eisenberg <rae@cs.brynmawr.edu>, Jan Stolarek <jan.stolarek@p.lodz.pl>
latest: '3.2'
description-type: markdown
description: "`singletons-base`\r\n=================\r\n\r\n[![Hackage](https://img.shields.io/hackage/v/singletons-base.svg)](http://hackage.haskell.org/package/singletons-base)\r\n\r\n`singletons-base`
  uses `singletons-th` to define promoted and singled\r\nfunctions from the @base@
  library, including the `Prelude`. This library was\r\noriginally presented in\r\n[_Dependently
  Typed Programming with Singletons_](https://richarde.dev/papers/2012/singletons/paper.pdf),\r\npublished
  at the Haskell Symposium, 2012. See also\r\n[the paper published at Haskell Symposium,
  2014](https://richarde.dev/papers/2014/promotion/promotion.pdf),\r\nwhich describes
  how promotion works in greater detail.\r\n\r\nWARNING: `singletons-base` defines
  orphan instances for `Sing`, `SingKind`, etc.\r\nfor common types such as `Bool`,
  `[]`, `Maybe`, etc. If you define\r\ninstances of these types in your code, you
  will likely not be able to use\r\nthat code with `singletons-base`.\r\n\r\n`singletons-base`
  uses code that relies on bleeding-edge GHC language\r\nextensions. As such, `singletons-base`
  only supports the latest major version\r\nof GHC (currently GHC 9.6). For more information,\r\nconsult
  the `singletons`\r\n[`README`](https://github.com/goldfirere/singletons/blob/master/README.md).\r\n\r\nYou
  may also be interested in the following related libraries:\r\n\r\n* The `singletons`
  library is a small, foundational library that defines\r\n  basic singleton-related
  types and definitions.\r\n* The `singletons-th` library defines Template Haskell
  functionality that\r\n  allows _promotion_ of term-level functions to type-level
  equivalents and\r\n  _singling_ functions to dependently typed equivalents.\r\n"
license-name: BSD-3-Clause

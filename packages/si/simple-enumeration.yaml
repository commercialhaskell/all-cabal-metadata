all-versions:
- '0.1'
- '0.2'
- 0.2.1
author: Brent Yorgey
basic-deps:
  base: '>=4.7 && <5'
  integer-gmp: '>=0'
changelog: |
  # Changelog for enumeration

  ## 0.2.1 (25 June 2020)

  [Make `Data.Enumeration.Invertible.functionOf` a bit more permissive.](https://github.com/byorgey/enumeration/commit/59090f46ce01d7eda7371ba673fe54763b96c97e)

  ## 0.2 (3 July 2019)

  Added `Data.Enumeration.Invertible`.

  ## 0.1 (14 May 2019)

  Initial release.

  ## Unreleased changes
changelog-type: markdown
description: |
  ![CI](https://github.com/byorgey/enumeration/workflows/CI/badge.svg)

  # Lightweight, efficiently indexable enumerations

  This package defines a type of *enumerations*, along with combinators
  for building and manipulating them.  An enumeration is a finite or
  countably infinite sequence of values, represented as a function from
  an index to a value. Hence it is possible to work with even very large
  finite sets.  Enumerations also naturally support (uniform) random
  sampling.

  Note the goal of this package is *not* to enumerate values of Haskell
  types; there already exist many other packages to do that.  Rather,
  the goal is simply to provide an abstract framework for working with
  enumerations of any values at all.

  See the documentation for examples; see the [announcement blog
  post](https://byorgey.wordpress.com/2019/05/14/lightweight-efficiently-sampleable-enumerations-in-haskell/)
  for additional examples and discussion.
description-type: markdown
hash: 8625b269c1650d3dd0e3887351c153049f4369853e0d525219e07480ea004b9f
homepage: https://github.com/byorgey/enumeration#readme
latest: 0.2.1
license-name: BSD-3-Clause
maintainer: byorgey@gmail.com
synopsis: Finite or countably infinite sequences of values.
test-bench-deps:
  base: '>=4.7 && <5'
  doctest: '>=0.8'

homepage: https://github.com/rasheedja/simplex-method#readme
changelog-type: markdown
hash: 308cb0b129e5475df1250e6666c58571f2161276d0b9f29ed8171524ba67591c
test-bench-deps:
  base: '>=4.7 && <5'
  simplex-method: -any
maintainer: jrasheed178@gmail.com
synopsis: Implementation of the two-phase simplex method in exact rational arithmetic
changelog: |
  # Changelog for simplex-haskell

  ## Unreleased changes
basic-deps:
  base: '>=4.7 && <5'
all-versions:
- 0.1.0.0
author: Junaid Rasheed
latest: 0.1.0.0
description-type: markdown
description: "# simplex-method\n\n`simplex-method` is a Haskell library that implements
  the two-phase [simplex method](https://en.wikipedia.org/wiki/Simplex_algorithm)
  in exact rational arithmetic.\n\n## Quick Overview\n\nThe `Linear.Simplex.Simplex`
  module contain both phases of the simplex method.\n\n### Phase One\n\nPhase one
  is implemented by `findFeasibleSolution`:\n\n```haskell\nfindFeasibleSolution ::
  [PolyConstraint] -> Maybe (DictionaryForm, [Integer], [Integer], Integer)\n```\n\n`findFeasibleSolution`
  takes a list of `PolyConstraint`s.\nThe `PolyConstraint` type, as well as other
  custom types required by this library, are defined in the `Linear.Simplex.Types`
  module.\n`PolyConstraint` is defined as:\n\n```haskell\ndata PolyConstraint =\n
  \ LEQ VarConstMap Rational      | \n  GEQ VarConstMap Rational      | \n  EQ  VarConstMap
  Rational       deriving (Show, Eq);\n```\n\nAnd `VarConstMap` is defined as:\n\n```haskell\ntype
  VarConstMap = [(Integer, Rational)]\n```\n\nA `VarConstMap` is treated as a list
  of `Integer` variables mapped to their `Rational` coefficients, with an implicit
  `+` between each element in the list.\nFor example: `[(1, 2), (2, (-3)), (1, 3)]`
  is equivalent to `(2x1 + (-3x2) + 3x1)`.\n\nAnd a `PolyConstraint` is an inequality/equality
  where the LHS is a `VarConstMap` and the RHS is a `Rational`.\nFor example: `LEQ
  [(1, 2), (2, (-3)), (1, 3)] 60` is equivalent to `(2x1 + (-3x2) + 3x1) <= 60`.\n\nPassing
  a `[PolyConstraint]` to `findFeasibleSolution` will return a feasible solution if
  it exists as well as a list of slack variables, artificial variables, and a variable
  that can be safely used to represent the objective for phase two.\n`Nothing` is
  returned if the given `[PolyConstraint]` is infeasible.\nThe feasible system is
  returned as the type `DictionaryForm`:\n\n```haskell\ntype DictionaryForm = [(Integer,
  VarConstMap)]\n```\n\n`DictionaryForm` can be thought of as a list of equations,
  where the `Integer` represents a basic variable on the LHS that is equal to the
  RHS represented as a `VarConstMap`. In this `VarConstMap`, the `Integer` -1 is used
  internally to represent a `Rational` number.\n\n### Phase Two\n\n`optimizeFeasibleSystem`
  performs phase two of the simplex method, and has the type:\n\n```haskell\ndata
  ObjectiveFunction = Max VarConstMap | Min VarConstMap deriving (Show, Eq)\n\noptimizeFeasibleSystem
  :: ObjectiveFunction -> DictionaryForm -> [Integer] -> [Integer] -> Integer -> Maybe
  (Integer, [(Integer, Rational)])\n```\n\nWe first pass an `ObjectiveFunction`.\nThen
  we give a feasible system in `DictionaryForm`, a list of slack variables, a list
  of artificial variables, and a variable to represent the objective.\n`optimizeFeasibleSystem`
  Maximizes/Minimizes the linear equation represented as a `VarConstMap` in the given
  `ObjectiveFunction`.\nThe first item of the returned pair is the `Integer` variable
  representing the objective.\nThe second item is a list of `Integer` variables mapped
  to their optimized values.\nIf a variable is not in this list, the variable is equal
  to 0.\n\n### Two-Phase Simplex\n`twoPhaseSimplex` performs both phases of the simplex
  method.\nIt has the type:\n```haskell\ntwoPhaseSimplex :: ObjectiveFunction -> [PolyConstraint]
  -> Maybe (Integer, [(Integer, Rational)])\n```\nThe return type is the same as that
  of `optimizeFeasibleSystem`\n\n### Extracting Results\nThe result of the objective
  function is present in the return type of both `twoPhaseSimplex` and `optimizeFeasibleSystem`,
  but this can be difficult to grok in systems with many variables, so the following
  function will extract the value of the objective function for you.\n\n```haskell\nextractObjectiveValue
  :: Maybe (Integer, [(Integer, Rational)]) -> Maybe Rational\n```\n\nThere are similar
  functions for `DictionaryForm` as well as other custom types in the module `Linear.Simplex.Util`.\n\n##
  Usage notes\n\nYou must only use positive `Integer` variables in a `VarConstMap`.\nThis
  implementation assumes that the user only provides positive `Integer` variables;
  the `Integer` -1, for example, is sometimes used to represent a `Rational` number.
  \n\n## Example\n\n```haskell\nexampleFunction :: (ObjectiveFunction, [PolyConstraint])\nexampleFunction
  =\n  (\n    Max [(1, 3), (2, 5)],      -- 3x1 + 5x2\n    [\n      LEQ [(1, 3), (2,
  1)] 15, -- 3x1 + x2 <= 15 \n      LEQ [(1, 1), (2, 1)] 7,  -- x1 + x2 <= 7\n      LEQ
  [(2, 1)] 4,          -- x2 <= 4\n      LEQ [(1, -1), (2, 2)] 6  -- -x1 + 2x2 <=
  6\n    ]\n  )\n\ntwoPhaseSimplex (fst exampleFunction) (snd exampleFunction)\n```\n\nThe
  result of the call above is:\n```haskell\nJust\n  (7, -- Integer representing objective
  function\n  [\n    (7,29 % 1), -- Value for variable 7, so max(3x1 + 5x2) = 29.\n
  \   (1,3 % 1),  -- Value for variable 1, so x1 = 3 \n    (2,4 % 1)   -- Value for
  variable 2, so x2 = 4\n  ]\n  )\n```\n\nThere are many more examples in test/TestFunctions.hs.\nYou
  may use `prettyShowVarConstMap`, `prettyShowPolyConstraint`, and `prettyShowObjectiveFunction`
  to convert these tests into a more human-readable format.\n\n## Issues\n\nPlease
  share any bugs you find [here](https://github.com/rasheedja/simplex-haskell/issues).\n"
license-name: BSD-3-Clause

homepage: ''
changelog-type: ''
hash: 8413d0102d0c34c9781bea28098b517cbece629a7396859c675e822361372a41
test-bench-deps: {}
maintainer: maths@manuelbaerenz.de
synopsis: Functional Reactive Programming with type-level clocks
changelog: ''
basic-deps:
  free: ! '>=4.12 && <4.13'
  dunai: ==0.1.1.*
  base: ! '>=4.8 && <5'
  time: ! '>=1.6 && <1.7'
  containers: ! '>=0.5 && <0.6'
  rhine: -any
  transformers: ! '>=0.4 && <0.6'
all-versions:
- '0.1.0.0'
- '0.1.1.0'
author: Manuel BÃ¤renz
latest: '0.1.1.0'
description-type: markdown
description: ! "# README\n--------\n\nRhine is a library for synchronous and asynchronous
  Functional Reactive Programming (FRP).\nIt separates the aspects of clocking, scheduling
  and resampling\nfrom each other, and ensures clock-safety on the type level.\n\nComplex
  reactive programs often process data at different rates.\nFor example, games, GUIs
  and media applications\nmay output audio and video signals, or receive\nuser input
  at unpredictable times.\nCoordinating these different rates is a hard problem in
  general.\nIf not enough care is taken, buffer underruns and overflows, space and
  time leaks,\naccidental synchronisation of independent sub-systems,\nand concurrency
  issues such as dead-locks may all occur.\n\nRhine tackles these problems by annotating\nthe
  signal processing components with clocks,\nwhich hold the information when data
  will be\ninput, processed and output.\nDifferent components of the signal network\nwill
  become active at different times, or work\nat different rates. If components running
  under different clocks need to communicate, it\nhas to be decided when each component
  be-\ncomes active (\"scheduling\"), and how data is\ntransferred between the different
  rates (\"resampling\").\nRhine separates all these aspects from each\nother, and
  from the individual signal processing of each subsystem.\nIt offers a flexible API
  to all of them and implements several\nreusable standard solutions. In the places\nwhere
  these aspects need to intertwine, typing\nconstraints on clocks come into effect,
  enforcing clock safety.\n\nA typical example, which can be run as `cabal run Demonstration`,\nwould
  be:\n\n```\n  -- | Create a simple message containing the time stamp since program
  start,\n  --   for each tick of the clock.\n  --   Since 'createMessage' works for
  arbitrary clocks (and doesn't need further input data),\n  --   it is a 'Behaviour'.\n
  \ --   @td@ is the 'TimeDomain' of any clock used to sample,\n  --   and it needs
  to be constrained in order for time differences\n  --   to have a 'Show' instance.\n
  \ createMessage\n    :: (Monad m, Show (Diff td))\n    => String\n    -> Behaviour
  m td String\n  createMessage str\n    =   timeInfoOf sinceStart >-> arr show\n    >->
  arr ((\"Clock \" ++ str ++ \" has ticked at: \") ++)\n\n  -- | Output a message
  /every second/ (= every 1000 milliseconds).\n  --   Let us assume we want to assure
  that 'printEverySecond'\n  --   is only called every second,\n  --   then we constrain
  its type signature with the clock @Millisecond 1000@.\n  printEverySecond :: Show
  a => SyncSF IO (Millisecond 1000) a ()\n  printEverySecond = arrMSync print\n\n
  \ -- | Specialise 'createMessage' to a specific clock.\n  ms500 :: SyncSF IO (Millisecond
  500) () String\n  ms500 = createMessage \"500 MS\"\n\n\n  ms1200 :: SyncSF IO (Millisecond
  1200) () String\n  ms1200 = createMessage \"1200 MS\"\n\n  -- | Create messages
  every 500 ms and every 1200 ms,\n  --   collecting all of them in a list,\n  --
  \  which is output every second.\n  main :: IO ()\n  main = flow $\n    ms500 @@
  waitClock **@ concurrently @** ms1200 @@ waitClock\n    >-- collect -@- concurrently
  -->\n    printEverySecond @@ waitClock\n\n  -- | Uncomment the following for a type
  error (the clocks don't match):\n\n  -- typeError = ms500 >>> printEverySecond\n```\n"
license-name: BSD3

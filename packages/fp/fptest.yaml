homepage: https://github.com/jrp2014/fptest
changelog-type: ''
hash: be1af78917225e4ebeec7cb54e8dab3a8b7486371a37296525c084f2191d83c8
test-bench-deps:
  test-framework-hunit: ==0.3.*
  hlint: -any
  test-framework: ==0.8.*
  base: ==4.7.*
  parsec3-numbers: ==0.0.*
  test-framework-quickcheck2: ==0.3.*
  process: -any
  parsec: ==3.1.*
  doctest: -any
  HUnit: ==1.2.*
  regex-compat: -any
  QuickCheck: ==2.7.*
  Glob: -any
maintainer: jrp@dial.pipex.com
synopsis: IEEE754r floating point conformance tests
changelog: ''
basic-deps:
  test-framework-hunit: ==0.3.*
  test-framework: ==0.8.*
  base: ==4.7.*
  parsec3-numbers: ==0.0.*
  test-framework-quickcheck2: ==0.3.*
  parsec: ==3.1.*
  HUnit: ==1.2.*
  QuickCheck: ==2.7.*
all-versions:
- '0.2.1.0'
author: John Pavel
latest: '0.2.1.0'
description-type: markdown
description: ! '# IEEE754 conformance tests for Haskell


  This project contains floating point conformance tests in Haskell.


  There are two sets of tests so far:


  ##QTrial##

  **QTrial** is the floating point benchmark described in *IEEE Standard 754 for Binary
  Floating-Point Arithmetic* by Prof. W. Kahan [Download link](http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF)


  You should just be able to `cabal run` from the main directory or `runhaskell QTrial.hs`
  from `src`.


  An extract from the result is:



  ```

  Principal Tests:


  Results for Float:

  r = 4098.0 produces 12.0 and 12.0 sig. bits

  r = 4098.25 fails: root 0.99989897 isn''t at least 1

  r = 4097.004 produces 12.0 and 11.999298 sig. bits

  r =1.6777218e7 is too big for qtrail

  r =1.6777218e7 is too big for qtrail

  r =1.677722e7 is too big for qtrail

  r =9.4906264e7 is too big for qtrail

  r =9.4906264e7 is too big for qtrail

  r =2.6843546e8 is too big for qtrail

  r =2.6843546e8 is too big for qtrail

  r =2.6843546e8 is too big for qtrail

  r =2.6843546e8 is too big for qtrail

  r =2.6843546e8 is too big for qtrail

  r =4.2949673e9 is too big for qtrail

  r =4.2949673e9 is too big for qtrail

  Worst accuracy is 11.999298 sig. bits



  Results for Double:

  r = 4098.0 produces Infinity and Infinity sig. bits

  r = 4098.25 produces Infinity and 53.0 sig. bits

  r = 4097.00390625 produces Infinity and 53.451178091541244 sig. bits

  r = 1.6777218e7 produces Infinity and Infinity sig. bits

  r = 1.677721825e7 produces Infinity and 75.0 sig. bits

  r = 1.6777219e7 produces Infinity and 71.0 sig. bits

  r = 9.4906267e7 produces 26.499999994288153 and 26.499999986733027 sig. bits

  r = 9.490626725e7 fails: root 0.999999995635551 isn''t at least 1

  r = 2.684354505e8 produces 28.0 and 27.999999919383132 sig. bits

  r = 2.684354515e8 produces 28.0 and 27.99999993013205 sig. bits

  r = 2.68435458e8 produces 28.0 and 28.0 sig. bits

  r = 2.6843545825e8 produces 28.0 and 28.00000000268723 sig. bits

  r = 2.6843545700000006e8 produces 28.0 and 27.999999989251084 sig. bits

  r = 4.294967298e9 produces 32.0 and 32.0 sig. bits

  r = 4.29496729825e9 produces 32.0 and 32.00000000016795 sig. bits

  Worst accuracy is 26.499999986733027 sig. bits

  ```


  This is fine for the Float cases, but the test illustrates an issue with the Double
  case.


  ##FPTest##


  ** FPTest is being refactored so that it can be run in cabal **


  **FPTest** runs a sequence of floating point test vectors generated by IBM''s [FPGen
  Floating-Point Test Generator](https://www.research.ibm.com/haifa/projects/verification/fpgen/).


  This is done in two ways:


  * By interpreting the tests

  * By translating the tests into a Haskell HUnit test suite script that can just
  be run using `runhaskell`


  The IBM test vectors are contained in the `test_suite` directory, but you will want
  to get the latest version from the link above.


  You will, most likely, want the binary tests unless you have a decimal machine.  Only
  32-bit float tests are provided (not 64-bit double ones).



  The syntax of the test vectors can be found [here](https://www.research.ibm.com/haifa/projects/verification/fpgen/syntax.txt)
  or in Chapter 4 of [Floating-Point Test-Suite for IEEE](https://www.research.ibm.com/haifa/projects/verification/fpgen/papers/ieee-test-suite-v2.pdf)


  The test suite that IBM supplies actually stretches the spec somewhat.  For example,
  it also uses lower case versions of some specification elements.

'
license-name: BSD3

all-versions:
- 0.2.1.0
- 0.2.3.0
author: John Pavel
basic-deps:
  HUnit: '>=1.2 && <1.7'
  QuickCheck: '>=2.7 && <3'
  base: '>=4.7 && <5'
  parsec: '>=3.1 && <3.2'
  parsec3-numbers: '>=0.0 && <0.2'
  test-framework: '>=0.8 && <0.9'
  test-framework-hunit: '>=0.3 && <0.4'
  test-framework-quickcheck2: '>=0.3 && <0.4'
changelog: ''
changelog-type: ''
description: "# IEEE754 conformance tests for Haskell\n\nThis project contains IEEE754R
  floating point conformance tests in Haskell.\n\nThere are two sets of tests so far:\n\n##
  QTrial ##\n\n**QTrial** is the floating point benchmark described in *IEEE Standard
  754 for Binary Floating-Point Arithmetic* by Prof. W. Kahan [Download link](http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF)\n\nYou
  should just be able to `cabal run qtrial` from the main directory or `runhaskell
  QTrial.hs` from `src`.\n\nAn extract from the result is:\n\n\n```\nPrincipal Tests:\n\nResults
  for Float:\nr = 4098.0 produces 12.0 and 12.0 sig. bits\nr = 4098.25 fails: root
  0.99989897 isn't at least 1\nr = 4097.004 produces 12.0 and 11.999298 sig. bits\nr
  =1.6777218e7 is too big for qtrail\nr =1.6777218e7 is too big for qtrail\nr =1.677722e7
  is too big for qtrail\nr =9.4906264e7 is too big for qtrail\nr =9.4906264e7 is too
  big for qtrail\nr =2.6843546e8 is too big for qtrail\nr =2.6843546e8 is too big
  for qtrail\nr =2.6843546e8 is too big for qtrail\nr =2.6843546e8 is too big for
  qtrail\nr =2.6843546e8 is too big for qtrail\nr =4.2949673e9 is too big for qtrail\nr
  =4.2949673e9 is too big for qtrail\nWorst accuracy is 11.999298 sig. bits\n\n\nResults
  for Double:\nr = 4098.0 produces Infinity and Infinity sig. bits\nr = 4098.25 produces
  Infinity and 53.0 sig. bits\nr = 4097.00390625 produces Infinity and 53.451178091541244
  sig. bits\nr = 1.6777218e7 produces Infinity and Infinity sig. bits\nr = 1.677721825e7
  produces Infinity and 75.0 sig. bits\nr = 1.6777219e7 produces Infinity and 71.0
  sig. bits\nr = 9.4906267e7 produces 26.499999994288153 and 26.499999986733027 sig.
  bits\nr = 9.490626725e7 fails: root 0.999999995635551 isn't at least 1\nr = 2.684354505e8
  produces 28.0 and 27.999999919383132 sig. bits\nr = 2.684354515e8 produces 28.0
  and 27.99999993013205 sig. bits\nr = 2.68435458e8 produces 28.0 and 28.0 sig. bits\nr
  = 2.6843545825e8 produces 28.0 and 28.00000000268723 sig. bits\nr = 2.6843545700000006e8
  produces 28.0 and 27.999999989251084 sig. bits\nr = 4.294967298e9 produces 32.0
  and 32.0 sig. bits\nr = 4.29496729825e9 produces 32.0 and 32.00000000016795 sig.
  bits\nWorst accuracy is 26.499999986733027 sig. bits\n```\n\nThis is fine for the
  Float cases, but the test illustrates an issue with the Double case\nthat is the
  subject of [this ticket](https://ghc.haskell.org/trac/ghc/ticket/9534).\n\n## FPTest
  ##\n\n**FPTest** runs a sequence of floating point test vectors generated by\nIBM's
  [FPGen Floating-Point Test Generator](https://www.research.ibm.com/haifa/projects/verification/fpgen/),
  which\nis a commercial product.\n\nThis is done in two ways:\n\n* By interpreting
  the tests\n* By translating the tests into a Haskell HUnit test suite script that
  can just be run using `runhaskell`\n\nThe IBM test vectors are contained in the
  `test_suite` directory,\nbut you will want to get the latest version from the link
  above.\n\nYou will, most likely, want the binary tests unless you have a decimal
  machine.\nOnly 32-bit float test vectors are provided (not 64-bit double ones).\n\nThe
  syntax of the test vectors can be found [here](https://www.research.ibm.com/haifa/projects/verification/fpgen/syntax.txt)
  or in Chapter 4 of [Floating-Point Test-Suite for IEEE](https://www.research.ibm.com/haifa/projects/verification/fpgen/papers/ieee-test-suite-v2.pdf)\n\nNB:
  The test vectors do not use the normal syntax for hexadecimal floating point literals.
  \ The literals represent normal numbers\nas '1.fPsigned exponent' and subnormal
  numbers by '0.fPsigned exponent'. The significand 'f' represents the 23-bit significand\nfor
  Floats and the 52-bit significand for Doubles.  Since a hexadecimal digit represents
  4 bits, the question arises of where\nthe spare bit for Floats should sit.  In the
  standard representation (ie, set out in IEEE754 and implemented in the C 'dtoa'\nand
  \ 'strtod' libraries, the spare 0 sits to the right (so the 23-bit significand 'f'
  is *left* justified in the 24-bit\nhexadecimal representation).  The IBM representation
  *right* justifies the 23 bits of significand in the 24-bit hexadecimal\nrepresentation;
  the first hexadecimal digit of the significand represents 3 bits.\nThe IBM representation
  also has a fixed length format, including trailing zeros.\n\nSome test vectors also
  uses lower case versions of certain specification elements.\n\n### Results ###\n\nThe
  tests correctly identify some issues with GHC 7.8.3 that are being fixed or looked
  at:\n* [signum and abs are incorrect](https://ghc.haskell.org/trac/ghc/ticket/7858)\n*
  [the implementations of max / min are incorrect](https://ghc.haskell.org/trac/ghc/ticket/9530)
  \n\n### Caveats ###\n\nA fair proportion of the test vector types is not implemented,\nbecause
  there is no corresponding Haskell operation.  For example,\nHaskell has no direct
  support for\n\n* signalling NaNs\n* the reporting of underflow or other exceptions\n*
  rounding mode specification\n* non-standard operations such as fused multiply add
  or operations that are applicable only to decimal floating point\n\nThere is not
  a great deal of point in testing some of these facilities from Haskell; where they
  are\naccessible it would just be testing an underlying C library, which it might
  be better to\nto directly.\n\n\n## Other tests ##\n\n* [FBench](https://www.fourmilab.ch/fbench/)
  by John Walker, founder of AutoDeck, Inc \n is a complete optical design raytracing
  algorithm, shorn of its user interface.\n The benchmark, which has been going since
  1980 has been ported from C to a variety of languages,\n including [Haskell](http://www.fourmilab.ch/fourmilog/archives/2012-09/001395.html)\n"
description-type: markdown
hash: c995a751bb0ee8d37517af89efcdb5c4bb3d915bbf8a28584e54d0c0c60aa745
homepage: https://github.com/jrp2014/fptest
latest: 0.2.3.0
license-name: BSD-3-Clause
maintainer: jrp@dial.pipex.com
synopsis: IEEE754r floating point conformance tests
test-bench-deps:
  Glob: '>=0'
  HUnit: '>=1.2 && <1.7'
  QuickCheck: '>=2.7 && <3'
  base: '>=4.7 && <5'
  doctest: '>=0'
  hlint: '>=0'
  parsec: '>=3.1 && <3.2'
  parsec3-numbers: '>=0.0 && <0.2'
  process: '>=0'
  regex-compat: '>=0'
  test-framework: '>=0.8 && <0.9'
  test-framework-hunit: '>=0.3 && <0.4'
  test-framework-quickcheck2: '>=0.3 && <0.4'

homepage: ''
changelog-type: markdown
hash: e0428a41e297e0c5394f367a5b65e9d386321f89eaee1f9b08fe51e171ad4ca5
test-bench-deps: {}
maintainer: dan.firth@homtopic.tech
synopsis: Type-level computation for composite using first-class-families.
changelog: |
  # Changelog for fcf-composite

  ## v0.1.0.0

  * Add `ToComposite` and `FromComposite` FCF expressions.
  * Add `Union`, `Difference` and `Intersection` FCF expressions.
basic-deps:
  first-class-families: '>=0.8.0.0 && <0.9'
  fcf-containers: '>=0.5.0 && <0.7'
  base: '>=4.7 && <5'
  composite-base: '>=0.7.0.0 && <0.8'
all-versions:
- 0.1.0.0
author: Daniel Firth
latest: 0.1.0.0
description-type: markdown
description: |
  # fcf-composite

  Fcf support for [composite](https://hackage.haskell.org/package/composite-base) records. This gives bidirection between a composite
  style `[s :-> a]` and `MapC s a` from
  [fcf-containers](https://hackage.haskell.org/package/fcf-containers).

  Using this we can compute record types via the Map
  [operations](https://hackage.haskell.org/package/fcf-containers-0.6.0/docs/Fcf-Data-MapC.html)
  in Fcf.

  ```{.haskell}
  data Difference :: [Type] -> [Type] -> Exp [Type]

  type instance Eval (Difference xs ys) = Eval (ToComposite =<< Fcf.Data.MapC.Difference (Eval (FromComposite xs)) (Eval (FromComposite ys)))

  type A = ["a" :-> Int, "b" :-> String, "c" :-> ()]

  type B = ["a" :-> Int, "c" :-> ()]

  myRec :: Record (Eval (Difference A B))
  myRec = "foo" :*: RNil -- checks!
  ```

  Note: Since `ToComposite` and `FromComposite` use `ToList` and `FromList` from
  Fcf.Data.MapC, then the fields will always be returned in alphabetical order
  according to the symbol name, so you may need to use `rcast`.
license-name: MIT

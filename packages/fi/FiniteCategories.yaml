homepage: https://gitlab.utc.fr/gsabbagh/FiniteCategories
changelog-type: markdown
hash: 5b952548d1d802adc9a74b2408a706cf5a6997a1be2bec25bc89e2d78124fc11
test-bench-deps:
  FiniteCategories: -any
  base: '>=4.16.0.0 && <4.19'
  text: '>=1.0 && <2.2'
  filepath: '>=1.4.100.1 && <1.5'
  WeakSets: '>=1.4.0.1 && <1.4.0.2'
  containers: '>=0.6.6.0 && <0.7'
  random: '>=1.2.1 && <1.3'
  directory: '>=1.3.8.1 && <1.4'
maintainer: guillaumesabbagh@protonmail.com
synopsis: Finite categories and usual categorical constructions on them.
changelog: "# Revision history for FiniteCategories\r\n\r\n## 0.1.0.0 -- 2022-03-21\r\n\r\n*
  First version.\r\n\r\n## 0.2.0.0 -- 2023-03-13\r\n\r\n* Separation between Category
  and FiniteCategory typeclasses, new architecture for the project, Kan extensions,
  etc.\r\n\r\n## 0.3.0.0 -- 2023-09-29\r\n\r\n* Splitting the package with FiniteCategoriesGraphViz.
  Colimit of composition graphs.\r\n\r\n### 0.3.0.1 -- 2023-09-29\r\n\r\n* Broadening
  range of text bounds.\r\n\r\n### 0.4.0.0 -- 2023-09-29\r\n\r\n* Broadening range
  of base bounds."
basic-deps:
  base: '>=4.16.0.0 && <4.19'
  text: '>=1.0 && <2.2'
  filepath: '>=1.4.100.1 && <1.5'
  WeakSets: '>=1.4.0.1 && <1.4.0.2'
  containers: '>=0.6.6.0 && <0.7'
  random: '>=1.2.1 && <1.3'
  directory: '>=1.3.8.1 && <1.4'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
- 0.3.0.1
- 0.4.0.0
author: Guillaume Sabbagh
latest: 0.4.0.0
description-type: markdown
description: "# FiniteCategories\r\n\r\nThe goal of this project is to represent small
  finite categories in order to make usual constructions automatically on them (e.g.
  (co)limits, (co)completion, adjunctions, kan extensions, etc.)\r\n\r\n## Table of
  Contents\r\n1. [General Info](#general-info)\r\n2. [Technologies](#technologies)\r\n3.
  [Installation](#installation)\r\n4. [Collaboration](#collaboration)\r\n5. [Examples](#examples)\r\n\r\n##
  General Info\r\n\r\nThis package provides tools to create categories at the value
  level. This is different from the __Hask__ category where types are objects in a
  category with an infinite number of objects and arrows, here we construct categories
  where objects and arrows are arbitrary values so that we can change categories during
  runtime. Each category implements two functions following the category structure
  axioms : `ar` which returns arrows between two objects of the category and `identity`
  which returns the identity of an object. Each `FiniteCategory` implements an additional
  function : `ob` which returns the objects of the category. Thanks to theses functions,
  we can construct automatically all the usual constructions on the categories (limits
  and colimits, adjunctions, Yoneda embedding, etc.) Functors are different from usual
  `Functor` typeclass, we store functors as mapping between objects and morphisms
  of two categories which respect the category structure.\r\n\r\nThis package is also
  different from the package `data-category` because we can enumerate objects and
  arrows in a category.  This allows us to construct limit, colimits, adjunctions,
  etc. automatically for arbitrary finite categories. On the other hand, we loose
  typecheck at compilation time which ensures that composition is sound in __Hask__,
  composition in our package might lead to an error raised during runtime.\r\n\r\n##
  See also\r\n\r\nSee the package `FiniteCategoriesGraphViz` to export the categories
  as images created with GraphViz.\r\n\r\n## Installation\r\n\r\nSimply run ```cabal
  install FiniteCategories```\r\n\r\n## Collaboration\r\n\r\nAll contributions are
  appreciated! Contact me by email for any information.\r\n\r\n## Usage\r\n\r\nIf
  you want to construct small categories by hand, see `Math.FiniteCategories.CompositionGraph`
  which allows to construct the free category generated by a graph quotiented by a
  congruence relation on paths of the graph. The function `readCGFile` allows to construct
  a `CompositionGraph` from a simple file, for example :\r\n\r\n```\r\nA -f-> B -g->
  D = A -h-> C -i-> D\r\n```\r\n\r\nis a square category where the two diagonals are
  identified.\r\n\r\nTo construct a functor, see `Diagram` in `Math.FiniteCategories.FunctorCategory`.
  You can also use `readCGDFile` from `Math.FiniteCategories.CompositionGraph` :\r\n\r\n```\r\n<SRC>\r\nX\r\nY
  -1-> Z\r\n</SRC>\r\n<TGT>\r\nA -f-> B -g-> D = A -h-> C -i-> D\r\n</TGT>\r\n\r\nX
  => A\r\nY -1-> Z => B -g-> D\r\n```\r\n\r\nSee `Math.Categories.ConeCategory`, `Math.Functors.Adjunction`
  and `Math.Functors.KanExtension` for useful functions to construct usual categorical
  constructions.\r\n\r\n\r\n\r\n\r\n\r\n## Examples\r\n\r\nA category exported with
  graphviz looks like the following image : \r\n\r\n![Category](https://gitlab.utc.fr/gsabbagh/FiniteCategories/-/raw/master/Images/ExampleCategory.png)\r\n\r\nA
  diagram on this category selecting two objects C and D is represented next :\r\n\r\n![Diagram](https://gitlab.utc.fr/gsabbagh/FiniteCategories/-/raw/master/Images/ExampleDiagram.png)\r\n\r\nA
  cone on this diagram follows, the apex of the cone is in green, its legs are in
  yellow and the diagram is in blue :\r\n\r\n![Cone](https://gitlab.utc.fr/gsabbagh/FiniteCategories/-/raw/master/Images/ExampleCone.png)\r\n\r\nThe
  limiting cone is represented below, it is the product of the two objects C and D.\r\n\r\n![Limit](https://gitlab.utc.fr/gsabbagh/FiniteCategories/-/raw/master/Images/ExampleLimit.png)\r\n"
license-name: GPL-3.0-or-later

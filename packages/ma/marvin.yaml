homepage: https://marvin.readthedocs.io
changelog-type: markdown
hash: 12c02ecb7675dc41d059956371c62f10470ae4a1c8a9306fdf878509ee539221
test-bench-deps: {}
maintainer: dev@justus.science
synopsis: A modular chat bot
changelog: ! '# 0.1.1 - 17.02.2017


  - Added changelog

  - Added version bounds

'
basic-deps:
  warp: ==3.*
  http-client: ==0.4.*
  bytestring: ==0.10.*
  wai: ==3.*
  haskeline: ! '>=0.7 && <1'
  stm: ! '>=2.0 && <2.5'
  base: ! '>=4.7 && <5'
  time: ==1.*
  configurator: ==0.3.*
  unordered-containers: ==0.2.*
  text: ! '>=1.0 && <1.3'
  monad-loops: ==0.4.*
  monad-control: ==1.*
  filepath: ==1.4.*
  websockets: ==0.9.*
  lifted-base: ==0.2.*
  wreq: ==0.4.*
  lens: ==4.*
  marvin: ==0.1.*
  text-icu: ! '>=0.6 && <0.8'
  warp-tls: ==3.*
  http-client-tls: ! '>=0.2 && <0.4'
  wuss: ! '>=1.0 && <1.2'
  network-uri: ! '>=2.6.1.0 && <2.7'
  mtl: ! '>=2.2 && <3'
  marvin-interpolate: ==1.0.*
  lifted-async: ! '>=0.8 && <0.10'
  hashable: ! '>=1.0 && <1.3'
  transformers-base: ==0.4.*
  mustache: ! '>=0.2 && <2.2'
  monad-logger: ==0.3.*
  optparse-applicative: ! '>=0.11 && <1'
  random: ! '>=1.0 && <1.2'
  deepseq: ==1.*
  http-types: ! '>=0.8 && <1.0'
  aeson: ! '>=0.11 && <1.2'
  mono-traversable: ==1.0.*
  vector: ! '>=0.11 && <1'
  directory: ! '>=1.2.6.2 && <1.3'
all-versions:
- '0.0.1'
- '0.0.2'
- '0.0.3'
- '0.0.4'
- '0.0.5'
- '0.0.6'
- '0.0.7'
- '0.0.8'
- '0.0.9'
- '0.1.0'
- '0.1.1'
author: JustusAdam
latest: '0.1.1'
description-type: markdown
description: ! "# Marvin, the paranoid bot (âº stage)\n\n[![Travis](https://travis-ci.org/JustusAdam/marvin.svg?branch=master)](https://travis-ci.org/JustusAdam/marvin)\n[![Hackage](https://img.shields.io/hackage/v/marvin.svg)](http://hackage.haskell.org/package/marvin)\n\nMarvin
  is an attempt to combine the ease of use of [hubot](https://hubot.github.com) with
  the typesafety and easy syntax of Haskell and the performance gains from compiled
  languages.\n\nThe in-depth documentation can be found on readthedocs https://marvin.readthedocs.org
  \n\n\n## Installation\n\nYou can get a release version of marvin on [Hackage](https://hackage.haskell.org/package/marvin).\n\nHowever
  this library is still a very early stage so you might want to get updates quicker.
  \nYou can do so by using [stack](https://docs.haskellstack.org) and adding a recent
  commit of this repository to your `stack.yaml` file.\nStack will take care of downloading
  and building it for you.\n\n\n## TLDR\n\n```Haskell\nmodule MyScript where\n\nimport
  Marvin.Prelude\n\nscript :: IsAdapter a => ScriptInit a\nscript = defineScript \"my-script\"
  $ do\n    hear \"sudo (.+)\" $ do\n        match <- getMatch\n\n        reply $(isL
  \"All right, i'll do #{match !! 1}\")\n    \n    respond \"open the (\\\\w+) door\"
  $ do\n        match <- getMatch\n        let door = match !! 1\n        openDoor
  door\n        send $(isL \"Door #{door} opened\")\n    \n    respond \"what is in
  file (\\\\w+)\\\\??\" $ do\n        match <- getMatch \n        let file = match
  !! 1\n\n        contents <- liftIO $ readFile file\n\n        send contents\n```\n\n##
  How to Marvin\n\nThe best way to use Marvin is very much taken from hubot.\n\nA
  Marvin instance composes of a collection of scripts which are reactions or actions
  on certain messages posted in slack.\nEach script is a Haskell source file. \nThey
  get compiled into one single static binary, which acts depending on the adapter
  used, in the case of the slack real time messaging adapter for instance it opens
  a websocket to the slack server from which it recieves events as they happen in
  your chat application.\n\n### Defining scripts\n\nDefining scripts is very easy.\n\nCreate
  a new Haskell source file like \"MyScript.hs\" and import marvins prelude `Marvin.Prelude`.\nThis
  provides you with all the tools you need to interact with marvin.\n\nNow you can
  start to define your script with `defineScript` which produces a script initializer.\nIf
  you wish to use marvins automatic script discovery your script initializer should
  be named `script`  \n\n```Haskell\nmodule MyScript where\n\nimport Marvin.Prelude\n\nscript
  :: IsAdapter a => ScriptInit a\nscript = defineScript \"my-script\" $ do\n    ...\n```\n\nThe
  script id, \"my-script\" in this case, is the name used for this script when repoting
  loggin messages as well as the key for this scripts configuration, see [configuration](#configuration).\n\nIn
  the define script block you can have marvin react to certain events with `hear`
  and `respond`.\nMore information on those in the section [reacting](#reacting)\n\nFinally
  after you have defined your scripts you have to tie them together.\nYou can do this
  [manually](#wiring-manually) or you can have marvin create the boilerplate code
  for you.\n\nTo do this simply place a main file (this is the file you'll be compiling
  later) in the same directory the scripts are placed in.\nLeave the file empty except
  for this line at the top `{-# OPTIONS_GHC -F -pgmF marvin-pp #-}`.\nWhen you compile
  the file marvin will look for any other \".hs\" and \".lhs\" files in the same directory,
  import them and define a server which runs with the `script` from each.\nIf you
  wish to hide a file from the auto discovery either place it in a different directory
  or prefix it with \".\" or \"_\".\n\n### Reacting\n\nThere are two main ways (currently)
  of reacting to events, `hear` and `respond`.\n\n`hear` is for matching any incoming
  message. The provided regex is tried against all incomming messages, if one matches
  the handler is called.\n\n`repond` only triggers on message which have the bot name,
  or a case variation thereof as the first word.\n\n\nOnce a handler has triggered
  it may perform arbitrary IO actions (using `liftIO`) and send messages using `reply`
  and `send`.\n\n- `reply` addresses the message to the original sender of the message
  that triggered the handler.\n- `send` sends it to the same Channel the tiggering
  message weas sent to.\n- `messageChannel` sends a message to a Channel specified
  by the user.\n\n### Configuration\n\nConfiguration for marvin is written in the
  [configurator](https://hackage.haskell.org/package/configurator) syntax.\n\nConfiguration
  pertaining to the bot is stored under the \"bot\" key.\n\n```\nbot {\n    name =
  \"my-bot\"\n    logging = \"INFO\"\n}\n```\n\nBy default each script has access
  to a configuration stored under `script.<script-id>`.\nAnd of course these scripts
  can have nested config groups.\n\n```\nbot {\n    name = \"my-bot\"\n}\n\nscript
  {\n    script-1 {\n        some-string = \"foo\"\n        some-int = 1337\n        bome-bool
  = true\n    }\n    script 2 {\n        nested-group {\n            val = false\n
  \       }\n        name = \"Trump\"\n        capable = false\n    }\n}\n```\n\nConfiguration
  pertaining to the adapter is stored under `adapter.<adapter-name>`\n\n```\nbot {\n
  \   name = \"my-bot\"\n    logging = \"INFO\"\n}\nadapter {\n    slack-rtm {\n        token
  = \"eofk\"\n    }\n}\n``` \n\n### Wiring manually\n\nHow Marvin interacts with your
  chat program depends on the used Adapter.\nFor instance the currently default `slack-rtm`
  adapter creates a (client) websocket connection with the slack API and listens to
  the events there.\nOther adapters may require to set up a server. \n\n### Utilities\n\nAll
  these utilities are already available to you if you import `Marvin.Prelude`.\n\n####
  Regex\n\nImplemented in `Marvin.Util.Regex`, documentation coming soon.\n\n####
  Mutable variables\n\nImplementation started in `Marvin.Util.Mutable`, documentation
  coming soon.\n\n#### Format strings\n\nMarvins Prelude exposes the [marvin-interpolate](https://github.com/JustusAdam/marvin-interpolate)
  library, which enables the user to write CoffeeScript/Scala like interpolated Strings
  using Template Haskell.\n\n```haskell\n\nstr = let x = \"Hello\" in $(isL \"#{x}
  World!\")\n-- \"Hello World\"\n```\n\n#### JSON\n\nExposed in `Marvin.Util.JSON`
  documentation coming soon. Until then refer to [aeson](https://hackage.haskell.org/package/aeson).\n\n####
  Logging\n\nMarvin comes with a logging facility built in. \n`Marvin.Util.Logging`
  expose the logging facility. \nSeveral functions are available, depending on the
  urgency of your message, like `logError`, `logInfo` and `logWarn`.\nLogging messages
  made this way are automatically formatted and tagged with the scripts that reported
  them.\n\nBy default all logging messages with higher priority `NOTICE` or higher
  are shown. \nUsing the command line parameter `verbose` also adds `INFO` messages
  and `debug` adds `DEBUG` messages.\nYou can select the exact logging level in your
  config file (see also [configuration](#configuration)).\n \n\n#### Random\n\nImplemented
  in `Marvin.Util.Random`, documentation coming soon.\n\n#### HTTP\n\nCoarsely implemented
  in `Marvin.Util.HTTP`, documentation coming soon.\n"
license-name: BSD3

homepage: ''
changelog-type: markdown
hash: 34a269f12bede32615a8d69881fb46b8fa814d2ec91b54637adb40f83da66775
test-bench-deps:
  base: -any
  hspec: -any
  containers: -any
  matroid: -any
  QuickCheck: -any
maintainer: Immanuel Albrecht <mail@immanuel-albrecht.de>
synopsis: matroid (combinatorial pre-geometries) library
changelog: |
  # Revision history for matroid

  ## 0.0.0.1 -- 2021-02-28

  * Added greedy algorithm.

  ## 0.0.0  -- 2021-01-06

  * First version. Released on an unsuspecting world.
basic-deps:
  base: '>=4 && <5'
  hspec: '>=2.7.5 && <2.8'
  containers: '>=0.6.2 && <0.7'
  QuickCheck: '>=2.14.2 && <2.15'
all-versions:
- 0.0.0
- 0.0.0.1
author: Immanuel Albrecht <mail@immanuel-albrecht.de>
latest: 0.0.0.1
description-type: markdown
description: "# matroid\n\nThis library provides typeclasses and basic functionality
  that revolves around the combinatorial structures\nknown as matroids.\n\n## Language
  features\n\n```\n{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}\n```\n\n##
  Installation\n\nDownload and extract the sources to a directory of your liking.
  Then run\n```\ncabal install --lib matroid\n```\n\n\n## Usage\n\n### Quick demo\n\nFor
  instance, download and extract the sources to a directory of your liking, then run\n```\ncabal
  repl\n```\n\nThen you get a prompt where you can start hacking. Let's see the groundset
  of the implementation\nof the famous M(K_4) matroid, and mess around a bit:\n```\n*Data.Matroid>
  groundset $ mK 4\nfromList [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]\n*Data.Matroid>
  import qualified Data.Set as S\n*Data.Matroid S> rk (mK 4) $ S.fromList [(1,2),(1,3),(2,3)]\n2\n*Data.Matroid
  S> basis (mK 4) $ S.fromList [(1,2),(1,3),(2,3)]\nfromList [(1,2),(1,3)]\n*Data.Matroid
  S> cl (mK 4) $ S.fromList [(1,2),(1,3),(2,3)]\nfromList [(1,2),(1,3),(2,3)]\n*Data.Matroid
  S> rk (dual $ mK 4) $ S.fromList [(1,2),(1,3),(2,3)]\n3\n*Data.Matroid S> coRk (dual
  $ mK 4) $ S.fromList [(1,2),(1,3),(2,3)]\n2\n```\nOf course, we got U_{4,2}, too:\n```\n*Data.Matroid
  S> uniform 4 2\nuniformOn (fromList [1,2,3,4]) 2\n```\n\n### User-defined matroids\n\nThis
  library is most useful for implementing your own matroid types and make them an
  instance of ```Matroid m a```.\nHere, the type ```m``` corresponds to a class of
  matroids, and the type ```a``` corresponds to the type of the matroid\nelements.
  Thus a matroid always has a type of the form ```m a```. This makes sense because
  matroids arise in a lot of very\ndifferent situations, and it is important to be
  able to distinguish a graphic matroid where the edges are of type ```(Int,Int)```,
  \nfrom a linear matroid with the same edge type. In the graphic case, we would interpret
  the matroid elements as edges in a graph,\nin the latter we might interpret the
  elements as vectors over a finite field.\n\nIn ```Data.Matroid.Ops``` we define
  a parametrized type ```AMatroid a``` that represents the notion of an abstract matroid,\nwhich
  hides away the internals of the different matroid types from us, but also provides
  us with a way to accept any matroid\nwith elements of a given type as a parameter.
  You can convert any ```Matroid m a``` to ```AMatroid a``` with the ```abstract```\nmethod.
  The instance definiton ```Matroid AMatroid a``` can be found in the ```Data.Matroid.Typeclass```
  module. We would\nlike to mention that the default implementations of the various
  methods offered by the matroid typeclass ```Matroid m a``` \nare bounced back to
  ```AMatroid a``` where they are defined.\n\nWriting a new ```Matroid m a``` instance
  is quite simple: you have to implement the ```groundset :: (m a) -> Set a``` routine\nwhich
  returns the set of all elements of your matroid, and at least one of the following
  methods:\n\na) ```rk :: (m a) -> Set a -> Int``` which should return the rank of
  a set of matroid elements,\nb) ```indep :: (m a) -> Set a -> Bool``` which should
  determine whether a set of matroid elements is independent,\nc) ```basis :: (m a)
  -> Set a -> Set a``` which should determine an independent subset with maximal cardinality.\n\nOnce
  you have done this, all the other methods are provided by the library. It is advisable
  to also use one or more\nof the test suites provided in the ```Test.Matroid``` module
  to verify that your implementation is indeed a matroid.\nThe ```matroidSuite```
  also needs your matroid instance to be an instance of ```Show (m a)```.\n\nHere
  is a minimal implementation of a rank 3 uniform matroid on the characters 'a' to
  'g':\n```\n{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}\n\nimport Data.Matroid\nimport
  qualified Data.Set as S\nimport Test.Hspec\nimport Test.QuickCheck\nimport Test.Matroid\n\ndata
  MyMatroid a = MyMatroid\n\ninstance Matroid MyMatroid Char where\n    groundset
  m = S.fromList \"abcdefg\"\n    rk MyMatroid x = min 3 $ length x\n\ninstance Show
  (MyMatroid Char) where\n    show MyMatroid = \"MyMatroid\"\n\n{- end of minimal
  implementation -}\n\nm :: MyMatroid Char\nm = MyMatroid\n\nmain :: IO ()\nmain =
  hspec (matroidSuite $ return m)\n```\n## How to run the library tests\n\nDownload
  and extract the sources to a directory of your liking. Then run\n```\nstack clean
  && stack build --test --coverage\n```\n\n## Browse the docs\n\nDownload and extract
  the sources to a directory of your liking. Then run\n```\nstack haddock --open .\n```\n\n##
  Contributing\n\nUpload your changes and create a pull request on the [github repo](https://github.com/alb-i/h-matroid)."
license-name: BSD-3-Clause

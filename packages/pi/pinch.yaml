homepage: https://github.com/abhinav/pinch#readme
changelog-type: markdown
hash: 0da4940423cdb4c2536aabf0df5979eff0e137132b3686405c3758418fd08589
test-bench-deps:
  pinch: -any
  bytestring: ! '>=0.10 && <0.11'
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  hspec: ! '>=2.0'
  text: ! '>=1.2 && <1.3'
  semigroups: ! '>=0.18 && <0.19'
  containers: ! '>=0.5 && <0.7'
  QuickCheck: ! '>=2.5'
  vector: ! '>=0.10 && <0.13'
maintainer: mail@abhinavg.net
synopsis: An alternative implementation of Thrift for Haskell.
changelog: |+
  0.3.5.0 (2019-09-25)
  ====================

  -   Introduce decodeWithLeftovers for receiving unparsed portions
      of the provided bytestring.

  0.3.4.1 (2019-02-20)
  ====================

  -   Bounds bumps

  0.3.4.0 (2018-11-11)
  ====================

  -   Support GHC 8.6 (#20).

  0.3.3.0 (2018-06-15)
  ====================

  -   Add Semigroup instances for some internal types. This improves GHC 8.4
      compatibility.


  0.3.2.0 (2017-06-03)
  ====================

  -   Compact: Fixed bug which caused incorrect encoding of doubles.


  0.3.1.0 (2017-05-13)
  ====================

  -   Support GHC 8.2 (#14).


  0.3.0.2 (2017-01-12)
  ====================

  -   Bump upper bound for vector (#11).


  0.3.0.1 (2016-07-12)
  ====================

  -   Compile on 32-bit systems.

  0.3.0.0 (2016-06-02)
  ====================

  -   Add support for the Thrift Compact Protocol (#2).
  -   Add support for returning the leftover ByteString when parsing Thrift
      payloads (#3).

  0.2.0.2 (2016-07-12)
  ====================

  -   Compile on 32-bit systems.

  0.2.0.1 (2016-05-23)
  ====================

  -   Build with GHC 8.

  0.2.0.0 (2015-12-27)
  ====================

  Breaking changes:

  -   `unpinch` no longer returns `Either String a`. Instead it returns a
      `Parser a`.
  -   `Protocol.serialize*` methods no longer produce a `ByteString.Builder` and
      the serialized length. Instead, they produce a custom `Builder` type.

  Other changes:

  -   Improve deserialization performance significantly by getting rid of
      unnecessary calls to `Data.Typeable.{eqT, cast}`.
  -   Improve serialization performance by allocating the output buffer in one go
      rather than using `ByteString.Builder`.
  -   Improve serialization and deserialization performance further by changing
      the intermediate representation of lists, sets, and maps.

  0.1.0.2 (2015-12-27)
  ====================

  -   Loosen `vector` version constraint.

  0.1.0.1 (2015-11-15)
  ====================

  -   Fixed recursion in C pre-processor expansion. This can break the build on
      some systems.

  0.1.0.0 (2015-11-15)
  ====================

  -   Initial release.

basic-deps:
  bytestring: ! '>=0.10 && <0.11'
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=1.2 && <1.3'
  semigroups: ! '>=0.18 && <0.19'
  array: ! '>=0.5'
  containers: ! '>=0.5 && <0.7'
  ghc-prim: -any
  hashable: ! '>=1.2 && <1.3'
  deepseq: ! '>=1.3 && <1.5'
  vector: ! '>=0.10 && <0.13'
all-versions:
- 0.1.0.1
- 0.1.0.2
- 0.2.0.0
- 0.2.0.1
- 0.2.0.2
- 0.3.0.0
- 0.3.0.1
- 0.3.0.2
- 0.3.1.0
- 0.3.2.0
- 0.3.3.0
- 0.3.4.0
- 0.3.4.1
- 0.3.5.0
author: Abhinav Gupta
latest: 0.3.5.0
description-type: markdown
description: |2+

  [![build-status]](https://travis-ci.org/abhinav/pinch)

  `pinch` aims to provide an alternative implementation of Apache Thrift for
  Haskell. The `pinch` library itself acts only as a serialization library. Types
  specify their Thrift encoding by defining instances of the `Pinchable`
  typeclass, which may be done by hand or automatically with the use of Generics.

    [build-status]: https://travis-ci.org/abhinav/pinch.svg?branch=master

  Haddock documentation for this package is avilable on [Hackage] and [here].

    [Hackage]: http://hackage.haskell.org/package/pinch
    [here]: http://abhinavg.net/pinch/

  Overview
  --------

  Types which can be encoded into Thrift payloads implement the `Pinchable`
  typeclass.

  Given the Thrift struct,

  ```thrift
  struct Person {
      1: required string name
      2: optional i64 dateOfBirth
  }
  ```

  You can write a `Pinchable` instance like so,

  ```haskell
  data Person = Person { name :: Text, dateOfBirth :: Maybe Int64 }
      deriving (Eq)

  instance Pinchable Person where
      type Tag Person = TStruct
      -- The Tag tells the system that this represents a struct.

      pinch (Person name dateOfBirth) =
          struct [1 .= name, 2 ?= dateOfBirth]

      unpinch value =
          Person <$> value .:  1
                 <*> value .:? 2
  ```

  Better yet, you can drive an instance automatically.

  ```haskell
  {-# LANGUAGE DeriveGeneric, DataKinds #-}
  import GHC.Generics (Generic)

  data Person = Person
      { name        :: Field 1 Text
      , dateOfBirth :: Field 2 (Maybe Int64)
      } deriving (Eq, Generic)

  instance Pinchable Person
  ```

  Objects can be serialized and deserialized using the `encode` and `decode`
  methods. These methods accept a `Protocol` as an argument.

  ```haskell
  decode binaryProtocol (encode binaryProtocol person) == person
  ```

  For more information, check the documentation and the examples.

  Supported Protocols
  -------------------

  The following Thrift protocols are supported:

  -   Binary
  -   Compact

  Caveats
  -------

  -   There is no code generation or template haskell support yet so types from
      the Thrift file will have to be translated by hand.

license-name: BSD-3-Clause

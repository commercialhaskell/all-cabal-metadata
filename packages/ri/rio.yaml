all-versions:
- 0.0.0.0
- 0.0.1.0
- 0.0.2.0
- 0.0.3.0
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
- 0.1.3.0
- 0.1.4.0
- 0.1.5.0
- 0.1.6.0
- 0.1.7.0
- 0.1.8.0
- 0.1.9.2
- 0.1.10.0
- 0.1.11.0
- 0.1.12.0
- 0.1.13.0
- 0.1.14.0
- 0.1.14.1
- 0.1.15.0
- 0.1.15.1
- 0.1.16.0
- 0.1.17.0
- 0.1.18.0
- 0.1.19.0
- 0.1.20.0
- 0.1.21.0
- 0.1.22.0
- 0.1.23.0
author: Michael Snoyman
basic-deps:
  base: '>=4.12 && <10'
  bytestring: '>=0'
  containers: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  exceptions: '>=0'
  filepath: '>=0'
  hashable: '>=0'
  microlens: '>=0.4.2.0'
  microlens-mtl: '>=0'
  mtl: '>=0'
  primitive: '>=0'
  process: '>=0'
  text: '>=0'
  time: '>=0'
  typed-process: '>=0.2.5.0'
  unix: '>=0'
  unliftio: '>=0.2.14'
  unliftio-core: '>=0'
  unordered-containers: '>=0'
  vector: '>=0'
changelog: "# Changelog for rio\r\n\r\n## 0.1.23.0\r\n\r\n* Support GHC 9.14\r\n*
  Re-export type operator `~`, from `base-4.17.0.0`\r\n\r\n## 0.1.22.0\r\n\r\n* Expose
  `augmentPathMap'`\r\n\r\n## 0.1.21.0\r\n\r\n* Fix minor bug in `augmentPathMap`
  on windows wrt [#234](https://github.com/commercialhaskell/rio/issues/234) not adhering
  to case-insensitive semantics\r\n\r\n## 0.1.20.0\r\n\r\n* Export `UnliftIO.QSem`
  and `UnliftIO.QSemN` in `RIO`\r\n\r\n## 0.1.19.0\r\n\r\n* Expose `fromLeft` and
  `fromRight`\r\n\r\n## 0.1.18.0\r\n\r\n* Add colours to the `LogOption` constructor
  [#222](https://github.com/commercialhaskell/rio/pull/222)\r\n\r\n## 0.1.17.0\r\n\r\n*
  Expose `Bifunctor`, `Bifoldable`, and `Bitraversable`.\r\n* The `first` and `second`
  functions exported by `RIO` formerly originated from\r\n  `Control.Arrow`. They
  now come from `Bifunctor`.\r\n\r\n## 0.1.16.0\r\n\r\n* Expand the number of `microlens`
  functions exported by the RIO prelude.\r\n* Add new module `RIO.Lens` which provides
  the rest of `microlens`.\r\n\r\n## 0.1.15.1\r\n\r\n* Replace `canonicalizePath`
  with `makeAbsolute` [#217](https://github.com/commercialhaskell/rio/issues/217)\r\n\r\n##
  0.1.15.0\r\n\r\n* Include source in log messages\r\n\r\n## 0.1.14.1\r\n\r\n* Support
  `unliftio-core` 0.2\r\n\r\n## 0.1.14.0\r\n\r\n* Addition of `mkSimpleApp`\r\n* Addition
  of `lookupEnvFromContext`\r\n\r\n## 0.1.13.0\r\n\r\n* Add `withLazyFileUtf8`\r\n*
  Add `mapRIO`\r\n* Add generic logger\r\n* Add `exeExtensions` and improve `findExecutable`
  on Windows [#205](https://github.com/commercialhaskell/rio/issues/205)\r\n\r\n##
  0.1.12.0\r\n\r\n* Add `logFormat` and `setLogFormat` for `LogOptions`.\r\n\r\n##
  0.1.11.0\r\n\r\n* Replace atomic and durable file writing functions with the ones
  from `unliftio`, see [#167](https://github.com/commercialhaskell/rio/pull/167)\r\n\r\n##
  0.1.10.0\r\n\r\n* Relax a bunch of `RIO.File` functions from `MonadUnliftIO` to
  `MonadIO`\r\n* Custom `Monoid` instance for `Utf8Builder` that matches semantics
  of the\r\n  derived one, but doesn't break list fusion\r\n* Qualified import recommendations
  for `*.Partial`, `*.Unchecked`, `*.Unsafe`\r\n* Re-export `Data.Ord.Down` from `RIO.Prelude`\r\n*
  Addition of `RIO.NonEmpty` module\r\n* Addition of `RIO.NonEmpty.Partial` module\r\n*
  Export `NonEmpty` type and its constructor `(:|)` from RIO.Prelude.Types\r\n* Fix
  handling of non-ASCII characters in `logSticky`\r\n* Deprecate `withProcess` and
  `withProcess_`, add `withProcessWait`, `withProcessWait_`, `withProcessTerm`, and
  `withProcessTerm_`\r\n\r\n## 0.1.9.2\r\n\r\n* Bring back re-export of `Monad.fail`
  from `RIO.Prelude`.\r\n\r\n## 0.1.9.1\r\n\r\n* Remove accidental reexport of `Control.Applicative.empty`
  introduced in the previous release.\r\n* Functions from `Data.Data.Data` class are
  brought to the re-export list as well.\r\n\r\n## 0.1.9.0\r\n\r\n* Add `Prelude.Exit`
  to export lifted versions of the exit functions from `System.Exit`.\r\n* Re-export
  the `Control.Monad.State.State` and `Control.Monad.State.StateT` types and related
  computation functions in `RIO.State`.\r\n* Re-export the `Control.Monad.Writer.Writer`
  and `Control.Monad.Writer.WriterT` types and related computation functions in `RIO.Writer`.\r\n*
  Re-export `pred`, `succ` in `RIO.Partial`.\r\n* Add `Semigroup` and `Monoid` instances
  for `RIO`\r\n* Add the `Deque` double-ended queue data type\r\n* Re-export `Data.Map.Strict.toAscList`
  and `Data.Map.Strict.toDescList` from `RIO.Map`.\r\n* Re-export `Data.Sequence.Seq`
  from `RIO`.\r\n* Addition of `RIO.Prelude` module\r\n* Addition of `RIO.Prelude.Types`
  module\r\n* Re-export `zipWith` and `runST` from `RIO.Prelude`\r\n* Re-export `Exception`,
  `MonadFail`, `Typeable` and `ST` from `RIO.Prelude.Types`\r\n* Switch to `MonadFail.fail`
  from `Monad.fail` and re-exported it from `RIO.Prelude`\r\n\r\n\r\n## 0.1.8.0\r\n\r\n*
  Re-export `Control.Monad.State.modify`, `Control.Monad.State.modify'` and `Control.Monad.State.gets`
  in `RIO.State`\r\n\r\n## 0.1.7.0\r\n\r\n* Addition of `textDisplay` to `Display`
  class.\r\n\r\n## 0.1.6.0\r\n\r\n* Changed `logUseColor` to default to `False` on
  Windows, even when verbose and on the terminal\r\n* Add `RIO.File` module which
  offers a family of file handling functions\r\n  (`withBinaryFileDurable`, `withBinaryFileDurableAtomic`,
  among others.) with\r\n  better durability and atomicity guarantees\r\n\r\n## 0.1.5.0\r\n\r\n*
  Re-export `Numeric.Natural.Natural` [#119](https://github.com/commercialhaskell/rio/issues/119)\r\n*
  Re-export `Data.Functor.<&>` from GHC 8.4+, falling back local definition for `base
  < 4.11` [#117](https://github.com/commercialhaskell/rio/issues/117)\r\n* Re-export
  `Data.Proxy.Proxy(..)`\r\n* Re-export `fromEnum` from RIO, export `toEnum`, `read`
  and `fromJust` from RIO.Partial\r\n* Add `noLogging` function to skip logging on
  specific sub-routines\r\n* Re-export `Control.Category.>>>`\r\n\r\n## 0.1.4.0\r\n\r\n*
  Add `Const` and `Identity`\r\n* Add `Reader` and `runReader`\r\n* Add instances
  for `MonadWriter` and `MonadState` to `RIO` via mutable reference [#103](https://github.com/commercialhaskell/rio/issues/103)\r\n\r\n##
  0.1.3.0\r\n\r\n* Add `newLogFunc` function to create `LogFunc` records outside of
  a callback scope\r\n* Allow dynamic reloading of `logMinLevel` and `logVerboseFormat`
  for the `LogOptions` record\r\n* Add `foldMapM`\r\n* Add `headMaybe`, `lastMaybe`,
  `tailMaybe`, `initMaybe`, `maximumMaybe`, `minimumMaybe`,\r\n  `maximumByMaybe`,
  `minimumByMaybe` functions to `RIO.List` module (issue #82)\r\n* Move non-partial
  functions `scanr1` and `scanl1` from `RIO.List.Partial` to `RIO.List` (issue #82)\r\n*
  Add `SimpleApp` and `runSimpleApp`\r\n* Add `asIO`\r\n\r\n## 0.1.2.0\r\n\r\n* Allow
  setting usage of code location in the log output\r\n\r\n## 0.1.1.0\r\n\r\n* Move
  some accidentally included partial functions\r\n\r\n## 0.1.0.0\r\n\r\n* Initial
  stable release\r\n\r\n## 0.0\r\n\r\n__NOTE__ All releases beginning with 0.0 are
  considered\r\nexperimental. Caveat emptor!\r\n"
changelog-type: markdown
description: "# The rio library\r\n\r\n*A standard library for Haskell*\r\n\r\n![Rio](https://github.com/user-attachments/assets/20e95e85-0124-47ad-98ea-c211e9114b9b)\r\n\r\n![Tests](https://github.com/commercialhaskell/rio/workflows/Tests/badge.svg)\r\n\r\nThe
  goal of the `rio` library is to make it easier to adopt Haskell\r\nfor writing production
  software.  It is intended as a cross between:\r\n\r\n* Collection of well-designed,
  trusted libraries\r\n* Useful `Prelude` replacement\r\n* A set of best practices
  for writing production quality Haskell code\r\n\r\nThis repository contains the
  `rio` library and other related\r\nlibraries, such as `rio-orphans`. There is a
  [tutorial on how to use\r\n`rio`](https://haskell.fpcomplete.com/library/rio) available
  on FP\r\nComplete's Haskell site. This README discusses project goals and\r\ncollects
  other reference information.\r\n\r\n## Standard library\r\n\r\nWhile GHC ships with
  a `base` library, as well as a number of other\r\ncommon packages like `directory`
  and `transformers`, there are large\r\ngaps in functionality provided by these libraries.
  This choice for a\r\nmore minimalistic `base` is by design, but it leads to some\r\nunfortunate
  consequences:\r\n\r\n* For a given task, it's often unclear which is the right library
  to\r\n  use\r\n* When writing libraries, there is often concern about adding\r\n
  \ dependencies to any libraries outside of `base`, due to creating a\r\n  heavier
  dependency footprint\r\n* By avoiding adding dependencies, many libraries end up\r\n
  \ reimplementing the same functionality, often with incompatible types\r\n  and
  type classes, leading to difficulty using libraries together\r\n\r\nThis library
  attempts to define a standard library for Haskell. One\r\nimmediate response may
  be [XKCD #927](https://xkcd.com/927/):\r\n\r\n![XKCD Standards](https://imgs.xkcd.com/comics/standards.png)\r\n\r\nTo
  counter that effect, this library takes a specific approach: __it\r\nreuses existing,
  commonly used libraries__. Instead of defining an\r\nincompatible `Map` type, for
  instance, we standardize on the commonly\r\nused one from the `containers` library
  and reexport it from this\r\nlibrary.\r\n\r\nThis library attempts to define a set
  of libraries as \"standard,\"\r\nmeaning they are recommended for use, and should
  be encouraged as\r\ndependencies for other libraries. It does this by depending
  on these\r\nlibraries itself, and reexporting their types and functions for easy\r\nuse.\r\n\r\nBeyond
  the ecosystem effects we hope to achieve, this will hopefully\r\nmake the user story
  much easier. For a new user or team trying to get\r\nstarted, there is an easy library
  to depend upon for a large\r\npercentage of common functionality.\r\n\r\nSee the
  dependencies of this package to see the list of packages\r\nconsidered standard.
  The primary interfaces of each of these packages\r\nis exposed from this library
  via a `RIO.`-prefixed module reexporting\r\nits interface.\r\n\r\n## Prelude replacement\r\n\r\nThe
  `RIO` module works as a prelude replacement, providing more\r\nfunctionality and
  types out of the box than the standard prelude (such\r\nas common data types like
  `ByteString` and `Text`), as well as\r\nremoving common \"gotchas\", like partial
  functions and lazy I/O. The\r\nguiding principle here is:\r\n\r\n* If something
  is safe to use in general and has no expected naming\r\n  conflicts, expose it from
  `RIO`\r\n* If something should not always be used, or has naming conflicts,\r\n
  \ expose it from another module in the `RIO.` hierarchy.\r\n\r\n## Best practices\r\n\r\nBelow
  is a set of best practices we recommend following. You're\r\nobviously free to take
  any, all, or none of this. Over time, these\r\nwill probably develop into much more
  extensive docs. Some of these\r\ndesign decisions will be catered to by choices
  in the `rio` library.\r\n\r\nFor Haskellers looking for a set of best practices
  to follow: you've\r\ncome to the right place!\r\n\r\n### Import practices\r\n\r\nThis
  library is intended to provide a fully loaded set of basic\r\nfunctionality. You
  should:\r\n\r\n* Enable the `NoImplicitPrelude` language extension (see below)\r\n*
  Add `import RIO` as your replacement prelude in all modules\r\n* Use the `RIO.`-prefixed
  modules as necessary, imported using the\r\n  recommended qualified names in the
  modules themselves. For example,\r\n  `import qualified RIO.ByteString as B`. See
  the module documentation\r\n  for more information.\r\n* Infix operators may be
  imported unqualified, with a separate import\r\n  line if necessary. For example,
  `import RIO.Map ((?!), (\\\\))`. Do\r\n  this only if your module contains no overlapping
  infix names,\r\n  regardless of qualification. For instance, if you are importing
  both\r\n  `RIO.Map.\\\\` and `RIO.List.\\\\` do not import either one unqualified.\r\n\r\nIn
  the future, we may have editor integration or external tooling to\r\nhelp with import
  management.\r\n\r\n### Language extensions\r\n\r\nVery few projects these days use
  bare-bones Haskell 98\r\nor 2010. Instead, almost all codebases enable some set
  of additional\r\nlanguage extensions. Below is a list of extensions we recommend
  as a\r\ngood default, in that these are:\r\n\r\n* Well accepted in the community\r\n*
  Cause little to no code breakage versus leaving them off\r\n* Are generally considered
  safe\r\n\r\nOur recommended defaults are:\r\n\r\n```\r\nAutoDeriveTypeable\r\nBangPatterns\r\nBinaryLiterals\r\nConstraintKinds\r\nDataKinds\r\nDefaultSignatures\r\nDeriveDataTypeable\r\nDeriveFoldable\r\nDeriveFunctor\r\nDeriveGeneric\r\nDeriveTraversable\r\nDoAndIfThenElse\r\nEmptyDataDecls\r\nExistentialQuantification\r\nFlexibleContexts\r\nFlexibleInstances\r\nFunctionalDependencies\r\nGADTs\r\nGeneralizedNewtypeDeriving\r\nInstanceSigs\r\nKindSignatures\r\nLambdaCase\r\nMonadFailDesugaring\r\nMultiParamTypeClasses\r\nMultiWayIf\r\nNamedFieldPuns\r\nNoImplicitPrelude\r\nOverloadedStrings\r\nPartialTypeSignatures\r\nPatternGuards\r\nPolyKinds\r\nRankNTypes\r\nRecordWildCards\r\nScopedTypeVariables\r\nStandaloneDeriving\r\nTupleSections\r\nTypeFamilies\r\nTypeSynonymInstances\r\nViewPatterns\r\n```\r\n\r\nNotes
  on some surprising choices:\r\n\r\n* `RecordWildCards` is really up for debate.
  It's widely used, but\r\n  rightfully considered by many to be dangerous. Open question
  about\r\n  what we do with it.\r\n* Despite the fact that `OverloadedStrings` can
  break existing code,\r\n  we recommend its usage to encourage avoidance of the `String`
  data\r\n  type. Also, for new code, the risk of breakage is much lower.\r\n* `MonadFailDesugaring`
  helps prevent partial pattern matches in your\r\n  code, see [#85](https://github.com/commercialhaskell/rio/issues/85)\r\n\r\nDue
  to concerns about tooling usage (see [issue\r\n#9](https://github.com/commercialhaskell/rio/issues/9)),
  we recommend\r\nadding these extensions on-demand in your individual source modules\r\ninstead
  of including them in your `package.yaml` or `.cabal` files.\r\n\r\nThere are other
  language extensions which are perfectly fine to use as\r\nwell, but are not recommended
  to be turned on by default:\r\n\r\n```\r\nCPP\r\nTemplateHaskell\r\nForeignFunctionInterface\r\nMagicHash\r\nUnliftedFFITypes\r\nTypeOperators\r\nUnboxedTuples\r\nPackageImports\r\nQuasiQuotes\r\nDeriveAnyClass\r\nDeriveLift\r\nStaticPointers\r\n```\r\n\r\n###
  GHC Options\r\n\r\nWe recommend using these GHC compiler warning flags on all projects,
  to catch\r\nproblems that might otherwise go overlooked:\r\n\r\n* `-Wall`\r\n* `-Wcompat`\r\n*
  `-Widentities`\r\n* `-Wincomplete-record-updates`\r\n* `-Wincomplete-uni-patterns`\r\n*
  `-Wpartial-fields`\r\n* `-Wredundant-constraints`\r\n\r\nYou may add them per file,
  or to your `package.yaml`, or pass them on\r\nthe command line when running ghc.
  We include these in the project\r\ntemplate's `package.yaml` file.\r\n\r\nFor code
  targeting production use, you should also use the flag that turns all\r\nwarnings
  into errors, to force you to resolve the warnings before you ship your\r\ncode:\r\n\r\n*
  `-Werror`\r\n\r\nFurther reading:\r\n\r\n* Alexis King explains why these are a
  good idea in [her blog\r\npost](https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/)\r\nwhich
  was the original inspiration for this section.\r\n* Max Tagher gives an in-depth
  overview of these flags, and more,\r\n[in his blog post](https://medium.com/mercury-bank/enable-all-the-warnings-a0517bc081c3).\r\n\r\n###
  Monads\r\n\r\nA primary design choice you'll need to make in your code is how to\r\nstructure
  your monads. There are many options out there, with various\r\ntrade-offs. Instead
  of going through all of the debates, we're going\r\nto point to\r\n[an existing
  blog post](https://www.fpcomplete.com/blog/2017/07/the-rio-monad),\r\nand here just
  give recommendations.\r\n\r\n* If your code is going to perform I/O: it should live
  in the `RIO`\r\n  monad. `RIO` is \"reader IO.\" It's the same as `ReaderT env IO`,
  but\r\n  includes some helper functions in this library and leads to nicer\r\n  type
  signatures and error messages.\r\n\r\n* If you need to provide access to specific
  data to a function, do it\r\n  via a typeclass constraint on the `env`, _not_ via
  a concrete\r\n  env. For example, this is bad:\r\n\r\n  ```haskell\r\n  myFunction
  :: RIO Config Foo\r\n  ```\r\n\r\n  This is good:\r\n\r\n  ```haskell\r\n  class
  HasConfig env where\r\n    configL :: Lens' env Config -- more on this in a moment\r\n
  \ myFunction :: HasConfig env => RIO env Foo\r\n  ```\r\n\r\n  Reason: by using
  typeclass constraints on the environment, we can\r\n  easily compose multiple functions
  together and collect up the\r\n  constraints, which wouldn't be possible with concrete\r\n
  \ environments. We _could_ go more general with mtl-style typeclasses,\r\n  like
  `MonadReader` or `MonadHasConfig`, but `RIO` is a perfect\r\n  balance point in
  the composability/concreteness space (see blog post\r\n  above for more details).\r\n\r\n*
  When defining `Has`-style typeclasses for the environments, we use\r\n  lenses (which
  are exposed by `RIO`) because it provides for easy\r\n  composability. We also leverage
  superclasses wherever possible. As\r\n  an example of how this works in practice:\r\n\r\n
  \ ```haskell\r\n  -- Defined in RIO.Logger\r\n  class HasLogFunc env where\r\n    logFuncL
  :: Lens' env LogFunc\r\n\r\n  class HasConfig env where\r\n    configL :: Lens'
  env Config\r\n  instance HasConfig Config where\r\n    configL = id\r\n\r\n  data
  Env = Env { envLogFunc :: !LogFunc, envConfig :: !Config }\r\n  class (HasLogFunc
  env, HasConfig env) => HasEnv env where\r\n    envL :: Lens' env Env\r\n  instance
  HasLogFunc Env where\r\n    logFuncL = lens envLogFunc (\\x y -> x { envLogFunc
  = y })\r\n  instance HasConfig Env where\r\n    configL = lens envConfig (\\x y
  -> x { envConfig = y })\r\n  instance HasEnv Env where\r\n    envL = id\r\n\r\n
  \ -- And then, at some other part of the code\r\n  data SuperEnv = SuperEnv { seEnv
  :: !Env, seOtherStuff :: !OtherStuff }\r\n  instance HasLogFunc SuperEnv where\r\n
  \   logFuncL = envL.logFuncL\r\n  instance HasConfig SuperEnv where\r\n    configL
  = envL.configL\r\n  instance HasEnv SuperEnv where\r\n    envL = lens seEnv (\\x
  y -> x { seEnv = y })\r\n  ```\r\n\r\n* If you're writing code that you want to
  be usable outside of `RIO`\r\n  for some reason, you should stick to the good mtl-style
  typeclasses:\r\n  `MonadReader`, `MonadIO`, `MonadUnliftIO`, `MonadThrow`, and\r\n
  \ `PrimMonad`. It's better to use `MonadReader`+`Has` than to create\r\n  new typeclasses
  like `MonadLogger`, though usually just sticking\r\n  with the simpler `RIO env`
  is fine (and can easily be converted to\r\n  the more general form with `liftRIO`).
  You should avoid using the\r\n  following typeclasses (intentionally not exposed
  from this library):\r\n  `MonadBase`, `MonadBaseControl`, `MonadCatch`, and `MonadMask`.\r\n\r\n###
  Exceptions\r\n\r\nFor in-depth discussion, see [safe exception\r\nhandling](https://haskell.fpcomplete.com/tutorial/exceptions).
  The\r\nbasic idea is:\r\n\r\n* If something can fail, and you want people to deal
  with that failure\r\n  every time (e.g., `lookup`), then return a `Maybe` or `Either`\r\n
  \ value.\r\n* If the user will usually not want to deal with it, then use\r\n  exceptions.
  In the case of pure code, use a `MonadThrow`\r\n  constraint. In the case of `IO`
  code: use runtime exceptions via\r\n  `throwIO` (works in the `RIO` monad too).\r\n*
  You'll be upset and frustrated that you don't know exactly how some\r\n  `IO` action
  can fail. Accept that pain, live with it, internalize\r\n  it, use `tryAny`, and
  move on. It's the price we pay for async\r\n  exceptions.\r\n* Do all resource allocations
  with functions like `bracket` and\r\n  `finally`.\r\n\r\nIt’s a good idea to define
  an app-wide exception type:\r\n\r\n```haskell\r\ndata AppExceptions\r\n  = NetworkChangeError
  Text\r\n  | FilePathError FilePath\r\n  | ImpossibleError\r\n  deriving (Typeable)\r\n\r\ninstance
  Exception AppExceptions\r\n\r\ninstance Show AppExceptions where\r\n  show =\r\n
  \   \\case\r\n      NetworkChangeError err -> \"network error: \" <> (unpack err)\r\n
  \     FilePathError fp -> \"error accessing filepath at: \" <> fp\r\n      ImpossibleError
  -> \"this codepath should never have been executed. Please report a bug.\"\r\n```\r\n\r\n###
  Strict data fields\r\n\r\nMake data fields strict by default, unless you have a
  good reason to\r\ndo otherwise.\r\n\r\n### Project template\r\n\r\nWe provide a
  project template which sets up lots of things for you out\r\nof the box. You can
  use it by running:\r\n\r\n```\r\n$ stack new projectname rio\r\n```\r\n\r\n### Safety
  first\r\n\r\nThis library intentionally puts safety first, and therefore avoids\r\npromoting
  partial functions and lazy I/O. If you think you need lazy\r\nI/O: you need a streaming
  data library like conduit instead.\r\n\r\n### When to generalize\r\n\r\nA common
  question in Haskell code is when should you generalize. Here\r\nare some simple
  guidelines. For parametric polymorphism: _almost\r\nalways_ generalize, it makes
  your type signatures more informative and\r\nfunctions more useful. In other words,
  `reverse :: [a] -> [a]` is far\r\nbetter than `reverse :: [Int] -> [Int]`.\r\n\r\nWhen
  it comes to typeclasses: the story is more nuanced. For\r\ntypeclasses provided
  by `RIO`, like `Foldable` or `Traversable`, it's\r\ngenerally a good thing to generalize
  to them when possible. The real\r\nquestion is defining your own typeclasses. As
  a general rule: avoid\r\ndoing so as long as possible. And _if_ you define a typeclass:
  make\r\nsure its usage can't lead to accidental bugs by allowing you to swap\r\nin
  types you didn't expect.\r\n\r\n### Module hierarchy\r\n\r\nThe `RIO.Prelude.` module
  hierarchy contains identifiers which are reexported\r\nby the `RIO` module. The
  reason for this is to make it easier to view the\r\ngenerated Haddocks. The `RIO`
  module itself is intended to be imported\r\nunqualified, with `NoImplicitPrelude`
  enabled. All other modules are _not_\r\nreexported by the `RIO` module,\r\nand will
  document inside of them whether they should be imported qualified or\r\nunqualified.\r\n"
description-type: markdown
hash: 7e29e746ab5c33e6ae9977cc8d8250a749d16ff2c372c59fd4a4eb67b06d9919
homepage: https://github.com/commercialhaskell/rio#readme
latest: 0.1.23.0
license-name: MIT
maintainer: michael@snoyman.com
synopsis: A standard library for Haskell
test-bench-deps:
  QuickCheck: '>=0'
  base: '>=4.12 && <10'
  bytestring: '>=0'
  containers: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  exceptions: '>=0'
  filepath: '>=0'
  hashable: '>=0'
  hspec: '>=0'
  microlens: '>=0.4.2.0'
  microlens-mtl: '>=0'
  mtl: '>=0'
  primitive: '>=0'
  process: '>=0'
  rio: '>=0'
  text: '>=0'
  time: '>=0'
  typed-process: '>=0.2.5.0'
  unix: '>=0'
  unliftio: '>=0.2.14'
  unliftio-core: '>=0'
  unordered-containers: '>=0'
  vector: '>=0'

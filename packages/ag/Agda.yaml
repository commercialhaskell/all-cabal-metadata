homepage: http://wiki.portal.chalmers.se/agda/
changelog-type: text
hash: 8ec525d8d905ae32f99cf67db0105c4e42baf666cfbcc8e8f3e2d160dea161d0
test-bench-deps: {}
maintainer: Ulf Norell <ulfn@chalmers.se>
synopsis: A dependently typed functional programming language and proof assistant
changelog: ! "------------------------------------------------------------------------\n--
  Release notes for Agda version 2.5.1.2\n------------------------------------------------------------------------\n\n*
  Fixed broken type signatures that were incorrectly accepted due to\n  GHC #12784
  (https://ghc.haskell.org/trac/ghc/ticket/12784).\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.5.1.1\n------------------------------------------------------------------------\n\nImportant
  changes since 2.5.1:\n\nInstallation and infrastructure\n===============================\n\n*
  Added support for GHC 8.0.1.\n\nBug fixes\n=========\n\n* Fixed a serious performance
  problem with instance search\n\n  Issues #1952 and #1998. Also related: #1955 and
  #2025\n\n* Interactively splitting variable with C-c C-c no longer introduces\n
  \ new trailing patterns.  This fixes issue #1950.\n\n    data Ty : Set where\n      _⇒_
  : Ty → Ty → Ty\n\n    ⟦_⟧ : Ty → Set\n    ⟦ A ⇒ B ⟧ = ⟦ A ⟧ → ⟦ B ⟧\n\n    data
  Term : Ty → Set where\n      K : (A B : Ty) → Term (A ⇒ (B ⇒ A))\n\n    test : (A
  : Ty) (a : Term A) → ⟦ A ⟧\n    test A a = {!a!}\n\n  Before change, case splitting
  on `a` would give\n\n    test .(A ⇒ (B ⇒ A)) (K A B) x x₁ = ?\n\n  Now, it yields\n\n
  \   test .(A ⇒ (B ⇒ A)) (K A B) = ?\n\n* Other issues fixed ( see https://github.com/agda/agda/issues
  ):\n  - #1322 (Missing error for attempted higher order instance)\n  - #1951 (mixfix
  binders not working in 'syntax')\n  - #1967 (too eager insteance search error)\n
  \ - #1974 (lost constraint dependencies)\n  - #1982 (internal error in unifier)\n
  \ - #2034 (function type instance goals)\n\nCompiler backends\n=================\n\n*
  UHC compiler backend\n\n  Added support for UHC 1.1.9.4.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.5.1\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.2.5:\n\nDocumentation\n=============\n\n* There is now an official
  Agda User Manual:\n  http://agda.readthedocs.org/en/stable/\n\nInstallation and
  infrastructure\n===============================\n\n* Builtins and primitives are
  now defined in a new set of modules available to\n  all users, independent of any
  particular library. The modules are\n\n    Agda.Builtin.Bool\n    Agda.Builtin.Char\n
  \   Agda.Builtin.Coinduction\n    Agda.Builtin.Equality\n    Agda.Builtin.Float\n
  \   Agda.Builtin.FromNat\n    Agda.Builtin.FromNeg\n    Agda.Builtin.FromString\n
  \   Agda.Builtin.IO\n    Agda.Builtin.Int\n    Agda.Builtin.List\n    Agda.Builtin.Nat\n
  \   Agda.Builtin.Reflection\n    Agda.Builtin.Size\n    Agda.Builtin.Strict\n    Agda.Builtin.String\n
  \   Agda.Builtin.TrustMe\n    Agda.Builtin.Unit\n\n  The standard library reexports
  the primitives from the new modules.\n\n  The Agda.Builtin modules are installed
  in the same way as Agda.Primitive,\n  but unlike Agda.Primitive they are not loaded
  automatically.\n\nPragmas and options\n===================\n\n* Library management\n\n
  \ There is a new 'library' concept for managing include paths. A library\n  consists
  of\n    - a name,\n    - a set of libraries it depends on, and\n    - a set of include
  paths.\n\n  A library is defined in a .agda-lib file using the following format:\n\n
  \   name: LIBRARY-NAME  -- Comment\n    depend: LIB1 LIB2\n      LIB3\n      LIB4\n
  \   include: PATH1\n      PATH2\n      PATH3\n\n  Dependencies are library names,
  not paths to .agda-lib files, and\n  include paths are relative to the location
  of the library-file.\n\n  To be useable, a library file has to be listed (with its
  full path) in\n  AGDA_DIR/libraries (or AGDA_DIR/libraries-VERSION, for a given
  Agda\n  version). AGDA_DIR defaults to ~/.agda on unix-like systems\n  and C:/Users/USERNAME/AppData/Roaming/agda
  or similar on Windows, and can be\n  overridden by setting the AGDA_DIR environment
  variable.\n\n  Environment variables in the paths (of the form $VAR or ${VAR}) are\n
  \ expanded. The location of the libraries file used can be overridden using the\n
  \ --library-file=FILE flag, although this is not expected to be very useful.\n\n
  \ You can find out the precise location of the 'libraries' file by\n  calling 'agda
  -l fjdsk Dummy.agda' and looking at the error message (assuming\n  you don't have
  a library called fjdsk installed).\n\n  There are three ways a library gets used:\n\n
  \   - You supply the --library=LIB (or -l LIB) option to Agda. This is\n      equivalent
  to adding a -iPATH for each of the include paths of LIB\n      and its (transitive)
  dependencies.\n\n    - No explicit --library flag is given, and the current project
  root\n      (of the Agda file that is being loaded) or one of its parent directories\n
  \     contains a .agda-lib file defining a library LIB. This library is used as\n
  \     if a --librarary=LIB option had been given, except that it is not\n      necessary
  for the library to be listed in the AGDA_DIR/libraries file.\n\n    - No explicit
  --library flag, and no .agda-lib file in the project\n      root. In this case the
  file AGDA_DIR/defaults is read and all\n      libraries listed are added to the
  path. The defaults file should\n      contain a list of library names, each on a
  separate line. In this\n      case the current directory is also added to the path.\n\n
  \     To disable default libraries, you can give the flag\n      --no-default-libraries.\n\n
  \ Library names can end with a version number (for instance,\n  mylib-1.2.3). When
  resolving a library name (given in a --library\n  flag, or listed as a default library
  or library dependency) the\n  following rules are followed:\n\n    - If you don't
  give a version number, any version will do.\n    - If you give a version number
  an exact match is required.\n    - When there are multiple matches an exact match
  is preferred, and\n      otherwise the latest matching version is chosen.\n\n  For
  example, suppose you have the following libraries installed:\n  mylib, mylib-1.0,
  otherlib-2.1, and otherlib-2.3. In this case, aside\n  from the exact matches you
  can also say --library=otherlib to get\n  otherlib-2.3.\n\n* New Pragma COMPILED_DECLARE_DATA
  for binding recursively defined\n  Haskell data types to recursively defined Agda
  data types.\n\n  If you have a Haskell type like\n\n    {-# LANGUAGE GADTs #-}\n\n
  \   module Issue223 where\n\n    data A where\n      BA :: B -> A\n\n    data B
  where\n      AB :: A -> B\n      BB :: B\n\n  You can now bind it to corresponding
  mutual Agda inductive data\n  types as follows:\n\n    {-# IMPORT Issue223 #-}\n\n
  \   data A : Set\n    {-# COMPILED_DECLARE_DATA A Issue223.A #-}\n    data B : Set\n
  \   {-# COMPILED_DECLARE_DATA B Issue223.B #-}\n\n    data A where\n      BA : B
  → A\n\n    {-# COMPILED_DATA A Issue223.A Issue223.BA #-}\n    data B where\n      AB
  : A → B\n      BB : B\n\n    {-# COMPILED_DATA B Issue223.B Issue223.AB Issue223.BB
  #-}\n\n  This fixes issue 223.\n\n* New pragma HASKELL for adding inline Haskell
  code (GHC backend only)\n\n  Arbitrary Haskell code can be added to a module using
  the HASKELL pragma.\n  For instance,\n\n    {-# HASKELL\n      echo :: IO ()\n      echo
  = getLine >>= putStrLn\n    #-}\n\n    postulate echo : IO ⊤\n    {-# COMPILED echo
  echo #-}\n\n* New option --exact-split.\n\n  The --exact-split flag causes Agda
  to raise an error whenever a clause in a\n  definition by pattern matching cannot
  be made to hold definitionally (i.e. as\n  a reduction rule). Specific clauses can
  be excluded from this check by means\n  of the {-# CATCHALL #-} pragma.\n\n  For
  instance, the following definition will be rejected as the second clause\n  cannot
  be made to hold definitionally:\n\n    min : Nat → Nat → Nat\n    min zero    y
  \      = zero\n    min x       zero    = zero\n    min (suc x) (suc y) = suc (min
  x y)\n\n  Catchall clauses have to be marked as such, for instance:\n\n    eq :
  Nat → Nat → Bool\n    eq zero    zero    = true\n    eq (suc m) (suc n) = eq m n\n
  \   {-# CATCHALL #-}\n    eq _       _       = false\n\n* New option: --no-exact-split.\n\n
  \ This option can be used to override a global --exact-split in a\n  file, by adding
  a pragma {-# OPTIONS --no-exact-split #-}.\n\n* New options: --sharing and --no-sharing.\n\n
  \ These options are used to enable/disable sharing and call-by-need evaluation.\n
  \ The default is --no-sharing.\n\n  Note that they cannot appear in an OPTIONS pragma,
  but have to be given as\n  command line arguments or added to the Agda Program Args
  from Emacs with M-x\n  customize-group agda2.\n\n* New pragma DISPLAY.\n\n  {-#
  DISPLAY f e1 .. en = e #-}\n\n  This causes f e1 .. en to be printed in the same
  way as e, where ei can bind\n  variables used in e. The expressions ei and e are
  scope checked, but not\n  type checked.\n\n  For example this can be used to print
  overloaded (instance) functions with\n  the overloaded name:\n\n    instance\n      NumNat
  : Num Nat\n      NumNat = record { ..; _+_ = natPlus }\n\n    {-# DISPLAY natPlus
  a b = a + b #-}\n\n  Limitations\n\n    Left-hand sides are restricted to variables,
  constructors, defined\n    functions or types, and literals. In particular, lambdas
  are not allowed in\n    left-hand sides.\n\n    Since DISPLAY pragmas are not type
  checked implicit argument insertion may\n    not work properly if the type of f
  computes to an implicit function space\n    after pattern matching.\n\n* Removed
  pragma {-# ETA R #-}\n\n  The pragma {-# ETA R #-} is replaced by the eta-equality
  directive\n  inside record declarations.\n\n* New option --no-eta-equality.\n\n
  \ The --no-eta-equality flag disables eta rules for declared record types.\n  It
  has the same effect as no-eta-equality inside each declaration of\n  a record type
  R.\n\n  If used with the OPTIONS pragma it will not affect records defined\n  in
  other modules.\n\n* The semantics of {-# REWRITE r #-} pragmas in parametrized modules
  has\n  changed (see Issue 1652).\n\n  Rewrite rules are no longer lifted to the
  top context. Instead, they now only\n  apply to terms in (extensions of) the module
  context. If you want the old\n  behaviour, you should put the {-# REWRITE r #-}
  pragma outside of the module\n  (i.e. unindent it).\n\n* New pragma {-# INLINE f
  #-} causes f to be inlined during compilation.\n\n* The STATIC pragma is now taken
  into account during compilation.\n\n  Calls to a function marked STATIC are normalised
  before compilation. The\n  typical use case for this is to mark the interpreter
  of an embedded language\n  as STATIC.\n\n* Option --type-in-type no longer implies
  --no-universe-polymorphism,\n  thus, it can be used with explicit universe levels.
  [Issue 1764]\n  It simply turns off error reporting for any level mismatch now.\n
  \ Examples:\n\n    {-# OPTIONS --type-in-type #-}\n\n    Type : Set\n    Type =
  Set\n\n    data D {α} (A : Set α) : Set where\n      d : A → D A\n\n    data E α
  β : Set β where\n      e : Set α → E α β\n\n* New NO_POSITIVITY_CHECK pragma to
  switch off the positivity checker\n  for data/record definitions and mutual blocks.\n\n
  \ The pragma must precede a data/record definition or a mutual block.\n\n  The pragma
  cannot be used in --safe mode.\n\n  Examples (see Issue1614*.agda and Issue1760*.agda
  in test/Succeed/):\n\n  1. Skipping a single data definition.\n\n       {-# NO_POSITIVITY_CHECK
  #-}\n       data D : Set where\n         lam : (D → D) → D\n\n  2. Skipping a single
  record definition.\n\n       {-# NO_POSITIVITY_CHECK #-}\n       record U : Set
  where\n         field ap : U → U\n\n  3. Skipping an old-style mutual block: Somewhere
  within a `mutual`\n     block before a data/record definition.\n\n       mutual\n
  \        data D : Set where\n           lam : (D → D) → D\n\n         {-# NO_POSITIVITY_CHECK
  #-}\n         record U : Set where\n           field ap : U → U\n\n  4. Skipping
  an old-style mutual block: Before the `mutual` keyword.\n\n       {-# NO_POSITIVITY_CHECK
  #-}\n       mutual\n         data D : Set where\n           lam : (D → D) → D\n\n
  \        record U : Set where\n             field ap : U → U\n\n  5. Skipping a
  new-style mutual block: Anywhere before the\n     declaration or the definition
  of data/record in the block.\n\n     record U : Set\n     data D   : Set\n\n     record
  U where\n       field ap : U → U\n\n     {-# NO_POSITIVITY_CHECK #-}\n     data
  D where\n       lam : (D → D) → D\n\n* Removed --no-coverage-check option. [Issue
  1918]\n\nLanguage\n========\n\nOperator syntax\n---------------\n\n* The default
  fixity for syntax declarations has changed from -666 to 20.\n\n* Sections.\n\n  Operators
  can be sectioned by replacing arguments with underscores.\n  There must not be any
  whitespace between these underscores and the\n  adjacent nameparts. Examples:\n\n
  \   pred : ℕ → ℕ\n    pred = _∸ 1\n\n    T : Bool → Set\n    T = if_then ⊤ else
  ⊥\n\n    if : {A : Set} (b : Bool) → A → A → A\n    if b = if b then_else_\n\n  Sections
  are translated into lambda expressions. Examples:\n\n    _∸ 1              ↦  λ
  section → section ∸ 1\n\n    if_then ⊤ else ⊥  ↦  λ section → if section then ⊤
  else ⊥\n\n    if b then_else_   ↦  λ section section₁ →\n                             if
  b then section else section₁\n\n  Operator sections have the same fixity as the
  underlying operator\n  (except in cases like \"if b then_else_\", in which the section
  is\n  \"closed\", but the operator is not).\n\n  Operator sections are not supported
  in patterns (with the exception\n  of dot patterns), and notations coming from syntax
  declarations\n  cannot be sectioned.\n\n* A long-standing operator fixity bug has
  been fixed. As a consequence\n  some programs that used to parse no longer do.\n\n
  \ Previously each precedence level was (incorrectly) split up into\n  five separate
  ones, ordered as follows, with the earlier ones\n  binding less tightly than the
  later ones:\n\n    - Non-associative operators.\n\n    - Left associative operators.\n\n
  \   - Right associative operators.\n\n    - Prefix operators.\n\n    - Postfix operators.\n\n
  \ Now this problem has been addressed. It is no longer possible to mix\n  operators
  of a given precedence level but different associativity.\n  However, prefix and
  right associative operators are seen as having\n  the same associativity, and similarly
  for postfix and left\n  associative operators.\n\n  Examples\n  --------\n\n  The
  following code is no longer accepted:\n\n    infixl 6 _+_\n    infix  6 _∸_\n\n
  \   rejected : ℕ\n    rejected = 1 + 0 ∸ 1\n\n  However, the following previously
  rejected code is accepted:\n\n    infixr 4 _,_\n    infix  4 ,_\n\n    ,_ : {A :
  Set} {B : A → Set} {x : A} → B x → Σ A B\n    , y = _ , y\n\n    accepted : Σ ℕ
  λ i → Σ ℕ λ j → Σ (i ≡ j) λ _ → Σ ℕ λ k → j ≡ k\n    accepted = 5 , , refl , , refl\n\n*
  The classification of notations with binders into the categories\n  infix, prefix,
  postfix or closed has changed. [Issue 1450]\n\n  The difference is that, when classifying
  the notation, only\n  /regular/ holes are taken into account, not /binding/ ones.\n\n
  \ Example: The notation\n\n    syntax m >>= (λ x → f) = x <- m , f\n\n  was previously
  treated as infix, but is now treated as prefix.\n\n* Notation can now include wildcard
  binders.\n\n  Example: syntax Σ A (λ _ → B) = A × B\n\n* If an overloaded operator
  is in scope with several distinct\n  precedence levels, then several instances of
  this operator will be\n  included in the operator grammar, possibly leading to ambiguity.\n
  \ Previously the operator was given the default fixity [Issue 1436].\n\n  There
  is an exception to this rule: If there are multiple precedences,\n  but at most
  one is explicitly declared, then only one instance will be\n  included in the grammar.
  If there are no explicitly declared\n  precedences, then this instance will get
  the default precedence, and\n  otherwise it will get the declared precedence.\n\n
  \ If multiple occurrences of an operator are \"merged\" in the grammar,\n  and they
  have distinct associativities, then they are treated as\n  being non-associative.\n\n
  \ The three paragraphs above also apply to identical notations (coming\n  from syntax
  declarations) for a given overloaded name.\n\n  Examples:\n\n    module A where\n\n
  \     infixr 5 _∷_\n      infixr 5 _∙_\n      infixl 3 _+_\n      infix  1 bind\n\n
  \     syntax bind c (λ x → d) = x ← c , d\n\n    module B where\n\n      infix  5
  _∷_\n      infixr 4 _∙_\n      -- No fixity declaration for _+_.\n      infixl 2
  bind\n\n      syntax bind c d = c ∙ d\n\n    module C where\n\n      infixr 2 bind\n\n
  \     syntax bind c d = c ∙ d\n\n    open A\n    open B\n    open C\n\n    -- _∷_
  is infix 5.\n    -- _∙_ has two fixities: infixr 4 and infixr 5.\n    -- _+_ is
  infixl 3.\n    -- A.bind's notation is infix 1.\n    -- B.bind and C.bind's notations
  are infix 2.\n\n    -- There is one instance of \"_ ∷ _\" in the grammar, and one\n
  \   -- instance of \"_ + _\".\n\n    -- There are three instances of \"_ ∙ _\" in
  the grammar, one\n    -- corresponding to A._∙_, one corresponding to B._∙_, and
  one\n    -- corresponding to both B.bind and C.bind.\n\nReflection\n----------\n\n*
  The reflection framework has received a massive overhaul.\n\n  A new type of reflected
  type checking computations supplants most of the old\n  reflection primitives. The
  quoteGoal, quoteContext and tactic primitives are\n  deprecated and will be removed
  in the future, and the unquoteDecl and unquote\n  primitives have changed behaviour.
  Furthermore the following primitive\n  functions have been replaced by builtin type
  checking computations:\n\n    - primQNameType              --> AGDATCMGETTYPE\n
  \   - primQNameDefinition        --> AGDATCMGETDEFINITION\n    - primDataConstructors
  \      --> subsumed by AGDATCMGETDEFINITION\n    - primDataNumberOfParameters -->
  subsumed by AGDATCMGETDEFINITION\n\n  See below for details.\n\n* Types are no longer
  packaged with a sort.\n\n  The AGDATYPE and AGDATYPEEL built-ins have been removed.
  Reflected types are\n  now simply terms.\n\n* Reflected definitions have more information.\n\n
  \ The type for reflected definitions has changed to\n\n    data Definition : Set
  where\n      fun-def     : List Clause  → Definition\n      data-type   : Nat →
  List Name → Definition -- parameters and constructors\n      record-type : Name
  → Definition            -- name of the data/record type\n      data-con    : Name
  → Definition            -- name of the constructor\n      axiom       : Definition\n
  \     prim-fun    : Definition\n\n  Correspondingly the built-ins for function,
  data and record definitions\n  (AGDAFUNDEF, AGDAFUNDEFCON, AGDADATADEF, AGDARECORDDEF)
  have been removed.\n\n* Reflected type checking computations.\n\n  There is a primitive
  TC monad representing type checking computations. The\n  unquote, unquoteDecl, and
  the new unquoteDef all expect computations in this\n  monad (see below). The interface
  to the monad is the following\n\n    -- Error messages can contain embedded names
  and terms.\n    data ErrorPart : Set where\n      strErr  : String → ErrorPart\n
  \     termErr : Term → ErrorPart\n      nameErr : Name → ErrorPart\n\n    {-# BUILTIN
  AGDAERRORPART       ErrorPart #-}\n    {-# BUILTIN AGDAERRORPARTSTRING strErr    #-}\n
  \   {-# BUILTIN AGDAERRORPARTTERM   termErr   #-}\n    {-# BUILTIN AGDAERRORPARTNAME
  \  nameErr   #-}\n\n    postulate\n      TC         : ∀ {a} → Set a → Set a\n      returnTC
  \  : ∀ {a} {A : Set a} → A → TC A\n      bindTC     : ∀ {a b} {A : Set a} {B : Set
  b} → TC A → (A → TC B) → TC B\n\n      -- Unify two terms, potentially solving metavariables
  in the process.\n      unify      : Term → Term → TC ⊤\n\n      -- Throw a type
  error. Can be caught by catchTC.\n      typeError  : ∀ {a} {A : Set a} → List ErrorPart
  → TC A\n\n      -- Block a type checking computation on a metavariable. This will
  abort\n      -- the computation and restart it (from the beginning) when the\n      --
  metavariable is solved.\n      blockOnMeta : ∀ {a} {A : Set a} → Meta → TC A\n\n
  \     -- Backtrack and try the second argument if the first argument throws a\n
  \     -- type error.\n      catchTC    : ∀ {a} {A : Set a} → TC A → TC A → TC A\n\n
  \     -- Infer the type of a given term\n      inferType  : Term → TC Type\n\n      --
  Check a term against a given type. This may resolve implicit arguments\n      --
  in the term, so a new refined term is returned. Can be used to create\n      --
  new metavariables: newMeta t = checkType unknown t\n      checkType  : Term → Type
  → TC Term\n\n      -- Compute the normal form of a term.\n      normalise  : Term
  → TC Term\n\n      -- Get the current context.\n      getContext : TC (List (Arg
  Type))\n\n      -- Extend the current context with a variable of the given type.\n
  \     extendContext : ∀ {a} {A : Set a} → Arg Type → TC A → TC A\n\n      -- Set
  the current context.\n      inContext     : ∀ {a} {A : Set a} → List (Arg Type)
  → TC A → TC A\n\n      -- Quote a value, returning the corresponding Term.\n      quoteTC
  : ∀ {a} {A : Set a} → A → TC Term\n\n      -- Unquote a Term, returning the corresponding
  value.\n      unquoteTC : ∀ {a} {A : Set a} → Term → TC A\n\n      -- Create a fresh
  name.\n      freshName  : String → TC QName\n\n      -- Declare a new function of
  the given type. The function must be defined\n      -- later using 'defineFun'.
  Takes an Arg Name to allow declaring instances\n      -- and irrelevant functions.
  The Visibility of the Arg must not be hidden.\n      declareDef : Arg QName → Type
  → TC ⊤\n\n      -- Define a declared function. The function may have been declared
  using\n      -- 'declareDef' or with an explicit type signature in the program.\n
  \     defineFun  : QName → List Clause → TC ⊤\n\n      -- Get the type of a defined
  name. Replaces 'primQNameType'.\n      getType    : QName → TC Type\n\n      --
  Get the definition of a defined name. Replaces 'primQNameDefinition'.\n      getDefinition
  : QName → TC Definition\n\n    {-# BUILTIN AGDATCM                   TC                 #-}\n
  \   {-# BUILTIN AGDATCMRETURN             returnTC           #-}\n    {-# BUILTIN
  AGDATCMBIND               bindTC             #-}\n    {-# BUILTIN AGDATCMUNIFY              unify
  \             #-}\n    {-# BUILTIN AGDATCMNEWMETA            newMeta            #-}\n
  \   {-# BUILTIN AGDATCMTYPEERROR          typeError          #-}\n    {-# BUILTIN
  AGDATCMBLOCKONMETA        blockOnMeta        #-}\n    {-# BUILTIN AGDATCMCATCHERROR
  \        catchTC            #-}\n    {-# BUILTIN AGDATCMINFERTYPE          inferType
  \         #-}\n    {-# BUILTIN AGDATCMCHECKTYPE          checkType          #-}\n
  \   {-# BUILTIN AGDATCMNORMALISE          normalise          #-}\n    {-# BUILTIN
  AGDATCMGETCONTEXT         getContext         #-}\n    {-# BUILTIN AGDATCMEXTENDCONTEXT
  \     extendContext      #-}\n    {-# BUILTIN AGDATCMINCONTEXT          inContext
  \         #-}\n    {-# BUILTIN AGDATCMQUOTETERM          quoteTC            #-}\n
  \   {-# BUILTIN AGDATCMUNQUOTETERM        unquoteTC          #-}\n    {-# BUILTIN
  AGDATCMFRESHNAME          freshName          #-}\n    {-# BUILTIN AGDATCMDECLAREDEF
  \        declareDef         #-}\n    {-# BUILTIN AGDATCMDEFINEFUN          defineFun
  \         #-}\n    {-# BUILTIN AGDATCMGETTYPE            getType            #-}\n
  \   {-# BUILTIN AGDATCMGETDEFINITION      getDefinition      #-}\n\n* Builtin type
  for metavariables\n\n  There is a new builtin type for metavariables used by the
  new reflection\n  framework. It is declared as follows and comes with primitive
  equality,\n  ordering and show.\n\n    postulate Meta : Set\n    {-# BUILTIN AGDAMETA
  Meta #-}\n    primitive primMetaEquality : Meta → Meta → Bool\n    primitive primMetaLess
  : Meta → Meta → Bool\n    primitive primShowMeta : Meta → String\n\n  There are
  corresponding new constructors in the Term and Literal data types:\n\n    data Term
  : Set where\n      ...\n      meta : Meta → List (Arg Term) → Term\n\n    {-# BUILTIN
  AGDATERMMETA meta #-}\n\n    data Literal : Set where\n      ...\n      meta : Meta
  → Literal\n\n    {-# BUILTIN AGDALITMETA meta #-}\n\n* Builtin unit type\n\n    The
  type checker needs to know about the unit type, which you can allow by\n\n      record
  ⊤ : Set where\n      {-# BUILTIN UNIT ⊤ #-}\n\n* Changed behaviour of unquote\n\n
  \ The unquote primitive now expects a type checking computation instead of a\n  pure
  term. In particular 'unquote e' requires\n\n    e : Term → TC ⊤\n\n  where the argument
  is the representation of the hole in which the result\n  should go. The old unquote
  behaviour (where unquote expected a Term argument)\n  can be recovered by\n\n    OLD:
  unquote v\n    NEW: unquote λ hole → unify hole v\n\n* Changed behaviour of unquoteDecl\n\n
  \ The unquoteDecl primitive now expects a type checking computation instead of\n
  \ a pure function definition. It is possible to define multiple (mutually\n  recursive)
  functions at the same time. More specifically\n\n    unquoteDecl x₁ .. xₙ = m\n\n
  \ requires m : TC ⊤ and that x₁ .. xₙ are defined (using declareDef and\n  defineFun)
  after executing m. As before x₁ .. xₙ : QName in m, but have their\n  declared types
  outside the unquoteDecl.\n\n* New primitive unquoteDef.\n\n  There is a new declaration\n\n
  \   unquoteDef x₁ .. xₙ = m\n\n  This works exactly as unquoteDecl (see above) with
  the exception that x₁ ..\n  xₙ are required to already be declared.\n\n  The main
  advantage of unquoteDef over unquoteDecl is that unquoteDef is\n  allowed in mutual
  blocks, allowing mutually recursion between generated\n  definitions and hand-written
  definitions.\n\n* The reflection interface now exposes the name hint (as a string)\n
  \ for variables. As before, the actual binding structure is with\n  de Bruijn indices.
  The String value is just a hint used as a prefix\n  to help display the variable.
  The type Abs is a new bultin type used\n  for the constructors `Term.lam`, `Term.pi`,
  `Pattern.var`\n  (bultins `AGDATERMLAM`, `AGDATERMPI` and `AGDAPATVAR`).\n\n    data
  Abs (A : Set) : Set where\n      abs : (s : String) (x : A) → Abs A\n    {-# BUILTIN
  ABS    Abs #-}\n    {-# BUILTIN ABSABS abs #-}\n\n  Updated constructor types:\n\n
  \   Term.lam    : Hiding   → Abs Term → Term\n    Term.pi     : Arg Type → Abs Type
  → Term\n    Pattern.var : String   → Pattern\n\n* Reflection-based macros\n\n  Macros
  are functions of type t1 → t2 → .. → Term → TC ⊤ that are defined in a\n  'macro'
  block. Macro application is guided by the type of the macro, where\n  Term arguments
  desugar into the 'quoteTerm' syntax and Name arguments into\n  the 'quote' syntax.
  Arguments of any other type are preserved as-is. The last\n  Term argument is the
  hole term given to 'unquote' computation (see above).\n\n  For example, the macro
  application 'f u v w' where the macro\n  f has the type 'Term → Name → Bool → Term
  → TC ⊤' desugars into\n    'unquote (f (quoteTerm u) (quote v) w)'\n\n  Limitations:\n\n
  \   - Macros cannot be recursive. This can be worked around by defining the\n      recursive
  function outside the macro block and have the macro call the\n      recursive function.\n\n
  \ Silly example:\n\n    macro\n      plus-to-times : Term → Term → TC ⊤\n      plus-to-times
  (def (quote _+_) (a ∷ b ∷ [])) hole = unify hole (def (quote _*_) (a ∷ b ∷ []))\n
  \     plus-to-times v hole = unify hole v\n\n    thm : (a b : Nat) → plus-to-times
  (a + b) ≡ a * b\n    thm a b = refl\n\n  Macros are most useful when writing tactics,
  since they let you hide the\n  reflection machinery. For instance, suppose you have
  a solver\n\n    magic : Type → Term\n\n  that takes a reflected goal and outputs
  a proof (when successful). You can\n  then define the following macro\n\n    macro\n
  \     by-magic : Term → TC ⊤\n      by-magic hole =\n        bindTC (inferType hole)
  λ goal →\n        unify hole (magic goal)\n\n  This lets you apply the magic tactic
  without any syntactic noise at all:\n\n    thm : ¬ P ≡ NP\n    thm = by-magic\n\nLiterals
  and built-ins\n----------------------\n\n* Overloaded number literals.\n\n  You
  can now overload natural number literals using the new builtin FROMNAT:\n\n    {-#
  BUILTIN FROMNAT fromNat #-}\n\n  The target of the builtin should be a defined name.
  Typically you would do\n  something like\n\n    record Number (A : Set) : Set where\n
  \     field fromNat : Nat → A\n\n    open Number {{...}} public\n\n    {-# BUILTIN
  FROMNAT fromNat #-}\n\n  This will cause number literals 'n' to be desugared to
  'fromNat n' before\n  type checking.\n\n* Negative number literals.\n\n  Number
  literals can now be negative. For floating point literals it works as\n  expected.
  For integer literals there is a new builtin FROMNEG that enables\n  negative integer
  literals:\n\n    {-# BUILTIN FROMNEG fromNeg #-}\n\n  This causes negative literals
  '-n' to be desugared to 'fromNeg n'.\n\n* Overloaded string literals.\n\n  String
  literals can be overladed using the FROMSTRING builtin:\n\n    {-# BUILTIN FROMSTRING
  fromString #-}\n\n  The will cause string literals 's' to be desugared to 'fromString
  s' before\n  type checking.\n\n* Change to builtin integers.\n\n  The INTEGER builtin
  now needs to be bound to a datatype with two constructors\n  that should be bound
  to the new builtins INTEGERPOS and INTEGERNEGSUC as follows:\n\n    data Int : Set
  where\n      pos    : Nat -> Int\n      negsuc : Nat -> Int\n    {-# BUILTIN INTEGER
  \      Int    #-}\n    {-# BUILTIN INTEGERPOS    pos    #-}\n    {-# BUILTIN INTEGERNEGSUC
  negsuc #-}\n\n  where 'negsuc n' represents the integer '-n - 1'. For instance,
  '-5' is\n  represented as 'negsuc 4'. All primitive functions on integers except\n
  \ primShowInteger have been removed, since these can be defined without too\n  much
  trouble on the above representation using the corresponding functions on\n  natural
  numbers.\n\n  The primitives that have been removed are\n\n    primIntegerPlus\n
  \   primIntegerMinus\n    primIntegerTimes\n    primIntegerDiv\n    primIntegerMod\n
  \   primIntegerEquality\n    primIntegerLess\n    primIntegerAbs\n    primNatToInteger\n\n*
  New primitives for strict evaluation\n\n    primitive\n      primForce      : ∀
  {a b} {A : Set a} {B : A → Set b} (x : A) → (∀ x → B x) → B x\n      primForceLemma
  : ∀ {a b} {A : Set a} {B : A → Set b} (x : A) (f : ∀ x → B x) → primForce x f ≡
  f x\n\n  'primForce x f' evaluates to 'f x' if x is in weak head normal form, and\n
  \ 'primForceLemma x f' evaluates to 'refl' in the same situation. The following\n
  \ values are considered to be in weak head normal form:\n\n    - constructor applications\n
  \   - literals\n    - lambda abstractions\n    - type constructor (data/record types)
  applications\n    - function types\n    - Set a\n\nModules\n-------\n\n* Modules
  in import directives\n\n  When you use using/hiding/renaming on a name it now automatically
  applies to\n  any module of the same name, unless you explicitly mention the module.
  For\n  instance,\n\n    open M using (D)\n\n  is equivalent to\n\n    open M using
  (D; module D)\n\n  if M defines a module D. This is most useful for record and data
  types where\n  you always get a module of the same name as the type.\n\n  With this
  feature there is no longer useful to be able to qualify a\n  constructor (or field)
  by the name of the data type even when it differs from\n  the name of the corresponding
  module. The follow (weird) code used to work,\n  but doesn't work anymore:\n\n    module
  M where\n      data D where\n        c : D\n    open M using (D) renaming (module
  D to MD)\n    foo : D\n    foo = D.c\n\n  If you want to import only the type name
  and not the module you have to hide\n  it explicitly:\n\n    open M using (D) hiding
  (module D)\n\n  See discussion on Issue 836 (https://github.com/agda/agda/issues/836).\n\n*
  Private definitions of a module are no longer in scope at the Emacs\n  mode top-level.\n\n
  \ The reason for this change is that .agdai-files are stripped of unused\n  private
  definitions (which can yield significant performance\n  improvements for module-heavy
  code).\n\n  To test private definitions you can create a hole at the bottom of the\n
  \ module, in which private definitions will be visible.\n\nRecords\n-------\n\n*
  New record directives eta-equality/no-eta-equality\n\n  The keywords eta-equality/no-eta-equality
  enable/disable eta rules\n  for the (inductive) record type being declared.\n\n
  \ record Σ (A : Set) (B : A -> Set) : Set where\n    no-eta-equality\n    constructor
  _,_\n    field\n      fst : A\n      snd : B fst\n  open Σ\n\n  -- fail : ∀ {A :
  Set}{B : A -> Set} → (x : Σ A B) → x ≡ (fst x , snd x)\n  -- fail x = refl\n  --\n
  \ -- x != fst x , snd x of type Σ .A .B\n  -- when checking that the expression
  refl has type x ≡ (fst x , snd x)\n\n* Building records from modules.\n\n  The \"record
  { <fields> }\" syntax is now extended to accept module names as\n  well. Fields
  are thus defined using the corresponding definitions from the\n  given module.\n\n
  \ For instance assuming this record type R and module M:\n\n  record R : Set where\n
  \   field\n      x : X\n      y : Y\n      z : Z\n\n  module M where\n    x = {!
  ... !}\n    y = {! ... !}\n\n  r : R\n  r = record { M; z = {! ... !} }\n\n  Previously
  one had to write `record { x = M.x; y = M.y; z = {! ... !} }`.\n\n  More precisely
  this construction now supports any combination of explicit\n  field definitions
  and applied modules.\n\n  If a field is both given explicitly and available in one
  of the modules,\n  then the explicit one takes precedence.\n\n  If a field is available
  in more than one module then this is ambiguous\n  and therefore rejected. As a consequence
  the order of assignments does\n  not matter.\n\n  The modules can be both applied
  to arguments and have import directives\n  such as `hiding`, `using`, and `renaming`.
  In particular this construct\n  subsumes the record update construction.\n\n  Here
  is an example of record update:\n\n  -- Record update. Same as: record r { y = {!
  ... !} }\n  r2 : R\n  r2 = record { R r; y = {! ... !} }\n\n  A contrived example
  showing the use of hiding/renaming:\n\n  module M2 (a : A) where\n    w = {! ...
  !}\n    z = {! ... !}\n\n  r3 : A → R\n  r3 a = record { M hiding (y); M2 a renaming
  (w to y) }\n\n* Record patterns are now accepted.  Examples:\n\n    swap : {A B
  : Set} (p : A × B) → B × A\n    swap record{ proj₁ = a; proj₂ = b } = record{ proj₁
  = b; proj₂ = a }\n\n    thd3 : ...\n    thd3 record{ proj₂ = record { proj₂ = c
  }} = c\n\n* Record modules now properly hide all their parameters [Issue 1759]\n\n
  \ Previously parameters to parent modules were not hidden in the record\n  module,
  resulting in different behaviour between\n\n    module M (A : Set) where\n      record
  R (B : Set) : Set where\n\n  and\n\n    module M where\n      record R (A B : Set)
  : Set where\n\n  where in the former case, `A` would be an explicit argument to
  the module\n  `M.R`, but implicit in the latter case. Now `A` is implicit in both
  cases.\n\nInstance search\n---------------\n\n* Performance has been improved, recursive
  instance search which was previously\n  exponential in the depth is now only quadratic.\n\n*
  Constructors of records and datatypes are not anymore automatically considered\n
  \ as instances, you have to do so explicitely, for instance:\n\n    -- only [b]
  is an instance of D\n    data D : Set where\n      a : D\n      instance\n        b
  : D\n      c : D\n\n    -- the constructor is now an instance\n    record tt : Set
  where\n      instance constructor tt\n\n* Lambda-bound variables are no longer automatically
  considered instances.\n\n  Lambda-bound variables need to be bound as instance arguments
  to be\n  considered for instance search. For example,\n\n    _==_ : {A : Set} {{_
  : Eq A}} → A → A → Bool\n\n    fails : {A : Set} → Eq A → A → Bool\n    fails eqA
  x = x == x\n\n    works : {A : Set} {{_ : Eq A}} → A → Bool\n    works x = x ==
  x\n\n* Let-bound variables are no longer automatically considered instances.\n\n
  \ To make a let-bound variable available as an instance it needs to be declared\n
  \ with the 'instance' keyword, just like top-level instances. For example,\n\n    mkEq
  : {A : Set} → (A → A → Bool) → Eq A\n\n    fails : {A : Set} → (A → A → Bool) →
  A → Bool\n    fails eq x = let eqA = mkEq eq in x == x\n\n    works : {A : Set}
  → (A → A → Bool) → A → Bool\n    works eq x = let instance eqA = mkEq eq in x ==
  x\n\n* Record fields can be declared instances.\n\n  For example,\n\n    record
  EqSet : Set₁ where\n      field\n        set : Set\n        instance eq : Eq set\n\n
  \ This causes the projection function 'eq : (E : EqSet) → Eq (set E)' to be\n  considered
  for instance search.\n\n* Instance search can now find arguments in variable types
  (but such candidates can\n  only be lambda-bound variables, they can’t be declared
  as instances)\n\n    module _ {A : Set} (P : A → Set) where\n\n      postulate\n
  \       bla : {x : A} {{_ : P x}} → Set → Set\n\n      -- Works, the instance argument
  is found in the context\n      test :  {x : A} {{_ : P x}} → Set → Set\n      test
  B = bla B\n\n      -- Still forbidden, because [P] could be instantiated later to
  anything\n      instance\n       postulate\n        forbidden : {x : A} → P x\n\n*
  Instance search now refuses to solve constraints with unconstrained\n  metavariables,
  since this can lead to non-termination.\n\n  See [Issue #1532] for an example.\n\n*
  Top-level instances are now only considered if they are in scope. [Issue #1913]\n\n
  \ Note that lambda-bound instances need not be in scope.\n\nOther changes\n-------------\n\n*
  Unicode ellipsis character is allowed for the ellipsis token ... in\n  `with` expressions.\n\n*
  Prop is no longer a reserved word.\n\nType checking\n=============\n\n* Large indices.\n\n
  \ Force constructor arguments no longer count towards the size of a datatype.\n
  \ For instance, the definition of equality below is accepted.\n\n    data _≡_ {a}
  {A : Set a} : A → A → Set where\n      refl : ∀ x → x ≡ x\n\n  This gets rid of
  the asymmetry that the version of equality which indexes\n  only on the second argument
  could be small, but not the version above which\n  indexes on both arguments.\n\n*
  Detection of datatypes that satisfy K (i.e. sets)\n\n  Agda will now try to detect
  datatypes that satisfy K when --without-K is\n  enabled. A datatype satisfies K
  when it follows these three rules:\n\n  - The types of all non-recursive constructor
  arguments should satisfy K.\n\n  - All recursive constructor arguments should be
  first-order.\n\n  - The types of all indices should satisfy K.\n\n  For example,
  the types [Nat], [List Nat], and [x ≡ x] (where x : Nat) are\n  all recognized by
  Agda as satisfying K.\n\n* New unifier for case splitting\n\n  The unifier used
  by Agda for case splitting has been completely rewritten.\n  The new unifier takes
  a much more type-directed approach in order to avoid\n  the problems in issues #1406,
  #1408, #1427, and #1435.\n\n  The new unifier also has eta-equality for record types
  built-in. This should\n  avoid unnecessary case splitting on record constructors
  and improve the\n  performance of Agda on code that contains deeply nested record
  patterns (see\n  issues #473, #635, #1575, #1603, #1613, and #1645).\n\n  In some
  cases, the locations of the dot patterns computed by the unifier did\n  not correspond
  to the locations given by the user (see issue #1608). This has\n  now been fixed
  by adding an extra step after case splitting that checks\n  whether the user-written
  patterns are compatible with the computed ones.\n\n  In some rare cases, the new
  unifier is still too restrictive when --without-K\n  is enabled because it cannot
  generalize over the datatype indices (yet). For\n  example, the following code is
  rejected:\n\n    data Bar : Set₁ where\n      bar : Bar\n      baz : (A : Set) →
  Bar\n\n    data Foo : Bar → Set where\n      foo : Foo bar\n\n    test : foo ≡ foo
  → Set₁\n    test refl = Set\n\n* The aggressive behaviour of `with` introduced in
  2.4.2.5 has been\n  rolled back [Issue 1692]. With no longer abstracts in the types
  of\n  variables appearing in the with-expressions. [Issue 745]\n\n  This means that
  the following example no longer works:\n\n  ```agda\n    fails : (f : (x : A) →
  a ≡ x) (b : A) → b ≡ a\n    fails f b with a | f b\n    fails f b | .b | refl =
  f b\n  ```\n\n  The `with` no longer abstracts the type of `f` over `a`, since `f`
  appears\n  in the second with-expression `f b`. You can use a nested `with` to make\n
  \ this example work.\n\n  This example does work again:\n\n  ```agda\n    test :
  ∀{A : Set}{a : A}{f : A → A} (p : f a ≡ a) → f (f a) ≡ a\n    test p rewrite p =
  p\n  ```\n\n  After `rewrite p` the goal has changed to `f a ≡ a`, but the type\n
  \ of `p` has not been rewritten, thus, the final `p` solves the goal.\n\n  The following,
  which worked in 2.4.2.5, no longer works:\n\n  ```agda\n    fails : (f : (x : A)
  → a ≡ x) (b : A) → b ≡ a\n    fails f b rewrite f b = f b\n  ```\n\n  The rewrite
  with `f b : a ≡ b` is not applied to `f` as\n  the latter is part of the rewrite
  expression `f b`.  Thus,\n  the type of `f` remains untouched, and the changed goal\n
  \ `b ≡ b` is not solved by `f b`.\n\n* When using `rewrite` on a term `eq` of type
  `lhs ≡ rhs`, the `lhs`\n  is no longer abstracted in `rhs` [Issue 520].  This means
  that\n\n    f pats rewrite eq = body\n\n  is more than syntactic sugar for\n\n    f
  pats with lhs | eq\n    f pats | _ | refl = body\n\n  In particular, the following
  application of `rewrite` is now\n  possible\n\n    id : Bool → Bool\n    id true
  \ = true\n    id false = false\n\n    is-id : ∀ x → x ≡ id x\n    is-id true  =
  refl\n    is-id false = refl\n\n    postulate\n      P : Bool → Set\n      b : Bool\n
  \     p : P (id b)\n\n    proof : P b\n    proof rewrite is-id b = p\n\n  Previously,
  this was desugared to\n\n    proof with b | is-id b\n    proof | _ | refl = p\n\n
  \ which did not type check as `refl` does not have type `b ≡ id b`.\n  Now, Agda
  gets the task of checking `refl : _ ≡ id b` leading to\n  instantiation of `_` to
  `id b`.\n\nCompiler backends\n=================\n\n* Major Bug Fixes:\n\n  - Function
  clauses with different arities are now always compiled correctly\n    by the GHC/UHC
  backends. (Issue #727)\n\n* Co-patterns\n\n  - The GHC/UHC backends now support
  co-patterns. (Issues #1567, #1632)\n\n* Optimizations\n\n  - Builtin naturals are
  now represented as arbitrary-precision\n    Integers. See the user manual, section\n
  \   \"Agda Compilers -> Optimizations\" for details.\n\n* GHC Haskell backend (MAlonzo)\n\n
  \ - Pragmas\n\n    Since builtin naturals are compiled to Integer you can no longer\n
  \   give a {-# COMPILED_DATA #-} pragma for Nat. The same goes for\n    builtin
  booleans, integers, floats, characters and strings which are now\n    hard-wired
  to appropriate Haskell types.\n\n\n* UHC compiler backend\n\n  A new backend targeting
  the Utrecht Haskell Compiler (UHC) is available.\n  It targets the UHC Core language,
  and it's design is inspired by\n  the Epic backend. See the user manual, section\n
  \ \"Agda Compilers -> UHC Backend\" for installation instructions.\n\n\n  FFI\n\n
  \ The UHC backend has a FFI to Haskell similar to MAlonzo's.\n  The target Haskell
  code also needs to be compilable using UHC,\n  which does not support the Haskell
  base library version 4.*.\n\n  FFI pragmas for the UHC backend are not checked in
  any way. If the pragmas\n  are wrong, bad things will happen.\n\n  Imports\n  Additional
  Haskell modules can be brought into scope\n  with the IMPORT_UHC pragma:\n  {-#
  IMPORT_UHC Data.Char #-}\n  The Haskell modules UHC.Base and UHC.Agda.Builtins are
  always\n  in scope and don't need to be imported explicitly.\n\n  Datatypes\n  Agda
  datatypes can be bound to Haskell datatypes as follows:\n    Haskell:\n        data
  HsData a = HsCon1 | HsCon2 (HsData a)\n    Agda:\n        data AgdaData (A : Set)
  : Set where\n          AgdaCon1 : AgdaData A\n          AgdaCon2 : AgdaData A ->
  AgdaData A\n        {-# COMPILED_DATA_UHC AgdaData HsData HsCon1 HsCon2 #-}\n    The
  mapping has to cover all constructors of the used Haskell datatype,\n    else runtime
  behavior is undefined!\n\n  There are special reserved names to bind Agda datatypes
  to certain Haskell\n  datatypes. For example, this binds an Agda datatype\n  to
  Haskell's list datatype:\n    Agda:\n        data AgdaList (A : Set) : Set where\n
  \         Nil : AgdaList A\n          Cons : A -> AgdaList A -> AgdaList A\n        {-#
  COMPILED_DATA_UHC AgdaList __LIST__ __NIL__ __CONS__ #-}\n\n  The following \"magic\"
  datatypes are available:\n    HS Datatype | Datatype Pragma | HS Constructor | Constructor
  Pragma\n    ()            __UNIT__          ()               __UNIT__\n    List
  \         __LIST__          (:)              __CONS__\n                                    []
  \              __NIL__\n    Bool          __BOOL__          True             __TRUE__\n
  \                                   False            __FALSE__\n\n  Functions\n
  \ Agda postulates can be bound to Haskell functions. Similar as in MAlonzo,\n  all
  arguments of type Set need to be dropped before calling Haskell\n  functions. An
  example calling the return function:\n    Agda:\n        postulate hs-return : {A
  : Set} -> A -> IO A\n        {-# COMPILED_UHC hs-return (\\_ -> UHC.Agda.Builtins.primReturn)
  #-}\n\nEmacs mode and interaction\n==========================\n\n* Module contents
  (C-c C-o) now also works for records. [See issue #1926.]\n  If you have an inferable
  expression of record type in an interaction point,\n  you can invoke C-c C-o to
  see its fields and types.  Example\n\n    record R : Set where\n      field f :
  A\n\n    test : R → R\n    test r = {!r!}  -- C-c C-o here\n\n* Less aggressive
  error notification.\n\n  Previously Emacs could jump to the position of an error
  even if the\n  type-checking process was not initiated in the current buffer. Now\n
  \ this no longer happens: If the type-checking process was initiated\n  in another
  buffer, then the cursor is moved to the position of the\n  error in the buffer visiting
  the file (if any) and in every window\n  displaying the file, but focus should not
  change from one file to\n  another.\n\n  In the cases where focus does change from
  one file to another, one\n  can now use the go-back functionality to return to the
  previous\n  position.\n\n* Removed the agda-include-dirs customization parameter.\n\n
  \ Use agda-program-args with -iDIR or -lLIB instead, or add libraries to\n  ~/.agda/defaults
  (C:/Users/USERNAME/AppData/Roaming/agda/defaults or\n  similar on Windows). See
  Library management, above, for more\n  information.\n\nTools\n=====\n\nLaTeX-backend\n-------------\n\n*
  The default font has been changed to XITS (which is part of TeX Live):\n\n    http://www.ctan.org/tex-archive/fonts/xits/\n\n
  \ This font is more complete with respect to Unicode.\n\nagda-ghc-names\n--------------\n\n*
  New tool: The command\n\n    agda-ghc-names fixprof <compile-dir> <ProgName>.prof\n\n
  \ converts *.prof files obtained from profiling runs of MAlonzo-compiled\n  code
  to *.agdaIdents.prof, with the original Agda identifiers replacing\n  the MAlonzo-generated
  Haskell identifiers.\n\n  For usage and more details, see src/agda-ghc-names/README.txt.\n\nHighlighting
  and textual backends\n=================================\n\n* Names in import directives
  are now highlighted and are clickable.\n  [Issue 1714]\n  This leads also to nicer
  printing in the LaTeX and html backends.\n\nFixed issues\n============\n\nSee https://github.com/agda/agda/issues?q=milestone%3A2.5.1+is%3Aclosed\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2.5\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.2.4:\n\nInstallation and infrastructure\n===============================\n\n*
  Added support for GHC 7.10.3.\n\n* Added `cpphs` Cabal flag\n\n  Turn on/off this
  flag to choose cpphs/cpp as the C preprocessor.\n\n  This flag is turn on by default.\n\n
  \ (This flag was added in Agda 2.4.2.1 but it was not documented)\n\nPragmas and
  options\n===================\n\n* Termination pragmas are no longer allowed inside
  `where` clauses\n  [Issue 1137].\n\nType checking\n=============\n\n* `with`-abstraction
  is more aggressive, abstracts also in types of\n  variables that are used in the
  `with`-expressions, unless they are\n  also used in the types of the `with`-expressions.
  [Issue 1692]\n\n  Example:\n\n  ```agda\n    test : (f : (x : A) → a ≡ x) (b : A)
  → b ≡ a\n    test f b with a | f b\n    test f b | .b | refl = f b\n  ```\n\n  Previously,
  `with` would not abstract in types of variables that\n  appear in the `with`-expressions,
  in this case, both `f` and `b`,\n  leaving their types unchanged.\n  Now, it tries
  to abstract in `f`, as only `b` appears in the types of\n  the `with`-expressions
  which are `A` (of `a`) and `a ≡ b` (of `f b`).\n  As a result, the type of `f` changes
  to `(x : A) → b ≡ x` and the\n  type of the goal to `b ≡ b` (as previously).\n\n
  \ This also affects `rewrite`, which is implemented in terms of\n  `with`.\n\n  ```agda\n
  \   test : (f : (x : A) → a ≡ x) (b : A) → b ≡ a\n    test f b rewrite f b = f b\n
  \ ```\n\n  As the new `with` is not fully backwards-compatible, some parts of\n
  \ your Agda developments using `with` or `rewrite` might need\n  maintenance.\n\nFixed
  issues\n============\n\nSee https://github.com/agda/agda/issues\n* 1407\n* 1518\n*
  1670\n* 1677\n* 1698\n* 1701\n* 1710\n* 1718\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2.4\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.2.3:\n\nInstallation and infrastructure\n===============================\n\n*
  Removed support for GHC 7.4.2.\n\nPragmas and options\n===================\n\n*
  Option --copatterns is now on by default.  To switch off\n  parsing of copatterns,
  use:\n\n    {-# OPTIONS --no-copatterns #-}\n\n* Option --rewriting is now needed
  to use REWRITE pragmas\n  and rewriting during reduction.  Rewriting is not --safe.\n\n
  \ To use rewriting, first specify a relation symbol `R` that will\n  later be used
  to add rewrite rules.  A canonical candidate would be\n  propositional equality\n\n
  \   {-# BUILTIN REWRITE _≡_ #-}\n\n  but any symbol `R` of type `Δ → A → A → Set
  i` for some `A` and\n  `i` is accepted.  Then symbols `q` can be added to rewriting\n
  \ provided their type is of the form `Γ → R ds l r`.  This will add\n  a rewrite
  rule\n\n    Γ ⊢ l ↦ r : A[ds/Δ]\n\n  to the signature, which fires whenever a term
  is an instance of `l`.\n  For example, if\n\n    plus0 : ∀ x → x + 0 ≡ x\n\n  (ideally,
  there is a proof for `plus0`, but it could be a\n  postulate), then\n\n    {-# REWRITE
  plus0 #-}\n\n  will prompt Agda to rewrite any well-typed term of the form `t +
  0`\n  to `t`.\n\n  Some caveats:  Agda accepts and applies rewrite rules naively,
  it is\n  very easy to break consistency and termination of type checking.\n  Some
  examples of rewrite rules that should /not/ be added:\n\n    refl     : ∀ x → x
  ≡ x             -- Agda loops\n    plus-sym : ∀ x y → x + y ≡ y + x   -- Agda loops\n
  \   absurd   : true ≡ false            -- Breaks consistency\n\n  Adding only proven
  equations should at least preserve consistency,\n  but this is only a conjecture,
  so know what you are doing!\n  Using rewriting, you are entering into the wilderness,
  where you are\n  on your own!\n\nLanguage\n========\n\n* forall / ∀ now parses like
  λ, i.e., the following parses now [Issue 1583]:\n\n    ⊤ × ∀ (B : Set) → B → B\n\n*
  The underscore pattern _ can now also stand for an inaccessible\n  pattern (dot
  pattern). This alleviates the need for writing `._'.\n  [Issue 1605]  Instead of\n\n
  \   transVOld : ∀{A : Set} (a b c : A) → a ≡ b → b ≡ c → a ≡ c\n    transVOld _
  ._ ._ refl refl = refl\n\n  one can now write\n\n    transVNew : ∀{A : Set} (a b
  c : A) → a ≡ b → b ≡ c → a ≡ c\n    transVNew _ _ _ refl refl = refl\n\n  and let
  Agda decide where to put the dots.  This was always possible\n  by using hidden
  arguments\n\n    transH : ∀{A : Set}{a b c : A} → a ≡ b → b ≡ c → a ≡ c\n    transH
  refl refl = refl\n\n  which is now equivalent to\n\n    transHNew : ∀{A : Set}{a
  b c : A} → a ≡ b → b ≡ c → a ≡ c\n    transHNew {a = _}{b = _}{c = _} refl refl
  = refl\n\n  Before, underscore _ stood for an unnamed variable that could not be\n
  \ instantiated by an inaccessible pattern.  If one no wants to prevent\n  Agda from
  instantiating, one needs to use a variable name other than\n  underscore (however,
  in practice this situation seems unlikely).\n\nType checking\n=============\n\n*
  Polarity of phantom arguments to data and record types has changed. [Issue 1596]\n
  \ Polarity of size arguments is Nonvariant (both monotone and antitone).\n  Polarity
  of other arguments is Covariant (monotone).\n  Both were Invariant before (neither
  monotone nor antitone).\n\n  The following example type-checks now:\n\n    open
  import Common.Size\n\n    -- List should be monotone in both arguments\n    -- (even
  when `cons' is missing).\n\n    data List (i : Size) (A : Set) : Set where\n      []
  : List i A\n\n    castLL : ∀{i A} → List i (List i A) → List ∞ (List ∞ A)\n    castLL
  x = x\n\n    -- Stream should be antitone in the first and monotone in the second
  argument\n    -- (even with field `tail' missing).\n\n    record Stream (i : Size)
  (A : Set) : Set where\n      coinductive\n      field\n        head : A\n\n    castSS
  : ∀{i A} → Stream ∞ (Stream ∞ A) → Stream i (Stream i A)\n    castSS x = x\n\n*
  SIZELT lambdas must be consistent [Issue 1523, see Abel and Pientka, ICFP 2013].\n
  \ When lambda-abstracting over type (Size< size) then size must be\n  non-zero,
  for any valid instantiation of size variables.\n\n  The good:\n\n      data Nat
  (i : Size) : Set where\n        zero : ∀ (j : Size< i) → Nat i\n        suc  : ∀
  (j : Size< i) → Nat j → Nat i\n\n      {-# TERMINATING #-}\n      -- This definition
  is fine, the termination checker is too strict at the moment.\n      fix : ∀ {C
  : Size → Set}\n         → (∀ i → (∀ (j : Size< i) → Nat j -> C j) → Nat i → C i)\n
  \        → ∀ i → Nat i → C i\n      fix t i (zero j)  = t i (λ (k : Size< i) → fix
  t k) (zero j)\n      fix t i (suc j n) = t i (λ (k : Size< i) → fix t k) (suc j
  n)\n\n    The λ (k : Size< i) is fine in both cases, as context\n\n      i : Size,
  j : Size< i\n\n    guarantees that i is non-zero.\n\n  The bad:\n\n      record
  Stream {i : Size} (A : Set) : Set where\n        coinductive\n        constructor
  _∷ˢ_\n        field\n          head  : A\n          tail  : ∀ {j : Size< i} → Stream
  {j} A\n      open Stream public\n\n      _++ˢ_ : ∀ {i A} → List A → Stream {i} A
  → Stream {i} A\n      []        ++ˢ s = s\n      (a ∷ as)  ++ˢ s = a ∷ˢ (as ++ˢ
  s)\n\n    This fails, maybe unjustified, at\n\n      i : Size, s : Stream {i} A\n
  \       ⊢\n          a ∷ˢ (λ {j : Size< i} → as ++ˢ s)\n\n    Fixed by defining
  the constructor by copattern matching:\n\n      record Stream {i : Size} (A : Set)
  : Set where\n        coinductive\n        field\n          head  : A\n          tail
  \ : ∀ {j : Size< i} → Stream {j} A\n      open Stream public\n\n      _∷ˢ_ : ∀ {i
  A} → A → Stream {i} A → Stream {↑ i} A\n      head  (a ∷ˢ as) = a\n      tail  (a
  ∷ˢ as) = as\n\n      _++ˢ_ : ∀ {i A} → List A → Stream {i} A → Stream {i} A\n      []
  \       ++ˢ s = s\n      (a ∷ as)  ++ˢ s = a ∷ˢ (as ++ˢ s)\n\n  The ugly:\n\n      fix
  : ∀ {C : Size → Set}\n         → (∀ i → (∀ (j : Size< i) → C j) → C i)\n         →
  ∀ i → C i\n      fix t i = t i λ (j : Size< i) → fix t j\n\n   For i=0, there is
  no such j at runtime, leading to looping\n   behavior.\n\nInteraction\n===========\n\n*
  Issue 635 has been fixed.  Case splitting does not spit out implicit\n  record patterns
  any more.\n\n    record Cont : Set₁ where\n      constructor _◃_\n      field\n
  \       Sh  : Set\n        Pos : Sh → Set\n\n    open Cont\n\n    data W (C : Cont)
  : Set where\n      sup : (s : Sh C) (k : Pos C s → W C) → W C\n\n    bogus : {C
  : Cont} → W C → Set\n    bogus w = {!w!}\n\n  Case splitting on w yielded, since
  the fix of issue 473,\n\n    bogus {Sh ◃ Pos} (sup s k) = ?\n\n  Now it gives, as
  expected,\n\n    bogus (sup s k) = ?\n\nPerformance\n===========\n\n* As one result
  of the 21st Agda Implementor's Meeting (AIM XXI),\n  serialization of the standard
  library is 50% faster (time reduced by\n  a third), without using additional disk
  space for the interface\n  files.\n\n\nBug fixes\n=========\n\n* Issues fixed (
  see https://github.com/agda/agda/issues ):\n  1546 (copattern matching and with-clauses)\n
  \ 1560 (positivity checker inefficiency)\n  1584 (let pattern with trailing implicit)\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2.3\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.2.2:\n\nInstallation and infrastructure\n===============================\n\n*
  Added support for GHC 7.10.1.\n\n* Removed support for GHC 7.0.4.\n\nLanguage\n========\n\n*
  _ is no longer a valid name for a definition.  The following fails now:\n  [Issue
  1465]\n\n    postulate _ : Set\n\n* Typed bindings can now contain hiding information
  [Issue 1391].\n  This means you can now write\n\n    assoc : (xs {ys zs} : List
  A) → ((xs ++ ys) ++ zs) ≡ (xs ++ (ys ++ zs))\n\n  instead of the longer\n\n    assoc
  : (xs : List A) {ys zs : List A} → ...\n\n  It also works with irrelevance\n\n    .(xs
  {ys zs} : List A) → ...\n\n  but of course does not make sense if there is hiding
  information already.\n  Thus, this is (still) a parse error:\n\n    {xs {ys zs}
  : List A} → ...\n\n* The builtins for sized types no longer need accompanying postulates.\n
  \ The BUILTIN pragmas for size stuff now also declare the identifiers\n  they bind
  to.\n\n    {-# BUILTIN SIZEUNIV SizeUniv #-}  --  SizeUniv : SizeUniv\n    {-# BUILTIN
  SIZE     Size     #-}  --  Size     : SizeUniv\n    {-# BUILTIN SIZELT   Size<_
  \  #-}  --  Size<_   : ..Size → SizeUniv\n    {-# BUILTIN SIZESUC  ↑_       #-}
  \ --  ↑_       : Size → Size\n    {-# BUILTIN SIZEINF  ∞        #-}  --  ∞       :
  Size\n\n  Size and Size< now live in the new universe SizeUniv.\n  It is forbidden
  to build function spaces in this universe,\n  in order to prevent the malicious
  assumption of a size predecessor\n\n    pred : (i : Size) → Size< i\n\n  [Issue
  1428].\n\n* Unambiguous notations (coming from syntax declarations) that resolve\n
  \ to ambiguous names are now parsed unambiguously [Issue 1194].\n\n* If only some
  instances of an overloaded name have a given\n  associated notation (coming from
  syntax declarations), then this\n  name can only be resolved to the given instances
  of the\n  name, not to other instances [Issue 1194].\n\n  Previously, if different
  instances of an overloaded name had\n  /different/ associated notations, then none
  of the notations could\n  be used. Now all of them can be used.\n\n  Note that notation
  identity does not only involve the right-hand\n  side of the syntax declaration.
  For instance, the following\n  notations are not seen as identical, because the
  implicit argument\n  names are different:\n\n    module A where\n\n      data D
  : Set where\n        c : {x y : D} → D\n\n      syntax c {x = a} {y = b} = a ∙ b\n\n
  \   module B where\n\n      data D : Set where\n        c : {y x : D} → D\n\n      syntax
  c {y = a} {x = b} = a ∙ b\n\n* If an overloaded operator is in scope with at least
  two distinct\n  fixities, then it gets the default fixity [Issue 1436].\n\n  Similarly,
  if two or more identical notations for a given overloaded\n  name are in scope,
  and these notations do not all have the\n  same fixity, then they get the default
  fixity.\n\nType checking\n=============\n\n* Functions of varying arity can now
  have with-clauses and use rewrite.\n  Example:\n\n    NPred : Nat → Set\n    NPred
  0       = Bool\n    NPred (suc n) = Nat → NPred n\n\n    const : Bool → ∀{n} → NPred
  n\n    const b {0}       = b\n    const b {suc n} m = const b {n}\n\n    allOdd
  : ∀ n → NPred n\n    allOdd 0 = true\n    allOdd (suc n) m with even m\n    ...
  | true  = const false\n    ... | false = allOdd n\n\n* Function defined by copattern
  matching can now have with-clauses\n  and use rewrite.  Example:\n\n    {-# OPTIONS
  --copatterns #-}\n\n    record Stream (A : Set) : Set where\n      coinductive\n
  \     constructor delay\n      field\n        force : A × Stream A\n    open Stream\n\n
  \   map : ∀{A B} → (A → B) → Stream A → Stream B\n    force (map f s) with force
  s\n    ... | a , as = f a , map f as\n\n    record Bisim {A B} (R : A → B → Set)
  (s : Stream A) (t : Stream B) : Set where\n      coinductive\n      constructor
  ~delay\n      field\n        ~force : let a , as = force s\n                     b
  , bs = force t\n                 in  R a b × Bisim R as bs\n    open Bisim\n\n    SEq
  : ∀{A} (s t : Stream A) → Set\n    SEq = Bisim (_≡_)\n\n    -- Slightly weird definition
  of symmetry to demonstrate rewrite.\n\n    ~sym' : ∀{A} {s t : Stream A} → SEq s
  t → SEq t s\n    ~force (~sym' {s = s} {t} p) with force s | force t | ~force p\n
  \   ... | a , as | b , bs | r , q rewrite r = refl , ~sym' q\n\n* Instances can
  now be defined by copattern matching. [Issue 1413]\n  The following example extends
  the one in\n  [Abel, Pientka, Thibodeau, Setzer, POPL 2013, Section 2.2]:\n\n    {-#
  OPTIONS --copatterns #-}\n\n    -- The Monad type class\n\n    record Monad (M :
  Set → Set) : Set1 where\n      field\n        return : {A : Set}   → A → M A\n        _>>=_
  \ : {A B : Set} → M A → (A → M B) → M B\n    open Monad {{...}}\n\n    -- The State
  newtype\n\n    record State (S A : Set) : Set where\n      field\n        runState
  : S → A × S\n    open State\n\n    -- State is an instance of Monad\n\n    instance\n
  \     stateMonad : {S : Set} → Monad (State S)\n      runState (return {{stateMonad}}
  a  ) s  = a , s    -- NEW\n      runState (_>>=_  {{stateMonad}} m k) s₀ =          --
  NEW\n        let a , s₁ = runState m s₀\n        in  runState (k a) s₁\n\n    --
  stateMonad fulfills the monad laws\n\n    leftId : {A B S : Set}(a : A)(k : A →
  State S B) →\n      (return a >>= k) ≡ k a\n    leftId a k = refl\n\n    rightId
  : {A B S : Set}(m : State S A) →\n      (m >>= return) ≡ m\n    rightId m = refl\n\n
  \   assoc : {A B C S : Set}(m : State S A)(k : A → State S B)(l : B → State S C)
  →\n       ((m >>= k) >>= l) ≡ (m >>= λ a → k a >>= l)\n    assoc m k l = refl\n\n\nEmacs
  mode\n==========\n\n* The new menu option \"Switch to another version of Agda\"
  tries to do\n  what it says.\n\n* Changed feature: Interactively split result.\n\n
  \ [ This is as before: ]\n  Make-case (C-c C-c) with no variables given tries to
  split on the\n  result to introduce projection patterns.  The hole needs to be of\n
  \ record type, of course.\n\n    test : {A B : Set} (a : A) (b : B) → A × B\n    test
  a b = ?\n\n  Result-splitting ? will produce the new clauses:\n\n    proj₁ (test
  a b) = ?\n    proj₂ (test a b) = ?\n\n  [ This has changed: ]\n  If hole is of function
  type, make-case will introduce only pattern\n  variables (as much as it can).\n\n
  \   testFun : {A B : Set} (a : A) (b : B) → A × B\n    testFun = ?\n\n  Result-splitting
  ? will produce the new clause:\n\n    testFun a b = ?\n\n  A second invocation of
  make-case will then introduce projection patterns.\n\nError messages\n==============\n\n*
  Agda now suggests corrections of misspelled options, e.g.\n\n    {-# OPTIONS\n      --dont-termination-check\n
  \     --without-k\n      --senf-gurke\n      #-}\n\n    Unrecognized options:\n
  \   --dont-termination-check (did you mean --no-termination-check ?)\n    --without-k
  (did you mean --without-K ?)\n    --senf-gurke\n\n  Nothing close to --senf-gurke,
  I am afraid.\n\nCompiler backends\n=================\n\n* The Epic backend has been
  removed [Issue 1481].\n\nBug fixes\n=========\n\n* Fixed bug with unquoteDecl not
  working in instance blocks [Issue 1491].\n\n* Other issues fixed ( see https://code.google.com/p/agda/issues
  )\n  1497\n  1500\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.2.1:\n\nBug fixes\n=========\n\n* Compilation on Windows fixed.\n\n*
  Other issues fixed ( see https://code.google.com/p/agda/issues )\n  1332\n  1353\n
  \ 1360\n  1366\n  1369\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2.1\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.2:\n\nPragmas and options\n===================\n\n* New pragma
  {-# TERMINATING #-} replacing {-# NO_TERMINATION_CHECK #-}\n\n  Complements the
  existing pragma {-# NON_TERMINATING #-}.\n  Skips termination check for the associated
  definitions and marks\n  them as terminating.  Thus, it is a replacement for\n  {-#
  NO_TERMINATION_CHECK #-} with the same semantics.\n\n  You can no longer use pragma
  {-# NO_TERMINATION_CHECK #-} to skip\n  the termination check, but must label your
  definitions as either\n  {-# TERMINATING #-} or {-# NON_TERMINATING #-} instead.\n\n
  \ Note: {-# OPTION --no-termination-check #-} labels all your\n  definitions as
  {-# TERMINATING #-}, putting you in the danger zone\n  of a loop in the type checker.\n\nLanguage\n========\n\n*
  Referring to a local variable shadowed by module opening is now\n  an error.  Previous
  behavior was preferring the local over the\n  imported definitions. [Issue 1266]\n\n
  \ Note that module parameters are locals as well as variables bound by\n  λ, dependent
  function type, patterns, and let.\n\n  Example:\n\n    module M where\n      A =
  Set1\n\n    test : (A : Set) → let open M in A\n\n  The last A produces an error,
  since it could refer to the local\n  variable A or to the definition imported from
  module M.\n\n* `with` on a variable bound by a module telescope or a pattern of
  a\n  parent function is now forbidden.  [Issue 1342]\n\n    data Unit : Set where\n
  \     unit : Unit\n\n    id : (A : Set) → A → A\n    id A a = a\n\n    module M
  (x : Unit) where\n\n      dx : Unit → Unit\n      dx unit = x\n\n      g : ∀ u →
  x ≡ dx u\n      g with x\n      g | unit  = id (∀ u → unit ≡ dx u) ?\n\n  Even though
  this code looks right, Agda complains about the type\n  expression `∀ u → unit ≡
  dx u`.  If you ask Agda what should go\n  there instead, it happily tells you that
  it wants\n  `∀ u → unit ≡ dx u`. In fact what you do not see and Agda\n  will never
  show you is that the two expressions actually differ in\n  the invisible first argument
  to `dx`, which is visible only outside\n  module `M`.  What Agda wants is an invisible
  `unit` after `dx`, but all\n  you can write is an invisible `x` (which is inserted
  behind the\n  scenes).\n\n  To avoid those kinds of paradoxes, `with` is now outlawed
  on module\n  parameters.  This should ensure that the invisible arguments are\n
  \ always exactly the module parameters.\n\n  Since a `where` block is desugared
  as module with pattern variables\n  of the parent clause as module parameters, the
  same strikes you for\n  uses of `with` on pattern variables of the parent function.\n\n
  \   f : Unit → Unit\n    f x = unit\n      where\n        dx : Unit → Unit\n        dx
  unit = x\n\n        g : ∀ u → x ≡ dx u\n        g with x\n        g | unit  = id
  ((u : Unit) → unit ≡ dx u) ?\n\n  The `with` on pattern variable `x` of the parent
  clause `f x = unit`\n  is outlawed now.\n\nType checking\n=============\n\n* Termination
  check failure is now a proper error.\n\n  We no longer continue type checking after
  termination check failures.\n  Use pragmas {-# NON_TERMINATING #-} and {-# NO_TERMINATION_CHECK
  #-}\n  near the offending definitions if you want to do so.\n  Or switch off the
  termination checker altogether with\n  {-# OPTIONS --no-termination-check #-} (at
  your own risk!).\n\n* (Since Agda 2.4.2:) Termination checking --without-K restricts\n
  \ structural descent to arguments ending in data types or `Size`.\n  Likewise, guardedness
  is only tracked when result type is data or\n  record type.\n\n    mutual\n      data
  WOne : Set where wrap : FOne → WOne\n      FOne = ⊥ → WOne\n\n    noo : (X : Set)
  → (WOne ≡ X) → X → ⊥\n    noo .WOne refl (wrap f) = noo FOne iso f\n\n  `noo` is
  rejected since at type `X` the structural descent\n  `f < wrap f` is discounted
  --without-K.\n\n    data Pandora : Set where\n      C : ∞ ⊥ → Pandora\n\n    loop
  : (A : Set) → A ≡ Pandora → A\n    loop .Pandora refl = C (♯ (loop ⊥ foo))\n\n  `loop`
  is rejected since guardedness is not tracked at type `A`\n  --without-K.\n\n  See
  issues 1023, 1264, 1292.\n\nTermination checking\n====================\n\n* The
  termination checker can now recognize simple subterms in dot\n  patterns.\n\n    data
  Subst : (d : Nat) → Set where\n      c₁ : ∀ {d} → Subst d → Subst d\n      c₂ :
  ∀ {d₁ d₂} → Subst d₁ → Subst d₂ → Subst (suc d₁ + d₂)\n\n    postulate\n      comp
  : ∀ {d₁ d₂} → Subst d₁ → Subst d₂ → Subst (d₁ + d₂)\n\n    lookup : ∀ d → Nat →
  Subst d → Set₁\n    lookup d             zero    (c₁ ρ)             = Set\n    lookup
  d             (suc v) (c₁ ρ)             = lookup d v ρ\n    lookup .(suc d₁ + d₂)
  v      (c₂ {d₁} {d₂} ρ σ) = lookup (d₁ + d₂) v (comp ρ σ)\n\n  The dot pattern here
  is actually normalized, so it is\n\n    suc (d₁ + d₂)\n\n  and the corresponding
  recursive call argument is (d₁ + d₂).\n  In such simple cases, Agda can now recognize
  that the pattern is\n  constructor applied to call argument, which is valid descent.\n\n
  \ Note however, that Agda only looks for syntactic equality when\n  identifying
  subterms, since it is not allowed to normalize terms on\n  the rhs during termination
  checking.\n\n  Actually writing the dot pattern has no effect, this works as well,\n
  \ and looks pretty magical... ;-)\n\n    hidden : ∀{d} → Nat → Subst d → Set₁\n
  \   hidden zero    (c₁ ρ)   = Set\n    hidden (suc v) (c₁ ρ)   = hidden v ρ\n    hidden
  v       (c₂ ρ σ) = hidden v (comp ρ σ)\n\nTools\n=====\n\nLaTeX-backend\n-------------\n\n*
  Fixed the issue of identifiers containing operators being typeset with\n  excessive
  math spacing.\n\nBug fixes\n=========\n\n* Issue 1194\n\n* Issue 836:  Fields and
  constructors can be qualified by the\n  record/data *type* as well as by their record/data
  module.\n  This now works also for record/data type imported from\n  parametrized
  modules:\n\n    module M (_ : Set₁) where\n\n      record R : Set₁ where\n        field\n
  \         X : Set\n\n    open M Set using (R)  -- rather than using (module R)\n\n
  \   X : R → Set\n    X = R.X\n\n------------------------------------------------------------------------\n--
  Release notes for Agda version 2.4.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.0.2:\n\nPragmas and options\n===================\n\n* New option:
  --with-K.\n\n  This can be used to override a global --without-K in a file, by\n
  \ adding a pragma {-# OPTIONS --with-K #-}.\n\n* New pragma {-# NON_TERMINATING
  #-}\n\n  This is a safer version of NO_TERMINATION_CHECK which doesn't treat the\n
  \ affected functions as terminating. This means that NON_TERMINATING functions\n
  \ do not reduce during type checking. They do reduce at run-time and when\n  invoking
  C-c C-n at top-level (but not in a hole).\n\nLanguage\n========\n\n* Instance search
  is now more efficient and recursive (see issue 938)\n  (but without termination
  check yet).\n\n  A new keyword `instance' has been introduced (in the style of\n
  \ `abstract' and  `private') which must now be used for every\n  definition/postulate
  that has to be taken into account during instance\n  resolution. For example:\n\n
  \   record RawMonoid (A : Set) : Set where\n      field\n        nil  : A\n        _++_
  : A -> A -> A\n\n    open RawMonoid {{...}}\n\n    instance\n      rawMonoidList
  : {A : Set} -> RawMonoid (List A)\n      rawMonoidList = record { nil = []; _++_
  = List._++_ }\n\n      rawMonoidMaybe : {A : Set} {{m : RawMonoid A}} -> RawMonoid
  (Maybe A)\n      rawMonoidMaybe {A} = record { nil = nothing ; _++_ = catMaybe }\n
  \       where\n          catMaybe : Maybe A -> Maybe A -> Maybe A\n          catMaybe
  nothing mb = mb\n          catMaybe ma nothing = ma\n          catMaybe (just a)
  (just b) = just (a ++ b)\n\n  Moreover, each type of an instance must end in (something
  that reduces\n  to) a named type (e.g. a record, a datatype or a postulate). This\n
  \ allows us to build a simple index structure\n\n    data/record name  -->  possible
  instances\n\n  that speeds up instance search.\n\n  Instance search takes into account
  all local bindings and all global\n  'instance' bindings and the search is recursive.
  For instance,\n  searching for\n\n    ? : RawMonoid (Maybe (List A))\n\n  will consider
  the candidates {rawMonoidList, rawMonoidMaybe}, fail to\n  unify the first one,
  succeeding with the second one\n\n    ? = rawMonoidMaybe {A = List A} {{m = ?m}}
  : RawMonoid (Maybe (List A))\n\n  and continue with goal\n\n    ?m : RawMonoid (List
  A)\n\n  This will then find\n\n    ?m = rawMonoidList {A = A}\n\n  and putting together
  we have the solution.\n\n  Be careful that there is no termination check for now,
  you can easily\n  make Agda loop by declaring the identity function as an instance.
  But\n  it shouldn’t be possible to make Agda loop by only declaring\n  structurally
  recursive instances (whatever that means).\n\n  Additionally:\n\n  * Uniqueness
  of instances is up to definitional equality (see issue 899).\n\n  * Instances of
  the following form are allowed:\n\n        EqSigma : {A : Set} {B : A → Set} {{EqA
  : Eq A}}\n                  {{EqB : {a : A} → Eq (B a)}}\n                  → Eq
  (Σ A B)\n\n    When searching recursively for an instance of type\n    `{a : A}
  → Eq (B a)', a lambda will automatically be introduced and\n    instance search
  will search for something of type `Eq (B a)' in\n    the context extended by `a
  : A'. When searching for an instance, the\n    `a' argument does not have to be
  implicit, but in the definition of\n    EqSigma, instance search will only be able
  to use EqB if `a' is implicit.\n\n  * There is no longer any attempt to solve irrelevant
  metas by instance\n    search.\n\n  * Constructors of records and datatypes are
  automatically added to the\n    instance table.\n\n* You can now use 'quote' in
  patterns.\n\n  For instance, here is a function that unquotes a (closed) natural
  number\n  term.\n\n    unquoteNat : Term → Maybe Nat\n    unquoteNat (con (quote
  Nat.zero) [])            = just zero\n    unquoteNat (con (quote Nat.suc) (arg _
  n ∷ [])) = fmap suc (unquoteNat n)\n    unquoteNat _                                    =
  nothing\n\n* The builtin constructors AGDATERMUNSUPPORTED and AGDASORTUNSUPPORTED
  are now\n  translated to meta variables when unquoting.\n\n* New syntactic sugar
  'tactic e' and 'tactic e | e1 | .. | en'.\n\n  It desugars as follows and makes
  it less unwieldy to call reflection-based\n  tactics.\n\n    tactic e                -->
  quoteGoal g in unquote (e g)\n    tactic e | e1 | .. | en --> quoteGoal g in unquote
  (e g) e1 .. en\n\n  Note that in the second form the tactic function should generate
  a function\n  from a number of new subgoals to the original goal. The type of e
  should be\n  Term -> Term in both cases.\n\n* New reflection builtins for literals.\n\n
  \ The Term data type AGDATERM now needs an additional constructor AGDATERMLIT\n
  \ taking a reflected literal defined as follows (with appropriate builtin\n  bindings
  for the types Nat, Float, etc).\n\n    data Literal : Set where\n      nat    :
  Nat    → Literal\n      float  : Float  → Literal\n      char   : Char   → Literal\n
  \     string : String → Literal\n      qname  : QName  → Literal\n\n    {-# BUILTIN
  AGDALITERAL   Literal #-}\n    {-# BUILTIN AGDALITNAT    nat     #-}\n    {-# BUILTIN
  AGDALITFLOAT  float   #-}\n    {-# BUILTIN AGDALITCHAR   char    #-}\n    {-# BUILTIN
  AGDALITSTRING string  #-}\n    {-# BUILTIN AGDALITQNAME  qname   #-}\n\n  When quoting
  (quoteGoal or quoteTerm) literals will be mapped to the\n  AGDATERMLIT constructor.
  Previously natural number literals were quoted\n  to suc/zero application and other
  literals were quoted to\n  AGDATERMUNSUPPORTED.\n\n* New reflection builtins for
  function definitions.\n\n  AGDAFUNDEF should now map to a data type defined as follows\n
  \ (with {-# BUILTIN QNAME       QName   #-}\n        {-# BUILTIN ARG         Arg
  \    #-}\n        {-# BUILTIN AGDATERM    Term    #-}\n        {-# BUILTIN AGDATYPE
  \   Type    #-}\n        {-# BUILTIN AGDALITERAL Literal #-}).\n\n    data Pattern
  : Set where\n      con    : QName → List (Arg Pattern) → Pattern\n      dot    :
  Pattern\n      var    : Pattern\n      lit    : Literal → Pattern\n      proj   :
  QName → Pattern\n      absurd : Pattern\n\n    {-# BUILTIN AGDAPATTERN   Pattern
  #-}\n    {-# BUILTIN AGDAPATCON    con     #-}\n    {-# BUILTIN AGDAPATDOT    dot
  \    #-}\n    {-# BUILTIN AGDAPATVAR    var     #-}\n    {-# BUILTIN AGDAPATLIT
  \   lit     #-}\n    {-# BUILTIN AGDAPATPROJ   proj    #-}\n    {-# BUILTIN AGDAPATABSURD
  absurd  #-}\n\n    data Clause : Set where\n      clause        : List (Arg Pattern)
  → Term → Clause\n      absurd-clause : List (Arg Pattern) → Clause\n\n    {-# BUILTIN
  AGDACLAUSE       Clause        #-}\n    {-# BUILTIN AGDACLAUSECLAUSE clause        #-}\n
  \   {-# BUILTIN AGDACLAUSEABSURD absurd-clause #-}\n\n    data FunDef : Set where\n
  \     fun-def : Type → List Clause → FunDef\n\n    {-# BUILTIN AGDAFUNDEF    FunDef
  \ #-}\n    {-# BUILTIN AGDAFUNDEFCON fun-def #-}\n\n* New reflection builtins for
  extended (pattern-matching) lambda.\n\n  The AGDATERM data type has been augmented
  with a constructor\n\n    AGDATERMEXTLAM : List AGDACLAUSE → List (ARG AGDATERM)
  → AGDATERM\n\n  Absurd lambdas (λ ()) are quoted to extended lambdas with an absurd
  clause.\n\n* Unquoting declarations.\n\n  You can now define (recursive) functions
  by reflection using the new\n  unquoteDecl declaration\n\n    unquoteDecl x = e\n\n
  \ Here e should have type AGDAFUNDEF and evaluate to a closed value. This value\n
  \ is then spliced in as the definition of x. In the body e, x has type QNAME\n  which
  lets you splice in recursive definitions.\n\n  Standard modifiers, such as fixity
  declarations, can be applied to x as\n  expected.\n\n* Quoted levels\n\n  Universe
  levels are now quoted properly instead of being quoted to\n  AGDASORTUNSUPPORTED.
  Setω  still gets an unsupported sort, however.\n\n* Module applicants can now be
  operator applications. Example:\n\n    postulate\n      [_] : A -> B\n\n    module
  M (b : B) where\n\n    module N (a : A) = M [ a ]\n\n  [See Issue 1245.]\n\n* Minor
  change in module application semantics. [Issue 892]\n\n  Previously re-exported
  functions were not redefined when instantiating a\n  module. For instance\n\n    module
  A where f = ...\n    module B (X : Set) where\n      open A public\n    module C
  = B Nat\n\n  In this example C.f would be an alias for A.f, so if both A and C were
  opened\n  f would not be ambiguous. However, this behaviour is not correct when
  A and B\n  share some module parameters (issue 892). To fix this C now defines its
  own\n  copy of f (which evaluates to A.f), which means that opening A and C results\n
  \ in an ambiguous f.\n\nType checking\n=============\n\n* Recursive records need
  to be declared as either inductive or coinductive.\n  'inductive' is no longer default
  for recursive records.\n  Examples:\n\n    record _×_ (A B : Set) : Set where\n
  \     constructor _,_\n      field\n        fst : A\n        snd : B\n\n    record
  Tree (A : Set) : Set where\n      inductive\n      constructor tree\n      field\n
  \       elem     : A\n        subtrees : List (Tree A)\n\n    record Stream (A :
  Set) : Set where\n      coinductive\n      constructor _::_\n      field\n        head
  : A\n        tail : Stream A\n\n  If you are using old-style (musical) coinduction,
  a record may have\n  to be declared as inductive, paradoxically.\n\n    record Stream
  (A : Set) : Set where\n      inductive -- YES, THIS IS INTENDED !\n      constructor
  _∷_\n      field\n        head : A\n        tail : ∞ (Stream A)\n\n  This is because
  the ``coinduction'' happens in the use of `∞' and not\n  in the use of `record'.\n\nTools\n=====\n\nEmacs
  mode\n----------\n\n* A new menu option \"Display\" can be used to display the version
  of\n  the running Agda process.\n\nLaTeX-backend\n-------------\n\n* New experimental
  option ``references'' has been added. When specified,\n  i.e.:\n\n      \\usepackage[references]{agda}\n\n
  \ a new command called \\AgdaRef is provided, which lets you reference\n  previously
  typeset commands, e.g.:\n\n      Let us postulate \\AgdaRef{apa}.\n\n      \\begin{code}\n
  \     postulate\n        apa : Set\n      \\end{code}\n\n  Above ``apa'' will be
  typeset (highlighted) the same in the text as in\n  the code, provided that the
  LaTeX output is post-processed using\n  src/data/postprocess-latex.pl, e.g.:\n\n
  \   cp $(dirname $(dirname $(agda-mode locate)))/postprocess-latex.pl .\n    agda
  -i. --latex Example.lagda\n    cd latex/\n    perl ../postprocess-latex.pl Example.tex
  > Example.processed\n    mv Example.processed Example.tex\n    xelatex Example.tex\n\n
  \ Mix-fix and unicode should work as expected (unicode requires\n  XeLaTeX/LuaLaTeX),
  but there are limitations:\n\n    + Overloading identifiers should be avoided, if
  multiples exist\n      \\AgdaRef will typeset according to the first it finds.\n\n
  \   + Only the current module is used, should you need to reference\n      identifiers
  in other modules then you need to specify which other\n      module manually, i.e.
  \\AgdaRef[module]{identifier}.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.4.0.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.0.1:\n\n* The Agda input mode now supports alphabetical super
  and subscripts,\n  in addition to the numerical ones that were already present.\n
  \ [Issue 1240]\n\n* New feature: Interactively split result.\n\n  Make case (C-c
  C-c) with no variables given tries to split on the\n  result to introduce projection
  patterns.  The hole needs to be of\n  record type, of course.\n\n    test : {A B
  : Set} (a : A) (b : B) → A × B\n    test a b = ?\n\n  Result-splitting ? will produce
  the new clauses:\n\n    proj₁ (test a b) = ?\n    proj₂ (test a b) = ?\n\n  If hole
  is of function type ending in a record type, the necessary\n  pattern variables
  will be introduced before the split.  Thus, the\n  same result can be obtained by
  starting from:\n\n    test : {A B : Set} (a : A) (b : B) → A × B\n    test = ?\n\n*
  The so far undocumented ETA pragma now throws an error if applied to\n  definitions
  that are not records.\n\n  ETA can be used to force eta-equality at recursive record
  types,\n  for which eta is not enabled automatically by Agda.\n  Here is such an
  example:\n\n    mutual\n      data Colist (A : Set) : Set where\n        [] : Colist
  A\n        _∷_ : A → ∞Colist A → Colist A\n\n      record ∞Colist (A : Set) : Set
  where\n        coinductive\n        constructor delay\n        field       force
  : Colist A\n\n    open ∞Colist\n\n    {-# ETA ∞Colist #-}\n\n    test : {A : Set}
  (x : ∞Colist A) → x ≡ delay (force x)\n    test x = refl\n\n  Note:  Unsafe use
  of ETA can make Agda loop, e.g. by triggering\n  infinite eta expansion!\n\n* Bugs
  fixed (see https://code.google.com/p/agda/issues):\n  1203\n  1205\n  1209\n  1213\n
  \ 1214\n  1216\n  1225\n  1226\n  1231\n  1233\n  1239\n  1241\n  1243\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.4.0.1\n------------------------------------------------------------------------\n\nImportant
  changes since 2.4.0:\n\n* The option --compile-no-main has been renamed to --no-main.\n\n*
  COMPILED_DATA pragmas can now be given for records.\n\n* Various bug fixes.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.4.0\n------------------------------------------------------------------------\n\nImportant
  changes since 2.3.2.2:\n\nInstallation and infrastructure\n===============================\n\n*
  A new module called Agda.Primitive has been introduced. This module\n  is available
  to all users, even if the standard library is not used.\n  Currently the module
  contains level primitives and their\n  representation in Haskell when compiling
  with MAlonzo:\n\n    infixl 6 _⊔_\n\n    postulate\n      Level : Set\n      lzero
  : Level\n      lsuc  : (ℓ : Level) → Level\n      _⊔_   : (ℓ₁ ℓ₂ : Level) → Level\n\n
  \   {-# COMPILED_TYPE Level ()      #-}\n    {-# COMPILED lzero ()           #-}\n
  \   {-# COMPILED lsuc  (\\_ -> ())   #-}\n    {-# COMPILED _⊔_   (\\_ _ -> ()) #-}\n\n
  \   {-# BUILTIN LEVEL     Level  #-}\n    {-# BUILTIN LEVELZERO lzero  #-}\n    {-#
  BUILTIN LEVELSUC  lsuc   #-}\n    {-# BUILTIN LEVELMAX  _⊔_    #-}\n\n  To bring
  these declarations into scope you can use a declaration\n  like the following one:\n\n
  \   open import Agda.Primitive using (Level; lzero; lsuc; _⊔_)\n\n  The standard
  library reexports these primitives (using the names\n  zero and suc instead of lzero
  and lsuc) from the Level module.\n\n  Existing developments using universe polymorphism
  might now trigger\n  the following error message:\n\n    Duplicate binding for built-in
  thing LEVEL, previous binding to\n    .Agda.Primitive.Level\n\n  To fix this problem,
  please remove the duplicate bindings.\n\n  Technical details (perhaps relevant to
  those who build Agda\n  packages):\n\n  The include path now always contains a directory
  <DATADIR>/lib/prim,\n  and this directory is supposed to contain a subdirectory
  Agda\n  containing a file Primitive.agda.\n\n  The standard location of <DATADIR>
  is system- and\n  installation-specific.  E.g., in a cabal --user installation of\n
  \ Agda-2.3.4 on a standard single-ghc Linux system it would be\n  $HOME/.cabal/share/Agda-2.3.4
  or something similar.\n\n  The location of the <DATADIR> directory can be configured
  at\n  compile-time using Cabal flags (--datadir and --datasubdir).\n  The location
  can also be set at run-time, using the Agda_datadir\n  environment variable.\n\nPragmas
  and options\n===================\n\n* Pragma NO_TERMINATION_CHECK placed within
  a mutual block is now\n  applied to the whole mutual block (rather than being discarded\n
  \ silently).  Adding to the uses 1.-4. outlined in the release notes\n  for 2.3.2
  we allow:\n\n  3a. Skipping an old-style mutual block: Somewhere within 'mutual'\n
  \     block before a type signature or first function clause.\n\n       mutual\n
  \        {-# NO_TERMINATION_CHECK #-}\n         c : A\n         c = d\n\n         d
  : A\n         d = c\n\n* New option --no-pattern-matching\n\n  Disables all forms
  of pattern matching (for the current file).\n  You can still import files that use
  pattern matching.\n\n* New option -v profile:7\n\n  Prints some stats on which phases
  Agda spends how much time.\n  (Number might not be very reliable, due to garbage
  collection\n  interruptions, and maybe due to laziness of Haskell.)\n\n* New option
  --no-sized-types\n\n  Option --sized-types is now default.\n  --no-sized-types will
  turn off an extra (inexpensive) analysis on\n  data types used for subtyping of
  sized types.\n\nLanguage\n========\n\n* Experimental feature: quoteContext\n\n  There
  is a new keyword 'quoteContext' that gives users access to the\n  list of names
  in the current local context. For instance:\n\n    open import Data.Nat\n    open
  import Data.List\n    open import Reflection\n\n    foo : ℕ → ℕ → ℕ\n    foo 0 m
  = 0\n    foo (suc n) m = quoteContext xs in ?\n\n  In the remaining goal, the list
  xs will consist of two names, n and\n  m, corresponding to the two local variables.
  At the moment it is not\n  possible to access let bound variables -- this feature
  may be added\n  in the future.\n\n* Experimental feature: Varying arity.\n  Function
  clauses may now have different arity, e.g.,\n\n    Sum : ℕ → Set\n    Sum 0       =
  ℕ\n    Sum (suc n) = ℕ → Sum n\n\n    sum : (n : ℕ) → ℕ → Sum n\n    sum 0       acc
  \  = acc\n    sum (suc n) acc m = sum n (m + acc)\n\n  or,\n\n    T : Bool → Set\n
  \   T true  = Bool\n    T false = Bool → Bool\n\n    f : (b : Bool) → T b\n    f
  false true  = false\n    f false false = true\n    f true = true\n\n  This feature
  is experimental.  Yet unsupported:\n  * Varying arity and 'with'.\n  * Compilation
  of functions with varying arity to Haskell, JS, or Epic.\n\n* Experimental feature:
  copatterns.  (Activated with option --copatterns)\n\n  We can now define a record
  by explaining what happens if you project\n  the record.  For instance:\n\n    {-#
  OPTIONS --copatterns #-}\n\n    record _×_ (A B : Set) : Set where\n      constructor
  _,_\n      field\n        fst : A\n        snd : B\n    open _×_\n\n    pair : {A
  B : Set} → A → B → A × B\n    fst (pair a b) = a\n    snd (pair a b) = b\n\n    swap
  : {A B : Set} → A × B → B × A\n    fst (swap p) = snd p\n    snd (swap p) = fst
  p\n\n    swap3 : {A B C : Set} → A × (B × C) → C × (B × A)\n    fst (swap3 t)       =
  snd (snd t)\n    fst (snd (swap3 t)) = fst (snd t)\n    snd (snd (swap3 t)) = fst
  t\n\n  Taking a projection on the left hand side (lhs) is called a\n  projection
  pattern, applying to a pattern is called an application\n  pattern.  (Alternative
  terms: projection/application copattern.)\n\n  In the first example, the symbol
  'pair', if applied to variable\n  patterns a and b and then projected via fst, reduces
  to a.\n  'pair' by itself does not reduce.\n\n  A typical application are coinductive
  records such as streams:\n\n    record Stream (A : Set) : Set where\n      coinductive\n
  \     field\n        head : A\n        tail : Stream A\n    open Stream\n\n    repeat
  : {A : Set} (a : A) -> Stream A\n    head (repeat a) = a\n    tail (repeat a) =
  repeat a\n\n  Again, 'repeat a' by itself will not reduce, but you can take\n  a
  projection (head or tail) and then it will reduce to the\n  respective rhs.  This
  way, we get the lazy reduction behavior\n  necessary to avoid looping corecursive
  programs.\n\n  Application patterns do not need to be trivial (i.e., variable\n
  \ patterns), if we mix with projection patterns.  E.g., we can have\n\n    nats
  : Nat -> Stream Nat\n    head (nats zero) = zero\n    tail (nats zero) = nats zero\n
  \   head (nats (suc x)) = x\n    tail (nats (suc x)) = nats x\n\n  Here is an example
  (not involving coinduction) which demostrates\n  records with fields of function
  type:\n\n    -- The State monad\n\n    record State (S A : Set) : Set where\n      constructor
  state\n      field\n        runState : S → A × S\n    open State\n\n    -- The Monad
  type class\n\n    record Monad (M : Set → Set) : Set1 where\n      constructor monad\n
  \     field\n        return : {A : Set}   → A → M A\n        _>>=_  : {A B : Set}
  → M A → (A → M B) → M B\n\n\n    -- State is an instance of Monad\n    -- Demonstrates
  the interleaving of projection and application patterns\n\n    stateMonad : {S :
  Set} → Monad (State S)\n    runState (Monad.return stateMonad a  ) s  = a , s\n
  \   runState (Monad._>>=_  stateMonad m k) s₀ =\n      let a , s₁ = runState m s₀\n
  \     in  runState (k a) s₁\n\n    module MonadLawsForState {S : Set} where\n\n
  \     open Monad (stateMonad {S})\n\n      leftId : {A B : Set}(a : A)(k : A → State
  S B) →\n        (return a >>= k) ≡ k a\n      leftId a k = refl\n\n      rightId
  : {A B : Set}(m : State S A) →\n        (m >>= return) ≡ m\n      rightId m = refl\n\n
  \     assoc : {A B C : Set}(m : State S A)(k : A → State S B)(l : B → State S C)
  →\n        ((m >>= k) >>= l) ≡ (m >>= λ a → (k a >>= l))\n      assoc m k l = refl\n\n
  \ Copatterns are yet experimental and the following does not work:\n\n  * Copatterns
  and 'with' clauses.\n\n  * Compilation of copatterns to Haskell, JS, or Epic.\n\n
  \ * Projections generated by\n      open R {{...}}\n    are not handled properly
  on lhss yet.\n\n  * Conversion checking is slower in the presence of copatterns,\n
  \   since stuck definitions of record type do no longer count\n    as neutral, since
  they can become unstuck by applying a projection.\n    Thus, comparing two neutrals
  currently requires comparing all\n    they projections, which repeats a lot of work.\n\n*
  Top-level module no longer required.\n\n  The top-level module can be omitted from
  an Agda file. The module name is\n  then inferred from the file name by dropping
  the path and the .agda\n  extension. So, a module defined in /A/B/C.agda would get
  the name C.\n\n  You can also suppress only the module name of the top-level module
  by writing\n\n    module _ where\n\n  This works also for parameterised modules.\n\n*
  Module parameters are now always hidden arguments in projections.\n  For instance:\n\n
  \   module M (A : Set) where\n\n      record Prod (B : Set) : Set where\n        constructor
  _,_\n        field\n          fst : A\n          snd : B\n      open Prod public\n\n
  \   open M\n\n  Now, the types of fst and snd are\n\n    fst : {A : Set}{B : Set}
  → Prod A B → A\n    snd : {A : Set}{B : Set} → Prod A B → B\n\n  Until 2.3.2, they
  were\n\n    fst : (A : Set){B : Set} → Prod A B → A\n    snd : (A : Set){B : Set}
  → Prod A B → B\n\n  This change is a step towards symmetry of constructors and projections.\n
  \ (Constructors always took the module parameters as hidden arguments).\n\n* Telescoping
  lets: Local bindings are now accepted in telescopes\n  of modules, function types,
  and lambda-abstractions.\n\n  The syntax of telescopes as been extended to support
  'let':\n\n    id : (let ★ = Set) (A : ★) → A → A\n    id A x = x\n\n  In particular
  one can now 'open' modules inside telescopes:\n\n   module Star where\n     ★ :
  Set₁\n     ★ = Set\n\n   module MEndo (let open Star) (A : ★) where\n     Endo :
  ★\n     Endo = A → A\n\n  Finally a shortcut is provided for opening modules:\n\n
  \   module N (open Star) (A : ★) (open MEndo A) (f : Endo) where\n      ...\n\n
  \ The semantics of the latter is\n\n    module _ where\n      open Star\n      module
  _ (A : ★) where\n        open MEndo A\n        module N (f : Endo) where\n          ...\n\n
  \ The semantics of telescoping lets in function types and lambda\n  abstractions
  is just expanding them into ordinary lets.\n\n* More liberal left-hand sides in
  lets [Issue 1028]:\n\n    You can now write left-hand sides with arguments also
  for let bindings\n    without a type signature. For instance,\n\n      let f x =
  suc x in f zero\n\n    Let bound functions still can't do pattern matching though.\n\n*
  Ambiguous names in patterns are now optimistically resolved in favor\n  of constructors.
  [Issue 822] In particular, the following succeeds now:\n\n    module M where\n\n
  \     data D : Set₁ where\n        [_] : Set → D\n\n    postulate [_] : Set → Set\n\n
  \   open M\n\n    Foo : _ → Set\n    Foo [ A ] = A\n\n* Anonymous where-modules
  are opened public. [Issue 848]\n\n    <clauses>\n    f args = rhs\n      module
  _ telescope where\n        body\n    <more clauses>\n\n  means the following (not
  proper Agda code, since you cannot put a\n  module in-between clauses)\n\n    <clauses>\n
  \   module _ {arg-telescope} telescope where\n      body\n\n    f args = rhs\n    <more
  clauses>\n\n  Example:\n\n    A : Set1\n    A = B module _ where\n      B : Set1\n
  \     B = Set\n\n    C : Set1\n    C = B\n\n* Builtin ZERO and SUC have been merged
  with NATURAL.\n\n  When binding the NATURAL builtin, ZERO and SUC are bound to the
  appropriate\n  constructors automatically. This means that instead of writing\n\n
  \   {-# BUILTIN NATURAL Nat #-}\n    {-# BUILTIN ZERO zero #-}\n    {-# BUILTIN
  SUC suc #-}\n\n  you just write\n\n    {-# BUILTIN NATURAL Nat #-}\n\n* Pattern
  synonym can now have implicit arguments. [Issue 860]\n\n  For example,\n\n    pattern
  tail=_ {x} xs = x ∷ xs\n\n    len : ∀ {A} → List A → Nat\n    len []         = 0\n
  \   len (tail= xs) = 1 + len xs\n\n* Syntax declarations can now have implicit arguments.
  [Issue 400]\n\n  For example\n\n    id : ∀ {a}{A : Set a} -> A -> A\n    id x =
  x\n\n    syntax id {A} x = x ∈ A\n\n* Minor syntax changes\n\n  * -} is now parsed
  as end-comment even if no comment was begun.\n    As a consequence, the following
  definition gives a parse error\n\n      f : {A- : Set} -> Set\n      f {A-} = A-\n\n
  \   because Agda now sees ID(f) LBRACE ID(A) END-COMMENT, and no\n    longer ID(f)
  LBRACE ID(A-) RBRACE.\n\n    The rational is that the previous lexing was to context-sensitive,\n
  \   attempting to comment-out f using {- and -} lead to a parse error.\n\n  * Fixities
  (binding strengths) can now be negative numbers as\n    well. [Issue 1109]\n\n      infix
  -1 _myop_\n\n  * Postulates are now allowed in mutual blocks. [Issue 977]\n\n  *
  Empty where blocks are now allowed. [Issue 947]\n\n  * Pattern synonyms are now
  allowed in parameterised modules. [Issue 941]\n\n  * Empty hiding and renaming lists
  in module directives are now allowed.\n\n  * Module directives using, hiding, renaming
  and public can now appear in\n    arbitrary order. Multiple using/hiding/renaming
  directives are allowed, but\n    you still cannot have both using and hiding (because
  that doesn't make\n    sense). [Issue 493]\n\nGoal and error display\n======================\n\n*
  The error message \"Refuse to construct infinite term\" has been\n  removed, instead
  one gets unsolved meta variables.  Reason: the\n  error was thrown over-eagerly.
  [Issue 795]\n\n* If an interactive case split fails with message\n\n    Since goal
  is solved, further case distinction is not supported;\n    try `Solve constraints'
  instead\n\n  then the associated interaction meta is assigned to a solution.\n  Press
  C-c C-= (Show constraints) to view the solution and C-c C-s\n  (Solve constraints)
  to apply it. [Issue 289]\n\nType checking\n=============\n\n* [ issue 376 ] Implemented
  expansion of bound record variables during meta assignment.\n  Now Agda can solve
  for metas X that are applied to projected variables, e.g.:\n\n    X (fst z) (snd
  z) = z\n\n    X (fst z)         = fst z\n\n  Technically, this is realized by substituting
  (x , y) for z with fresh\n  bound variables x and y.  Here the full code for the
  examples:\n\n    record Sigma (A : Set)(B : A -> Set) : Set where\n      constructor
  _,_\n      field\n        fst : A\n        snd : B fst\n    open Sigma\n\n    test
  : (A : Set) (B : A -> Set) ->\n      let X : (x : A) (y : B x) -> Sigma A B\n          X
  = _\n      in  (z : Sigma A B) -> X (fst z) (snd z) ≡ z\n    test A B z = refl\n\n
  \   test' : (A : Set) (B : A -> Set) ->\n      let X : A -> A\n          X = _\n
  \     in  (z : Sigma A B) -> X (fst z) ≡ fst z\n    test' A B z = refl\n\n  The
  fresh bound variables are named fst(z) and snd(z) and can appear\n  in error messages,
  e.g.:\n\n    fail : (A : Set) (B : A -> Set) ->\n      let X : A -> Sigma A B\n
  \         X = _\n      in  (z : Sigma A B) -> X (fst z) ≡ z\n    fail A B z = refl\n\n
  \ results in error:\n\n    Cannot instantiate the metavariable _7 to solution fst(z)
  , snd(z)\n    since it contains the variable snd(z) which is not in scope of the\n
  \   metavariable or irrelevant in the metavariable but relevant in the\n    solution\n
  \   when checking that the expression refl has type _7 A B (fst z) ≡ z\n\n* Dependent
  record types and definitions by copatterns require\n  reduction with previous function
  clauses while checking the\n  current clause. [Issue 907]\n\n  For a simple example,
  consider\n\n    test : ∀ {A} → Σ Nat λ n → Vec A n\n    proj₁ test = zero\n    proj₂
  test = []\n\n  For the second clause, the lhs and rhs are typed as\n\n    proj₂
  test : Vec A (proj₁ test)\n    []         : Vec A zero\n\n  In order for these types
  to match, we have to reduce the lhs type\n  with the first function clause.\n\n
  \ Note that termination checking comes after type checking, so be\n  careful to
  avoid non-termination!  Otherwise, the type checker\n  might get into an infinite
  loop.\n\n* The implementation of the primitive primTrustMe has changed.\n  It now
  only reduces to REFL if the two arguments x and y have\n  the same computational
  normal form.  Before, it reduced when\n  x and y were definitionally equal, which
  included type-directed\n  equality laws such as eta-equality.  Yet because reduction
  is\n  untyped, calling conversion from reduction lead to Agda crashes\n  [Issue
  882].\n\n  The amended description of primTrustMe is (cf. release notes for 2.2.6):\n\n
  \   primTrustMe : {A : Set} {x y : A} → x ≡ y\n\n  Here _≡_ is the builtin equality
  (see BUILTIN hooks for equality,\n  above).\n\n  If x and y have the same computational
  normal form, then\n  primTrustMe {x = x} {y = y} reduces to refl.\n\n  A note on
  primTrustMe's runtime behavior:\n  The MAlonzo compiler replaces all uses of primTrustMe
  with the\n  REFL builtin, without any check for definitional equality. Incorrect\n
  \ uses of primTrustMe can potentially lead to segfaults or similar\n  problems of
  the compiled code.\n\n* Implicit patterns of record type are now only eta-expanded
  if there\n  is a record constructor. [Issues 473, 635]\n\n    data D : Set where\n
  \     d : D\n\n    data P : D → Set where\n      p : P d\n\n    record Rc : Set
  where\n      constructor c\n      field f : D\n\n    works : {r : Rc} → P (Rc.f
  r) → Set\n    works p = D\n\n  This works since the implicit pattern {r} is eta-expanded
  to\n  {c x} which allows the type of p to reduce to P x and x to be\n  unified with
  d.  The corresponding explicit version is:\n\n    works' : (r : Rc) → P (Rc.f r)
  → Set\n    works' (c .d) p = D\n\n  However, if the record constructor is removed,
  the same example will\n  fail:\n\n    record R : Set where\n      field f : D\n\n
  \   fails : {r : R} → P (R.f r) → Set\n    fails p = D\n\n    -- d != R.f r of type
  D\n    -- when checking that the pattern p has type P (R.f r)\n\n  The error is
  justified since there is no pattern we could write down\n  for r.  It would have
  to look like\n\n    record { f = .d }\n\n  but anonymous record patterns are not
  part of the language.\n\n* Absurd lambdas at different source locations are no longer\n
  \ different. [Issue 857]\n  In particular, the following code type-checks now:\n\n
  \   absurd-equality : _≡_ {A = ⊥ → ⊥} (λ()) λ()\n    absurd-equality = refl\n\n
  \ Which is a good thing!\n\n* Printing of named implicit function types.\n\n  When
  printing terms in a context with bound variables Agda renames new\n  bindings to
  avoid clashes with the previously bound names. For instance, if A\n  is in scope,
  the type (A : Set) → A is printed as (A₁ : Set) → A₁. However,\n  for implicit function
  types the name of the binding matters, since it can be\n  used when giving implicit
  arguments.\n\n  For this situation, the following new syntax has been introduced:\n
  \ {x = y : A} → B is an implicit function type whose bound variable (in scope\n
  \ in B) is y, but where the name of the argument is x for the purposes of\n  giving
  it explicitly. For instance, with A in scope, the type {A : Set} → A\n  is now printed
  as {A = A₁ : Set} → A₁.\n\n  This syntax is only used when printing and is currently
  not being parsed.\n\n* Changed the semantics of --without-K. [Issue 712, Issue 865,
  Issue 1025]\n\n  New specification of --without-K:\n\n  When --without-K is enabled,
  the unification of indices for pattern matching\n  is restricted in two ways:\n\n
  \ 1. Reflexive equations of the form x == x are no longer solved, instead Agda\n
  \    gives an error when such an equation is encountered.\n\n  2. When unifying
  two same-headed constructor forms 'c us' and 'c vs' of type\n     'D pars ixs',
  the datatype indices ixs (but not the parameters) have to\n     be *self-unifiable*,
  i.e. unification of ixs with itself should succeed\n     positively. This is a nontrivial
  requirement because of point 1.\n\n  Examples:\n\n  * The J rule is accepted.\n\n
  \     J : {A : Set} (P : {x y : A} → x ≡ y → Set) →\n          (∀ x → P (refl x))
  →\n          ∀ {x y} (x≡y : x ≡ y) → P x≡y\n      J P p (refl x) = p x\n\n    This
  definition is accepted since unification of x with y doesn't require\n    deletion
  or injectivity.\n\n  * The K rule is rejected.\n\n      K : {A : Set} (P : {x :
  A} → x ≡ x → Set) →\n          (∀ x → P (refl {x = x})) →\n         ∀ {x} (x≡x :
  x ≡ x) → P x≡x\n      K P p refl = p _\n\n    Definition is rejected with the following
  error:\n\n      Cannot eliminate reflexive equation x = x of type A because K has\n
  \     been disabled.\n      when checking that the pattern refl has type x ≡ x\n\n
  \ * Symmetry of the new criterion.\n\n      test₁ : {k l m : ℕ} → k + l ≡ m → ℕ\n
  \     test₁ refl = zero\n\n      test₂ : {k l m : ℕ} → k ≡ l + m → ℕ\n      test₂
  refl = zero\n\n    Both versions are now accepted (previously only the first one
  was).\n\n  * Handling of parameters.\n\n      cons-injective : {A : Set} (x y :
  A) → (x ∷ []) ≡ (y ∷ []) → x ≡ y\n      cons-injective x .x refl = refl\n\n    Parameters
  are not unified, so they are ignored by the new criterion.\n\n  * A larger example:
  antisymmetry of ≤.\n\n      data _≤_ : ℕ → ℕ → Set where\n        lz : (n : ℕ) →
  zero ≤ n\n        ls : (m n : ℕ) → m ≤ n → suc m ≤ suc n\n\n      ≤-antisym : (m
  n : ℕ) → m ≤ n → n ≤ m → m ≡ n\n      ≤-antisym .zero    .zero    (lz .zero) (lz
  .zero)   = refl\n      ≤-antisym .(suc m) .(suc n) (ls m n p) (ls .n .m q) =\n                   cong
  suc (≤-antisym m n p q)\n\n  * [ Issue 1025 ]\n\n      postulate mySpace : Set\n
  \     postulate myPoint : mySpace\n\n      data Foo : myPoint ≡ myPoint → Set where\n
  \       foo : Foo refl\n\n      test : (i : foo ≡ foo) → i ≡ refl\n      test refl
  = {!!}\n\n    When applying injectivity to the equation \"foo ≡ foo\" of type \"Foo
  refl\",\n    it is checked that the index refl of type \"myPoint ≡ myPoint\" is\n
  \   self-unifiable. The equation \"refl ≡ refl\" again requires injectivity, so\n
  \   now the index myPoint is checked for self-unifiability, hence the error:\n\n
  \     Cannot eliminate reflexive equation myPoint = myPoint of type\n      mySpace
  because K has been disabled.\n      when checking that the pattern refl has type
  foo ≡ foo\n\nTermination checking\n====================\n\n* A buggy facility coined
  \"matrix-shaped orders\" that supported\n  uncurried functions (which take tuples
  of arguments instead of one\n  argument after another) has been removed from the
  termination\n  checker. [Issue 787]\n\n* Definitions which fail the termination
  checker are not unfolded any\n  longer to avoid loops or stack overflows in Agda.
  \ However, the\n  termination checker for a mutual block is only invoked after\n
  \ type-checking, so there can still be loops if you define a\n  non-terminating
  function.  But termination checking now happens\n  before the other supplementary
  checks: positivity, polarity,\n  injectivity and projection-likeness.\n  Note that
  with the pragma {-# NO_TERMINATION_CHECK #-} you can make\n  Agda treat any function
  as terminating.\n\n* Termination checking of functions defined by 'with' has been
  improved.\n\n  Cases which previously required --termination-depth\n  to pass the
  termination checker (due to use of 'with') no longer\n  need the flag. For example\n\n
  \   merge : List A → List A → List A\n    merge [] ys = ys\n    merge xs [] = xs\n
  \   merge (x ∷ xs) (y ∷ ys) with x ≤ y\n    merge (x ∷ xs) (y ∷ ys)    | false =
  y ∷ merge (x ∷ xs) ys\n    merge (x ∷ xs) (y ∷ ys)    | true  = x ∷ merge xs (y
  ∷ ys)\n\n  This failed to termination check previously, since the 'with' expands
  to an\n  auxiliary function merge-aux:\n\n    merge-aux x y xs ys false = y ∷ merge
  (x ∷ xs) ys\n    merge-aux x y xs ys true  = x ∷ merge xs (y ∷ ys)\n\n  This function
  makes a call to merge in which the size of one of the arguments\n  is increasing.
  To make this pass the termination checker now inlines the\n  definition of merge-aux
  before checking, thus effectively termination\n  checking the original source program.\n\n
  \ As a result of this transformation doing 'with' on a variable no longer\n  preserves
  termination. For instance, this does not termination check:\n\n    bad : Nat → Nat\n
  \   bad n with n\n    ... | zero  = zero\n    ... | suc m = bad m\n\n* The performance
  of the termination checker has been improved.  For\n  higher --termination-depth
  the improvement is significant.\n  While the default --termination-depth is still
  1, checking with\n  higher --termination-depth should now be feasible.\n\nCompiler
  backends\n=================\n\n* The MAlonzo compiler backend now has support for
  compiling modules\n  that are not full programs (i.e. don't have a main function).
  The\n  goal is that you can write part of a program in Agda and the rest in\n  Haskell,
  and invoke the Agda functions from the Haskell code. The\n  following features were
  added for this reason:\n\n  * A new command-line option --compile-no-main: the command\n\n
  \     agda --compile-no-main Test.agda\n\n    will compile Test.agda and all its
  dependencies to Haskell and\n    compile the resulting Haskell files with --make,
  but (unlike\n    --compile) not tell GHC to treat Test.hs as the main module. This\n
  \   type of compilation can be invoked from emacs by customizing the\n    agda2-backend
  variable to value MAlonzoNoMain and then calling\n    \"C-c C-x C-c\" as before.\n\n
  \ * A new pragma COMPILED_EXPORT was added as part of the MAlonzo FFI.\n    If we
  have an Agda file containing the following:\n\n       module A.B where\n\n       test
  : SomeType\n       test = someImplementation\n\n       {-# COMPILED_EXPORT test
  someHaskellId #-}\n\n    then test will be compiled to a Haskell function called\n
  \   someHaskellId in module MAlonzo.Code.A.B that can be invoked from\n    other
  Haskell code. Its type will be translated according to the\n    normal MAlonzo rules.\n\nTools\n=====\n\nEmacs
  mode\n----------\n\n* A new goal command \"Helper Function Type\" (C-c C-h) has
  been added.\n\n  If you write an application of an undefined function in a goal,
  the Helper\n  Function Type command will print the type that the function needs
  to have in\n  order for it to fit the goal. The type is also added to the Emacs
  kill-ring\n  and can be pasted into the buffer using C-y.\n\n  The application must
  be of the form \"f args\" where f is the name of the\n  helper function you want
  to create. The arguments can use all the normal\n  features like named implicits
  or instance arguments.\n\n  Example:\n\n    Here's a start on a naive reverse on
  vectors:\n\n      reverse : ∀ {A n} → Vec A n → Vec A n\n      reverse [] = []\n
  \     reverse (x ∷ xs) = {!snoc (reverse xs) x!}\n\n    Calling C-c C-h in the goal
  prints\n\n      snoc : ∀ {A} {n} → Vec A n → A → Vec A (suc n)\n\n* A new command
  \"Explain why a particular name is in scope\" (C-c C-w) has been\n  added. [Issue207]\n\n
  \ This command can be called from a goal or from the top-level and will as the\n
  \ name suggests explain why a particular name is in scope.\n\n  For each definition
  or module that the given name can refer to a trace is\n  printed of all open statements
  and module applications leading back to the\n  original definition of the name.\n\n
  \ For example, given\n\n    module A (X : Set₁) where\n      data Foo : Set where\n
  \       mkFoo : Foo\n    module B (Y : Set₁) where\n      open A Y public\n    module
  C = B Set\n    open C\n\n  Calling C-c C-w on mkFoo at the top-level prints\n\n
  \   mkFoo is in scope as\n    * a constructor Issue207.C._.Foo.mkFoo brought into
  scope by\n      - the opening of C at Issue207.agda:13,6-7\n      - the application
  of B at Issue207.agda:11,12-13\n      - the application of A at Issue207.agda:9,8-9\n
  \     - its definition at Issue207.agda:6,5-10\n\n  This command is useful if Agda
  complains about an ambiguous name and you need\n  to figure out how to hide the
  undesired interpretations.\n\n* Improvements to the \"make case\" command (C-c C-c)\n\n
  \ - One can now also split on hidden variables, using the name\n    (starting with
  .) with which they are printed.\n    Use C-c C-, to see all variables in context.\n\n
  \ - Concerning the printing of generated clauses:\n\n  * Uses named implicit arguments
  to improve readability.\n\n  * Picks explicit occurrences over implicit ones when
  there is a choice of\n    binding site for a variable.\n\n  * Avoids binding variables
  in implicit positions by replacing dot patterns\n    that uses them by wildcards
  (._).\n\n* Key bindings for lots of \"mathematical\" characters (examples: \U0001D434\U0001D468\U0001D49C\U0001D4D0\U0001D504)\n
  \ have been added to the Agda input method.\n  Example: type \\MiA\\MIA\\McA\\MCA\\MfA
  to get \U0001D434\U0001D468\U0001D49C\U0001D4D0\U0001D504.\n\n  Note: \\McB does
  not exist in unicode (as well as others in that style),\n  but the \\MC (bold) alphabet
  is complete.\n\n* Key bindings for \"blackboard bold\" B (\U0001D539) and 0-9 (\U0001D7D8-\U0001D7E1)
  have been added\n  to the Agda input method (\\bb and \\b[0-9]).\n\n* Key bindings
  for controlling simplification/normalisation:\n\n  [TODO: Simplification should
  be explained somewhere.]\n\n  Commands like \"Goal type and context\" (C-c C-,)
  could previously be\n  invoked in two ways. By default the output was normalised,
  but if a\n  prefix argument was used (for instance via C-u C-c C-,), then no\n  explicit
  normalisation was performed. Now there are three options:\n\n  * By default (C-c C-,)
  the output is simplified.\n\n  * If C-u is used exactly once (C-u C-c C-,), then
  the result is\n    neither (explicitly) normalised nor simplified.\n\n  * If C-u
  is used twice (C-u C-u C-c C-,), then the result is\n    normalised.\n\n  [TODO:
  As part of the release of Agda 2.3.4 the key binding page on\n  the wiki should
  be updated.]\n\nLaTeX-backend\n-------------\n\n* Two new color scheme options were
  added to agda.sty:\n\n  \\usepackage[bw]{agda}, which highlights in black and white;\n
  \ \\usepackage[conor]{agda}, which highlights using Conor's colors.\n\n  The default
  (no options passed) is to use the standard colors.\n\n* If agda.sty cannot be found
  by the latex environment, it is now\n  copied into the latex output directory ('latex'
  by default) instead\n  of the working directory. This means that the commands needed
  to\n  produce a PDF now is\n\n    agda --latex -i . <file>.lagda\n    cd latex\n
  \   pdflatex <file>.tex\n\n* The LaTeX-backend has been made more tool agnostic,
  in particular\n  XeLaTeX and LuaLaTeX should now work. Here is a small example\n
  \ (test/LaTeXAndHTML/succeed/UnicodeInput.lagda):\n\n    \\documentclass{article}\n
  \   \\usepackage{agda}\n    \\begin{document}\n\n    \\begin{code}\n    data αβγδεζθικλμνξρστυφχψω
  : Set₁ where\n\n    postulate\n      →⇒⇛⇉⇄↦⇨↠⇀⇁ : Set\n    \\end{code}\n\n    \\[\n
  \   ∀X [ ∅ ∉ X ⇒ ∃f:X ⟶  ⋃ X\\ ∀A ∈ X (f(A) ∈ A) ]\n    \\]\n    \\end{document}\n\n
  \ Compiled as follows, it should produce a nice looking PDF (tested with\n  TeX
  Live 2012):\n\n    agda --latex <file>.lagda\n    cd latex\n    xelatex <file>.tex
  (or lualatex <file>.tex)\n\n  If symbols are missing or xelatex/lualatex complains
  about the font\n  missing, try setting a different font using:\n\n    \\setmathfont{<math-font>}\n\n
  \ Use the fc-list tool to list available fonts.\n\n* Add experimental support for
  hyperlinks to identifiers\n\n  If the hyperref latex package is loaded before the
  agda package and\n  the links option is passed to the agda package, then the agda
  package\n  provides a function called \\AgdaTarget. Identifiers which have been\n
  \ declared targets, by the user, will become clickable hyperlinks in the\n  rest
  of the document. Here is a small example\n  (test/LaTeXAndHTML/succeed/Links.lagda):\n\n
  \   \\documentclass{article}\n    \\usepackage{hyperref}\n    \\usepackage[links]{agda}\n
  \   \\begin{document}\n\n    \\AgdaTarget{ℕ}\n    \\AgdaTarget{zero}\n    \\begin{code}\n
  \   data ℕ : Set where\n      zero  : ℕ\n      suc   : ℕ → ℕ\n    \\end{code}\n\n
  \   See next page for how to define \\AgdaFunction{two} (doesn't turn into a\n    link
  because the target hasn't been defined yet). We could do it\n    manually though;
  \\hyperlink{two}{\\AgdaDatatype{two}}.\n\n    \\newpage\n\n    \\AgdaTarget{two}\n
  \   \\hypertarget{two}{}\n    \\begin{code}\n    two : ℕ\n    two = suc (suc zero)\n
  \   \\end{code}\n\n    \\AgdaInductiveConstructor{zero} is of type\n    \\AgdaDatatype{ℕ}.
  \\AgdaInductiveConstructor{suc} has not been defined to\n    be a target so it doesn't
  turn into a link.\n\n    \\newpage\n\n    Now that the target for \\AgdaFunction{two}
  has been defined the link\n    works automatically.\n\n    \\begin{code}\n    data
  Bool : Set where\n      true false : Bool\n    \\end{code}\n\n    The AgdaTarget
  command takes a list as input, enabling several\n    targets to be specified as
  follows:\n\n    \\AgdaTarget{if, then, else, if\\_then\\_else\\_}\n    \\begin{code}\n
  \   if_then_else_ : {A : Set} → Bool → A → A → A\n    if true  then t else f = t\n
  \   if false then t else f = f\n    \\end{code}\n\n    \\newpage\n\n    Mixfix identifier
  need their underscores escaped:\n    \\AgdaFunction{if\\_then\\_else\\_}.\n\n    \\end{document}\n\n
  \ The boarders around the links can be suppressed using hyperref's\n  hidelinks
  option:\n\n    \\usepackage[hidelinks]{hyperref}\n\n  Note that the current approach
  to links does not keep track of scoping\n  or types, and hence overloaded names
  might create links which point to\n  the wrong place. Therefore it is recommended
  to not overload names\n  when using the links option at the moment, this might get
  fixed in the\n  future.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.3.2.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.3.2.1:\n\n* Fixed a bug that sometimes made it tricky to use the
  Emacs mode on\n  Windows [issue 757].\n\n* Made Agda build with newer versions of
  some libraries.\n\n* Fixed a bug that caused ambiguous parse error messages [issue
  147].\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.3.2.1\n------------------------------------------------------------------------\n\nImportant
  changes since 2.3.2:\n\nInstallation\n============\n\n* Made it possible to compile
  Agda with more recent versions of\n  hashable, QuickCheck and Win32.\n\n* Excluded
  mtl-2.1.\n\nType checking\n=============\n\n* Fixed bug in the termination checker
  (issue 754).\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.3.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.3.0:\n\nInstallation\n============\n\n* The Agda-executable package
  has been removed.\n\n  The executable is now provided as part of the Agda package.\n\n*
  The Emacs mode no longer depends on haskell-mode or GHCi.\n\n* Compilation of Emacs
  mode Lisp files.\n\n  You can now compile the Emacs mode Lisp files by running \"agda-mode\n
  \ compile\". This command is run by \"make install\".\n\n  Compilation can, in some
  cases, give a noticeable speedup.\n\n  WARNING: If you reinstall the Agda mode without
  recompiling the\n  Emacs Lisp files, then Emacs may continue using the old, compiled\n
  \ files.\n\nPragmas and options\n===================\n\n* The --without-K check
  now reconstructs constructor parameters.\n\n  New specification of --without-K:\n\n
  \ If the flag is activated, then Agda only accepts certain\n  case-splits. If the
  type of the variable to be split is D pars ixs,\n  where D is a data (or record)
  type, pars stands for the parameters,\n  and ixs the indices, then the following
  requirements must be\n  satisfied:\n\n  * The indices ixs must be applications of
  constructors (or literals)\n    to distinct variables. Constructors are usually
  not applied to\n    parameters, but for the purposes of this check constructor\n
  \   parameters are treated as other arguments.\n\n  * These distinct variables must
  not be free in pars.\n\n* Irrelevant arguments are printed as _ by default now.
  \ To turn on\n  printing of irrelevant arguments, use option\n\n    --show-irrelevant\n\n*
  New: Pragma NO_TERMINATION_CHECK to switch off termination checker\n  for individual
  function definitions and mutual blocks.\n\n  The pragma must precede a function
  definition or a mutual block.\n  Examples (see test/Succeed/NoTerminationCheck.agda):\n\n
  \ 1. Skipping a single definition: before type signature.\n\n       {-# NO_TERMINATION_CHECK
  #-}\n       a : A\n       a = a\n\n  2. Skipping a single definition: before first
  clause.\n\n       b : A\n       {-# NO_TERMINATION_CHECK #-}\n       b = b\n\n  3.
  Skipping an old-style mutual block: Before 'mutual' keyword.\n\n       {-# NO_TERMINATION_CHECK
  #-}\n       mutual\n         c : A\n         c = d\n\n         d : A\n         d
  = c\n\n  4. Skipping a new-style mutual block: Anywhere before a type\n     signature
  or first function clause in the block\n\n       i : A\n       j : A\n\n       i
  = j\n       {-# NO_TERMINATION_CHECK #-}\n       j = i\n\n  The pragma cannot be
  used in --safe mode.\n\nLanguage\n========\n\n* Let binding record patterns\n\n
  \   record _×_ (A B : Set) : Set where\n      constructor _,_\n      field\n        fst
  : A\n        snd : B\n    open _×_\n\n    let (x , (y , z)) = t\n    in  u\n\n  will
  now be interpreted as\n\n    let x = fst t\n        y = fst (snd t)\n        z =
  snd (snd t)\n    in  u\n\n  Note that the type of t needs to be inferable.  If you
  need to provide\n  a type signature, you can write the following:\n\n    let a :
  ...\n        a = t\n        (x , (y , z)) = a\n    in  u\n\n* Pattern synonyms\n\n
  \ A pattern synonym is a declaration that can be used on the left hand\n  side (when
  pattern matching) as well as the right hand side (in\n  expressions). For example:\n\n
  \ pattern z    = zero\n  pattern ss x = suc (suc x)\n\n  f : ℕ -> ℕ\n  f z       =
  z\n  f (suc z) = ss z\n  f (ss n)  = n\n\n  Pattern synonyms are implemented by
  substitution on the abstract\n  syntax, so definitions are scope-checked but not
  type-checked. They\n  are particularly useful for universe constructions.\n\n* Qualified
  mixfix operators\n\n  It is now possible to use a qualified mixfix operator by qualifying
  the first\n  part of the name. For instance\n\n    import Data.Nat as Nat\n    import
  Data.Bool as Bool\n\n    two = Bool.if true then 1 Nat.+ 1 else 0\n\n* Sections
  [Issue 735].  Agda now parses anonymous modules as sections:\n\n    module _ {a}
  (A : Set a) where\n\n      data List : Set a where\n        []  : List\n        _∷_
  : (x : A) (xs : List) → List\n\n    module _ {a} {A : Set a} where\n\n      _++_
  : List A → List A → List A\n      []       ++ ys = ys\n      (x ∷ xs) ++ ys = x
  ∷ (xs ++ ys)\n\n    test : List Nat\n    test = (5 ∷ []) ++ (3 ∷ [])\n\n  In general,
  now the syntax\n\n    module _ parameters where\n      declarations\n\n  is accepted
  and has the same effect as\n\n    private\n      module M parameters where\n        declarations\n
  \   open M public\n\n  for a fresh name M.\n\n* Instantiating a module in an open
  import statement [Issue 481].  Now accepted:\n\n    open import Path.Module args
  [using/hiding/renaming (...)]\n\n  This only brings the imported identifiers from
  Path.Module into scope,\n  not the module itself!  Consequently, the following is
  pointless, and raises\n  an error:\n\n    import Path.Module args [using/hiding/renaming
  (...)]\n\n  You can give a private name M to the instantiated module via\n\n    import
  Path.Module args as M [using/hiding/renaming (...)]\n    open import Path.Module
  args as M [using/hiding/renaming (...)]\n\n  Try to avoid 'as' as part of the arguments.
  \ 'as' is not a keyword;\n  the following can be legal, although slightly obfuscated
  Agda code:\n\n    open import as as as as as as\n\n* Implicit module parameters
  can be given by name. E.g.\n\n    open M {namedArg = bla}\n\n  This feature has
  been introduced in Agda 2.3.0 already.\n\n* Multiple type signatures sharing a same
  type can now be written as a single\n  type signature.\n\n    one two : ℕ\n    one
  = suc zero\n    two = suc one\n\nGoal and error display\n======================\n\n*
  Meta-variables that were introduced by hidden argument `arg' are now\n  printed
  as _arg_number instead of just _number.  [Issue 526]\n\n* Agda expands identifiers
  in anonymous modules when printing.\n  Should make some goals nicer to read. [Issue
  721]\n\n* When a module identifier is ambiguous, Agda tells you if one\n  of them
  is a data type module.  [Issues 318, 705]\n\nType checking\n=============\n\n* Improved
  coverage checker.  The coverage checker splits on\n  arguments that have constructor
  or literal pattern, committing\n  to the left-most split that makes progress.\n
  \ Consider the lookup function for vectors:\n\n    data Fin : Nat → Set where\n
  \     zero : {n : Nat} → Fin (suc n)\n      suc  : {n : Nat} → Fin n → Fin (suc
  n)\n\n    data Vec (A : Set) : Nat → Set where\n      []  : Vec A zero\n      _∷_
  : {n : Nat} → A → Vec A n → Vec A (suc n)\n\n    _!!_ : {A : Set}{n : Nat} → Vec
  A n → Fin n → A\n    (x ∷ xs) !! zero  = x\n    (x ∷ xs) !! suc i = xs !! i\n\n
  \ In Agda up to 2.3.0, this definition is rejected unless we add\n  an absurd clause\n\n
  \   [] !! ()\n\n  This is because the coverage checker committed on splitting\n
  \ on the vector argument, even though this inevitably lead to\n  failed coverage,
  because a case for the empty vector [] is missing.\n\n  The improvement to the coverage
  checker consists on committing\n  only on splits that have a chance of covering,
  since all possible\n  constructor patterns are present.  Thus, Agda will now split\n
  \ first on the Fin argument, since cases for both zero and suc are\n  present.  Then,
  it can split on the Vec argument, since the\n  empty vector is already ruled out
  by instantiating n to a suc _.\n\n* Instance arguments resolution will now consider
  candidates which\n  still expect hidden arguments. For example:\n\n    record Eq
  (A : Set) : Set where\n      field eq : A → A → Bool\n\n    open Eq {{...}}\n\n
  \   eqFin : {n : ℕ} → Eq (Fin n)\n    eqFin = record { eq = primEqFin }\n\n    testFin
  : Bool\n    testFin = eq fin1 fin2\n\n  The type-checker will now resolve the instance
  argument of the eq\n  function to eqFin {_}. This is only done for hidden arguments,
  not\n  instance arguments, so that the instance search stays non-recursive.\n\n*
  Constraint solving: Upgraded Miller patterns to record patterns. [Issue 456]\n\n
  \ Agda now solves meta-variables that are applied to record patterns.\n  A typical
  (but here, artificial) case is:\n\n    record Sigma (A : Set)(B : A -> Set) : Set
  where\n      constructor _,_\n      field\n        fst : A\n        snd : B fst\n\n
  \   test : (A : Set)(B : A -> Set) ->\n      let X : Sigma A B -> Sigma A B\n          X
  = _\n      in  (x : A)(y : B x) -> X (x , y) ≡ (x , y)\n    test A B x y = refl\n\n
  \ This yields a constraint of the form\n\n    _X A B (x , y) := t[x,y]\n\n  (with
  t[x,y] = (x, y)) which is not a Miller pattern.\n  However, Agda now solves this
  as\n\n    _X A B z := t[fst z,snd z].\n\n* Changed: solving recursive constraints.
  \ [Issue 585]\n\n  Until 2.3.0, Agda sometimes inferred values that did not pass
  the\n  termination checker later, or would even make Agda loop.  To prevent this,\n
  \ the occurs check now also looks into the definitions of the current mutual\n  block,
  to avoid constructing recursive solutions.  As a consequence, also\n  terminating
  recursive solutions are no longer found automatically.\n\n  This effects a programming
  pattern where the recursively computed\n  type of a recursive function is left to
  Agda to solve.\n\n    mutual\n\n      T : D -> Set\n      T pattern1 = _\n      T
  pattern2 = _\n\n      f : (d : D) -> T d\n      f pattern1 = rhs1\n      f pattern2
  = rhs2\n\n  This might no longer work from now on.\n  See examples test/Fail/Issue585*.agda\n\n*
  Less eager introduction of implicit parameters.  [Issue 679]\n\n  Until Agda 2.3.0,
  trailing hidden parameters were introduced eagerly\n  on the left hand side of a
  definition.  For instance, one could not\n  write\n\n    test : {A : Set} -> Set\n
  \   test = \\ {A} -> A\n\n  because internally, the hidden argument {A : Set} was
  added to the\n  left-hand side, yielding\n\n    test {_} = \\ {A} -> A\n\n  which
  raised a type error.  Now, Agda only introduces the trailing\n  implicit parameters
  it has to, in order to maintain uniform function\n  arity.  For instance, in\n\n
  \   test : Bool -> {A B C : Set} -> Set\n    test true {A}      = A\n    test false
  {B = B} = B\n\n  Agda will introduce parameters A and B in all clauses, but not
  C,\n  resulting in\n\n    test : Bool -> {A B C : Set} -> Set\n    test true  {A}
  {_}     = A\n    test false {_} {B = B} = B\n\n  Note that for checking where-clauses,
  still all hidden trailing\n  parameters are in scope.  For instance:\n\n    id :
  {i : Level}{A : Set i} -> A -> A\n    id = myId\n      where myId : forall {A} ->
  A -> A\n            myId x = x\n\n  To be able to fill in the meta variable _1 in\n\n
  \   myId : {A : Set _1} -> A -> A\n\n  the hidden parameter {i : Level} needs to
  be in scope.\n\n  As a result of this more lazy introduction of implicit parameters,\n
  \ the following code now passes.\n\n    data Unit : Set where\n      unit : Unit\n\n
  \   T : Unit → Set\n    T unit = {u : Unit} → Unit\n\n    test : (u : Unit) → T
  u\n    test unit with unit\n    ... | _ = λ {v} → v\n\n  Before, Agda would eagerly
  introduce the hidden parameter {v} as\n  unnamed left-hand side parameter, leaving
  no way to refer to it.\n\n  The related issue 655 has also been addressed.  It is
  now possible\n  to make `synonym' definitions\n\n    name = expression\n\n  even
  when the type of expression begins with a hidden quantifier.\n  Simple example:\n\n
  \   id2 = id\n\n  That resulted in unsolved metas until 2.3.0.\n\n* Agda detects
  unused arguments and ignores them during equality\n  checking. [Issue 691, solves
  also issue 44.]\n\n  Agda's polarity checker now assigns 'Nonvariant' to arguments\n
  \ that are not actually used (except for absurd matches).  If\n  f's first argument
  is Nonvariant, then f x is definitionally equal\n  to f y regardless of x and y.
  \ It is similar to irrelevance, but\n  does not require user annotation.\n\n  For
  instance, unused module parameters do no longer get in the way:\n\n    module M
  (x : Bool) where\n\n      not : Bool → Bool\n      not true  = false\n      not
  false = true\n\n    open M true\n    open M false renaming (not to not′)\n\n    test
  : (y : Bool) → not y ≡ not′ y\n    test y = refl\n\n  Matching against record or
  absurd patterns does not count as `use',\n  so we get some form of proof irrelevance:\n\n
  \   data ⊥ : Set where\n    record ⊤ : Set where\n      constructor trivial\n\n
  \   data Bool : Set where\n      true false : Bool\n\n    True : Bool → Set\n    True
  true  = ⊤\n    True false = ⊥\n\n    fun : (b : Bool) → True b → Bool\n    fun true
  \ trivial = true\n    fun false ()\n\n    test : (b : Bool) → (x y : True b) → fun
  b x ≡ fun b y\n    test b x y = refl\n\n  More examples in test/Succeed/NonvariantPolarity.agda.\n\n
  \ Phantom arguments:  Parameters of record and data types are considered\n  `used'
  even if they are not actually used.  Consider:\n\n    False : Nat → Set\n    False
  zero    = ⊥\n    False (suc n) = False n\n\n    module Invariant where\n      record
  Bla (n : Nat)(p : False n) : Set where\n\n    module Nonvariant where\n      Bla
  : (n : Nat) → False n → Set\n      Bla n p = ⊤\n\n  Even though record `Bla' does
  not use its parameters n and p, they\n  are considered as used, allowing \"phantom
  type\" techniques.\n\n  In contrast, the arguments of function `Bla' are recognized
  as unused.\n  The following code type-checks if we open Invariant but leaves unsolved\n
  \ metas if we open Nonvariant.\n\n    drop-suc : {n : Nat}{p : False n} → Bla (suc
  n) p → Bla n p\n    drop-suc _ = _\n\n    bla : (n : Nat) → {p : False n} → Bla
  n p → ⊥\n    bla zero {()} b\n    bla (suc n) b = bla n (drop-suc b)\n\n  If `Bla'
  is considered invariant, the hidden argument in the recursive\n  call can be inferred
  to be `p'.  If it is considered non-variant, then\n  `Bla n X = Bla n p' does not
  entail `X = p' and the hidden argument\n  remains unsolved.  Since `bla' does not
  actually use its hidden argument,\n  its value is not important and it could be
  searched for.\n  Unfortunately, polarity analysis of `bla' happens only after type\n
  \ checking, thus, the information that `bla' is non-variant in `p' is\n  not available
  yet when meta-variables are solved.\n  (See test/Fail/BrokenInferenceDueToNonvariantPolarity.agda)\n\n*
  Agda now expands simple definitions (one clause, terminating)\n  to check whether
  a function is constructor headed. [Issue 747]\n  For instance, the following now
  also works:\n\n    MyPair : Set -> Set -> Set\n    MyPair A B = Pair A B\n\n    Vec
  : Set -> Nat -> Set\n    Vec A zero    = Unit\n    Vec A (suc n) = MyPair A (Vec
  A n)\n\n  Here, Unit and Pair are data or record types.\n\nCompiler backends\n=================\n\n*
  -Werror is now overridable.\n\n  To enable compilation of Haskell modules containing
  warnings, the\n  -Werror flag for the MAlonzo backend has been made overridable.
  If,\n  for example, --ghc-flag=-Wwarn is passed when compiling, one can get\n  away
  with things like:\n\n    data PartialBool : Set where\n      true : PartialBool\n\n
  \   {-# COMPILED_DATA PartialBool Bool True #-}\n\n  The default behavior remains
  as it used to be and rejects the above\n  program.\n\nTools\n=====\n\nEmacs mode\n----------\n\n*
  Asynchronous Emacs mode.\n\n  One can now use Emacs while a buffer is type-checked.
  If the buffer\n  is edited while the type-checker runs, then syntax highlighting
  will\n  not be updated when type-checking is complete.\n\n* Interactive syntax highlighting.\n\n
  \ The syntax highlighting is updated while a buffer is type-checked:\n\n  • At first
  the buffer is highlighted in a somewhat crude way\n    (without go-to-definition
  information for overloaded\n    constructors).\n\n  • If the highlighting level
  is \"interactive\", then the piece of code\n    that is currently being type-checked
  is highlighted as such. (The\n    default is \"non-interactive\".)\n\n  • When a
  mutual block has been type-checked it is highlighted\n    properly (this highlighting
  includes warnings for potential\n    non-termination).\n\n  The highlighting level
  can be controlled via the new configuration\n  variable agda2-highlight-level.\n\n*
  Multiple case-splits can now be performed in one go.\n\n  Consider the following
  example:\n\n    _==_ : Bool → Bool → Bool\n    b₁ == b₂ = {!!}\n\n  If you split
  on \"b₁ b₂\", then you get the following code:\n\n    _==_ : Bool → Bool → Bool\n
  \   true == true = {!!}\n    true == false = {!!}\n    false == true = {!!}\n    false
  == false = {!!}\n\n  The order of the variables matters. Consider the following
  code:\n\n    lookup : ∀ {a n} {A : Set a} → Vec A n → Fin n → A\n    lookup xs i
  = {!!}\n\n  If you split on \"xs i\", then you get the following code:\n\n    lookup
  : ∀ {a n} {A : Set a} → Vec A n → Fin n → A\n    lookup [] ()\n    lookup (x ∷ xs)
  zero = {!!}\n    lookup (x ∷ xs) (suc i) = {!!}\n\n  However, if you split on \"i
  xs\", then you get the following code\n  instead:\n\n    lookup : ∀ {a n} {A : Set
  a} → Vec A n → Fin n → A\n    lookup (x ∷ xs) zero = ?\n    lookup (x ∷ xs) (suc
  i) = ?\n\n  This code is rejected by Agda 2.3.0, but accepted by 2.3.2 thanks\n
  \ to improved coverage checking (see above).\n\n* The Emacs mode now presents information
  about which module is\n  currently being type-checked.\n\n* New global menu entry:
  Information about the character at point.\n\n  If this entry is selected, then information
  about the character at\n  point is displayed, including (in many cases) information
  about how\n  to type the character.\n\n* Commenting/uncommenting the rest of the
  buffer.\n\n  One can now comment or uncomment the rest of the buffer by typing\n
  \ C-c C-x M-; or by selecting the menu entry \"Comment/uncomment the\n  rest of
  the buffer\".\n\n* The Emacs mode now uses the Agda executable instead of GHCi.\n\n
  \ The *ghci* buffer has been renamed to *agda2*.\n\n  A new configuration variable
  has been introduced:\n  agda2-program-name, the name of the Agda executable (by
  default\n  agda).\n\n  The variable agda2-ghci-options has been replaced by\n  agda2-program-args:
  extra arguments given to the Agda executable (by\n  default none).\n\n  If you want
  to limit Agda's memory consumption you can add some\n  arguments to agda2-program-args,
  for instance +RTS -M1.5G -RTS.\n\n* The Emacs mode no longer depends on haskell-mode.\n\n
  \ Users who have customised certain haskell-mode variables (such as\n  haskell-ghci-program-args)
  may want to update their configuration.\n\nLaTeX-backend\n-------------\n\nAn experimental
  LaTeX-backend which does precise highlighting a la the\nHTML-backend and code alignment
  a la lhs2TeX has been added.\n\nHere is a sample input literate Agda file:\n\n  \\documentclass{article}\n\n
  \ \\usepackage{agda}\n\n  \\begin{document}\n\n  The following module declaration
  will be hidden in the output.\n\n  \\AgdaHide{\n  \\begin{code}\n  module M where\n
  \ \\end{code}\n  }\n\n  Two or more spaces can be used to make the backend align
  stuff.\n\n  \\begin{code}\n  data ℕ : Set where\n    zero  : ℕ\n    suc   : ℕ →
  ℕ\n\n  _+_ : ℕ → ℕ → ℕ\n  zero   + n = n\n  suc m  + n = suc (m + n)\n  \\end{code}\n\n
  \ \\end{document}\n\nTo produce an output PDF issue the following commands:\n\n
  \ agda --latex -i . <file>.lagda\n  pdflatex latex/<file>.tex\n\nOnly the top-most
  module is processed, like with lhs2tex and unlike with\nthe HTML-backend. If you
  want to process imported modules you have to\ncall agda --latex manually on each
  of those modules.\n\nThere are still issues related to formatting, see the bug tracker
  for\nmore information:\n\n  https://code.google.com/p/agda/issues/detail?id=697\n\nThe
  default agda.sty might therefore change in backwards-incompatible\nways, as work
  proceeds in trying to resolve those problems.\n\n\nImplemented features:\n\n  *
  Two or more spaces can be used to force alignment of things, like\n    with lhs2tex.
  See example above.\n\n  * The highlighting information produced by the type checker
  is used to\n    generate the output. For example, the data declaration in the example\n
  \   above, produces:\n\n      \\AgdaKeyword{data} \\AgdaDatatype{ℕ} \\AgdaSymbol{:}\n
  \         \\AgdaPrimitiveType{Set} \\AgdaKeyword{where}\n\n    These latex commands
  are defined in agda.sty (which is imported by\n    \\usepackage{agda}) and cause
  the highlighting.\n\n  * The latex-backend checks if agda.sty is found by the latex\n
  \   environment, if it isn't a default agda.sty is copied from Agda's\n    data-dir
  into the working directory (and thus made available to the\n    latex environment).\n\n
  \   If the default agda.sty isn't satisfactory (colors, fonts, spacing,\n    etc)
  then the user can modify it and make put it somewhere where the\n    latex environment
  can find it. Hopefully most aspects should be\n    modifiable via agda.sty rather
  than having to tweak the\n    implementation.\n\n  * --latex-dir can be used to
  change the default output directory.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.3.0\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.10:\n\nLanguage\n========\n\n* New more liberal syntax for mutually
  recursive definitions.\n\n  It is no longer necessary to use the 'mutual' keyword
  to define\n  mutually recursive functions or datatypes. Instead, it is enough to\n
  \ declare things before they are used. Instead of\n\n    mutual\n      f : A\n      f
  = a[f, g]\n\n      g : B[f]\n      g = b[f, g]\n\n  you can now write\n\n    f :
  A\n    g : B[f]\n    f = a[f, g]\n    g = b[f, g].\n\n  With the new style you have
  more freedom in choosing the order in\n  which things are type checked (previously
  type signatures were\n  always checked before definitions). Furthermore you can
  mix\n  arbitrary declarations, such as modules and postulates, with\n  mutually
  recursive definitions.\n\n  For data types and records the following new syntax
  is used to\n  separate the declaration from the definition:\n\n    -- Declaration.\n
  \   data Vec (A : Set) : Nat → Set  -- Note the absence of 'where'.\n\n    -- Definition.\n
  \   data Vec A where\n      []   : Vec A zero\n      _::_ : {n : Nat} → A → Vec
  A n → Vec A (suc n)\n\n    -- Declaration.\n    record Sigma (A : Set) (B : A →
  Set) : Set\n\n    -- Definition.\n    record Sigma A B where\n      constructor
  _,_\n      field fst : A\n            snd : B fst\n\n  When making separated declarations/definitions
  private or abstract\n  you should attach the 'private' keyword to the declaration
  and the\n  'abstract' keyword to the definition. For instance, a private,\n  abstract
  function can be defined as\n\n    private\n      f : A\n    abstract\n      f =
  e\n\n  Finally it may be worth noting that the old style of mutually\n  recursive
  definitions is still supported (it basically desugars into\n  the new style).\n\n*
  Pattern matching lambdas.\n\n  Anonymous pattern matching functions can be defined
  using the syntax\n\n    \\ { p11 .. p1n -> e1 ; ... ; pm1 .. pmn -> em }\n\n  (where,
  as usual, \\ and -> can be replaced by λ and →). Internally\n  this is translated
  into a function definition of the following form:\n\n    .extlam p11 .. p1n = e1\n
  \   ...\n    .extlam pm1 .. pmn = em\n\n  This means that anonymous pattern matching
  functions are generative.\n  For instance, refl will not be accepted as an inhabitant
  of the type\n\n    (λ { true → true ; false → false }) ≡\n    (λ { true → true ;
  false → false }),\n\n  because this is equivalent to extlam1 ≡ extlam2 for some
  distinct\n  fresh names extlam1 and extlam2.\n\n  Currently the 'where' and 'with'
  constructions are not allowed in\n  (the top-level clauses of) anonymous pattern
  matching functions.\n\n  Examples:\n\n    and : Bool → Bool → Bool\n    and = λ
  { true x → x ; false _ → false }\n\n    xor : Bool → Bool → Bool\n    xor = λ {
  true  true  → false\n            ; false false → false\n            ; _     _     →
  true\n            }\n\n    fst : {A : Set} {B : A → Set} → Σ A B → A\n    fst =
  λ { (a , b) → a }\n\n    snd : {A : Set} {B : A → Set} (p : Σ A B) → B (fst p)\n
  \   snd = λ { (a , b) → b }\n\n* Record update syntax.\n\n  Assume that we have
  a record type and a corresponding value:\n\n    record MyRecord : Set where\n      field\n
  \       a b c : ℕ\n\n    old : MyRecord\n    old = record { a = 1; b = 2; c = 3
  }\n\n  Then we can update (some of) the record value's fields in the\n  following
  way:\n\n    new : MyRecord\n    new = record old { a = 0; c = 5 }\n\n  Here new
  normalises to record { a = 0; b = 2; c = 5 }. Any\n  expression yielding a value
  of type MyRecord can be used instead of\n  old.\n\n  Record updating is not allowed
  to change types: the resulting value\n  must have the same type as the original
  one, including the record\n  parameters. Thus, the type of a record update can be
  inferred if the type\n  of the original record can be inferred.\n\n  The record
  update syntax is expanded before type checking. When the\n  expression\n\n    record
  old { upd-fields }\n\n  is checked against a record type R, it is expanded to\n\n
  \   let r = old in record { new-fields },\n\n  where old is required to have type
  R and new-fields is defined as\n  follows: for each field x in R,\n\n    - if x
  = e is contained in upd-fields then x = e is included in\n      new-fields, and
  otherwise\n    - if x is an explicit field then x = R.x r is included in\n      new-fields,
  and\n    - if x is an implicit or instance field, then it is omitted from\n      new-fields.\n\n
  \ (Instance arguments are explained below.) The reason for treating\n  implicit
  and instance fields specially is to allow code like the\n  following:\n\n    record
  R : Set where\n      field\n        {length} : ℕ\n        vec      : Vec ℕ length\n
  \       -- More fields…\n\n    xs : R\n    xs = record { vec = 0 ∷ 1 ∷ 2 ∷ [] }\n\n
  \   ys = record xs { vec = 0 ∷ [] }\n\n  Without the special treatment the last
  expression would need to\n  include a new binding for length (for instance \"length
  = _\").\n\n* Record patterns which do not contain data type patterns, but which\n
  \ do contain dot patterns, are no longer rejected.\n\n* When the --without-K flag
  is used literals are now treated as\n  constructors.\n\n* Under-applied functions
  can now reduce.\n\n  Consider the following definition:\n\n    id : {A : Set} →
  A → A\n    id x = x\n\n  Previously the expression id would not reduce. This has
  been changed\n  so that it now reduces to λ x → x. Usually this makes little\n  difference,
  but it can be important in conjunction with 'with'. See\n  issue 365 for an example.\n\n*
  Unused AgdaLight legacy syntax (x y : A; z v : B) for telescopes has\n  been removed.\n\nUniverse
  polymorphism\n---------------------\n\n* Universe polymorphism is now enabled by
  default.\n  Use --no-universe-polymorphism to disable it.\n\n* Universe levels are
  no longer defined as a data type.\n\n  The basic level combinators can be introduced
  in the following way:\n\n  postulate\n    Level : Set\n    zero  : Level\n    suc
  \  : Level → Level\n    max   : Level → Level → Level\n\n  {-# BUILTIN LEVEL     Level
  #-}\n  {-# BUILTIN LEVELZERO zero  #-}\n  {-# BUILTIN LEVELSUC  suc   #-}\n  {-#
  BUILTIN LEVELMAX  max   #-}\n\n* The BUILTIN equality is now required to be universe-polymorphic.\n\n*
  trustMe is now universe-polymorphic.\n\nMeta-variables and unification\n------------------------------\n\n*
  Unsolved meta-variables are now frozen after every mutual block.\n  This means that
  they cannot be instantiated by subsequent code. For\n  instance,\n\n    one : Nat\n
  \   one = _\n\n    bla : one ≡ suc zero\n    bla = refl\n\n  leads to an error now,
  whereas previously it lead to the\n  instantiation of _ with \"suc zero\". If you
  want to make use of the\n  old behaviour, put the two definitions in a mutual block.\n\n
  \ All meta-variables are unfrozen during interactive editing, so that\n  the user
  can fill holes interactively. Note that type-checking of\n  interactively given
  terms is not perfect: Agda sometimes refuses to\n  load a file, even though no complaints
  were raised during the\n  interactive construction of the file. This is because
  certain checks\n  (for instance, positivity) are only invoked when a file is loaded.\n\n*
  Record types can now be inferred.\n\n  If there is a unique known record type with
  fields matching the\n  fields in a record expression, then the type of the expression
  will\n  be inferred to be the record type applied to unknown parameters.\n\n  If
  there is no known record type with the given fields the type\n  checker will give
  an error instead of producing lots of unsolved\n  meta-variables.\n\n  Note that
  \"known record type\" refers to any record type in any\n  imported module, not just
  types which are in scope.\n\n* The occurrence checker distinguishes rigid and strongly
  rigid\n  occurrences [Reed, LFMTP 2009; Abel & Pientka, TLCA 2011].\n\n  The completeness
  checker now accepts the following code:\n\n    h : (n : Nat) → n ≡ suc n → Nat\n
  \   h n ()\n\n  Internally this generates a constraint _n = suc _n where the\n  meta-variable
  _n occurs strongly rigidly, i.e. on a constructor path\n  from the root, in its
  own defining term tree. This is never\n  solvable.\n\n  Weakly rigid recursive occurrences
  may have a solution [Jason Reed's\n  PhD thesis, page 106]:\n\n    test : (k : Nat)
  →\n           let X : (Nat → Nat) → Nat\n               X = _\n           in\n           (f
  : Nat → Nat) → X f ≡ suc (f (X (λ x → k)))\n    test k f = refl\n\n  The constraint
  _X k f = suc (f (_X k (λ x → k))) has the solution\n  _X k f = suc (f (suc k)),
  despite the recursive occurrence of _X.\n  Here _X is not strongly rigid, because
  it occurs under the bound\n  variable f. Previously Agda rejected this code; now
  it instead\n  complains about an unsolved meta-variable.\n\n* Equation constraints
  involving the same meta-variable in the head\n  now trigger pruning [Pientka, PhD,
  Sec. 3.1.2; Abel & Pientka, TLCA\n  2011]. Example:\n\n    same : let X : A → A
  → A → A × A\n               X = _\n           in {x y z : A} → X x y y ≡ (x , y)\n
  \                         × X x x y ≡ X x y y\n    same = refl , refl\n\n  The second
  equation implies that X cannot depend on its second\n  argument. After pruning the
  first equation is linear and can be\n  solved.\n\n* Instance arguments.\n\n  A new
  type of hidden function arguments has been added: instance\n  arguments. This new
  feature is based on influences from Scala's\n  implicits and Agda's existing implicit
  arguments.\n\n  Plain implicit arguments are marked by single braces: {…}. Instance\n
  \ arguments are instead marked by double braces: {{…}}. Example:\n\n    postulate\n
  \     A : Set\n      B : A → Set\n      a : A\n      f : {{a : A}} → B a\n\n  Instead
  of the double braces you can use the symbols ⦃ and ⦄, but\n  these symbols must
  in many cases be surrounded by whitespace. (If\n  you are using Emacs and the Agda
  input method, then you can conjure\n  up the symbols by typing \"\\{{\" and \"\\}}\",
  respectively.)\n\n  Instance arguments behave as ordinary implicit arguments, except
  for\n  one important aspect: resolution of arguments which are not provided\n  explicitly.
  For instance, consider the following code:\n\n    test = f\n\n  Here Agda will notice
  that f's instance argument was not provided\n  explicitly, and try to infer it.
  All definitions in scope at f's\n  call site, as well as all variables in the context,
  are considered.\n  If exactly one of these names has the required type (A), then
  the\n  instance argument will be instantiated to this name.\n\n  This feature can
  be used as an alternative to Haskell type classes.\n  If we define\n\n    record
  Eq (A : Set) : Set where\n      field equal : A → A → Bool,\n\n  then we can define
  the following projection:\n\n    equal : {A : Set} {{eq : Eq A}} → A → A → Bool\n
  \   equal {{eq}} = Eq.equal eq\n\n  Now consider the following expression:\n\n    equal
  false false ∨ equal 3 4\n\n  If the following Eq \"instances\" for Bool and ℕ are
  in scope, and no\n  others, then the expression is accepted:\n\n    eq-Bool : Eq
  Bool\n    eq-Bool = record { equal = … }\n\n    eq-ℕ : Eq ℕ\n    eq-ℕ = record {
  equal = … }\n\n  A shorthand notation is provided to avoid the need to define\n
  \ projection functions manually:\n\n    module Eq-with-implicits = Eq {{...}}\n\n
  \ This notation creates a variant of Eq's record module, where the\n  main Eq argument
  is an instance argument instead of an explicit one.\n  It is equivalent to the following
  definition:\n\n    module Eq-with-implicits {A : Set} {{eq : Eq A}} = Eq eq\n\n
  \ Note that the short-hand notation allows you to avoid naming the\n  \"-with-implicits\"
  module:\n\n    open Eq {{...}}\n\n  Instance argument resolution is not recursive.
  As an example,\n  consider the following \"parametrised instance\":\n\n    eq-List
  : {A : Set} → Eq A → Eq (List A)\n    eq-List {A} eq = record { equal = eq-List-A
  }\n      where\n      eq-List-A : List A → List A → Bool\n      eq-List-A []       []
  \      = true\n      eq-List-A (a ∷ as) (b ∷ bs) = equal a b ∧ eq-List-A as bs\n
  \     eq-List-A _        _        = false\n\n  Assume that the only Eq instances
  in scope are eq-List and eq-ℕ.\n  Then the following code does not type-check:\n\n
  \   test = equal (1 ∷ 2 ∷ []) (3 ∷ 4 ∷ [])\n\n  However, we can make the code work
  by constructing a suitable\n  instance manually:\n\n    test′ = equal (1 ∷ 2 ∷ [])
  (3 ∷ 4 ∷ [])\n      where eq-List-ℕ = eq-List eq-ℕ\n\n  By restricting the \"instance
  search\" to be non-recursive we avoid\n  introducing a new, compile-time-only evaluation
  model to Agda.\n\n  For more information about instance arguments, see Devriese
  &\n  Piessens [ICFP 2011]. Some examples are also available in the\n  examples/instance-arguments
  subdirectory of the Agda distribution.\n\nIrrelevance\n-----------\n\n* Dependent
  irrelevant function types.\n\n  Some examples illustrating the syntax of dependent
  irrelevant\n  function types:\n\n    .(x y : A) → B    .{x y z : A} → B\n    ∀ x
  .y → B        ∀ x .{y} {z} .v → B\n\n  The declaration\n\n    f : .(x : A) → B[x]\n
  \   f x = t[x]\n\n  requires that x is irrelevant both in t[x] and in B[x]. This
  is\n  possible if, for instance, B[x] = B′ x, with B′ : .A → Set.\n\n  Dependent
  irrelevance allows us to define the eliminator for the\n  Squash type:\n\n    record
  Squash (A : Set) : Set where\n      constructor squash\n      field\n        .proof
  : A\n\n    elim-Squash : {A : Set} (P : Squash A → Set)\n                  (ih :
  .(a : A) → P (squash a)) →\n                  (a⁻ : Squash A) → P a⁻\n    elim-Squash
  P ih (squash a) = ih a\n\n  Note that this would not type-check with\n  (ih : (a : A) -> P (squash a)).\n\n*
  Records with only irrelevant fields.\n\n  The following now works:\n\n    record
  IsEquivalence {A : Set} (_≈_ : A → A → Set) : Set where\n      field\n        .refl
  \ : Reflexive _≈_\n        .sym   : Symmetric _≈_\n        .trans : Transitive _≈_\n\n
  \   record Setoid : Set₁ where\n      infix 4 _≈_\n      field\n        Carrier
  \       : Set\n        _≈_            : Carrier → Carrier → Set\n        .isEquivalence
  : IsEquivalence _≈_\n\n      open IsEquivalence isEquivalence public\n\n  Previously
  Agda complained about the application\n  IsEquivalence isEquivalence, because isEquivalence
  is irrelevant and\n  the IsEquivalence module expected a relevant argument. Now,
  when\n  record modules are generated for records consisting solely of\n  irrelevant
  arguments, the record parameter is made irrelevant:\n\n    module IsEquivalence
  {A : Set} {_≈_ : A → A → Set}\n                         .(r : IsEquivalence {A =
  A} _≈_) where\n      …\n\n* Irrelevant things are no longer erased internally. This
  means that\n  they are printed as ordinary terms, not as \"_\" as before.\n\n* The
  new flag --experimental-irrelevance enables irrelevant universe\n  levels and matching
  on irrelevant data when only one constructor is\n  available. These features are
  very experimental and likely to change\n  or disappear.\n\nReflection\n----------\n\n*
  The reflection API has been extended to mirror features like\n  irrelevance, instance
  arguments and universe polymorphism, and to\n  give (limited) access to definitions.
  For completeness all the\n  builtins and primitives are listed below:\n\n    --
  Names.\n\n    postulate Name : Set\n\n    {-# BUILTIN QNAME Name #-}\n\n    primitive\n
  \     -- Equality of names.\n      primQNameEquality : Name → Name → Bool\n\n    --
  Is the argument visible (explicit), hidden (implicit), or an\n    -- instance argument?\n\n
  \   data Visibility : Set where\n      visible hidden instance : Visibility\n\n
  \   {-# BUILTIN HIDING   Visibility #-}\n    {-# BUILTIN VISIBLE  visible    #-}\n
  \   {-# BUILTIN HIDDEN   hidden     #-}\n    {-# BUILTIN INSTANCE instance   #-}\n\n
  \   -- Arguments can be relevant or irrelevant.\n\n    data Relevance : Set where\n
  \     relevant irrelevant : Relevance\n\n    {-# BUILTIN RELEVANCE  Relevance  #-}\n
  \   {-# BUILTIN RELEVANT   relevant   #-}\n    {-# BUILTIN IRRELEVANT irrelevant
  #-}\n\n    -- Arguments.\n\n    data Arg A : Set where\n      arg : (v : Visibility)
  (r : Relevance) (x : A) → Arg A\n\n    {-# BUILTIN ARG    Arg #-}\n    {-# BUILTIN
  ARGARG arg #-}\n\n    -- Terms.\n\n    mutual\n      data Term : Set where\n        --
  Variable applied to arguments.\n        var     : (x : ℕ) (args : List (Arg Term))
  → Term\n        -- Constructor applied to arguments.\n        con     : (c : Name)
  (args : List (Arg Term)) → Term\n        -- Identifier applied to arguments.\n        def
  \    : (f : Name) (args : List (Arg Term)) → Term\n        -- Different kinds of
  λ-abstraction.\n        lam     : (v : Visibility) (t : Term) → Term\n        --
  Pi-type.\n        pi      : (t₁ : Arg Type) (t₂ : Type) → Term\n        -- A sort.\n
  \       sort    : Sort → Term\n        -- Anything else.\n        unknown : Term\n\n
  \     data Type : Set where\n        el : (s : Sort) (t : Term) → Type\n\n      data
  Sort : Set where\n        -- A Set of a given (possibly neutral) level.\n        set
  \    : (t : Term) → Sort\n        -- A Set of a given concrete level.\n        lit
  \    : (n : ℕ) → Sort\n        -- Anything else.\n        unknown : Sort\n\n    {-#
  BUILTIN AGDASORT            Sort    #-}\n    {-# BUILTIN AGDATYPE            Type
  \   #-}\n    {-# BUILTIN AGDATERM            Term    #-}\n    {-# BUILTIN AGDATERMVAR
  \        var     #-}\n    {-# BUILTIN AGDATERMCON         con     #-}\n    {-# BUILTIN
  AGDATERMDEF         def     #-}\n    {-# BUILTIN AGDATERMLAM         lam     #-}\n
  \   {-# BUILTIN AGDATERMPI          pi      #-}\n    {-# BUILTIN AGDATERMSORT        sort
  \   #-}\n    {-# BUILTIN AGDATERMUNSUPPORTED unknown #-}\n    {-# BUILTIN AGDATYPEEL
  \         el      #-}\n    {-# BUILTIN AGDASORTSET         set     #-}\n    {-#
  BUILTIN AGDASORTLIT         lit     #-}\n    {-# BUILTIN AGDASORTUNSUPPORTED unknown
  #-}\n\n    postulate\n      -- Function definition.\n      Function  : Set\n      --
  Data type definition.\n      Data-type : Set\n      -- Record type definition.\n
  \     Record    : Set\n\n    {-# BUILTIN AGDAFUNDEF    Function  #-}\n    {-# BUILTIN
  AGDADATADEF   Data-type #-}\n    {-# BUILTIN AGDARECORDDEF Record    #-}\n\n    --
  Definitions.\n\n    data Definition : Set where\n      function     : Function  →
  Definition\n      data-type    : Data-type → Definition\n      record′      : Record
  \   → Definition\n      constructor′ : Definition\n      axiom        : Definition\n
  \     primitive′   : Definition\n\n    {-# BUILTIN AGDADEFINITION                Definition
  \  #-}\n    {-# BUILTIN AGDADEFINITIONFUNDEF          function     #-}\n    {-#
  BUILTIN AGDADEFINITIONDATADEF         data-type    #-}\n    {-# BUILTIN AGDADEFINITIONRECORDDEF
  \      record′      #-}\n    {-# BUILTIN AGDADEFINITIONDATACONSTRUCTOR constructor′
  #-}\n    {-# BUILTIN AGDADEFINITIONPOSTULATE       axiom        #-}\n    {-# BUILTIN
  AGDADEFINITIONPRIMITIVE       primitive′   #-}\n\n    primitive\n      -- The type
  of the thing with the given name.\n      primQNameType        : Name → Type\n      --
  The definition of the thing with the given name.\n      primQNameDefinition  : Name
  → Definition\n      -- The constructors of the given data type.\n      primDataConstructors
  : Data-type → List Name\n\n  As an example the expression\n\n    primQNameType (quote
  zero)\n\n  is definitionally equal to\n\n    el (lit 0) (def (quote ℕ) [])\n\n  (if
  zero is a constructor of the data type ℕ).\n\n* New keyword: unquote.\n\n  The construction
  \"unquote t\" converts a representation of an Agda term\n  to actual Agda code in
  the following way:\n\n  1. The argument t must have type Term (see the reflection
  API above).\n\n  2. The argument is normalised.\n\n  3. The entire construction
  is replaced by the normal form, which is\n     treated as syntax written by the
  user and type-checked in the\n     usual way.\n\n  Examples:\n\n    test : unquote
  (def (quote ℕ) []) ≡ ℕ\n    test = refl\n\n    id : (A : Set) → A → A\n    id =
  unquote (lam visible (lam visible (var 0 [])))\n\n    id-ok : id ≡ (λ A (x : A)
  → x)\n    id-ok = refl\n\n* New keyword: quoteTerm.\n\n  The construction \"quoteTerm t\"
  is similar to \"quote n\", but whereas\n  quote is restricted to names n, quoteTerm
  accepts terms t. The\n  construction is handled in the following way:\n\n  1. The
  type of t is inferred. The term t must be type-correct.\n\n  2. The term t is normalised.\n\n
  \ 3. The construction is replaced by the Term representation (see the\n     reflection
  API above) of the normal form. Any unsolved metavariables\n     in the term are
  represented by the \"unknown\" term constructor.\n\n  Examples:\n\n    test₁ : quoteTerm
  (λ {A : Set} (x : A) → x) ≡\n            lam hidden (lam visible (var 0 []))\n    test₁
  = refl\n\n    -- Local variables are represented as de Bruijn indices.\n    test₂
  : (λ {A : Set} (x : A) → quoteTerm x) ≡ (λ x → var 0 [])\n    test₂ = refl\n\n    --
  Terms are normalised before being quoted.\n    test₃ : quoteTerm (0 + 0) ≡ con (quote
  zero) []\n    test₃ = refl\n\nCompiler backends\n=================\n\nMAlonzo\n-------\n\n*
  The MAlonzo backend's FFI now handles universe polymorphism in a\n  better way.\n\n
  \ The translation of Agda types and kinds into Haskell now supports\n  universe-polymorphic
  postulates. The core changes are that the\n  translation of function types has been
  changed from\n\n    T[[ Pi (x : A) B ]] =\n      if A has a Haskell kind then\n
  \       forall x. () -> T[[ B ]]\n      else if x in fv B then\n        undef\n
  \     else\n        T[[ A ]] -> T[[ B ]]\n\n  into\n\n    T[[ Pi (x : A) B ]] =\n
  \     if x in fv B then\n        forall x. T[[ A ]] -> T[[ B ]]  -- Note: T[[A]]
  not Unit.\n      else\n        T[[ A ]] -> T[[ B ]],\n\n  and that the translation
  of constants (postulates, constructors and\n  literals) has been changed from\n\n
  \   T[[ k As ]] =\n      if COMPILED_TYPE k T then\n        T T[[ As ]]\n      else\n
  \       undef\n\n  into\n\n    T[[ k As ]] =\n      if COMPILED_TYPE k T then\n
  \       T T[[ As ]]\n      else if COMPILED k E then\n        ()\n      else\n        undef.\n\n
  \ For instance, assuming a Haskell definition\n\n    type AgdaIO a b = IO b,\n\n
  \ we can set up universe-polymorphic IO in the following way:\n\n    postulate\n
  \     IO     : ∀ {ℓ} → Set ℓ → Set ℓ\n      return : ∀ {a} {A : Set a} → A → IO
  A\n      _>>=_  : ∀ {a b} {A : Set a} {B : Set b} →\n               IO A → (A →
  IO B) → IO B\n\n    {-# COMPILED_TYPE IO AgdaIO              #-}\n    {-# COMPILED
  return  (\\_ _ -> return)    #-}\n    {-# COMPILED _>>=_   (\\_ _ _ _ -> (>>=))
  #-}\n\n  This is accepted because (assuming that the universe level type is\n  translated
  to the Haskell unit type \"()\")\n\n    (\\_ _ -> return)\n      : forall a. ()
  -> forall b. () -> b -> AgdaIO a b\n      = T [[ ∀ {a} {A : Set a} → A → IO A ]]\n\n
  \ and\n\n    (\\_ _ _ _ -> (>>=))\n      : forall a. () -> forall b. () ->\n          forall
  c. () -> forall d. () ->\n            AgdaIO a c -> (c -> AgdaIO b d) -> AgdaIO
  b d\n      = T [[ ∀ {a b} {A : Set a} {B : Set b} →\n               IO A → (A →
  IO B) → IO B ]].\n\nEpic\n----\n\n* New Epic backend pragma: STATIC.\n\n  In the
  Epic backend, functions marked with the STATIC pragma will be\n  normalised before
  compilation. Example usage:\n\n    {-# STATIC power #-}\n\n    power : ℕ → ℕ → ℕ\n
  \   power 0       x = 1\n    power 1       x = x\n    power (suc n) x = power n
  x * x\n\n  Occurrences of \"power 4 x\" will be replaced by \"((x * x) * x) * x\".\n\n*
  Some new optimisations have been implemented in the Epic backend:\n\n  - Removal
  of unused arguments.\n\n  A worker/wrapper transformation is performed so that unused\n
  \ arguments can be removed by Epic's inliner. For instance, the map\n  function
  is transformed in the following way:\n\n    map_wrap : (A B : Set) → (A → B) → List
  A → List B\n    map_wrap A B f xs = map_work f xs\n\n    map_work f []       = []\n
  \   map_work f (x ∷ xs) = f x ∷ map_work f xs\n\n  If map_wrap is inlined (which
  it will be in any saturated call),\n  then A and B disappear in the generated code.\n\n
  \ Unused arguments are found using abstract interpretation. The bodies\n  of all
  functions in a module are inspected to decide which variables\n  are used. The behaviour
  of postulates is approximated based on their\n  types. Consider return, for instance:\n\n
  \   postulate return : {A : Set} → A → IO A\n\n  The first argument of return can
  be removed, because it is of type\n  Set and thus cannot affect the outcome of a
  program at runtime.\n\n  - Injection detection.\n\n  At runtime many functions may
  turn out to be inefficient variants of\n  the identity function. This is especially
  true after forcing.\n  Injection detection replaces some of these functions with
  more\n  efficient versions. Example:\n\n    inject : {n : ℕ} → Fin n → Fin (1 +
  n)\n    inject {suc n} zero    = zero\n    inject {suc n} (suc i) = suc (inject
  {n} i)\n\n  Forcing removes the Fin constructors' ℕ arguments, so this function\n
  \ is an inefficient identity function that can be replaced by the\n  following one:\n\n
  \   inject {_} x = x\n\n  To actually find this function, we make the induction
  hypothesis\n  that inject is an identity function in its second argument and look\n
  \ at the branches of the function to decide if this holds.\n\n  Injection detection
  also works over data type barriers. Example:\n\n    forget : {A : Set} {n : ℕ} →
  Vec A n → List A\n    forget []       = []\n    forget (x ∷ xs) = x ∷ forget xs\n\n
  \ Given that the constructor tags (in the compiled Epic code) for\n  Vec.[] and
  List.[] are the same, and that the tags for Vec._∷_ and\n  List._∷_ are also the
  same, this is also an identity function. We\n  can hence replace the definition
  with the following one:\n\n    forget {_} xs = xs\n\n  To get this to apply as often
  as possible, constructor tags are\n  chosen /after/ injection detection has been
  run, in a way to make as\n  many functions as possible injections.\n\n  Constructor
  tags are chosen once per source file, so it may be\n  advantageous to define conversion
  functions like forget in the same\n  module as one of the data types. For instance,
  if Vec.agda imports\n  List.agda, then the forget function should be put in Vec.agda
  to\n  ensure that vectors and lists get the same tags (unless some other\n  injection
  function, which puts different constraints on the tags, is\n  prioritised).\n\n
  \ - Smashing.\n\n  This optimisation finds types whose values are inferable at runtime:\n\n
  \   * A data type with only one constructor where all fields are\n      inferable
  is itself inferable.\n    * Set ℓ is inferable (as it has no runtime representation).\n\n
  \ A function returning an inferable data type can be smashed, which\n  means that
  it is replaced by a function which simply returns the\n  inferred value.\n\n  An
  important example of an inferable type is the usual propositional\n  equality type
  (_≡_). Any function returning a propositional equality\n  can simply return the
  reflexivity constructor directly without\n  computing anything.\n\n  This optimisation
  makes more arguments unused. It also makes the\n  Epic code size smaller, which
  in turn speeds up compilation.\n\nJavaScript\n----------\n\n* ECMAScript compiler
  backend.\n\n  A new compiler backend is being implemented, targetting ECMAScript\n
  \ (also known as JavaScript), with the goal of allowing Agda programs\n  to be run
  in browsers or other ECMAScript environments.\n\n  The backend is still at an experimental
  stage: the core language is\n  implemented, but many features are still missing.\n\n
  \ The ECMAScript compiler can be invoked from the command line using\n  the flag
  --js:\n\n    agda --js --compile-dir=<DIR> <FILE>.agda\n\n  Each source <FILE>.agda
  is compiled into an ECMAScript target\n  <DIR>/jAgda.<TOP-LEVEL MODULE NAME>.js.
  The compiler can also be\n  invoked using the Emacs mode (the variable agda2-backend
  controls\n  which backend is used).\n\n  Note that ECMAScript is a strict rather
  than lazy language. Since\n  Agda programs are total, this should not impact program
  semantics,\n  but it may impact their space or time usage.\n\n  ECMAScript does
  not support algebraic datatypes or pattern-matching.\n  These features are translated
  to a use of the visitor pattern. For\n  instance, the standard library's List data
  type and null function\n  are translated into the following code:\n\n    exports[\"List\"]
  = {};\n    exports[\"List\"][\"[]\"] = function (x0) {\n        return x0[\"[]\"]();\n
  \     };\n    exports[\"List\"][\"_∷_\"] = function (x0) {\n        return function
  (x1) {\n          return function (x2) {\n            return x2[\"_∷_\"](x0, x1);\n
  \         };\n        };\n      };\n\n    exports[\"null\"] = function (x0) {\n
  \       return function (x1) {\n          return function (x2) {\n            return
  x2({\n              \"[]\": function () {\n                return jAgda_Data_Bool[\"Bool\"][\"true\"];\n
  \             },\n              \"_∷_\": function (x3, x4) {\n                return
  jAgda_Data_Bool[\"Bool\"][\"false\"];\n              }\n            });\n          };\n
  \       };\n      };\n\n  Agda records are translated to ECMAScript objects, preserving
  field\n  names.\n\n  Top-level Agda modules are translated to ECMAScript modules,\n
  \ following the common.js module specification. A top-level Agda\n  module \"Foo.Bar\"
  is translated to an ECMAScript module\n  \"jAgda.Foo.Bar\".\n\n  The ECMAScript
  compiler does not compile to Haskell, so the pragmas\n  related to the Haskell FFI
  (IMPORT, COMPILED_DATA and COMPILED) are\n  not used by the ECMAScript backend.
  Instead, there is a COMPILED_JS\n  pragma which may be applied to any declaration.
  For postulates,\n  primitives, functions and values, it gives the ECMAScript code
  to be\n  emitted by the compiler. For data types, it gives a function which\n  is
  applied to a value of that type, and a visitor object. For\n  instance, a binding
  of natural numbers to ECMAScript integers\n  (ignoring overflow errors) is:\n\n
  \   data ℕ : Set where\n      zero : ℕ\n      suc  : ℕ → ℕ\n\n    {-# COMPILED_JS
  ℕ function (x,v) {\n        if (x < 1) { return v.zero(); } else { return v.suc(x-1);
  }\n      } #-}\n    {-# COMPILED_JS zero 0 #-}\n    {-# COMPILED_JS suc function
  (x) { return x+1; } #-}\n\n    _+_ : ℕ → ℕ → ℕ\n    zero  + n = n\n    suc m + n
  = suc (m + n)\n\n    {-# COMPILED_JS _+_ function (x) { return function (y) {\n
  \                         return x+y; };\n      } #-}\n\n  To allow FFI code to
  be optimised, the ECMAScript in a COMPILED_JS\n  declaration is parsed, using a
  simple parser that recognises a pure\n  functional subset of ECMAScript, consisting
  of functions, function\n  applications, return, if-statements, if-expressions,\n
  \ side-effect-free binary operators (no precedence, left associative),\n  side-effect-free
  prefix operators, objects (where all member names\n  are quoted), field accesses,
  and string and integer literals.\n  Modules may be imported using the require(\"<module-id>\")
  syntax: any\n  impure code, or code outside the supported fragment, can be placed\n
  \ in a module and imported.\n\nTools\n=====\n\n* New flag --safe, which can be used
  to type-check untrusted code.\n\n  This flag disables postulates, primTrustMe, and
  \"unsafe\" OPTION\n  pragmas, some of which are known to make Agda inconsistent.\n\n
  \ Rejected pragmas:\n\n    --allow-unsolved-metas\n    --experimental-irrelevance\n
  \   --guardedness-preserving-type-construtors\n    --injective-type-constructors\n
  \   --no-coverage-check\n    --no-positivity-check\n    --no-termination-check\n
  \   --sized-types\n    --type-in-type\n\n  Note that, at the moment, it is not possible
  to define the universe\n  level or coinduction primitives when --safe is used (because
  they\n  must be introduced as postulates). This can be worked around by\n  type-checking
  trusted files in a first pass, without using --safe,\n  and then using --safe in
  a second pass. Modules which have already\n  been type-checked are not re-type-checked
  just because --safe is\n  used.\n\n* Dependency graphs.\n\n  The new flag --dependency-graph=FILE
  can be used to generate a DOT\n  file containing a module dependency graph. The
  generated file (FILE)\n  can be rendered using a tool like dot.\n\n* The --no-unreachable-check
  flag has been removed.\n\n* Projection functions are highlighted as functions instead
  of as\n  fields. Field names (in record definitions and record values) are\n  still
  highlighted as fields.\n\n* Support for jumping to positions mentioned in the information\n
  \ buffer has been added.\n\n* The \"make install\" command no longer installs Agda
  globally (by\n  default).\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.10\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.8:\n\nLanguage\n--------\n\n* New flag: --without-K.\n\n  This
  flag makes pattern matching more restricted. If the flag is\n  activated, then Agda
  only accepts certain case-splits. If the type\n  of the variable to be split is
  D pars ixs, where D is a data (or\n  record) type, pars stands for the parameters,
  and ixs the indices,\n  then the following requirements must be satisfied:\n\n  *
  The indices ixs must be applications of constructors to distinct\n    variables.\n\n
  \ * These variables must not be free in pars.\n\n  The intended purpose of --without-K
  is to enable experiments with a\n  propositional equality without the K rule. Let
  us define\n  propositional equality as follows:\n\n    data _≡_ {A : Set} : A →
  A → Set where\n      refl : ∀ x → x ≡ x\n\n  Then the obvious implementation of
  the J rule is accepted:\n\n    J : {A : Set} (P : {x y : A} → x ≡ y → Set) →\n        (∀
  x → P (refl x)) →\n        ∀ {x y} (x≡y : x ≡ y) → P x≡y\n    J P p (refl x) = p
  x\n\n  The same applies to Christine Paulin-Mohring's version of the J rule:\n\n
  \   J′ : {A : Set} {x : A} (P : {y : A} → x ≡ y → Set) →\n         P (refl x) →\n
  \        ∀ {y} (x≡y : x ≡ y) → P x≡y\n    J′ P p (refl x) = p\n\n  On the other
  hand, the obvious implementation of the K rule is not\n  accepted:\n\n    K : {A
  : Set} (P : {x : A} → x ≡ x → Set) →\n        (∀ x → P (refl x)) →\n        ∀ {x}
  (x≡x : x ≡ x) → P x≡x\n    K P p (refl x) = p x\n\n  However, we have /not/ proved
  that activation of --without-K ensures\n  that the K rule cannot be proved in some
  other way.\n\n* Irrelevant declarations.\n\n  Postulates and functions can be marked
  as irrelevant by prefixing\n  the name with a dot when the name is declared. Example:\n\n
  \   postulate\n      .irrelevant : {A : Set} → .A → A\n\n  Irrelevant names may
  only be used in irrelevant positions or in\n  definitions of things which have been
  declared irrelevant.\n\n  The axiom irrelevant above can be used to define a projection
  from\n  an irrelevant record field:\n\n    data Subset (A : Set) (P : A → Set) :
  Set where\n      _#_ : (a : A) → .(P a) → Subset A P\n\n    elem : ∀ {A P} → Subset
  A P → A\n    elem (a # p) = a\n\n    .certificate : ∀ {A P} (x : Subset A P) → P
  (elem x)\n    certificate (a # p) = irrelevant p\n\n  The right-hand side of certificate
  is relevant, so we cannot define\n\n    certificate (a # p) = p\n\n  (because p
  is irrelevant). However, certificate is declared to be\n  irrelevant, so it can
  use the axiom irrelevant. Furthermore the\n  first argument of the axiom is irrelevant,
  which means that\n  irrelevant p is well-formed.\n\n  As shown above the axiom irrelevant
  justifies irrelevant\n  projections. Previously no projections were generated for
  irrelevant\n  record fields, such as the field certificate in the following\n  record
  type:\n\n    record Subset (A : Set) (P : A → Set) : Set where\n      constructor
  _#_\n      field\n        elem         : A\n        .certificate : P elem\n\n  Now
  projections are generated automatically for irrelevant fields\n  (unless the flag
  --no-irrelevant-projections is used). Note that\n  irrelevant projections are highly
  experimental.\n\n* Termination checker recognises projections.\n\n  Projections
  now preserve sizes, both in patterns and expressions.\n  Example:\n\n    record
  Wrap (A : Set) : Set where\n      constructor wrap\n      field\n        unwrap
  : A\n\n    open Wrap public\n\n    data WNat : Set where\n      zero : WNat\n      suc
  \ : Wrap WNat → WNat\n\n    id : WNat → WNat\n    id zero    = zero\n    id (suc
  w) = suc (wrap (id (unwrap w)))\n\n  In the structural ordering unwrap w ≤ w. This
  means that\n\n    unwrap w ≤ w < suc w,\n\n  and hence the recursive call to id
  is accepted.\n\n  Projections also preserve guardedness.\n\nTools\n-----\n\n* Hyperlinks
  for top-level module names now point to the start of the\n  module rather than to
  the declaration of the module name. This\n  applies both to the Emacs mode and to
  the output of agda --html.\n\n* Most occurrences of record field names are now highlighted
  as\n  \"fields\". Previously many occurrences were highlighted as\n  \"functions\".\n\n*
  Emacs mode: It is no longer possible to change the behaviour of the\n  TAB key by
  customising agda2-indentation.\n\n* Epic compiler backend.\n\n  A new compiler backend
  is being implemented. This backend makes use\n  of Edwin Brady's language Epic\n
  \ (http://www.cs.st-andrews.ac.uk/~eb/epic.php) and its compiler. The\n  backend
  should handle most Agda code, but is still at an\n  experimental stage: more testing
  is needed, and some things written\n  below may not be entirely true.\n\n  The Epic
  compiler can be invoked from the command line using the\n  flag --epic:\n\n    agda
  --epic --epic-flag=<EPIC-FLAG> --compile-dir=<DIR> <FILE>.agda\n\n  The --epic-flag
  flag can be given multiple times; each flag is given\n  verbatim to the Epic compiler
  (in the given order). The resulting\n  executable is named after the main module
  and placed in the\n  directory specified by the --compile-dir flag (default: the
  project\n  root). Intermediate files are placed in a subdirectory called Epic.\n\n
  \ The backend requires that there is a definition named main. This\n  definition
  should be a value of type IO Unit, but at the moment this\n  is not checked (so
  it is easy to produce a program which segfaults).\n  Currently the backend represents
  actions of type IO A as functions\n  from Unit to A, and main is applied to the
  unit value.\n\n  The Epic compiler compiles via C, not Haskell, so the pragmas\n
  \ related to the Haskell FFI (IMPORT, COMPILED_DATA and COMPILED) are\n  not used
  by the Epic backend. Instead there is a new pragma\n  COMPILED_EPIC. This pragma
  is used to give Epic code for postulated\n  definitions (Epic code can in turn call
  C code). The form of the\n  pragma is {-# COMPILED_EPIC def code #-}, where def
  is the name of\n  an Agda postulate and code is some Epic code which should include\n
  \ the function arguments, return type and function body. As an example\n  the IO
  monad can be defined as follows:\n\n    postulate\n      IO     : Set → Set\n      return
  : ∀ {A} → A → IO A\n      _>>=_  : ∀ {A B} → IO A → (A → IO B) → IO B\n\n    {-#
  COMPILED_EPIC return (u : Unit, a : Any) -> Any =\n                        ioreturn(a)
  #-}\n    {-# COMPILED_EPIC\n          _>>=_ (u1 : Unit, u2 : Unit, x : Any, f :
  Any) -> Any =\n            iobind(x,f) #-}\n\n  Here ioreturn and iobind are Epic
  functions which are defined in the\n  file AgdaPrelude.e which is always included.\n\n
  \ By default the backend will remove so-called forced constructor\n  arguments (and
  case-splitting on forced variables will be\n  rewritten). This optimisation can
  be disabled by using the flag\n  --no-forcing.\n\n  All data types which look like
  unary natural numbers after forced\n  constructor arguments have been removed (i.e.
  types with two\n  constructors, one nullary and one with a single recursive argument)\n
  \ will be represented as \"BigInts\". This applies to the standard Fin\n  type,
  for instance.\n\n  The backend supports Agda's primitive functions and the BUILTIN\n
  \ pragmas. If the BUILTIN pragmas for unary natural numbers are used,\n  then some
  operations, like addition and multiplication, will use\n  more efficient \"BigInt\"
  operations.\n\n  If you want to make use of the Epic backend you need to install
  some\n  dependencies, see the README.\n\n* The Emacs mode can compile using either
  the MAlonzo or the Epic\n  backend. The variable agda2-backend controls which backend
  is used.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.8\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.6:\n\nLanguage\n--------\n\n* Record pattern matching.\n\n  It
  is now possible to pattern match on named record constructors.\n  Example:\n\n    record
  Σ (A : Set) (B : A → Set) : Set where\n      constructor _,_\n      field\n        proj₁
  : A\n        proj₂ : B proj₁\n\n    map : {A B : Set} {P : A → Set} {Q : B → Set}\n
  \         (f : A → B) → (∀ {x} → P x → Q (f x)) →\n          Σ A P → Σ B Q\n    map
  f g (x , y) = (f x , g y)\n\n  The clause above is internally translated into the
  following one:\n\n    map f g p = (f (Σ.proj₁ p) , g (Σ.proj₂ p))\n\n  Record patterns
  containing data type patterns are not translated.\n  Example:\n\n    add : ℕ × ℕ
  → ℕ\n    add (zero  , n) = n\n    add (suc m , n) = suc (add (m , n))\n\n  Record
  patterns which do not contain data type patterns, but which\n  do contain dot patterns,
  are currently rejected. Example:\n\n    Foo : {A : Set} (p₁ p₂ : A × A) → proj₁
  p₁ ≡ proj₁ p₂ → Set₁\n    Foo (x , y) (.x , y′) refl = Set\n\n* Proof irrelevant
  function types.\n\n  Agda now supports irrelevant non-dependent function types:\n\n
  \   f : .A → B\n\n  This type implies that f does not depend computationally on
  its\n  argument. One intended use case is data structures with embedded\n  proofs,
  like sorted lists:\n\n    postulate\n      _≤_ : ℕ → ℕ → Set\n      p₁  : 0 ≤ 1\n
  \     p₂  : 0 ≤ 1\n\n    data SList (bound : ℕ) : Set where\n      []    : SList
  bound\n      scons : (head : ℕ) →\n              .(head ≤ bound) →\n              (tail
  : SList head) →\n              SList bound\n\n  The effect of the irrelevant type
  in the signature of scons is that\n  scons's second argument is never inspected
  after Agda has ensured\n  that it has the right type. It is even thrown away, leading
  to\n  smaller term sizes and hopefully some gain in efficiency. The\n  type-checker
  ignores irrelevant arguments when checking equality, so\n  two lists can be equal
  even if they contain different proofs:\n\n    l₁ : SList 1\n    l₁ = scons 0 p₁
  []\n\n    l₂ : SList 1\n    l₂ = scons 0 p₂ []\n\n    l₁≡l₂ : l₁ ≡ l₂\n    l₁≡l₂
  = refl\n\n  Irrelevant arguments can only be used in irrelevant contexts.\n  Consider
  the following subset type:\n\n    data Subset (A : Set) (P : A → Set) : Set where\n
  \     _#_ : (elem : A) → .(P elem) → Subset A P\n\n  The following two uses are
  fine:\n\n    elimSubset : ∀ {A C : Set} {P} →\n                 Subset A P → ((a
  : A) → .(P a) → C) → C\n    elimSubset (a # p) k = k a p\n\n    elem : {A : Set}
  {P : A → Set} → Subset A P → A\n    elem (x # p) = x\n\n  However, if we try to
  project out the proof component, then Agda\n  complains that \"variable p is declared
  irrelevant, so it cannot be\n  used here\":\n\n    prjProof : ∀ {A P} (x : Subset
  A P) → P (elem x)\n    prjProof (a # p) = p\n\n  Matching against irrelevant arguments
  is also forbidden, except in\n  the case of irrefutable matches (record constructor
  patterns which\n  have been translated away). For instance, the match against the\n
  \ pattern (p , q) here is accepted:\n\n    elim₂ : ∀ {A C : Set} {P Q : A → Set}
  →\n            Subset A (λ x → Σ (P x) (λ _ → Q x)) →\n            ((a : A) → .(P
  a) → .(Q a) → C) → C\n    elim₂ (a # (p , q)) k = k a p q\n\n  Absurd matches ()
  are also allowed.\n\n  Note that record fields can also be irrelevant. Example:\n\n
  \   record Subset (A : Set) (P : A → Set) : Set where\n      constructor _#_\n      field\n
  \       elem   : A\n        .proof : P elem\n\n  Irrelevant fields are never in
  scope, neither inside nor outside the\n  record. This means that no record field
  can depend on an irrelevant\n  field, and furthermore projections are not defined
  for such fields.\n  Irrelevant fields can only be accessed using pattern matching,
  as in\n  elimSubset above.\n\n  Irrelevant function types were added very recently,
  and have not\n  been subjected to much experimentation yet, so do not be surprised\n
  \ if something is changed before the next release. For instance,\n  dependent irrelevant
  function spaces (.(x : A) → B) might be added\n  in the future.\n\n* Mixfix binders.\n\n
  \ It is now possible to declare user-defined syntax that binds\n  identifiers. Example:\n\n
  \   postulate\n      State  : Set → Set → Set\n      put    : ∀ {S} → S → State
  S ⊤\n      get    : ∀ {S} → State S S\n      return : ∀ {A S} → A → State S A\n
  \     bind   : ∀ {A B S} → State S B → (B → State S A) → State S A\n\n    syntax
  bind e₁ (λ x → e₂) = x ← e₁ , e₂\n\n    increment : State ℕ ⊤\n    increment = x
  ← get ,\n                put (1 + x)\n\n  The syntax declaration for bind implies
  that x is in scope in e₂,\n  but not in e₁.\n\n  You can give fixity declarations
  along with syntax declarations:\n\n    infixr 40 bind\n    syntax bind e₁ (λ x →
  e₂) = x ← e₁ , e₂\n\n  The fixity applies to the syntax, not the name; syntax declarations\n
  \ are also restricted to ordinary, non-operator names. The following\n  declaration
  is disallowed:\n\n    syntax _==_ x y = x === y\n\n  Syntax declarations must also
  be linear; the following declaration\n  is disallowed:\n\n    syntax wrong x = x
  + x\n\n  Syntax declarations were added very recently, and have not been\n  subjected
  to much experimentation yet, so do not be surprised if\n  something is changed before
  the next release.\n\n* Prop has been removed from the language.\n\n  The experimental
  sort Prop has been disabled. Any program using Prop\n  should typecheck if Prop
  is replaced by Set₀. Note that Prop is still\n  a keyword.\n\n* Injective type constructors
  off by default.\n\n  Automatic injectivity of type constructors has been disabled
  (by\n  default). To enable it, use the flag --injective-type-constructors,\n  either
  on the command line or in an OPTIONS pragma. Note that this\n  flag makes Agda anti-classical
  and possibly inconsistent:\n\n    Agda with excluded middle is inconsistent\n    http://thread.gmane.org/gmane.comp.lang.agda/1367\n\n
  \ See test/Succeed/InjectiveTypeConstructors.agda for an example.\n\n* Termination
  checker can count.\n\n  There is a new flag --termination-depth=N accepting values
  N >= 1\n  (with N = 1 being the default) which influences the behavior of the\n
  \ termination checker. So far, the termination checker has only\n  distinguished
  three cases when comparing the argument of a recursive\n  call with the formal parameter
  of the callee.\n\n    < : the argument is structurally smaller than the parameter\n
  \   = : they are equal\n    ? : the argument is bigger or unrelated to the parameter\n\n
  \ This behavior, which is still the default (N = 1), will not\n  recognise the following
  functions as terminating.\n\n    mutual\n\n      f : ℕ → ℕ\n      f zero          =
  zero\n      f (suc zero)    = zero\n      f (suc (suc n)) = aux n\n\n      aux :
  ℕ → ℕ\n      aux m = f (suc m)\n\n  The call graph\n\n    f --(<)--> aux --(?)-->
  f\n\n  yields a recursive call from f to f via aux where the relation of\n  call
  argument to callee parameter is computed as \"unrelated\"\n  (composition of < and
  ?).\n\n  Setting N >= 2 allows a finer analysis: n has two constructors less\n  than
  suc (suc n), and suc m has one more than m, so we get the call\n  graph:\n\n    f
  --(-2)--> aux --(+1)--> f\n\n  The indirect call f --> f is now labeled with (-1),
  and the\n  termination checker can recognise that the call argument is\n  decreasing
  on this path.\n\n  Setting the termination depth to N means that the termination\n
  \ checker counts decrease up to N and increase up to N-1. The default,\n  N=1, means
  that no increase is counted, every increase turns to\n  \"unrelated\".\n\n  In practice,
  examples like the one above sometimes arise when \"with\"\n  is used. As an example,
  the program\n\n    f : ℕ → ℕ\n    f zero          = zero\n    f (suc zero)    =
  zero\n    f (suc (suc n)) with zero\n    ... | _ = f (suc n)\n\n  is internally
  represented as\n\n    mutual\n\n      f : ℕ → ℕ\n      f zero          = zero\n
  \     f (suc zero)    = zero\n      f (suc (suc n)) = aux n zero\n\n      aux :
  ℕ → ℕ → ℕ\n      aux m k = f (suc m)\n\n  Thus, by default, the definition of f
  using \"with\" is not accepted\n  by the termination checker, even though it looks
  structural (suc n\n  is a subterm of suc suc n). Now, the termination checker is\n
  \ satisfied if the option \"--termination-depth=2\" is used.\n\n  Caveats:\n\n  -
  This is an experimental feature, hopefully being replaced by\n    something smarter
  in the near future.\n\n  - Increasing the termination depth will quickly lead to
  very long\n    termination checking times. So, use with care. Setting termination\n
  \   depth to 100 by habit, just to be on the safe side, is not a good\n    idea!\n\n
  \ - Increasing termination depth only makes sense for linear data\n    types such
  as ℕ and Size. For other types, increase cannot be\n    recognised. For instance,
  consider a similar example with lists.\n\n      data List : Set where\n\tnil  :
  List\n\tcons : ℕ → List → List\n\n      mutual\n\tf : List → List\n\tf nil                  =
  nil\n\tf (cons x nil)         = nil\n\tf (cons x (cons y ys)) = aux y ys\n\n\taux
  : ℕ → List → List\n\taux z zs = f (cons z zs)\n\n    Here the termination checker
  compares cons z zs to z and also to\n    zs. In both cases, the result will be \"unrelated\",
  no matter how\n    high we set the termination depth. This is because when comparing\n
  \   cons z zs to zs, for instance, z is unrelated to zs, thus,\n    cons z zs is
  also unrelated to zs. We cannot say it is just \"one\n    larger\" since z could
  be a very large term. Note that this points\n    to a weakness of untyped termination
  checking.\n\n    To regain the benefit of increased termination depth, we need to\n
  \   index our lists by a linear type such as ℕ or Size. With\n    termination depth
  2, the above example is accepted for vectors\n    instead of lists.\n\n* The codata
  keyword has been removed. To use coinduction, use the\n  following new builtins:
  INFINITY, SHARP and FLAT. Example:\n\n    {-# OPTIONS --universe-polymorphism #-}\n\n
  \   module Coinduction where\n\n    open import Level\n\n    infix 1000 ♯_\n\n    postulate\n
  \     ∞  : ∀ {a} (A : Set a) → Set a\n      ♯_ : ∀ {a} {A : Set a} → A → ∞ A\n      ♭
  \ : ∀ {a} {A : Set a} → ∞ A → A\n\n    {-# BUILTIN INFINITY ∞  #-}\n    {-# BUILTIN
  SHARP    ♯_ #-}\n    {-# BUILTIN FLAT     ♭  #-}\n\n  Note that (non-dependent)
  pattern matching on SHARP is no longer\n  allowed.\n\n  Note also that strange things
  might happen if you try to combine the\n  pragmas above with COMPILED_TYPE, COMPILED_DATA
  or COMPILED pragmas,\n  or if the pragmas do not occur right after the postulates.\n\n
  \ The compiler compiles the INFINITY builtin to nothing (more or\n  less), so that
  the use of coinduction does not get in the way of FFI\n  declarations:\n\n    data
  Colist (A : Set) : Set where\n      []  : Colist A\n      _∷_ : (x : A) (xs : ∞
  (Colist A)) → Colist A\n\n    {-# COMPILED_DATA Colist [] [] (:) #-}\n\n* Infinite
  types.\n\n  If the new flag --guardedness-preserving-type-constructors is used,\n
  \ then type constructors are treated as inductive constructors when we\n  check
  productivity (but only in parameters, and only if they are\n  used strictly positively
  or not at all). This makes examples such as\n  the following possible:\n\n    data
  Rec (A : ∞ Set) : Set where\n      fold : ♭ A → Rec A\n\n    -- Σ cannot be a record
  type below.\n\n    data Σ (A : Set) (B : A → Set) : Set where\n      _,_ : (x :
  A) → B x → Σ A B\n\n    syntax Σ A (λ x → B) = Σ[ x ∶ A ] B\n\n    -- Corecursive
  definition of the W-type.\n\n    W : (A : Set) → (A → Set) → Set\n    W A B = Rec
  (♯ (Σ[ x ∶ A ] (B x → W A B)))\n\n    syntax W A (λ x → B) = W[ x ∶ A ] B\n\n    sup
  : {A : Set} {B : A → Set} (x : A) (f : B x → W A B) → W A B\n    sup x f = fold
  (x , f)\n\n    W-rec : {A : Set} {B : A → Set}\n            (P : W A B → Set) →\n
  \           (∀ {x} {f : B x → W A B} → (∀ y → P (f y)) → P (sup x f)) →\n            ∀
  x → P x\n    W-rec P h (fold (x , f)) = h (λ y → W-rec P h (f y))\n\n    -- Induction-recursion
  encoded as corecursion-recursion.\n\n    data Label : Set where\n      ′0 ′1 ′2
  ′σ ′π ′w : Label\n\n    mutual\n\n      U : Set\n      U = Σ Label U′\n\n      U′
  : Label → Set\n      U′ ′0 = ⊤\n      U′ ′1 = ⊤\n      U′ ′2 = ⊤\n      U′ ′σ =
  Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n      U′ ′π = Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n
  \     U′ ′w = Rec (♯ (Σ[ a ∶ U ] (El a → U)))\n\n      El : U → Set\n      El (′0
  , _)            = ⊥\n      El (′1 , _)            = ⊤\n      El (′2 , _)            =
  Bool\n      El (′σ , fold (a , b)) = Σ[ x ∶ El a ]  El (b x)\n      El (′π , fold
  (a , b)) =   (x : El a) → El (b x)\n      El (′w , fold (a , b)) = W[ x ∶ El a ]
  \ El (b x)\n\n    U-rec : (P : ∀ u → El u → Set) →\n            P (′1 , _) tt →\n
  \           P (′2 , _) true →\n            P (′2 , _) false →\n            (∀ {a
  b x y} →\n             P a x → P (b x) y → P (′σ , fold (a , b)) (x , y)) →\n            (∀
  {a b f} →\n             (∀ x → P (b x) (f x)) → P (′π , fold (a , b)) f) →\n            (∀
  {a b x f} →\n             (∀ y → P (′w , fold (a , b)) (f y)) →\n             P
  (′w , fold (a , b)) (sup x f)) →\n            ∀ u (x : El u) → P u x\n    U-rec
  P P1 P2t P2f Pσ Pπ Pw = rec\n      where\n      rec : ∀ u (x : El u) → P u x\n      rec
  (′0 , _)            ()\n      rec (′1 , _)            _              = P1\n      rec
  (′2 , _)            true           = P2t\n      rec (′2 , _)            false          =
  P2f\n      rec (′σ , fold (a , b)) (x , y)        = Pσ (rec _ x) (rec _ y)\n      rec
  (′π , fold (a , b)) f              = Pπ (λ x → rec _ (f x))\n      rec (′w , fold
  (a , b)) (fold (x , f)) = Pw (λ y → rec _ (f y))\n\n  The --guardedness-preserving-type-constructors
  extension is based on\n  a rather operational understanding of ∞/♯_; it's not yet
  clear if\n  this extension is consistent.\n\n* Qualified constructors.\n\n  Constructors
  can now be referred to qualified by their data type.\n  For instance, given\n\n
  \   data Nat : Set where\n      zero : Nat\n      suc  : Nat → Nat\n\n    data Fin
  : Nat → Set where\n      zero : ∀ {n} → Fin (suc n)\n      suc  : ∀ {n} → Fin n
  → Fin (suc n)\n\n  you can refer to the constructors unambiguously as Nat.zero,\n
  \ Nat.suc, Fin.zero, and Fin.suc (Nat and Fin are modules containing\n  the respective
  constructors). Example:\n\n    inj : (n m : Nat) → Nat.suc n ≡ suc m → n ≡ m\n    inj
  .m m refl = refl\n\n  Previously you had to write something like\n\n    inj : (n
  m : Nat) → _≡_ {Nat} (suc n) (suc m) → n ≡ m\n\n  to make the type checker able
  to figure out that you wanted the\n  natural number suc in this case.\n\n* Reflection.\n\n
  \ There are two new constructs for reflection:\n\n    - quoteGoal x in e\n\n      In
  e the value of x will be a representation of the goal type\n      (the type expected
  of the whole expression) as an element in a\n      datatype of Agda terms (see below).
  For instance,\n\n      example : ℕ\n      example = quoteGoal x in {! at this point
  x = def (quote ℕ) [] !}\n\n    - quote x : Name\n\n      If x is the name of a definition
  (function, datatype, record, or\n      a constructor), quote x gives you the representation
  of x as a\n      value in the primitive type Name (see below).\n\n  Quoted terms
  use the following BUILTINs and primitives (available\n  from the standard library
  module Reflection):\n\n    -- The type of Agda names.\n\n    postulate Name : Set\n\n
  \   {-# BUILTIN QNAME Name #-}\n\n    primitive primQNameEquality : Name → Name
  → Bool\n\n    -- Arguments.\n\n    Explicit? = Bool\n\n    data Arg A : Set where\n
  \     arg : Explicit? → A → Arg A\n\n    {-# BUILTIN ARG    Arg #-}\n    {-# BUILTIN
  ARGARG arg #-}\n\n    -- The type of Agda terms.\n\n    data Term : Set where\n
  \     var     : ℕ → List (Arg Term) → Term\n      con     : Name → List (Arg Term)
  → Term\n      def     : Name → List (Arg Term) → Term\n      lam     : Explicit?
  → Term → Term\n      pi      : Arg Term → Term → Term\n      sort    : Term\n      unknown
  : Term\n\n    {-# BUILTIN AGDATERM            Term    #-}\n    {-# BUILTIN AGDATERMVAR
  \        var     #-}\n    {-# BUILTIN AGDATERMCON         con     #-}\n    {-# BUILTIN
  AGDATERMDEF         def     #-}\n    {-# BUILTIN AGDATERMLAM         lam     #-}\n
  \   {-# BUILTIN AGDATERMPI          pi      #-}\n    {-# BUILTIN AGDATERMSORT        sort
  \   #-}\n    {-# BUILTIN AGDATERMUNSUPPORTED unknown #-}\n\n  Reflection may be
  useful when working with internal decision\n  procedures, such as the standard library's
  ring solver.\n\n* Minor record definition improvement.\n\n  The definition of a
  record type is now available when type checking\n  record module definitions. This
  means that you can define things\n  like the following:\n\n    record Cat : Set₁
  where\n      field\n        Obj  : Set\n        _=>_ : Obj → Obj → Set\n        --
  ...\n\n      -- not possible before:\n      op : Cat\n      op = record { Obj =
  Obj; _=>_ = λ A B → B => A }\n\nTools\n-----\n\n* The \"Goal type and context\"
  command now shows the goal type before\n  the context, and the context is shown
  in reverse order. The \"Goal\n  type, context and inferred type\" command has been
  modified in a\n  similar way.\n\n* Show module contents command.\n\n  Given a module
  name M the Emacs mode can now display all the\n  top-level modules and names inside
  M, along with types for the\n  names. The command is activated using C-c C-o or
  the menus.\n\n* Auto command.\n\n  A command which searches for type inhabitants
  has been added. The\n  command is invoked by pressing C-C C-a (or using the goal
  menu).\n  There are several flags and parameters, e.g. '-c' which enables\n  case-splitting
  in the search. For further information, see the Agda\n  wiki:\n\n    http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Auto\n\n*
  HTML generation is now possible for a module with unsolved\n  meta-variables, provided
  that the --allow-unsolved-metas flag is\n  used.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.6\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.4:\n\nLanguage\n--------\n\n* Universe polymorphism (experimental
  extension).\n\n  To enable universe polymorphism give the flag\n  --universe-polymorphism
  on the command line or (recommended) as an\n  OPTIONS pragma.\n\n  When universe
  polymorphism is enabled Set takes an argument which is\n  the universe level. For
  instance, the type of universe polymorphic\n  identity is\n\n    id : {a : Level}
  {A : Set a} → A → A.\n\n  The type Level is isomorphic to the unary natural numbers
  and should be\n  specified using the BUILTINs LEVEL, LEVELZERO, and LEVELSUC:\n\n
  \   data Level : Set where\n      zero : Level\n      suc  : Level → Level\n\n    {-#
  BUILTIN LEVEL     Level #-}\n    {-# BUILTIN LEVELZERO zero  #-}\n    {-# BUILTIN
  LEVELSUC  suc   #-}\n\n  There is an additional BUILTIN LEVELMAX for taking the
  maximum of two\n  levels:\n\n    max : Level → Level → Level\n    max  zero    m
  \     = m\n    max (suc n)  zero   = suc n\n    max (suc n) (suc m) = suc (max n
  m)\n\n    {-# BUILTIN LEVELMAX max #-}\n\n  The non-polymorphic universe levels
  Set, Set₁ and so on are sugar\n  for Set zero, Set (suc zero), etc.\n\n  At present
  there is no automatic lifting of types from one level to\n  another. It can still
  be done (rather clumsily) by defining types\n  like the following one:\n\n    data
  Lifted {a} (A : Set a) : Set (suc a) where\n      lift : A → Lifted A\n\n  However,
  it is likely that automatic lifting is introduced at some\n  point in the future.\n\n*
  Multiple constructors, record fields, postulates or primitives can\n  be declared
  using a single type signature:\n\n    data Bool : Set where\n      false true :
  Bool\n\n    postulate\n      A B : Set\n\n* Record fields can be implicit:\n\n    record
  R : Set₁ where\n      field\n        {A}         : Set\n        f           : A
  → A\n        {B C} D {E} : Set\n        g           : B → C → E\n\n  By default
  implicit fields are not printed.\n\n* Record constructors can be defined:\n\n    record
  Σ (A : Set) (B : A → Set) : Set where\n      constructor _,_\n      field\n        proj₁
  : A\n        proj₂ : B proj₁\n\n  In this example _,_ gets the type\n\n     (proj₁ : A)
  → B proj₁ → Σ A B.\n\n  For implicit fields the corresponding constructor arguments
  become\n  implicit.\n\n  Note that the constructor is defined in the /outer/ scope,
  so any\n  fixity declaration has to be given outside the record definition.\n  The
  constructor is not in scope inside the record module.\n\n  Note also that pattern
  matching for records has not been implemented\n  yet.\n\n* BUILTIN hooks for equality.\n\n
  \ The data type\n\n    data _≡_ {A : Set} (x : A) : A → Set where\n      refl :
  x ≡ x\n\n  can be specified as the builtin equality type using the following\n  pragmas:\n\n
  \   {-# BUILTIN EQUALITY _≡_  #-}\n    {-# BUILTIN REFL     refl #-}\n\n  The builtin
  equality is used for the new rewrite construct and\n  the primTrustMe primitive
  described below.\n\n* New rewrite construct.\n\n  If eqn : a ≡ b, where _≡_ is the
  builtin equality (see above) you\n  can now write\n\n    f ps rewrite eqn = rhs\n\n
  \ instead of\n\n    f ps with a | eqn\n    ... | ._ | refl = rhs\n\n  The rewrite
  construct has the effect of rewriting the goal and the\n  context by the given equation
  (left to right).\n\n  You can rewrite using several equations (in sequence) by separating\n
  \ them with vertical bars (|):\n\n    f ps rewrite eqn₁ | eqn₂ | … = rhs\n\n  It
  is also possible to add with clauses after rewriting:\n\n    f ps rewrite eqns with
  e\n    ... | p = rhs\n\n  Note that pattern matching happens before rewriting—if
  you want to\n  rewrite and then do pattern matching you can use a with after the\n
  \ rewrite.\n\n  See test/Succeed/Rewrite.agda for some examples.\n\n* A new primitive,
  primTrustMe, has been added:\n\n    primTrustMe : {A : Set} {x y : A} → x ≡ y\n\n
  \ Here _≡_ is the builtin equality (see BUILTIN hooks for equality,\n  above).\n\n
  \ If x and y are definitionally equal, then\n  primTrustMe {x = x} {y = y} reduces
  to refl.\n\n  Note that the compiler replaces all uses of primTrustMe with the\n
  \ REFL builtin, without any check for definitional equality. Incorrect\n  uses of
  primTrustMe can potentially lead to segfaults or similar\n  problems.\n\n  For an
  example of the use of primTrustMe, see Data.String in version\n  0.3 of the standard
  library, where it is used to implement decidable\n  equality on strings using the
  primitive boolean equality.\n\n* Changes to the syntax and semantics of IMPORT pragmas,
  which are\n  used by the Haskell FFI. Such pragmas must now have the following\n
  \ form:\n\n    {-# IMPORT <module name> #-}\n\n  These pragmas are interpreted as
  /qualified/ imports, so Haskell\n  names need to be given qualified (unless they
  come from the Haskell\n  prelude).\n\n* The horizontal tab character (U+0009) is
  no longer treated as white\n  space.\n\n* Line pragmas are no longer supported.\n\n*
  The --include-path flag can no longer be used as a pragma.\n\n* The experimental
  and incomplete support for proof irrelevance has\n  been disabled.\n\nTools\n-----\n\n*
  New \"intro\" command in the Emacs mode. When there is a canonical way\n  of building
  something of the goal type (for instance, if the goal\n  type is a pair), the goal
  can be refined in this way. The command\n  works for the following goal types:\n\n
  \   - A data type where only one of its constructors can be used to\n      construct
  an element of the goal type. (For instance, if the\n      goal is a non-empty vector,
  a \"cons\" will be introduced.)\n\n    - A record type. A record value will be introduced.
  Implicit\n      fields will not be included unless showing of implicit arguments\n
  \     is switched on.\n\n    - A function type. A lambda binding as many variables
  as possible\n      will be introduced. The variable names will be chosen from the\n
  \     goal type if its normal form is a dependent function type,\n      otherwise
  they will be variations on \"x\". Implicit lambdas will\n      only be inserted
  if showing of implicit arguments is switched\n      on.\n\n  This command can be
  invoked by using the refine command (C-c C-r)\n  when the goal is empty. (The old
  behaviour of the refine command in\n  this situation was to ask for an expression
  using the minibuffer.)\n\n* The Emacs mode displays \"Checked\" in the mode line
  if the current\n  file type checked successfully without any warnings.\n\n* If a
  file F is loaded, and this file defines the module M, it is an\n  error if F is
  not the file which defines M according to the include\n  path.\n\n  Note that the
  command-line tool and the Emacs mode define the\n  meaning of relative include paths
  differently: the command-line tool\n  interprets them relative to the current working
  directory, whereas\n  the Emacs mode interprets them relative to the root directory
  of the\n  current project. (As an example, if the module A.B.C is loaded from\n
  \ the file <some-path>/A/B/C.agda, then the root directory is\n  <some-path>.)\n\n*
  It is an error if there are several files on the include path which\n  match a given
  module name.\n\n* Interface files are relocatable. You can move around source trees
  as\n  long as the include path is updated in a corresponding way. Note\n  that a
  module M may be re-typechecked if its time stamp is strictly\n  newer than that
  of the corresponding interface file (M.agdai).\n\n* Type-checking is no longer done
  when an up-to-date interface exists.\n  (Previously the initial module was always
  type-checked.)\n\n* Syntax highlighting files for Emacs (.agda.el) are no longer
  used.\n  The --emacs flag has been removed. (Syntax highlighting information\n  is
  cached in the interface files.)\n\n* The Agate and Alonzo compilers have been retired.
  The options\n  --agate, --alonzo and --malonzo have been removed.\n\n* The default
  directory for MAlonzo output is the project's root\n  directory. The --malonzo-dir
  flag has been renamed to --compile-dir.\n\n* Emacs mode: C-c C-x C-d no longer resets
  the type checking state.\n  C-c C-x C-r can be used for a more complete reset. C-c C-x C-s\n
  \ (which used to reload the syntax highlighting information) has been\n  removed.
  C-c C-l can be used instead.\n\n* The Emacs mode used to define some \"abbrevs\",
  unless the user\n  explicitly turned this feature off. The new default is /not/
  to add\n  any abbrevs. The old default can be obtained by customising\n  agda2-mode-abbrevs-use-defaults
  (a customisation buffer can be\n  obtained by typing M-x customize-group agda2 RET
  after an Agda file\n  has been loaded).\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.4\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.2:\n\n* Change to the semantics of \"open import\" and \"open
  module\". The\n  declaration\n\n    open import M <using/hiding/renaming>\n\n  now
  translates to\n\n    import A\n    open A <using/hiding/renaming>\n\n  instead of\n\n
  \   import A <using/hiding/renaming>\n    open A.\n\n  The same translation is used
  for \"open module M = E …\". Declarations\n  involving the keywords as or public
  are changed in a corresponding\n  way (\"as\" always goes with import, and \"public\"
  always with open).\n\n  This change means that import directives do not affect the
  qualified\n  names when open import/module is used. To get the old behaviour you\n
  \ can use the expanded version above.\n\n* Names opened publicly in parameterised
  modules no longer inherit the\n  module parameters. Example:\n\n    module A where\n
  \     postulate X : Set\n\n    module B (Y : Set) where\n      open A public\n\n
  \ In Agda 2.2.2 B.X has type (Y : Set) → Set, whereas in Agda 2.2.4\n  B.X has type
  Set.\n\n* Previously it was not possible to export a given constructor name\n  through
  two different \"open public\" statements in the same module.\n  This is now possible.\n\n*
  Unicode subscript digits are now allowed for the hierarchy of\n  universes (Set₀,
  Set₁, …): Set₁ is equivalent to Set1.\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.2\n------------------------------------------------------------------------\n\nImportant
  changes since 2.2.0:\n\nTools\n-----\n\n* The --malonzodir option has been renamed
  to --malonzo-dir.\n\n* The output of agda --html is by default placed in a directory
  called\n  \"html\".\n\nInfrastructure\n--------------\n\n* The Emacs mode is included
  in the Agda Cabal package, and installed\n  by cabal install. The recommended way
  to enable the Emacs mode is to\n  include the following code in .emacs:\n\n    (load-file
  (let ((coding-system-for-read 'utf-8))\n                    (shell-command-to-string
  \"agda-mode locate\")))\n\n------------------------------------------------------------------------\n--
  Release notes for Agda 2 version 2.2.0\n------------------------------------------------------------------------\n\nImportant
  changes since 2.1.2 (which was released 2007-08-16):\n\nLanguage\n--------\n\n*
  Exhaustive pattern checking. Agda complains if there are missing\n  clauses in a
  function definition.\n\n* Coinductive types are supported. This feature is under\n
  \ development/evaluation, and may change.\n\n  http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.Codatatypes\n\n*
  Another experimental feature: Sized types, which can make it easier\n  to explain
  why your code is terminating.\n\n* Improved constraint solving for functions with
  constructor headed\n  right hand sides.\n\n  http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.FindingTheValuesOfImplicitArguments\n\n*
  A simple, well-typed foreign function interface, which allows use of\n  Haskell
  functions in Agda code.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.FFI\n\n*
  The tokens forall, -> and \\ can be written as ∀, → and λ.\n\n* Absurd lambdas:
  λ () and λ {}.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/440\n\n* Record
  fields whose values can be inferred can be omitted.\n\n* Agda complains if it spots
  an unreachable clause, or if a pattern\n  variable \"shadows\" a hidden constructor
  of matching type.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/720\n\nTools\n-----\n\n*
  Case-split: The user interface can replace a pattern variable with\n  the corresponding
  constructor patterns. You get one new left-hand\n  side for every possible constructor.\n\n
  \ http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.QuickGuideToEditingTypeCheckingAndCompilingAgdaCode\n\n*
  The MAlonzo compiler.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.MAlonzo\n\n*
  A new Emacs input method, which contains bindings for many Unicode\n  symbols, is
  by default activated in the Emacs mode.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.UnicodeInput\n\n*
  Highlighted, hyperlinked HTML can be generated from Agda source\n  code.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.HowToGenerateWebPagesFromSourceCode\n\n*
  The command-line interactive mode (agda -I) is no longer supported,\n  but should
  still work.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/245\n\n* Reload times
  when working on large projects are now considerably\n  better.\n\n  http://thread.gmane.org/gmane.comp.lang.agda/551\n\nLibraries\n---------\n\n*
  A standard library is under development.\n\n  http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Libraries.StandardLibrary\n\nDocumentation\n-------------\n\n*
  The Agda wiki is better organised. It should be easier for a\n  newcomer to find
  relevant information now.\n\n  http://wiki.portal.chalmers.se/agda/\n\nInfrastructure\n--------------\n\n*
  Easy-to-install packages for Windows and Debian/Ubuntu have been\n  prepared.\n\n
  \ http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Download\n\n* Agda 2.2.0
  is available from Hackage.\n\n  http://hackage.haskell.org/\n"
basic-deps:
  data-hash: ! '>=0.2.0.0 && <0.3'
  bytestring: ! '>=0.10.0.2 && <0.11'
  haskeline: ! '>=0.7.1.3 && <0.8'
  edit-distance: ! '>=0.2.1.2 && <0.3'
  EdisonAPI: ==1.3
  filemanip: ! '>=0.3.6.3 && <0.4'
  base: ! '>=4.6.0.1 && <4.10'
  time: ! '>=1.4.0.1 && <1.7'
  xhtml: ! '>=3000.2.1 && <3000.3'
  unordered-containers: ! '>=0.2.5.0 && <0.3'
  text: ! '>=0.11.3.1 && <1.3'
  strict: ! '>=0.3.2 && <0.4'
  Agda: ==2.5.1.2
  filepath: ! '>=1.3.0.1 && <1.5'
  process: ! '>=1.1.0.2 && <1.5'
  monadplus: ! '>=1.4 && <1.5'
  array: ! '>=0.4.0.1 && <0.6'
  EdisonCore: ! '>=1.3.1.1 && <1.3.2'
  containers: ! '>=0.5.0.0 && <0.6'
  haskell-src-exts: ! '>=1.16.0.1 && <1.18'
  binary: ! '>=0.7.2.1 && <0.9'
  hashtables: ! '>=1.0.1.8 && <1.2 || >=1.2.0.2 && <1.3'
  zlib: ! '>=0.4.0.1 && <0.6.1'
  mtl: ! '>=2.1.1 && <=2.1.3.1 || >=2.2.1 && <2.3'
  geniplate-mirror: ! '>=0.6.0.6 && <0.8'
  hashable: ! '>=1.2.1.0 && <1.3'
  transformers: ! '>=0.3 && <0.4 || >=0.4.1.0 && <0.6'
  parallel: ! '>=3.2.0.4 && <3.3'
  deepseq: ! '>=1.3.0.1 && <1.5'
  boxes: ! '>=0.1.3 && <0.2'
  QuickCheck: ! '>=2.8.2 && <2.9'
  equivalence: ! '>=0.2.5 && <0.4'
  pretty: ! '>=1.1.1.0 && <1.1.1.2 || >=1.1.2 && <1.2'
  template-haskell: ! '>=2.8.0.0 && <2.12'
  transformers-compat: ! '>=0.3.3.3 && <0.6'
  directory: ! '>=1.2.0.1 && <1.3'
all-versions:
- '2.2.0'
- '2.2.2'
- '2.2.4'
- '2.2.6'
- '2.2.8'
- '2.2.10'
- '2.3.0'
- '2.3.0.1'
- '2.3.2'
- '2.3.2.1'
- '2.3.2.2'
- '2.4.0'
- '2.4.0.1'
- '2.4.0.2'
- '2.4.2'
- '2.4.2.1'
- '2.4.2.2'
- '2.4.2.3'
- '2.4.2.4'
- '2.4.2.5'
- '2.5.1'
- '2.5.1.1'
- '2.5.1.2'
author: Ulf Norell, Andreas Abel, Nils Anders Danielsson, Makoto Takeyama, Catarina
  Coquand, with contributions by Stevan Andjelkovic, Marcin Benke, Jean-Philippe Bernardy,
  James Chapman, Jesper Cockx, Dominique Devriese, Peter Divanski, Fredrik Nordvall
  Forsberg, Olle Fredriksson, Daniel Gustafsson, Philipp Hausmann, Patrik Jansson,
  Alan Jeffrey, Wolfram Kahl, Fredrik Lindblad, Francesco Mazzoli, Stefan Monnier,
  Darin Morrison, Guilhem Moulin, Nicolas Pouillard, Andrés Sicard-Ramírez, Andrea
  Vezzosi and many more.
latest: '2.5.1.2'
description-type: markdown
description: ! "Agda 2\n======\n\n[![Hackage](https://img.shields.io/hackage/v/Agda.svg)](http://hackage.haskell.org/package/Agda)
  [![Build Status](https://travis-ci.org/agda/agda.svg?branch=master)](https://travis-ci.org/agda/agda)\n\nTable
  of contents:\n\n* [Prerequisites](#prerequisites)\n* [Installing Agda](#installing-agda)\n*
  [Configuring the Emacs mode](#configuring-the-emacs-mode)\n* [Installing Emacs under
  Windows](#installing-emacs-under-windows)\n\nNote that this README only discusses
  installation of Agda, not its standard\nlibrary. See the [Agda Wiki][agdawiki] for
  information about the library.\n\n\nPrerequisites\n-------------\n\nYou need recent
  versions of the following programs/libraries:\n\n* GHC:           http://www.haskell.org/ghc/\n*
  cabal-install: http://www.haskell.org/cabal/\n* Alex:          http://www.haskell.org/alex/\n*
  Happy:         http://www.haskell.org/happy/\n* GNU Emacs:     http://www.gnu.org/software/emacs/\n\nYou
  should also make sure that programs installed by cabal-install are\non your shell's
  search path.\n\nFor instructions on installing a suitable version of Emacs under\nWindows,
  see [below]((#installing-emacs-under-windows).\n\nNon-Windows users need to ensure
  that the development files for the C\nlibraries zlib and ncurses are installed (see
  http://zlib.net and\nhttp://www.gnu.org/software/ncurses/). Your package manager
  may be\nable to install these files for you. For instance, on Debian or Ubuntu\nit
  should suffice to run\n\n    apt-get install zlib1g-dev libncurses5-dev\n\nas root
  to get the correct files installed.\n\n### Note on GHC's CPP language extension\n\nRecent
  versions of Clang's preprocessor don't work well with Haskell.\nIn order to get
  some dependencies to build, you may need to set up Cabal\nto have GHC use cpphs
  by default. You can do this by adding\n\n    program-default-options\n      ghc-options:
  -pgmPcpphs -optP--cpp\n\nto your .cabal/config file. (You must be using cabal >=
  1.18. Note\nthat some packages may not compile with this option set.)\n\nYou don't
  need to set this option to install *Agda* from the current\ndevelopment source;
  Agda.cabal now uses cpphs.\n\n\nInstalling Agda\n---------------\n\nThere are several
  ways to install Agda:\n\n\n### Using a binary package prepared for your platform\n\nRecommended
  if such a package exists. See the [Agda Wiki][agdawiki].\n\n\n### Using a released
  source package from Hackage\n\nInstall the prerequisites mentioned below, then run
  the following commands:\n\n    cabal update\n    cabal install Agda\n    agda-mode
  setup\n\nThe last command tries to set up Emacs for use with Agda. As an alternative
  you\ncan copy the following text to your .emacs file:\n\n    (load-file (let ((coding-system-for-read
  'utf-8))\n                    (shell-command-to-string \"agda-mode locate\")))\n\nIt
  is also possible (but not necessary) to compile the Emacs mode's files:\n\n    agda-mode
  compile\n\nThis can, in some cases, give a noticeable speedup.\n\n**WARNING**: If
  you reinstall the Agda mode without recompiling the Emacs\nLisp files, then Emacs
  may continue using the old, compiled files.\n\n\n### Using the development version
  of the code\n\nYou can obtain tarballs of the development version from the [Agda\nWiki][agdawiki],
  or clone the repository.\n\nInstall the prerequisites discussed in [Prerequisites](#prerequisites).\n\nThen,
  either:\n\n*(1a)* Run the following commands in the top-level directory of the Agda
  source\ntree to install Agda:\n\n    cabal update\n    cabal install\n\n*(1b)* Run
  `agda-mode setup` to set up Emacs for use with Agda. Alternatively,\nadd the following
  text to your .emacs file:\n\n    (load-file (let ((coding-system-for-read 'utf-8))\n
  \                   (shell-command-to-string \"agda-mode locate\")))\n\nIt is also
  possible (but not necessary) to compile the Emacs mode's files:\n\n    agda-mode
  compile\n\nThis can, in some cases, give a noticeable speedup.\n\n**WARNING**: If
  you reinstall the Agda mode without recompiling the Emacs\nLisp files, then Emacs
  may continue using the old compiled files.\n\n*(2)* Or, you can try to install Agda
  (including a compiled Emacs mode) by\nrunning the following command:\n\n    make
  install\n\n\nConfiguring the Emacs mode\n--------------------------\n\nIf you want
  to you can customise the Emacs mode. Just start Emacs and\ntype the following:\n\n
  \   M-x load-library RET agda2-mode RET\n    M-x customize-group RET agda2 RET\n\nThis
  is useful if you want to change the Agda search path, in which\ncase you should
  change the agda2-include-dirs variable.\n\nIf you want some specific settings for
  the Emacs mode you can add them\nto agda2-mode-hook. For instance, if you do not
  want to use the Agda\ninput method (for writing various symbols like ∀≥ℕ→π⟦⟧) you
  can add\nthe following to your .emacs:\n\n    (add-hook 'agda2-mode-hook\n              '(lambda
  ()\n                ; If you do not want to use any input method:\n                (deactivate-input-method)\n
  \               ; (In some versions of Emacs you should use\n                ; inactivate-input-method
  instead of\n                ; deactivate-input-method.)\n\n                ; If
  you want to use the X input method:\n                (set-input-method \"X\")))\n\nNote
  that, on some systems, the Emacs mode changes the default font of\nthe current frame
  in order to enable many Unicode symbols to be\ndisplayed. This only works if the
  right fonts are available, though.\nIf you want to turn off this feature, then you
  should customise the\nagda2-fontset-name variable.\n\n------------------------------------------------------------------------\nInstalling
  Emacs under Windows\n------------------------------------------------------------------------\n\nA
  precompiled version of Emacs 24.3, with the necessary mathematical\nfonts, is available
  at http://homepage.cs.uiowa.edu/~astump/agda/\n\n[agdawiki]: http://wiki.portal.chalmers.se/agda/pmwiki.php\n\nHacking
  on Agda\n---------------\n\nHead to [`HACKING`](https://github.com/agda/agda/blob/master/HACKING)\n"
license-name: OtherLicense

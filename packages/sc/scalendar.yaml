homepage: https://github.com/stackbuilders/scalendar
changelog-type: markdown
hash: 5b75e5ed1b7e0c9287787a7639b118fbde748c854c67edc8f82c58557560810e
test-bench-deps:
  base: -any
  time: -any
  hspec: ! '>=2.4.2 && <3.0'
  text: -any
  SCalendar: -any
  containers: -any
  QuickCheck: ! '>=2.9.2 && <3.0'
maintainer: Stack Builders <hackage@stackbuilders.com>
synopsis: A library for handling calendars and resource availability over time.
changelog: ! "scalendar Change Log\n==================\n\n\n# History Of Changes\n=================\n\n##
  Tue Oct 03 2017\n * Version 1.2 with clarified algorithm patent rights and recognition
  of authorship in README and LICENSE.\n"
basic-deps:
  base: ! '>=4.8 && <5'
  time: ! '>=1.5 && <2'
  text: ! '>=1.2.0.0 && <2'
  containers: ! '>=0.5.7.1 && <0.6'
all-versions:
- '1.0.0'
- '1.1.0'
- '1.2.0'
author: Sebastian Pulido Gómez <spulido@stackbuilders.com>
latest: '1.2.0'
description-type: markdown
description: ! "# scalendar: Haskell Library to deal with resource availability in
  a Calendar.\n\n[![Build Status](https://travis-ci.org/stackbuilders/scalendar.svg?branch=master)](https://travis-ci.org/stackbuilders/scalendar)\n\nThis
  is a library for handling calendars and resource availability based on the\n`top-nodes
  algorithm` and set operations. That's why it is called `scalendar`: Calendars\nwhich
  which keep track of the availability of a set of resources.\nSince the bare `top-nodes
  algorithm` is not enough to IDENTIFY which are the\nspecific resources which are
  available in a given period of time - for example,\nthe id of the rooms which can
  still be reserved in a given `(checkIn-checkOut)`\ninterval - it was necessary to
  generalize that algorithm to work on sets of\nstrings which identify the available
  resources in a period. That generalization\nwas pretty smooth since addition in
  numbers was replaced by set Union and substraction\nin numbers was replaced by set
  Difference. Another important fact about sets is that\nthey do not allow duplicates,
  so every identifier is guaranteed to be unique.\n\n\n# Introduction\n\n\n# Data
  Types\n\n`scalendar` is a library based on binary trees, where a Calendar is defined
  as follows:\n\n```\ndata Calendar =\n    Unit TimePeriod (Set Text) (Set Text)\n
  \ | Node TimePeriod (Set Text) (Set Text) Calendar Calendar\n\ndata TimePeriod =\n
  \   TimeInterval UTCTime UTCTime\n  | TimeUnit UTCTime\n```\n\nThe idea is that
  each node in the calendar will store a TimePeriod which is a data type which stores\na
  time-interval with an`start-date` and an `end-date`.\n\nThe purpose is that terminal
  nodes (leaves) will represent a unit of time, `TimeUnit`, which in this case\nis
  a nominal day or 86400 seconds. Thus non-terminal nodes are intended to store a
  `TimeInterval` and\nleaves are intended to store `TimeUnits`. Both leaves and nodes
  store `Q` and `QN` sets, which are the\ndata structures which allow the Calendar
  to keep track of the availability of a set of resources.\nFor more information about
  the time representation according to the `top-nodes`\nalgorithm check [this](https://en.wikipedia.org/wiki/Top-nodes_algorithm)\n\nKnowing
  what the `Q` and `QN` sets mean is not quite important to use this library but\nroughly:\n
  - `QN(Node)` represents reserved elements for all reservations having this node
  as `top-node`\n - `Q(Node) = U(Q(LeftChild), Q(RightChild)) U QN(Node)`\n\nIn order
  to use this library, it only suffices to know the meaning of the following\ndata
  type:\n\n```\ndata SCalendar = SCalendar\n  { calUnits :: Set Text\n  , calendar
  :: Calendar\n  } deriving (Eq, Show)\n```\n\nAn `SCalendar` is only a product type
  of a set of identifiers and a group of available resources - for\nexample, the numbers
  which are used to identify rooms in a hotel `{\"101\", \"102\", ...}` - and a `Calendar`,\nwhich
  is the tree that keeps track of the availability of that set of resources.\n\nOther
  important data types are:\n\n\n- ```\n  data Reservation = Reservation\n    { reservUnits
  :: Set Text\n    , reservPeriod :: TimePeriod\n    }\n  ```\n\n  which represents
  a set of resources we want to reserve over a `TimePeriod` in a `SCalendar`.\n\n-
  ```\n  data Cancellation = Cancellation\n    { cancUnits :: Set Text\n    , cancPeriod
  :: TimePeriod\n    }\n  ```\n\n  which represents a set of resources we want to
  cancel over a `TimePeriod` in a `SCalendar`\n\n- ```\n  data Report = Report\n    {
  reportPeriod :: TimePeriod\n    , totalUnits :: Set Text\n    , reservedUnits ::
  Set Text\n    , remainingUnits :: Set Text\n    }\n  ```\n  which represents a `Report`
  for a given `TimePeriod` where a `Report` has the following\n  information:\n   -
  `totalUnits`: The set of total identifiers for resources which can be reserved in
  a\n     `SCalendar`.\n   - `reservedUnits`: The set of identifiers for resources
  which have been reserved for a `TimePeriod`.\n   - `remainingUnits`: The set of
  remaining identifiers for resources which can still be\n      reserved without creating
  conflicts in a `TimePeriod`.\n\n\n# Creating a Calendar\n\nFunctions to create Calendars
  are located in `Time.SCalendar.Types`\n\nTo create a bare `Calendar` which is not
  associated to any set of identifiers we can use\n\n```\ncreateCalendar :: Integer
  -- Year.\n               -> Int -- Month.\n               -> Int -- Day.\n               ->
  Int -- NumDays.\n               -> Maybe Calendar\n```\n\nwhere\n - `Year`: It is
  an `Integer` representing the starting year of the `Calendar`. For example\n    `2017`.\n
  - `Month`: It is an `Int` representing the starting month of the `Calendar`. For\n
  \   example, `2` is equivalent to February.\n - `Day`: It is an `Int` representing
  the starting day of the `Calendar`. It can be\n    any number representing one of
  the days of `Month`.\n - `NumDays`: It is the number of Days we want our `Calendar`
  to cover. The days covered\n    by it will always be a power of `2`. Thus if you
  input `30`, `createCalendar` will\n    find the first power of `2` which is greater
  or equal to `32`, in this case `2^5 = 32`.\n\nSo if everything is ok, this function
  `Just` returns a new `Calendar` which is suitable for\nthe given `NumDays`. A new
  `Calendar` is one which has neither reservations nor cancellations.\n\n`createSCalendar`
  is almost like `createCalendar` but instead of returning a bare `Calendar`,\nit
  returns an `SCalendar` which is a `Calendar` together with a set of identifiers
  (of type `Text`)\nwhich uniquely identify a group of available resources. The following
  example create an `SCalendar`\nof `2 ^ 8 = 512 days` starting from `2016-February-2`
  with a set of identifiers `{ a, b, c, d }`\n\n```\ncreateSCalendar :: Integer --
  Year.\n                -> Int -- Month.\n                -> Int -- Day.\n                ->
  Int -- NumDays.\n                -> Set Text -- Set of Identifiers\n                ->
  Maybe SCalendar\n\ncreateSCalendar 2017 2 1 365 (Set.fromList [\"a\", \"b\", \"c\",
  \"d\"])\n```\n\n# Checking Availability\n\nThere are two functions to check availability
  for a reservation. The first one is\n\n```\nisQuantityAvailable :: Int -> TimePeriod
  -> SCalendar -> Bool\n```\n\nwhere `Int` is an amount of resource we want to reserve,
  `TimePeriod` is the period of\ntime we want to reserve for that amount of resource,
  and `SCalendar` is the calendar\nwhere we want to check availability. Naturally,
  this function returns a `Bool` if the\namount of resources is available.\nNote that
  here we are just concerned with the amount of resources and whether there is\nsome
  set of identifiers whose size is greater of equal to that amount. If we need\nto
  check if a particular set of identifiers is available for reservation, we can\nuse
  the following function:\n\n```\nisReservAvailable :: Reservation -> SCalendar ->
  Bool\n```\n\nwhich is almost like the first function, but here we are taking into
  account the set\nof strings which identifies the resources we want to reserve since
  we are providing\na `Reservation` as input.\n\n\n# Adding reservations to a Calendar\n\nThere
  are two pairs of functions to add reservations to a calendar:\n\n```\nreservPeriod'
  :: Reservation -> Calendar -> Maybe Calendar\n```\n\nwhich inserts reservations
  into a calendar without any constraint.  That's it, this\nfunction does not apply
  any availability check before making the `Reservation`. That's\nwhy this function
  does not need a `SCalendar`, because it does not need to take\ninto account the
  set of total available resources.\n\nThe safe version is `reservPeriod` (without
  the quote) which enforces the\n`isReservAvailable` check over that reservation before
  adding it. Its type is\n\n```\nreservePeriod :: Reservation -> SCalendar -> Maybe
  SCalendar\n```\n\nwhere an `SCalendar` is needed because we are taking into account
  the set of total\navailable resources to make the validation.\n\nThe other pair
  of functions are quite similar but are handy for adding a list of\nreservations
  at once:\n\n```\nreserveManyPeriods' :: [Reservation] -> Calendar -> Maybe Calendar\n```\nwhich
  adds several reservations at once in a Calendar without any availability check.\n\n```\nreserveManyPeriods
  :: [Reservation] -> SCalendar -> Maybe SCalendar\n```\nwhich  will return a `SCalendar`
  only with the reservations that pass the\n`isReservAvailable` test. Here we must
  take into consideration that reservations will be\ninserted in the same order they
  come in the input list. So, if a reservation conflicts\nwith the ones that have
  been already inserted, it will not be included in the `SCalendar`.\n\n\n\n# Removing
  Reservation: Cancellations\n\nThere are two operations which allow us to remove
  reserved resources from a period of\ntime:\n\n```\ncancelPeriod :: Cancellation
  -> Calendar -> Maybe Calendar\n```\n\nThis operation takes a `Cancellation` and
  returns a `Calendar` with that `Cancellation`'s\nset of resource identifiers subtracted
  from that `Calendar` in that `Cancellation`'s\nperiod of time.\nBe careful with
  this operation because there is no restriction over the period you are\ndeleting.
  You may be deleting from several reservations, from periods of time which are\nmeaningless
  - which have already elapsed-, and so on. However, all this library is\nintended
  to be used together with some persistent storage system which will allow you\nto
  keep record of the exact dates and resources which are reserved or cancelled.\n\n\nThe
  other operation is\n\n```\ncancelManyPeriods :: [Cancellation] -> Calendar -> Maybe
  Calendar\n```\nwhich is handy for cancelling a list of periods at once.\n\nNote
  that for cancellations we do not need a `SCalendar` because we don't need to make\nany
  availability check.\n\n\n# One important thing to note\n\nSince this calendar implementation
  uses `Sets` and `Set` operations, you don't have to worry\nabout things like updating
  the total number of resource identifiers for your `SCalendar`.\nYou can freely remove
  or add identifiers to your `SCalendar` and there will be no\nconflicts while making
  availability checks, reservations, cancellations, and so on.\n\n\n# Reports\n\nIt
  is very useful to have an operation which can summarize some information about the\nstate
  of the calendar in a given period of time. That's why this library has\n\n```\nperiodReport
  :: TimePeriod  -> SCalendar -> Maybe Report\n```\n\nwhere `TimePeriod` is the interval
  of time you would like the `Report` to summarize and\n`SCalendar` is the calendar
  we are working on. This function returns a `Report` over that\nperiod of time with
  the following information:\n  - `totalUnits`: The set of total identifiers for resources
  in the `SCalendar`,\n    in other words, the set part of `(SCalendar set calendar)`.\n
  \ - `reservedUnits`: The set of resources which have been reserved for that period
  of time.\n  - `remainingUnits`: The set of remaining  resources which can still
  be reserved without\n    creating conflicts in a `TimePeriod`.\n\nNote that `totalUnits`,
  `reservedUnits`, `remainingUnits` are all of type `Set`, and that the type\nof `Report`
  is :\n\n  ```\n  data Report = Report\n    { reportPeriod :: TimePeriod\n    , totalUnits
  :: Set Text\n    , reservedUnits :: Set Text\n    , remainingUnits :: Set Text\n
  \   }\n  ```\n\n# Have Fun!\n\nSo if you find this library useful, have fun with
  it in applications which need some\nsort of calendar and resource availability management!!\n\n\n\n#
  Acknowledgements\n\nThe base code for this library was written by [Sebastián Pulido
  Gómez](https://github.com/sebashack) and\nwas sponsored by [Stack Builders](https://www.stackbuilders.com/)\n\nThanks
  to [Mark Karpov](https://www.stackbuilders.com/) and [Javier Casas](https://github.com/javcasas)
  for\ntheir code reviews and suggestions.\n\n\n# Top-Nodes Algorithm Patent information\n\nThe
  ideas used to implement this library come from an invention by [Martin Rayrole](https://worldwide.espacenet.com/publicationDetails/biblio?locale=en_EP&II=8&FT=D&CC=US&DB=EPODOC&NR=2004204978A1&date=20041014&ND=3&KC=A1&adjacent=true#).\n\nThis
  version of the algorithm invented by Martin Rayrole now does not have any patent
  protection. You can verify that by clicking on the `Abandonment` section of this
  [web-page](https://register.epo.org/ipfwretrieve?lng=en&apn=US.76452604.A). Thus
  this now belongs to the public domain!\n"
license-name: MIT

homepage: https://github.com/YoshikuniJujo/c-struct#readme
changelog-type: markdown
hash: 8a9c5a12638023db8adb51348567243fc04fed6be5825afa00bb6075f4b1b985
test-bench-deps:
  base: '>=4.7 && <5'
  array: -any
  c-struct: -any
  template-haskell: -any
  primitive: -any
maintainer: yoshikuni.jujo.pc@gmail.com
synopsis: To make a wrapper for struct of C language
changelog: |
  # Changelog for c-struct

  ## Unreleased changes
basic-deps:
  base: '>=4.7 && <5'
  array: -any
  template-haskell: -any
  primitive: -any
all-versions:
- 0.1.0.0
author: Yoshikuni Jujo
latest: 0.1.0.0
description-type: markdown
description: "# c-struct\n\n## C definition\n\nfoo.h\n\n```\n#ifndef _FOO_H\n#define
  _FOO_H\n\ntypedef struct { int x; int y; } Foo;\n\n#endif\n```\n\nfoo.c\n\n```\n#include
  <stdlib.h>\n#include <stdio.h>\n#include \"foo.h\"\n\nFoo *\nfoo_copy(Foo *src)\n{\n\tFoo
  *p = malloc(sizeof(Foo));\n\tp -> x = src -> x;\n\tp -> y = src -> y;\n\treturn
  p;\n}\n\nvoid\nfoo_free(Foo *p)\n{\n\tfree(p);\n}\n\nvoid\nfoo_print(Foo *f)\n{\n\tprintf(\"Foo:
  x = %d, y = %d\\n\", f -> x, f -> y);\n}\n\nvoid\nfoo_scale(Foo *f, int s)\n{\n\tf
  -> x = f -> x * s;\n\tf -> y = f -> y * s;\n}\n```\n\n## Immutable\n\n### Foo\n\nFoo.hsc\n\n```\n{-#
  LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PatternSynonyms,
  ViewPatterns #-}\n{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}\n\nmodule Foo where\n\nimport
  Foreign.Ptr (Ptr)\nimport Foreign.ForeignPtr (withForeignPtr)\nimport Foreign.Storable
  (peekByteOff, pokeByteOff)\nimport Foreign.C.Types (CInt(..))\nimport Foreign.C.Struct
  (struct)\n\n#include \"foo.h\"\n\nstruct \"Foo\" #{size Foo}\n\t[\t(\"x\", ''CInt,
  [| #{peek Foo, x} |], [| #{poke Foo, x} |]),\n\t\t(\"y\", ''CInt, [| #{peek Foo,
  y} |], [| #{poke Foo, y} |]) ]\n\t[''Show, ''Read, ''Eq, ''Ord, ''Bounded]\n\nfooPrint
  :: Foo -> IO ()\nfooPrint (Foo_ f) = withForeignPtr f c_foo_print\n\nforeign import
  ccall \"foo_print\" c_foo_print :: Ptr Foo -> IO ()\n```\n\nYou get newtype Foo.\n\n```\n>
  Foo 123 456\nFoo {fooX = 123, fooY = 456}\n> it { fooY = 654}\nFoo {fooX = 123,
  fooY = 654}\n> f = it\n> fooPrint f\nFoo: x = 123, y = 654\n> g = read \"Foo {fooX
  = 456, fooY = 123}\" :: Foo\n> g\nFoo {fooX = 456, fooY = 123}\n> f < g\nTrue\n>
  minBound :: Foo\nFoo {fooX = -2147483648, fooY = -2147483648}\n```\n\n### FooIx\n\nFooIx.hsc\n\n```\n{-#
  LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PatternSynonyms,
  ViewPatterns #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# OPTIONS_GHC -Wall
  -fno-warn-tabs #-}\n\nmodule FooIx where\n\nimport Foreign.Storable (Storable, peekByteOff,
  pokeByteOff)\nimport Foreign.C.Types (CInt(..))\nimport Foreign.C.Struct (struct)\nimport
  Data.Array (Ix(..))\n\n#include \"foo.h\"\n\nnewtype CIntIx = CIntIx CInt\n\tderiving
  (Show, Eq, Ord, Enum, Num, Real, Integral, Storable)\n\nstruct \"FooIx\" #{size
  Foo}\n\t[\t(\"x\", ''CIntIx, [| #{peek Foo, x} |], [| #{poke Foo, x} |]),\n\t\t(\"y\",
  ''CIntIx, [| #{peek Foo, y} |], [| #{poke Foo, y} |]) ]\n\t[''Show, ''Eq, ''Ord,
  ''Ix]\n\ninstance Ix CIntIx where\n\trange (l, u) = [l .. u]\n\tindex (l, _) i =
  fromIntegral $ i - l\n\tinRange (l, u) i = l <= i && i <= u\n```\n\nYou get newtype
  FooIx.\n\n```\n> :module + Data.Array\n> listArray (FooIx 3 5, FooIx 4 7) [5 ..]\narray
  (FooIx {fooIxX = CIntIx 3, fooIxY = CIntIx 5},FooIx {fooIxX = CIntIx 4, fooIxY =
  CIntIx 7}) [(FooIx {...\n> a = it\n> a ! FooIx 4 6\n9\n```\n\n## Mutable\n\nIf you
  want to change values of a struct, you should use `structPrim`.\n\nFooPrim.hsc\n\n```\n{-#
  LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TupleSections #-}\n{-# LANGUAGE PatternSynonyms,
  ViewPatterns #-}\n{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}\n\nmodule FooPrim where\n\nimport
  Foreign.Ptr (Ptr)\nimport Foreign.ForeignPtr (withForeignPtr)\nimport Foreign.Storable
  (peekByteOff, pokeByteOff)\nimport Foreign.C.Types (CInt(..))\nimport Foreign.C.Struct
  (struct, structPrim)\nimport Control.Monad.Primitive (PrimMonad(..), unsafeIOToPrim)\n\n#include
  \"foo.h\"\n\nstruct \"Foo\" #{size Foo}\n\t[\t(\"x\", ''CInt, [| #{peek Foo, x}
  |], [| #{poke Foo, x} |]),\n\t\t(\"y\", ''CInt, [| #{peek Foo, y} |], [| #{poke
  Foo, y} |]) ]\n\t[''Show, ''Read, ''Eq, ''Ord, ''Bounded]\n\nforeign import ccall
  \"foo_copy\" c_foo_copy :: Ptr Foo -> IO (Ptr Foo)\nforeign import ccall \"foo_free\"
  c_foo_free :: Ptr Foo -> IO ()\n\nstructPrim \"Foo\" 'c_foo_copy 'c_foo_free [''Show]\n\nfooScale
  :: PtimMonad m => FooPrim (PrimState m) -> CInt -> m ()\nfooScale (FooPrim f) s
  = unsafeIOToPrim $ withForeignPtr f (`c_foo_scale` s)\n\nforeign import ccall \"foo_scale\"
  c_foo_scale :: Ptr Foo -> CInt -> IO ()\n```\n\nYou get `FooPrim`, `FooST`, `FooIO`,
  `fooFreeze`, `fooThaw` and `fooCopy`.\n\n```\n> :modu\t+ Control.Monad.Primitive\n>
  :type fooFreeze\nfooFreeze :: PrimMonad m => FooPrim (PrimState m) -> m Foo\n> :type
  fooThaw\nfooThaw :: PrimMonad m => Foo -> m (FooPrim (PrimState m))\n> :type FooCopy\nfooCopy\n
  \ :: PrimMonad m =>\n     FooPrim (PrimState m) -> m (FooPrim (PrimState m))\n>
  Foo 123 456\nFoo {fooX = 123, fooY = 456}\n> fooThaw it\nFooPrim 0x00000000002354a60\n>
  fp = it\n> fooScale fp 3\n> fooFreeze fp\nFoo {fooX = 369, fooY = 1368}\n```\n"
license-name: BSD-3-Clause

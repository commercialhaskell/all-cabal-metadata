homepage: https://github.com/Bodigrim/bitvec
changelog-type: ''
hash: c62def378ed515514ec6d46580a5bfc0a6014f37569d72c482d0c3f643559ba1
test-bench-deps:
  test-framework-hunit: -any
  bitvec: -any
  test-framework: -any
  base: ! '>=3'
  test-framework-quickcheck2: -any
  quickcheck-classes: ! '>=0.6.1'
  HUnit: -any
  QuickCheck: ! '>=2.10'
  primitive: -any
  vector: ! '>=0.8'
maintainer: Andrew Lelechenko <andrew.lelechenko@gmail.com>
synopsis: Unboxed vectors of bits / dense IntSets
changelog: ''
basic-deps:
  base: ! '>=3 && <5'
  primitive: -any
  vector: ! '>=0.8'
all-versions:
- '0.1'
- 0.1.0.1
- 0.1.0.2
- 0.1.1.0
author: |-
  James Cook <mokus@deepbondi.net>,
  Andrew Lelechenko <andrew.lelechenko@gmail.com>
latest: 0.1.1.0
description-type: haddock
description: |-
  Another bit-array library for Haskell.  This one defines a `Bit`
  type (which is an instance of all the "expected" classes, including
  numeric ones) and makes that type an instance of `Data.Vector.Unboxed.
  Unbox`, so we get a lot of nice APIs for free.  `Bool` is already an
  unboxable type, but the current unboxed `Vector` implementation packs
  each bit as a byte.  This one packs 8 bits per byte, as expected
  (`UArray` from the `array` package also uses one bit per `Bool`).

  In addition to the `Vector` interface, there are several high-level
  operations and some low-level ones suitable for building new bulk
  operations by viewing the bit-vector as a word vector.
license-name: LicenseRef-PublicDomain

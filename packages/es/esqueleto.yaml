homepage: https://github.com/bitemyapp/esqueleto
changelog-type: markdown
hash: eaae6df05ee00931a2a00122938ad65d1630036582628c2ea5c1e1763bf96cae
test-bench-deps:
  exceptions: -any
  bytestring: -any
  mysql: -any
  unliftio: -any
  base: '>=4.8 && <5.0'
  time: -any
  persistent: -any
  unordered-containers: -any
  hspec: -any
  text: -any
  hspec-core: -any
  persistent-postgresql: -any
  conduit: -any
  tagged: -any
  containers: -any
  persistent-mysql: -any
  postgresql-simple: -any
  esqueleto: -any
  mtl: -any
  blaze-html: -any
  monad-logger: -any
  attoparsec: -any
  transformers: -any
  QuickCheck: -any
  resourcet: -any
  persistent-sqlite: -any
  aeson: -any
  template-haskell: -any
  mysql-simple: -any
maintainer: cma@bitemyapp.com
synopsis: Type-safe EDSL for SQL queries on persistent backends.
changelog: "3.5.8.1\n=======\n- @belevy\n    - [#336](https://github.com/bitemyapp/esqueleto/pull/336)\n
  \       - Fix bug with multiple nested subqueries introduced in 3.5.7.1\n        -
  Set operations will now only reuse variable names within the context of the set
  operation.\n            a subquery that references the set operation will correctly
  pick up where the subquery left off\n3.5.8.0\n=======\n- @ivanbakel\n    - [#331](https://github.com/bitemyapp/esqueleto/pull/331)\n
  \       - Add `deriveEsqueletoRecordWith` to derive Esqueleto instances for\n          records
  using custom deriving settings.\n        - Add `DeriveEsqueletoRecordSettings` to
  control how Esqueleto record\n          instances are derived.\n        - Add `sqlNameModifier`
  to control how Esqueleto record instance\n          deriving generates the SQL record
  type name.\n        - Add `sqlFieldModifier` to control how Esqueleto record instance\n
  \         deriving generates the SQL record fields.\n\n3.5.7.1\n=======\n- @belevy\n
  \   - [#334](https://github.com/bitemyapp/esqueleto/pull/334)\n        - Fix alias
  name bug with union and subselect \n\n3.5.7.0\n=======\n- @ivanbakel\n    - [#329](https://github.com/bitemyapp/esqueleto/pull/329)\n
  \       - Add `ToAlias` and `ToAliasReference` instances to the type produced\n
  \         by `deriveEsqueletoRecord`, allowing in-SQL records to be used in\n          CTEs\n\n-
  @9999years\n    - [#324](https://github.com/bitemyapp/esqueleto/pull/324)\n        -
  Add ability to use nested records with `deriveEsqueletoRecord`\n\n3.5.6.0\n=======\n-
  @9999years\n    - [#323](https://github.com/bitemyapp/esqueleto/pull/323)\n        -
  Add ability to derive esqueleto instances for records\n\n3.5.5.0\n=======\n- @parsonsmatt\n
  \   - [#317](https://github.com/bitemyapp/esqueleto/pull/317)\n        - Add `Eq`
  and `Show` instances to `:&`\n\n3.5.4.2\n=======\n- @parsonsmatt\n    - [#318](https://github.com/bitemyapp/esqueleto/pull/318)\n
  \       - Remove use of `SqlReadT` and `SqlWriteT` type alias so that Simplified\n
  \         Subsumption doesn't bite end users\n\n3.5.4.1\n=======\n- @parsonsmatt\n
  \   - [#312](https://github.com/bitemyapp/esqueleto/pull/312/)\n        - Support
  `persistent-2.14.0.0`\n\n3.5.4.0\n=======\n- @parsonsmatt\n    - [#310](https://github.com/bitemyapp/esqueleto/pull/310)\n
  \       - Add instances of `HasField` for `SqlExpr (Entity rec)` and `SqlExpr\n
  \         (Maybe (Entity rec))`. These instances allow you to use the\n          `OverloadedRecordDot`
  language extension in GHC 9.2 with SQL\n          representations of database entities.\n\n3.5.3.2\n=======\n-
  @parsonsmatt\n    - [#309](https://github.com/bitemyapp/esqueleto/pull/309)\n        -
  Bump `time` version bound\n\n3.5.3.1\n=======\n- @jappeace\n  - [#303](https://github.com/bitemyapp/esqueleto/pull/303)\n
  \     - Added docs for delete function for new experimental API.\n\n3.5.3.0\n=======\n-
  @m4dc4p\n  - [#291](https://github.com/bitemyapp/esqueleto/pull/291)\n         -
  Added `ToAlias` and `ToAliasReference` instaces to the `:&` type, mirroring\n         the
  tuple instances for the same classes. See [Issue #290](https://github.com/bitemyapp/esqueleto/issues/290)\n
  \        for discussion.\n- @NikitaRazmakhnin\n  - [#284](https://github.com/bitemyapp/esqueleto/pull/284)\n
  \       - Add PostgreSQL-specific support of VALUES(..) literals\n\n\n3.5.2.2\n=======\n-
  @NikitaRazmakhnin\n  - [#278](https://github.com/bitemyapp/esqueleto/pull/278)\n
  \       - Fix generating of bad sql using nexted expressions with `distinctOnOrderBy`.\n\n3.5.2.1\n=======\n-
  @cdparks\n  - [#273](https://github.com/bitemyapp/esqueleto/pull/273)\n        -
  Avoid generating an empty list as the left operand to `NOT IN`.\n\n3.5.2.0\n=======\n-
  @ivanbakel\n  - [#268](https://github.com/bitemyapp/esqueleto/pull/268)\n        -
  Added `SqlSelect` instance for `(:&)`, allowing it to be returned from\n          queries
  just like `(,)` tuples.\n\n3.5.1.0\n=======\n- @ibarrae\n  - [#265](https://github.com/bitemyapp/esqueleto/pull/265)\n
  \       - Added `selectOne`\n\n3.5.0.0\n=======\n- @belevy\n  - [#228](https://github.com/bitemyapp/esqueleto/pull/228)\n
  \       - Destroy all GADTs; Removes the From GADT and SqlExpr GADT\n        - From
  GADT is replaced with a From data type and FromRaw\n        - SqlExpr is now all
  defined in terms of ERaw\n        - Modified ERaw to contain a SqlExprMeta with
  any extra information\n          that may be needed\n        - Experimental top
  level is now strictly for documentation and all the\n          implementation details
  are in Experimental.* modules\n- @parsonsmatt\n    - [#259](https://github.com/bitemyapp/esqueleto/pull/259)\n
  \       - Create the `Database.Esqueleto.Legacy` module. The\n          `Database.Esqueleto`
  module now emits a warning, directing users to\n          either import `Database.Esqueleto.Legacy`
  to keep the old behavior or\n          to import `Database.Esqueleto.Experimental`
  to opt in to the new\n          behavior.\n        - Deleted the deprecated modules\n
  \         `Database.Esqueleto.Internal.{Language,Sql}`. Please use\n          `Database.Esqueleto.Internal.Internal`
  instead, or ideally post what\n          you need from the library so we can support
  you safely.\n        - Support GHC 9\n\n3.4.2.2\n=======\n- @parsonsmatt\n  - [#255](https://github.com/bitemyapp/esqueleto/pull/255)\n
  \   - Fix a bug where a composite primary key in a `groupBy` clause would break.\n\n3.4.2.1\n=======\n-
  @parsonsmatt\n  - [#245](https://github.com/bitemyapp/esqueleto/pull/245)\n    -
  Support `persistent-2.13`\n\n3.4.2.0\n=======\n- @parsonsmatt\n  - [#243](https://github.com/bitemyapp/esqueleto/pull/243)\n
  \   - Support `persistent-2.12`\n\n3.4.1.1\n=======\n- @MaxGabriel\n  - [#240](https://github.com/bitemyapp/esqueleto/pull/240/files)\n
  \   - Improve recommend hlint to avoid doing `x = NULL` SQL queries\n\n3.4.1.0\n=======\n-
  @arthurxavierx\n  - [#238](https://github.com/bitemyapp/esqueleto/pull/238)\n    -
  Fix non-exhaustive patterns in `unsafeSqlAggregateFunction`\n- @Vlix\n  - [#232](https://github.com/bitemyapp/esqueleto/pull/232)\n
  \   - Export the `ValidOnClauseValue` type family\n\n\n3.4.0.1\n=======\n- @arthurxavierx\n
  \ - [#221](https://github.com/bitemyapp/esqueleto/pull/221)\n    - Deprecate `ToAliasT`
  and `ToAliasReferenceT`\n- @parsonsmatt\n  - [#226](https://github.com/bitemyapp/esqueleto/pull/226)\n
  \   - Support `persistent-2.11`\n- @belevy\n  - [#225](https://github.com/bitemyapp/esqueleto/pull/225)\n
  \   - Simplify `ToFromT` extracting the overlapping and type error instances\n    -
  Make `ToFromT` and associated type family of `ToFrom`\n\n3.4.0.0\n=======\n- @belevy,
  @charukiewicz\n  - [#215](https://github.com/bitemyapp/esqueleto/pull/215)\n    -
  Added support for common table expressions (`with`, `withRecursive`)\n    - Added
  support for lateral JOINs with updated example (Example #6)\n    - Deprecated `SelectQuery`,
  removing the neccessity to tag `SqlQuery` values\n    - Deprecated use of data constructors
  for SQL set operations (replaced with functions)\n    - Refactored module structure
  to fix haddock build (fixes build from `3.3.4.0`)\n\n3.3.4.1\n=======\n- @maxgabriel\n
  \ - [#214](https://github.com/bitemyapp/esqueleto/pull/214)\n    - Add suggested
  hlint rules for proper `isNothing` usage\n\n\n3.3.4.0\n=======\n- @parsonsmatt\n
  \ - [#205](https://github.com/bitemyapp/esqueleto/pull/205)\n    - More documentation
  on the `Experimental` module\n    - `Database.Esqueleto.Experimental` now reexports
  `Database.Esqueleto`, so\n      the new \"approved\" import syntax is less verbose.
  Before, you'd write:\n\n      ```haskell\n      import Database.Esqueleto hiding
  (from, on)\n      import Database.Esqueleto.Experimental\n      ```\n\n      Now
  you can merely write:\n\n      ```haskell\n      import Database.Esqueleto.Experimental\n
  \     ```\n\n      Users will get 'redundant import' warnings if they followed the
  original\n      syntax, the solution is evident from the error message provided.\n\n3.3.3.3\n=======\n-
  @belevy\n  - [#191](https://github.com/bitemyapp/esqueleto/pull/191) - Bugfix rollup:\n
  \   Fix issue with extra characters in generated SQL;\n    Fix ToAliasReference
  for already referenced values;\n    Fix Alias/Reference for Maybe Entity\n- @maxgabriel\n
  \ - [#203](https://github.com/bitemyapp/esqueleto/pull/203) Document `isNothing`\n-
  @sestrella\n  - [#198](https://github.com/bitemyapp/esqueleto/pull/198) - Allow
  PostgreSQL aggregate functions to take a filter clause\n\n3.3.3.2\n========\n- @maxgabriel\n
  \ - [#190](https://github.com/bitemyapp/esqueleto/pull/190) Further document and
  test `ToBaseId`\n\n3.3.3.1\n========\n- @belevy\n  - [#189](https://github.com/bitemyapp/esqueleto/pull/189)
  - Fix bug in function calls with\n    aliased values introduced by SubQuery joins.\n\n3.3.3.0\n========\n-
  @belevy\n  - [#172](https://github.com/bitemyapp/esqueleto/pull/172) - Introduce
  new\n    experimental module for joins, set operations (eg UNION), and safer queries\n
  \   from outer joins.\n\n3.3.2\n========\n\n- @belevy\n  - [#177](https://github.com/bitemyapp/esqueleto/pull/177)
  Fix natural key handling in (^.)\n\n3.3.1.1\n========\n\n- @parsonsmatt\n  - [#170](https://github.com/bitemyapp/esqueleto/pull/170)
  Add documentation to `groupBy` to explain tuple nesting.\n\n3.3.1\n========\n\n-
  @charukiewicz, @belevy, @joemalin95\n  - [#167](https://github.com/bitemyapp/esqueleto/pull/167):
  Exposed functions that were added in `3.3.0`\n\n3.3.0\n========\n\n- @charukiewicz,
  @belevy, @joemalin95\n  - [#166](https://github.com/bitemyapp/esqueleto/pull/166):
  Add several common SQL string functions: `upper_`, `trim_`, `ltrim_`, `rtrim_`,
  `length_`, `left_`, `right_`\n\n3.2.3\n========\n\n- @hdgarrood\n  - [#163](https://github.com/bitemyapp/esqueleto/pull/163):
  Allow `unsafeSqlFunction` to take up to 10 arguments without needing to nest tuples.\n\n3.2.2\n========\n\n-
  @parsonsmatt\n  - [#161](https://github.com/bitemyapp/esqueleto/pull/161/): Fix
  an issue where\n    nested joins didn't get the right on clause.\n\n3.2.1\n========\n\n-
  @parsonsmatt\n  - [#159](https://github.com/bitemyapp/esqueleto/pull/159): Add an
  instance of `UnsafeSqlFunction ()` for 0-argument SQL\n  functions.\n\n3.2.0\n========\n\n-
  @parsonsmatt\n  - [#153](https://github.com/bitemyapp/esqueleto/pull/153): Deprecate\n
  \   `sub_select` and introduce `subSelect`, `subSelectMaybe`, and\n    `subSelectUnsafe`.\n-
  @parsonsmatt\n  - [#156](https://github.com/bitemyapp/esqueleto/pull/156): Remove
  the\n    restriction that `on` clauses must appear in reverse order to the joining\n
  \   tables.\n\n3.1.3\n========\n\n- @JoseD92\n  - [#155](https://github.com/bitemyapp/esqueleto/pull/149):
  Added `insertSelectWithConflict` postgres function.\n\n3.1.2\n========\n\n- @tippenein\n
  \ - [#149](https://github.com/bitemyapp/esqueleto/pull/157): Added `associateJoin`
  query helpers.\n\n3.1.1\n=======\n\n- @JoseD92\n  - [#149](https://github.com/bitemyapp/esqueleto/pull/149):
  Added `upsert` support.\n\n- @parsonsmatt\n  - [#133](https://github.com/bitemyapp/esqueleto/pull/133):
  Added `renderQueryToText` and related functions.\n\n3.1.0\n=======\n\n- @Vlix\n
  \ - [#128](https://github.com/bitemyapp/esqueleto/pull/128): Added `Database.Esqueleto.PostgreSQL.JSON`
  module with JSON operators and `JSONB` data type.\n- @ibarrae\n  - [#127](https://github.com/bitemyapp/esqueleto/pull/127):
  Added `between` and support for composite keys in `unsafeSqlBinOp`.\n\n3.0.0\n=======\n\n-
  @parsonsmatt\n  - [#122](https://github.com/bitemyapp/esqueleto/pull/122): Support
  `persistent-2.10.0`. This is a breaking change due to the removal of deprecated
  exports from the `persistent` library.\n  - [#113](https://github.com/bitemyapp/esqueleto/pull/113):
  Remove the `esqueleto` type class. To migrate here, use `SqlExpr`, `SqlQuery`, and
  `SqlBackend` instead of using the polymorphic `Esqueleto sqlExpr sqlQuery sqlBackend
  => ...` types.\n\n2.7.0\n=======\n\n- @parsonsmatt\n  - [#117](https://github.com/bitemyapp/esqueleto/pull/117):
  Removed `sqlQQ` and `executeQQ` functions from export, fixing doc build and building
  with `persistent` >= 2.9\n\n2.6.1\n=======\n\n- @ChrisCoffey\n  - [#114](https://github.com/bitemyapp/esqueleto/pull/114):
  Fix Haddock by\n    working around an upstream bug.\n\n2.6.0\n========\n- @bitemyapp\n
  \ - Reorganized dependencies, decided to break compatibility for Conduit 1.3, Persistent
  2.8, and `unliftio`.\n  - Moved tests for `random()` into database-specific test
  suites.\n  - Deprecated Language `random_`, split it into database-specific modules.\n-
  @parsonsmatt\n  - Added support for `PersistQueryRead`/`PersistQueryWrite`, enabling
  type-safe differentation of read and write capabilities.\n    - https://github.com/bitemyapp/esqueleto/pull/66\n-
  @sestrella\n  - Added support for `arrayAggDistinct` and `arrayRemove`.\n    - https://github.com/bitemyapp/esqueleto/pull/65\n
  \   - https://github.com/bitemyapp/esqueleto/pull/66\n- @mheinzel\n  - Fixed JOIN
  syntax in the documentation https://github.com/bitemyapp/esqueleto/pull/60\n- @illmade\n
  \ - Added instructions for running database specific tests\n    - https://github.com/bitemyapp/esqueleto/pull/64\n-
  @FintanH\n  - Removed CPP from the test suite, split the database-specific tests
  into their own respective modules.\n    - https://github.com/bitemyapp/esqueleto/pull/48\n
  \ - Added support for PostgreSQL's `now()`\n    - https://github.com/bitemyapp/esqueleto/pull/46\n
  \ - Added a comprehensive examples project to make practical application of Esqueleto
  easier.\n    - https://github.com/bitemyapp/esqueleto/pull/40\n- @EdwardBetts\n
  \ - Fixed a spelling error\n    - https://github.com/bitemyapp/esqueleto/pull/52\n"
basic-deps:
  bytestring: -any
  unliftio: -any
  base: '>=4.8 && <5.0'
  time: '>=1.5.0.1 && <=1.13'
  persistent: '>=2.13 && <3'
  unordered-containers: '>=0.2'
  text: '>=0.11 && <2.1'
  conduit: '>=1.3'
  tagged: '>=0.2'
  containers: -any
  blaze-html: -any
  monad-logger: -any
  attoparsec: '>=0.13 && <0.15'
  transformers: '>=0.2'
  resourcet: '>=1.2'
  aeson: '>=1.0'
  template-haskell: -any
all-versions:
- '0.1'
- '0.2'
- 0.2.1
- 0.2.2
- 0.2.3
- 0.2.4
- 0.2.5
- 0.2.6
- 0.2.7
- 0.2.8
- 0.2.9
- '1.0'
- 1.0.1
- 1.0.2
- 1.0.3
- 1.0.5
- 1.0.6
- 1.0.7
- 1.0.8
- '1.2'
- 1.2.1
- 1.2.2
- 1.2.2.1
- 1.2.3
- 1.2.4
- '1.3'
- 1.3.1
- 1.3.2
- 1.3.3
- 1.3.4
- 1.3.4.2
- 1.3.4.3
- 1.3.4.4
- 1.3.4.5
- 1.3.4.6
- 1.3.5
- 1.3.6
- 1.3.7
- 1.3.8
- 1.3.9
- 1.3.10
- 1.3.11
- 1.3.12
- '1.4'
- 1.4.1
- 1.4.1.2
- 1.4.1.3
- 1.4.2
- 1.4.3
- 1.4.4
- 2.0.0
- 2.0.1
- 2.0.2
- 2.0.3
- 2.1.0
- 2.1.1
- 2.1.2
- 2.1.2.1
- 2.1.2.2
- 2.1.2.3
- 2.1.3
- '2.2'
- 2.2.1
- 2.2.2
- 2.2.3
- 2.2.4
- 2.2.5
- 2.2.6
- 2.2.7
- 2.2.8
- 2.2.9
- 2.2.10
- 2.2.11
- 2.2.12
- 2.3.0
- 2.4.0
- 2.4.1
- 2.4.2
- 2.4.3
- 2.5.0
- 2.5.1
- 2.5.2
- 2.5.3
- 2.6.0
- 2.6.1
- 2.7.0
- 3.0.0
- 3.1.0
- 3.1.1
- 3.1.2
- 3.1.3
- 3.2.2
- 3.2.3
- 3.3.0
- 3.3.1
- 3.3.1.1
- 3.3.2
- 3.4.0.0
- 3.4.0.1
- 3.4.1.0
- 3.4.1.1
- 3.4.2.0
- 3.4.2.1
- 3.4.2.2
- 3.4.3.0
- 3.5.0.0
- 3.5.1.0
- 3.5.2.0
- 3.5.2.1
- 3.5.2.2
- 3.5.3.0
- 3.5.3.1
- 3.5.3.2
- 3.5.4.0
- 3.5.4.1
- 3.5.4.2
- 3.5.5.0
- 3.5.6.1
- 3.5.7.0
- 3.5.7.1
- 3.5.8.0
- 3.5.8.1
author: Felipe Lessa
latest: 3.5.8.1
description-type: markdown
description: |
  Esqueleto [![CI](https://github.com/bitemyapp/esqueleto/actions/workflows/haskell.yml/badge.svg?branch=master)](https://github.com/bitemyapp/esqueleto/actions/workflows/haskell.yml)
  ==========

  ![Skeleton](./esqueleto.png)
  <sup>Image courtesy [Chrissy Long](https://www.flickr.com/photos/chrissylong/313800029/)</sup>

  # Esqueleto, a SQL DSL for Haskell

  Esqueleto is a bare bones, type-safe EDSL for SQL queries that works with unmodified persistent SQL backends. The name of this library means "skeleton" in Portuguese and contains all three SQL letters in the correct order =). It was inspired by Scala's Squeryl but created from scratch. Its language closely resembles SQL. Currently, SELECTs, UPDATEs, INSERTs and DELETEs are supported.

  In particular, esqueleto is the recommended library for type-safe JOINs on persistent SQL backends. (The alternative is using raw SQL, but that's error prone and does not offer any composability.). For more information read [esqueleto](http://hackage.haskell.org/package/esqueleto).

  ## Setup

  If you're already using `persistent`, then you're ready to use `esqueleto`, no further setup is needed.  If you're just starting a new project and would like to use `esqueleto`, take a look at `persistent`'s [book](http://www.yesodweb.com/book/persistent) first to learn how to define your schema.

  If you need to use `persistent`'s default support for queries as well, either import it qualified:

  ```haskell
  -- For a module that mostly uses esqueleto.
  import Database.Esqueleto
  import qualified Database.Persistent as P
  ```

  or import `esqueleto` itself qualified:

  ```haskell
  -- For a module that uses esqueleto just on some queries.
  import Database.Persistent
  import qualified Database.Esqueleto as E
  ```

  Other than identifier name clashes, `esqueleto` does not conflict with `persistent` in any way.


  ## Goals

  The main goals of `esqueleto` are:

  - Be easily translatable to SQL. (You should be able to know exactly how the SQL query will end up.)
  - Support the most widely used SQL features.
  - Be as type-safe as possible.

  It is _not_ a goal to be able to write portable SQL. We do not try to hide the differences between DBMSs from you


  ## Introduction

  For the following examples, we'll use this example schema:

  ```haskell
  share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
    Person
      name String
      age Int Maybe
      deriving Eq Show
    BlogPost
      title String
      authorId PersonId
      deriving Eq Show
    Follow
      follower PersonId
      followed PersonId
      deriving Eq Show
  |]
  ```

  ## Select

  Most of `esqueleto` was created with `SELECT` statements in mind, not only because they're the most common but also because they're the most complex kind of statement.  The most simple kind of `SELECT` would be:

  ```haskell
  putPersons :: SqlPersist m ()
  putPersons = do
    people <- select $
                from $ \person -> do
                return person
    liftIO $ mapM_ (putStrLn . personName . entityVal) people
  ```

  which generates this SQL:

  ```sql
  SELECT *
  FROM Person
  ```

  `esqueleto` knows that we want an `Entity Person` just because of the `personName` that is printed.

  ## Where

  Filtering by `PersonName`:

  ```haskell
  select $
  from $ \p -> do
  where_ (p ^. PersonName ==. val "John")
  return p
  ```

  which generates this SQL:

  ```sql
  SELECT *
  FROM Person
  WHERE Person.name = "John"
  ```

  The `(^.)` operator is used to project a field from an entity. The field name is the same one generated by `persistent`s Template Haskell functions.  We use `val` to lift a constant Haskell value into the SQL query.

  Another example:

  In `esqueleto`, we may write the same query above as:

  ```haskell
  select $
  from $ \p -> do
  where_ (p ^. PersonAge >=. just (val 18))
  return p
  ```

  which generates this SQL:

  ```sql
  SELECT *
  FROM Person
  WHERE Person.age >= 18
  ```

  Since `age` is an optional `Person` field, we use `just` to lift `val 18 :: SqlExpr (Value Int)` into `just (val 18) ::SqlExpr (Value (Maybe Int))`.

  ### Alternative Field Projections

  The `(^.)` operator works on an `EntityField` value, which are generated by
  `persistent` as the table name + the field name. This can get a little bit
  verbose. As of `persistent-2.11`, you can use `OverloadedLabels` to make this a
  bit more concise:

  ```haskell
  {-# LANGUAGE OverloadedLabels #-}

  select $ do
      p <- from $ table @Person
      pure
          ( p ^. PersonName
          , p ^. #name
          )
  ```

  The `OverloadedLabels` support uses the `fieldName` as given by the Persistent
  entity definition syntax - no type name prefix necessary. Additionally, these
  field accesses are *polymorphic* - the following query filters any table that
  has a `name` column:

  ```haskell
  rowsByName
      :: forall rec.
      ( PersistEntity rec
      , PersistEntityBackend rec ~ SqlBackend
      , SymbolToField "name" rec Text
      )
      => SqlExpr (Value Text)
      -> SqlQuery (SqlExpr (Entity rec))
  rowsByName name = do
      rec <- from $ table @rec
      where_ $ rec ^. #name ==. name
      pure rec
  ```

  GHC 9.2 introduces the `OverloadedRecordDot` language extension, and `esqueleto`
  supports this on `SqlExpr (Entity rec)` and `SqlExpr (Maybe (Entity rec))`. It
  looks like this:

  ```haskell
  select $ do
      (person, blogPost) <-
          from $
              table @Person
              `leftJoin` table @BlogPost
              `on` do
                  \(person :& blogPost) ->
                      just person.id ==. blogPost.authorId
      pure (person.name, blogPost.title)
  ```

  ## Experimental/New Joins

  There's a new way to write `JOIN`s in esqueleto! It has less potential for
  runtime errors and is much more powerful than the old syntax. To opt in to the
  new syntax, import:

  ```haskell
  import Database.Esqueleto.Experimental
  ```

  This will conflict with the definition of `from` and `on` in the
  `Database.Esqueleto` module, so you'll want to remove that import.

  This style will become the new "default" in esqueleto-4.0.0.0, so it's a good
  idea to port your code to using it soon.

  The module documentation in `Database.Esqueleto.Experimental` has many examples,
  and they won't be repeated here. Here's a quick sample:

  ```haskell
  select $ do
    (a :& b) <-
      from $
        Table @BlogPost
        `InnerJoin`
        Table @Person
          `on` do \(bp :& a) ->
            bp ^. BlogPostAuthorId ==. a ^. PersonId
    pure (a, b)
  ```

  Advantages:

  - `ON` clause is attached directly to the relevant join, so you never need to
    worry about how they're ordered, nor will you ever run into bugs where the
    `on` clause is on the wrong `JOIN`
  - The `ON` clause lambda will all the available tables in it. This forbids
    runtime errors where an `ON` clause refers to a table that isn't in scope yet.
  - You can join on a table twice, and the aliases work out fine with the `ON`
    clause.
  - You can use `UNION`, `EXCEPT`, `INTERSECTION` etc  with this new syntax!
  - You can reuse subqueries more easily.

  ## Legacy Joins

  Implicit joins are represented by tuples.

  For example, to get the list of all blog posts and their authors, we could write:

  ```haskell
  select $
  from $ \(b, p) -> do
  where_ (b ^. BlogPostAuthorId ==. p ^. PersonId)
  orderBy [asc (b ^. BlogPostTitle)]
  return (b, p)
  ```

  which generates this SQL:

  ```sql
  SELECT BlogPost.*, Person.*
  FROM BlogPost, Person
  WHERE BlogPost.authorId = Person.id
  ORDER BY BlogPost.title ASC
  ```


  However, you may want your results to include people who don't have any blog posts as well using a `LEFT OUTER JOIN`:

  ```haskell
  select $
  from $ \(p `LeftOuterJoin` mb) -> do
  on (just (p ^. PersonId) ==. mb ?. BlogPostAuthorId)
  orderBy [asc (p ^. PersonName), asc (mb ?. BlogPostTitle)]
  return (p, mb)
  ```

  which generates this SQL:

  ```sql
  SELECT Person.*, BlogPost.*
  FROM Person LEFT OUTER JOIN BlogPost
  ON Person.id = BlogPost.authorId
  ORDER BY Person.name ASC, BlogPost.title ASC
  ```

  ## Left Outer Join

  On a `LEFT OUTER JOIN` the entity on the right hand side may not exist (i.e. there may be a `Person` without any `BlogPost`s), so while `p :: SqlExpr (Entity Person)`, we have `mb :: SqlExpr (Maybe (Entity BlogPost))`.  The whole expression above has type `SqlPersist m [(Entity Person, Maybe (Entity BlogPost))]`.  Instead of using `(^.)`, we used `(?.)` to project a field from a `Maybe (Entity a)`.

  We are by no means limited to joins of two tables, nor by joins of different tables.  For example, we may want a list of the `Follow` entity:

  ```haskell
  select $
  from $ \(p1 `InnerJoin` f `InnerJoin` p2) -> do
  on (p2 ^. PersonId ==. f ^. FollowFollowed)
  on (p1 ^. PersonId ==. f ^. FollowFollower)
  return (p1, f, p2)
  ```

  which generates this SQL:

  ```sql
  SELECT P1.*, Follow.*, P2.*
  FROM Person AS P1
  INNER JOIN Follow ON P1.id = Follow.follower
  INNER JOIN Person AS P2 ON P2.id = Follow.followed
  ```

  ## Update and Delete

  ```haskell
  do update $ \p -> do
       set p [ PersonName =. val "João" ]
       where_ (p ^. PersonName ==. val "Joao")
     delete $
       from $ \p -> do
       where_ (p ^. PersonAge <. just (val 14))
  ```

  The results of queries can also be used for insertions. In `SQL`, we might write the following, inserting a new blog post for every user:

  ```haskell
   insertSelect $ from $ \p->
   return $ BlogPost <# "Group Blog Post" <&> (p ^. PersonId)
  ```

  which generates this SQL:

  ```sql
  INSERT INTO BlogPost
  SELECT ('Group Blog Post', id)
  FROM Person
  ```

  Individual insertions can be performed through Persistent's `insert` function, reexported for convenience.

  ### Re-exports

  We re-export many symbols from `persistent` for convenience:
  - "Store functions" from "Database.Persist".
  - Everything from "Database.Persist.Class" except for `PersistQuery` and `delete` (use `deleteKey` instead).
  - Everything from "Database.Persist.Types" except for `Update`, `SelectOpt`, `BackendSpecificFilter` and `Filter`.
  - Everything from "Database.Persist.Sql" except for `deleteWhereCount` and `updateWhereCount`.

  ### RDBMS Specific

  There are many differences between SQL syntax and functions supported by different RDBMSs.  Since version 2.2.8, `esqueleto` includes modules containing functions that are specific to a given RDBMS.

  - PostgreSQL: `Database.Esqueleto.PostgreSQL`
  - MySQL: `Database.Esqueleto.MySQL`
  - SQLite: `Database.Esqueleto.SQLite`

  In order to use these functions, you need to explicitly import their corresponding modules.

  ### Unsafe functions, operators and values

  Esqueleto doesn't support every possible function, and it can't - many functions aren't available on every RDBMS platform, and sometimes the same functionality is hidden behind different names. To overcome this problem, Esqueleto exports a number of unsafe functions to call any function, operator or value. These functions can be found in Database.Esqueleto.Internal.Sql module.

  Warning: the functions discussed in this section must always be used with an explicit type signature,and the user must be careful to provide a type signature that corresponds correctly with the underlying code. The functions have extremely general types, and if you allow type inference to figure everything out for you, it may not correspond with the underlying SQL types that you want. This interface is effectively the FFI to SQL database, so take care!

  The most common use of these functions is for calling RDBMS specific or custom functions,
  for that end we use `unsafeSqlFunction`. For example, if we wish to consult the postgres
  `now` function we could so as follow:

  ```haskell
  postgresTime :: (MonadIO m, MonadLogger m) => SqlWriteT m UTCTime
  postgresTime =
    result <- select (pure now)
    case result of
      [x] -> pure x
      _ -> error "now() is guaranteed to return a single result"
    where
      now :: SqlExpr (Value UTCTime)
      now = unsafeSqlFunction "now" ()
  ```

  which generates this SQL:

  ```sql
  SELECT now()
  ```

  With the `now` function we could now use the current time of the postgres RDBMS on any query.
  Do notice that `now` does not use any arguments, so we use `()` that is an instance of
  `UnsafeSqlFunctionArgument` to represent no arguments, an empty list cast to a correct value
  will yield the same result as `()`.

  We can also use `unsafeSqlFunction` for more complex functions with customs values using
  `unsafeSqlValue` which turns any string into a sql value of whatever type we want, disclaimer:
  if you use it badly you will cause a runtime error. For example, say we want to try postgres'
  `date_part` function and get the day of a timestamp, we could use:

  ```haskell
  postgresTimestampDay :: (MonadIO m, MonadLogger m) => SqlWriteT m Int
  postgresTimestampDay =
    result <- select (return $ dayPart date)
    case result of
      [x] -> pure x
      _ -> error "dayPart is guaranteed to return a single result"
    where
      dayPart :: SqlExpr (Value UTCTime) -> SqlExpr (Value Int)
      dayPart s = unsafeSqlFunction "date_part" (unsafeSqlValue "\'day\'" :: SqlExpr (Value String) ,s)
      date :: SqlExpr (Value UTCTime)
      date = unsafeSqlValue "TIMESTAMP \'2001-02-16 20:38:40\'"
  ```

  which generates this SQL:

  ```sql
  SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40')
  ```

  Using `unsafeSqlValue` we were required to also define the type of the value.

  Another useful unsafe function is `unsafeSqlCastAs`, which allows us to cast any type
  to another within a query. For example, say we want to use our previews `dayPart` function
  on the current system time, we could:

  ```haskell
  postgresTimestampDay :: (MonadIO m, MonadLogger m) => SqlWriteT m Int
  postgresTimestampDay = do
    currentTime <- liftIO getCurrentTime
    result <- select (return $ dayPart (toTIMESTAMP $ val currentTime))
    case result of
      [x] -> pure x
      _ -> error "dayPart is guaranteed to return a single result"
    where
      dayPart :: SqlExpr (Value UTCTime) -> SqlExpr (Value Int)
      dayPart s = unsafeSqlFunction "date_part" (unsafeSqlValue "\'day\'" :: SqlExpr (Value String) ,s)
      toTIMESTAMP :: SqlExpr (Value UTCTime) -> SqlExpr (Value UTCTime)
      toTIMESTAMP = unsafeSqlCastAs "TIMESTAMP"
  ```

  which generates this SQL:

  ```sql
  SELECT date_part('day', CAST('2019-10-28 23:19:39.400898344Z' AS TIMESTAMP))
  ```

  ### SQL injection

  Esqueleto uses parameterization to prevent sql injections on values and arguments
  on all queries, for example, if we have:

  ```haskell
  myEvilQuery :: (MonadIO m, MonadLogger m) => SqlWriteT m ()
  myEvilQuery =
    select (return $ val ("hi\'; DROP TABLE foo; select \'bye\'" :: String)) >>= liftIO . print
  ```

  which generates this SQL(when using postgres):

  ```sql
  SELECT 'hi''; DROP TABLE foo; select ''bye'''
  ```

  And the printed value is `hi\'; DROP TABLE foo; select \'bye\'` and no table is dropped. This is good
  and makes the use of strings values safe. Unfortunately this is not the case when using unsafe functions.
  Let's see an example of defining a new evil `now` function:

  ```haskell
  myEvilQuery :: (MonadIO m, MonadLogger m) => SqlWriteT m ()
  myEvilQuery =
    select (return nowWithInjection) >>= liftIO . print
    where
      nowWithInjection :: SqlExpr (Value UTCTime)
      nowWithInjection = unsafeSqlFunction "0; DROP TABLE bar; select now" ([] :: [SqlExpr (Value Int)])
  ```

  which generates this SQL:

  ```sql
  SELECT 0; DROP TABLE bar; select now()
  ```

  If we were to run the above code we would see the postgres time printed but the table `bar`
  will be erased with no indication whatsoever. Another example of this behavior is seen when using
  `unsafeSqlValue`:

  ```haskell
  myEvilQuery :: (MonadIO m, MonadLogger m) => SqlWriteT m ()
  myEvilQuery =
    select (return $ dayPart dateWithInjection) >>= liftIO . print
    where
      dayPart :: SqlExpr (Value UTCTime) -> SqlExpr (Value Int)
      dayPart s = unsafeSqlFunction "date_part" (unsafeSqlValue "\'day\'" :: SqlExpr (Value String) ,s)
      dateWithInjection :: SqlExpr (Value UTCTime)
      dateWithInjection = unsafeSqlValue "TIMESTAMP \'2001-02-16 20:38:40\');DROP TABLE bar; select (16"
  ```

  which generates this SQL:

  ```sql
  SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');DROP TABLE bar; select (16)
  ```

  This will print 16 and also erase the `bar` table. The main take away of this examples is to
  never use any user or third party input inside an unsafe function without first parsing it or
  heavily sanitizing the input.

  ### Tests

  To run the tests, do `stack test`. This tests all the backends, so you'll need
  to have MySQL and Postgresql installed.

  #### Postgres

  Using apt-get, you should be able to do:

  ```
  sudo apt-get install postgresql postgresql-contrib
  sudo apt-get install libpq-dev
  ```

  Using homebrew on OSx

  ```
  brew install postgresql
  brew install libpq
  ```

  Detailed instructions on the Postgres wiki [here](https://wiki.postgresql.org/wiki/Detailed_installation_guides)

  The connection details are located near the bottom of the [test/PostgreSQL/Test.hs](test/PostgreSQL/Test.hs) file:

  ```
  withConn =
    R.runResourceT . withPostgresqlConn "host=localhost port=5432 user=esqutest password=esqutest dbname=esqutest"
  ```

  You can change these if you like but to just get them working set up as follows on linux:

  ```
  $ sudo -u postgres createuser esqutest
  $ sudo -u postgres createdb esqutest
  $ sudo -u postgres psql
  postgres=# \password esqutest
  ```

  And on osx

  ```
  $ createuser esqutest
  $ createdb esqutest
  $ psql postgres
  postgres=# \password esqutest
  ```

  #### MySQL

  To test MySQL, you'll need to have a MySQL server installation.
  Then, you'll need to create a database `esqutest` and a `'travis'@'localhost'`
  user which can access it:

  ```
  mysql> CREATE DATABASE esqutest;
  mysql> CREATE USER 'travis'@'localhost';
  mysql> ALTER USER 'travis'@'localhost' IDENTIFIED BY 'esqutest';
  mysql> GRANT ALL ON esqutest.* TO 'travis'@'localhost';
  ```
license-name: BSD-3-Clause

all-versions:
- 1.0.0
- 1.0.1
- 1.1.0
- 1.2.0
- 2.0.0
- 2.0.1
- 2.1.0
author: Jappie Klooster
basic-deps:
  base: '>=4.9.1.0 && <4.23.0.0'
  base16: '>=1.0 && <1.1'
  binary: <1
  bytestring: <2
  containers: '>=0.6.5 && <0.9'
  esqueleto: '>=3.5.10 && <3.7'
  geojson: '>=4.1.1 && <4.2'
  persistent: '>=2.13.3 && <2.19'
  text: '>=1.2.5 && <2.2'
changelog: "# Change log for esqueleto-postgis project\n\n## Version 2.1.0 \n* add
  st_unions\n\n## Version 2.0.1 \n* drop haskell works hedghog dependency\n\n## Version
  2.0.0 \n* Hide irrelevant modules\n* delete hex module, use base16 hex approach
  instead.\n* Much better docs that explain what's going on.\n\n## Version 1.2.0 \n+
  re-export point, less annoying to use.\n+ adopt wkt-geom package and put it in as
  a submodule,\n  original library doesn't appear to be maintained.\n  this way we're
  a step closer to stackage.\n  + got rid of the internal convention, \n    it goes
  against pvp. If we want some specialized\n    usage package I should split off a
  core package instead.\n    For now I don't care I don't think I'm not changing those
  \n    functions anyway.\n  + also ported over the test suite\n+ swap out bytestring-base16
  for base16, which appears maintained.\n\n\n## Version 1.1.0 \n+ Add st_union\n+
  add getPoitns to escape the postgis geometry more easily.\n+ bump bounds\n\n\n##
  Version 1.0.1 \n+ fix insane bounds by cabal genbounds. \n  I think this was caused
  due to running it from the flake which\n  takes a bunch of outdated packages from
  stackage.\n\n## Version 1.0.0 \n+ add st_contains\n+ add st_intersects\n+ add st_point\n+
  add custom datatype to map to persistent.\n+ bunch of roundtrip tests and sanity
  tests for added functions\n\n## Version 0.0.0 \n\nimport [template](https://github.com/jappeace/template).\n\n"
changelog-type: markdown
description: "[![https://jappieklooster.nl](https://img.shields.io/badge/blog-jappieklooster.nl-lightgrey)](https://jappieklooster.nl/tag/haskell.html)\n[![Githbu
  actions build status](https://img.shields.io/github/workflow/status/jappeace/esqueleto-postgis/Test)](https://github.com/jappeace/esqueleto-postgis/actions)\n[![Jappiejappie](https://img.shields.io/badge/discord-jappiejappie-black?logo=discord)](https://discord.gg/Hp4agqy)\n[![Hackage
  version](https://img.shields.io/hackage/v/esqueleto-postgis.svg?label=Hackage)](https://hackage.haskell.org/package/esqueleto-postgis)
  \n\n> Show me the place where space is not.\n\nImplement (partial) postgis functionality
  for esqueleto.\nhttps://postgis.net/\n\nuses wkt-geom to get a persistent instance,\nthen
  maps that to a custom datatype 'PostgisGeometry' which is valid\nfor roundtripping.\n\nThen
  the esqueleto combinators are defined around this datatype.\n\n# Tutorial\n\nmost
  linux distributions support this out of the box.\nnixos needs some special care:\n```nix\nservices.postgresql
  = {\n   enable = true;\n   package = (pkgs.postgresql_12.withPackages (p: [ p.postgis
  ]));\n};\n```\nFor mac you've to [install](https://postgis.net/documentation/getting_started/install_macos/)
  postgis.\n```sh\nbrew install postgis\n```\n\nMake sure to enable to postgis extension
  on your database (it's activated per database):\n```sql\nCREATE EXTENSION postgis;\n```\n\nyou
  can specify some posgis geometry,\nuse the point to nidicate dimensions, \npointxy
  = 2 dimensions\npointxyz = 3, pointxyzm = 4.\nThe library forces you to work in
  the same dimensions.\n\nYou can specify a table with the custom datatype, which
  will have geometry as sql type:\n\n```haskell\nshare\n  [mkPersist sqlSettings,
  mkMigrate \"migrateAll\"]\n  [persistUpperCase|\n  Unit sql=unit\n    geom       (PostgisGeometry
  PointXY)\n    deriving Eq Show\n|]\n```\n\nthen you can simply query on tat datatype:\n\n```haskell\ntest
  = testCase (\"it finds the one unit with st_contains\") $ do\n            result
  <- runDB $ do\n              _ <- insert $\n                Unit\n                  {
  unitGeom = Polygon $ makePolygon (PointXY 0 0) (PointXY 0 2) (PointXY 2 2) $ Seq.fromList
  [(PointXY 2 0)]\n                  }\n\n              selectOne $ do\n                unit
  <- from $ table @Unit\n                where_ $ unit ^. UnitGeom `st_contains` (val
  $ Point (PointXY 1 1))\n                pure countRows\n\n            -- expectation,
  the result should be 1\n            unValue <$> result @?= (Just (1 :: Int)),\n```\n\n#
  Contributing\ncontributions are welcome.\nThere are still many bindings missing!\n\n#
  Hacking\n\n### Tools\nEnter the nix shell.\n```\nnix develop\n```\nYou can checkout
  the makefile to see what's available:\n```\ncat makefile\n```\n\n### Running\n```\nmake
  run\n```\n\n### Fast filewatch which runs tests\n```\nmake ghcid\n```\n"
description-type: markdown
hash: 0576d2f757b470b6e4c8217a0785701e71888055dc1287b91653cceac20813c6
homepage: https://github.com/jappeace/esqueleto-postgis#readme
latest: 2.1.0
license-name: MIT
maintainer: jappieklooster@hotmail.com
synopsis: postgis bindings for esqueleto.
test-bench-deps:
  HUnit: '>=0'
  base: '>=4.9.1.0 && <4.23.0.0'
  base16: '>=1.0 && <1.1'
  binary: <1
  bytestring: <2
  call-stack: '>=0'
  containers: '>=0.6.5 && <0.9'
  esqueleto: '>=3.5.10 && <3.7'
  esqueleto-postgis: '>=0'
  geojson: '>=4.1.1 && <4.2'
  hedgehog: '>=0'
  hspec: '>=0'
  monad-logger: '>=0'
  persistent: '>=2.13.3 && <2.19'
  persistent-postgresql: '>=0'
  resourcet: '>=0'
  tasty: '>=0'
  tasty-hspec: '>=0'
  tasty-hunit: '>=0'
  tasty-quickcheck: '>=0'
  text: '>=1.2.5 && <2.2'

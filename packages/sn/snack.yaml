homepage: https://github.com/mordae/snack#readme
changelog-type: markdown
hash: 784ed638af378d9273865f64eac85244e38a06014978449eb9fa12aacb04e37b
test-bench-deps:
  snack: -any
  bytestring: '>=0.11'
  base: '>=4 && <5'
  text: '>=2.0'
  criterion: -any
  attoparsec: '>=0.13'
  string-conversions: -any
maintainer: mordae@anilinux.org
synopsis: Strict ByteString Parser Combinator
changelog: |
  [0.1.0.0] -- April 2022
  [0.1.0.0]: https://github.com/mordae/snack/compare/initial...0.1.0.0

  * Initial release
basic-deps:
  bytestring: '>=0.11'
  base: '>=4.13 && <5'
  text: '>=2.0'
  bytestring-lexing: '>=0.5'
all-versions:
- 0.1.0.0
author: Jan Hamal Dvořák
latest: 0.1.0.0
description-type: markdown
description: |
  # snack

  **Strict ByteString Parser Combinator**

  - Simple. Feel free to contribute.
  - Fast. Sometimes faster then Attoparsec.
  - ASCII. Good enough for IETF formats.
  - Also Text. But quite slower.

  Example:

  ```haskell
  import Data.ByteString (ByteString)
  import qualified Data.ByteString.Parser.Char8 as BSP

  parseList :: BSP.Parser [ByteString]
  parseList = (token `BSP.wrap` BSP.skipSpace) `BSP.sepBy` BSP.char ','
    where token = BSP.takeWhile isToken
          isToken c = inRange 'a' 'z' c ||
                      inRange 'A' 'Z' c ||
                      inRange '0' '9' c ||
                      c == '_' || c == '-'

  main :: IO ()
  main = do
    putStrLn $ show $ BSP.runParser parseList "monkey, wrench, bananas"
    putStrLn $ show $ BSP.runParser parseList "^quux"
    putStrLn $ show $ BSP.runParser (parseList <* BSP.endOfInput) "^quux"

  -- Will output:
  -- Just (["monkey","wrench","bananas"],"")
  -- Just ([""],"^quux")
  -- Nothing
  ```
license-name: MIT

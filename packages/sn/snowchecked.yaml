homepage: https://github.com/robertfischer/hs-snowflake-checked#readme
changelog-type: ''
hash: f4450db739662d55be9c08f74a0271556c636bf2206a0ecd02d4aa1c75e4caf2
test-bench-deps:
  bytestring: '>=0.10.12.0'
  snowchecked: -any
  base: '>=4.14.1.0 && <4.15'
  time: '>=1.9.3'
  hedgehog: -any
  data-default: '>=0.7.1.1'
  wide-word: '>=0.1.1.2'
  deepseq: '>=1.4.4.0'
maintainer: smokejumperit@gmail.com
synopsis: A checksummed variation on Twitter's Snowflake UID generation algorithm
changelog: ''
basic-deps:
  bytestring: '>=0.10.12.0'
  base: '>=4.14.1.0 && <4.15'
  time: '>=1.9.3'
  data-default: '>=0.7.1.1'
  wide-word: '>=0.1.1.2'
  deepseq: '>=1.4.4.0'
all-versions:
- 0.0.0.1
- 0.0.0.3
author: Robert Fischer
latest: 0.0.0.3
description-type: markdown
description: |
  # SnowChecked

  ## A Checksummed UID Generator based on Twitter's Snowflake

  Unique ids are useful, but traditional GUID/UUID formats are lengthy, inefficient, and hard for humans to use. Twitter
  created a novel format for UIDs called ["Snowflake"](https://developer.twitter.com/en/docs/twitter-ids) which addressed
  these issues, with the added benefit that the UIDs monotonically increase over time.
  This library extends the Snowflake format by adding checksum bits at the end. If you use this library with
  the number of checksum bits set to 0, then you have a Snowflake implementation.

  This extension is valuable because the checksum detects error on input. If you're using ids in a human setting
  (eg: having users type them in), then the checksum is valuable to catch typos, miscommunications, and other input issues.

  Like Snowflake, this algorithm uses some bits from the timestamp, some bits from a counter, and some bits of the node id.
  This algorithm extends Snowflake by also using some bits to store the checksum, which derives from the sum of the other
  parts.

  This implementation allows the number of bits in the id to range from 0 bits to 255^4 bits. The default configuration uses
  64 bits, with 40 bits used for time, 10 bits used for the counter, 8 bits used for the node id, and 6 bits for the checksum.
  The odds of a false positive on the checksum is `1/(2^checkbits)`, so the odds of a false positive in the default configuration
  is ~1.5%. This configuration can generate 1024 UIDs per millisecond per node: the 1025th request to a node for a UID in that
  millisecond will cause a pause in the thread for one millisecond, and then the counter will reset to 0. (If you need more UIDs
  than that, then create more generators with distinct node ids.)

  # Credit

  This project derives distantly from the [`snowfake` package on Hackage](https://hackage.haskell.org/package/snowflake).
license-name: Apache-2.0

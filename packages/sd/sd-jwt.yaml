all-versions:
- 0.1.0.0
- 0.1.0.1
author: Yaron Sheffer
basic-deps:
  aeson: '>=2.0 && <2.3'
  base: '>=4.14 && <5'
  base64-bytestring: '>=1.2 && <1.3'
  bytestring: '>=0.11 && <0.12'
  containers: '>=0.6 && <0.7'
  cryptonite: '>=0.30 && <0.31'
  directory: '>=1.3 && <1.4'
  jose: '>=0.10 && <0.13'
  lens: '>=4.16 && <5.4'
  memory: '>=0.18 && <0.19'
  mtl: '>=2.2 && <3'
  scientific: '>=0.3 && <0.4'
  sd-jwt: '>=0'
  text: '>=2.0 && <2.1'
  time: '>=1.9 && <1.13'
  vector: '>=0.13 && <0.14'
changelog: |
  # Changelog for `sd-jwt`

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
  and this project adheres to the
  [Haskell Package Versioning Policy](https://pvp.haskell.org/).

  ## 0.1.0.1 - 2025-01-10

  ### Fixed
  - Corrected documentation regarding RS256 deprecation status: RS256 (RSA-PKCS#1 v1.5) is deprecated for encryption per draft-ietf-jose-deprecate-none-rsa15, but remains valid for signatures. Previous documentation incorrectly stated RS256 was deprecated for signatures.

  ### Documentation
  - Updated README.md, source code comments, and module documentation to clarify RS256 deprecation status
  - PS256 (RSA-PSS) remains the recommended default for RSA keys

  ## 0.1.0.0 - 2025-01-09

  ### Added
  - Initial release of SD-JWT library implementing RFC 9901
  - SD-JWT issuance (issuer side)
  - SD-JWT presentation (holder side)
  - SD-JWT verification (verifier side)
  - Key Binding support (SD-JWT+KB) per RFC 9901 Section 4.3
  - Nested and recursive disclosures (RFC 9901 Sections 6.2, 6.3)
  - Multiple hash algorithms: SHA-256 (default), SHA-384, SHA-512
  - Multiple signing algorithms:
    - PS256 (RSA-PSS) - Default for RSA keys, recommended for security
    - RS256 (RSA-PKCS#1 v1.5) - Supported for signatures (deprecated for encryption per draft-ietf-jose-deprecate-none-rsa15)
    - ES256 (EC P-256) - Elliptic Curve signing
    - EdDSA (Ed25519) - Recommended for high-security applications
  - Persona-specific modules: `SDJWT.Issuer`, `SDJWT.Holder`, `SDJWT.Verifier`
  - Comprehensive test suite (>300 tests including property-based tests)
  - RFC 9901 test vector verification
  - End-to-end integration tests
  - Property-based testing with QuickCheck
  - Interoperability testing against the Python reference implementation
  - Complete Haddock documentation

  ### Security
  - PS256 (RSA-PSS) is the default algorithm for RSA keys (security best practice)
  - RS256 (RSA-PKCS#1 v1.5) is deprecated for encryption per draft-ietf-jose-deprecate-none-rsa15, but remains valid for signatures
  - EC signing timing attack warning documented (affects signing only, not verification)
  - RFC 8725bis compliance: algorithm validation, typ header support, "none" algorithm rejection

  ### Documentation
  - Comprehensive README with usage examples
  - Internal implementation plan documentation
  - Test plan documentation mapping tests to RFC sections
  - Security review documentation
  - RFC 8725bis compliance review

  ### Technical Details
  - Built on `jose` library (v0.10+) for JWT/JWS operations with native EC signing support
  - Uses `cryptonite` for cryptographic operations (hashing, random number generation)
  - Full RFC 9901 compliance including all examples from Sections 5.1 and 5.2
  - Support for JSON Pointer syntax (RFC 6901) for nested structures
  - Proper handling of JSON Pointer escaping (`~1` for `/`, `~0` for `~`)
changelog-type: markdown
description: "# SD-JWT: Selective Disclosure for JSON Web Tokens\n\n[![CI](https://github.com/yaronf/sd-jwt/actions/workflows/ci.yml/badge.svg)](https://github.com/yaronf/sd-jwt/actions/workflows/ci.yml)\n[![Hackage](https://img.shields.io/hackage/v/sd-jwt)](https://hackage.haskell.org/package/sd-jwt)\n\n[![Haddocks](https://img.shields.io/badge/docs-haddock-blue)](https://hackage.haskell.org/package/sd-jwt/docs)\n[![License](https://img.shields.io/badge/license-BSD--3--Clause-blue)](LICENSE)\n\nHaskell
  implementation of [RFC 9901](https://www.rfc-editor.org/rfc/rfc9901.html): Selective
  Disclosure for JSON Web Tokens (SD-JWT).\n\n## Overview\n\nSD-JWT enables selective
  disclosure of individual elements of a JSON data structure used as the payload of
  a JSON Web Signature (JWS). The primary use case is the selective disclosure of
  JSON Web Token (JWT) claims.\n\n## Features\n\n- ✅ SD-JWT issuance (issuer side)\n-
  ✅ SD-JWT presentation (holder side)\n- ✅ SD-JWT verification (verifier side)\n-
  ✅ Key Binding support (SD-JWT+KB)\n- ✅ Nested and recursive disclosures\n- ✅ Multiple
  hash algorithms (SHA-256, SHA-384, SHA-512)\n- ✅ Multiple signing algorithms: PS256
  (RSA-PSS, default), RS256 (RSA-PKCS#1 v1.5), ES256 (EC P-256), EdDSA (Ed25519)\n\n##
  Status\n\n✅ **Stable** - This implementation is feature-complete and ready for use.\n\nThe
  library implements RFC 9901 with comprehensive test coverage (224 tests). See [internal-docs/IMPLEMENTATION_PLAN.md](internal-docs/IMPLEMENTATION_PLAN.md)
  for implementation details.\n\n## Installation\n\n```bash\nstack build\n# or\ncabal
  build\n```\n\n## Examples\n\nA complete end-to-end example demonstrating the full
  SD-JWT flow (issuer → holder → verifier) is available:\n\n```bash\nstack exec sd-jwt-example\n#
  or\nstack runghc examples/EndToEndExample.hs\n```\n\nThis example shows:\n- Issuer
  creating an SD-JWT with selective disclosure\n- Holder selecting which claims to
  disclose and creating a presentation\n- Verifier verifying the presentation and
  extracting claims\n\n## Usage\n\n### Recommended: Use Persona-Specific Modules\n\nThe
  library provides three persona-specific modules for different use cases:\n\n####
  For Issuers (Creating SD-JWTs)\n\n⚠️ **Security Warning**: When using Elliptic Curve
  (EC) keys (ES256 algorithm), be aware that the underlying `jose` library's EC signing
  implementation may be vulnerable to timing attacks. This affects signing only, not
  verification. For applications where timing attacks are a concern, consider using
  RSA-PSS (PS256, default for RSA keys) or Ed25519 (EdDSA) keys instead.\n\n**Note**:
  RS256 (RSA-PKCS#1 v1.5) is deprecated for encryption per [draft-ietf-jose-deprecate-none-rsa15](https://datatracker.ietf.org/doc/draft-ietf-jose-deprecate-none-rsa15/),
  but remains valid for signatures. PS256 (RSA-PSS) is the recommended RSA algorithm
  and is used by default for RSA keys.\n\n```haskell\nimport SDJWT.Issuer\nimport
  qualified Data.Map.Strict as Map\nimport qualified Data.Aeson as Aeson\nimport qualified
  Data.Text as T\n\n-- Create claims\nlet claims = Map.fromList\n      [ (\"sub\",
  Aeson.String \"user_123\")\n      , (\"given_name\", Aeson.String \"John\")\n      ,
  (\"family_name\", Aeson.String \"Doe\")\n      ]\n\n-- Load issuer's private key
  (can be Text or jose JWK object)\n-- Example Text format: \"{\\\"kty\\\":\\\"RSA\\\",\\\"n\\\":\\\"...\\\",\\\"e\\\":\\\"AQAB\\\",\\\"d\\\":\\\"...\\\"}\"\nissuerPrivateKeyJWK
  <- loadPrivateKeyJWK  -- Your function to load the key (returns Text or JWK.JWK)\n\n--
  Create SD-JWT with selective disclosure\n-- PS256 (RSA-PSS) is used by default for
  RSA keys\n-- createSDJWT signature: mbTyp mbKid hashAlg key claimNames claims\nresult
  <- createSDJWT (Just \"sd-jwt\") Nothing SHA256 issuerPrivateKeyJWK [\"given_name\",
  \"family_name\"] claims\ncase result of\n  Right sdjwt -> do\n    let serialized
  = serializeSDJWT sdjwt\n    -- Send serialized SD-JWT to holder\n  Left err -> putStrLn
  $ \"Error creating SD-JWT: \" ++ show err\n```\n\n#### For Holders (Creating Presentations)\n\n```haskell\nimport
  SDJWT.Holder\nimport qualified Data.Text as T\nimport Data.Int (Int64)\n\n-- Deserialize
  SD-JWT received from issuer\ncase deserializeSDJWT sdjwtText of\n  Right sdjwt ->
  do\n    -- Select which disclosures to include in the presentation\n    -- The holder
  chooses which claims to reveal (e.g., only \"given_name\", not \"family_name\")\n
  \   case selectDisclosuresByNames sdjwt [\"given_name\"] of\n      Right presentation
  -> do\n        -- The presentation now contains:\n        -- - presentationJWT:
  The issuer-signed JWT (with digests for all claims)\n        -- - selectedDisclosures:
  Only the disclosures for \"given_name\"\n        -- Optionally add key binding (SD-JWT+KB)
  for proof of possession\n        holderPrivateKeyJWK <- loadPrivateKeyJWK  -- Your
  function to load holder's private key (Text or jose JWK)\n        let audience =
  \"verifier.example.com\"\n        let nonce = \"random-nonce-12345\"\n        let
  issuedAt = 1683000000 :: Int64\n        result <- addKeyBindingToPresentation SHA256
  holderPrivateKeyJWK audience nonce issuedAt presentation (Aeson.object [])\n        case
  result of\n          Right presentationWithKB -> do\n            -- Serialize the
  presentation: JWT~disclosure1~disclosure2~...~KB-JWT\n            -- This includes
  both the issuer-signed JWT and the selected disclosures\n            let serialized
  = serializePresentation presentationWithKB\n            -- Send serialized presentation
  to verifier\n            -- The verifier will verify the signature and reconstruct
  claims from the selected disclosures\n          Left err -> putStrLn $ \"Error adding
  key binding: \" ++ show err\n      Left err -> putStrLn $ \"Error selecting disclosures:
  \" ++ show err\n  Left err -> putStrLn $ \"Error deserializing SD-JWT: \" ++ show
  err\n```\n\n#### For Verifiers (Verifying SD-JWTs)\n\n```haskell\nimport SDJWT.Verifier\nimport
  qualified Data.Text as T\n\n-- Deserialize presentation received from holder\ncase
  deserializePresentation presentationText of\n  Right presentation -> do\n    --
  Load issuer's public key (can be Text or jose JWK object)\n    issuerPublicKeyJWK
  <- loadPublicKeyJWK  -- Your function to load issuer's public key (Text or jose
  JWK)\n    \n    -- Verify the SD-JWT (optionally require specific typ header)\n
  \   -- Pass Nothing to allow any typ, or Just \"sd-jwt\" to require specific typ\n
  \   result <- verifySDJWT issuerPublicKeyJWK presentation Nothing\n    case result
  of\n      Right processedPayload -> do\n        -- Extract claims\n        let claims
  = processedClaims processedPayload\n        -- Use verified claims\n      Left err
  -> putStrLn $ \"Verification failed: \" ++ show err\n  Left err -> putStrLn $ \"Error
  deserializing presentation: \" ++ show err\n```\n\n### Advanced Usage\n\nFor library
  developers or advanced use cases requiring low-level access,\nimport specific Internal
  modules as needed:\n\n```haskell\nimport SDJWT.Internal.Types\nimport SDJWT.Internal.Serialization\nimport
  SDJWT.Internal.Issuance\n-- etc.\n```\n\n### Nested Structures\n\nThe library supports
  nested structures using JSON Pointer syntax (RFC 6901), including both object properties
  and array elements:\n\n```haskell\nlet claims = Map.fromList\n      [ (\"address\",
  Aeson.Object $ KeyMap.fromList\n          [ (Key.fromText \"street_address\", Aeson.String
  \"123 Main St\")\n          , (Key.fromText \"locality\", Aeson.String \"City\")\n
  \         , (Key.fromText \"country\", Aeson.String \"US\")\n          ])\n      ,
  (\"nationalities\", Aeson.Array $ V.fromList\n          [ Aeson.String \"US\"\n
  \         , Aeson.String \"CA\"\n          , Aeson.String \"UK\"\n          ])\n
  \     ]\n\n-- Structured SD-JWT (Section 6.2): parent stays, sub-claims get _sd
  array\nresult <- buildSDJWTPayload SHA256 [\"address/street_address\", \"address/locality\"]
  claims\n\n-- Recursive Disclosures (Section 6.3): parent is selectively disclosable\nresult
  <- buildSDJWTPayload SHA256 [\"address\", \"address/street_address\", \"address/locality\"]
  claims\n\n-- Array elements: mark elements at indices 0 and 2 as selectively disclosable\nresult
  <- buildSDJWTPayload SHA256 [\"nationalities/0\", \"nationalities/2\"] claims\n\n--
  Mixed object and array paths\nresult <- buildSDJWTPayload SHA256 [\"address/street_address\",
  \"nationalities/1\"] claims\n\n-- Nested arrays: mark element at index 0 of the
  array at index 0\nresult <- buildSDJWTPayload SHA256 [\"nested_array/0/0\", \"nested_array/1/1\"]
  claims\n```\n\n#### JSON Pointer Escaping\n\nKeys containing forward slashes or
  tildes must be escaped using JSON Pointer syntax (RFC 6901):\n\n- `~1` = literal
  `/` (forward slash)\n- `~0` = literal `~` (tilde)\n\n**Important**: When creating
  claims Maps, use the actual (unescaped) JSON keys. When passing claim names to `buildSDJWTPayload`,
  use escaped forms for keys containing special characters.\n\nExamples:\n- Map key:
  `\"contact/email\"`, path: `[\"contact~1email\"]` → marks literal key `\"contact/email\"`
  (not nested)\n- Map key: `\"user~name\"`, path: `[\"user~0name\"]` → marks literal
  key `\"user~name\"` (not nested)\n- Map key: `\"address\"` (with nested `\"email\"`),
  path: `[\"address/email\"]` → marks `email` within `address` object (nested path)\n\n**Why
  escaping is necessary**: Without escaping, there would be ambiguity between:\n-
  A literal key named `\"address/email\"` \n- The `email` key nested within an `address`
  object\n\nJSON Pointer escaping resolves this ambiguity. See [RFC 6901](https://www.rfc-editor.org/rfc/rfc6901.html)
  for the complete specification.\n\n## Supported Algorithms\n\n### Signing Algorithms\n\n-
  **PS256 (RSA-PSS)** - Default for RSA keys, recommended for security\n- **RS256
  (RSA-PKCS#1 v1.5)** - Supported for signatures (deprecated for encryption per [draft-ietf-jose-deprecate-none-rsa15](https://datatracker.ietf.org/doc/draft-ietf-jose-deprecate-none-rsa15/),
  but not for signatures)\n- **ES256 (EC P-256)** - Elliptic Curve, may be vulnerable
  to timing attacks during signing\n- **EdDSA (Ed25519)** - Recommended for high-security
  applications\n\n**Note**: RSA keys default to PS256. To use RS256, include `\"alg\":
  \"RS256\"` in your JWK.\n\n### Hash Algorithms\n\n- **SHA-256** - Default algorithm\n-
  **SHA-384**\n- **SHA-512**\n\n## Key Format\n\nKeys can be provided in two formats:\n\n1.
  **Text (JSON string)** - Most convenient, no need to import `jose`:\n   ```haskell\n
  \  let claims = Map.fromList [(\"claim\", Aeson.String \"value\")]\n   let issuerKey
  :: T.Text = \"{\\\"kty\\\":\\\"RSA\\\",\\\"n\\\":\\\"...\\\",\\\"e\\\":\\\"AQAB\\\",\\\"d\\\":\\\"...\\\"}\"\n
  \  -- createSDJWT takes: mbTyp mbKid hashAlg key claimNames claims\n   result <-
  createSDJWT Nothing Nothing SHA256 issuerKey [\"claim\"] claims\n   -- Or with typ
  header (recommended):\n   result <- createSDJWT (Just \"sd-jwt\") Nothing SHA256
  issuerKey [\"claim\"] claims\n   ```\n\n2. **jose JWK object** - If you're already
  working with the `jose` library:\n   ```haskell\n   import Crypto.JOSE.JWK as JWK\n
  \  let claims = Map.fromList [(\"claim\", Aeson.String \"value\")]\n   jwk <- loadJWK
  \ -- Your function that returns JWK.JWK\n   -- createSDJWT takes: mbTyp mbKid hashAlg
  key claimNames claims\n   result <- createSDJWT Nothing Nothing SHA256 jwk [\"claim\"]
  claims\n   -- Or with typ header (recommended):\n   result <- createSDJWT (Just
  \"sd-jwt\") Nothing SHA256 jwk [\"claim\"] claims\n   ```\n\nThe library automatically
  handles both formats through the `JWKLike` type class. Users who don't import `jose`
  can use Text strings directly, while users already working with `jose` can pass
  JWK objects without serialization overhead.\n\n**JWK JSON Format Example:**\n```json\n{\n
  \ \"kty\": \"RSA\",\n  \"n\": \"base64url-encoded-modulus\",\n  \"e\": \"AQAB\",\n
  \ \"d\": \"base64url-encoded-private-exponent\"\n}\n```\n\nFor public keys, omit
  the `d` field. See [RFC 7517](https://www.rfc-editor.org/rfc/rfc7517.html) for JWK
  format specification.\n\n## Documentation\n\n- [RFC 9901](https://www.rfc-editor.org/rfc/rfc9901.html)
  - The SD-JWT specification\n- [RFC 7517](https://www.rfc-editor.org/rfc/rfc7517.html)
  - JSON Web Key (JWK) format\n- [RFC 7519](https://www.rfc-editor.org/rfc/rfc7519.html)
  - JSON Web Token (JWT)\n- [RFC 8725](https://www.rfc-editor.org/rfc/rfc8725.html)
  - JSON Web Token Best Current Practices\n- [internal-docs/IMPLEMENTATION_PLAN.md](internal-docs/IMPLEMENTATION_PLAN.md)
  - Implementation plan\n- [internal-docs/TEST_PLAN.md](internal-docs/TEST_PLAN.md)
  - Test coverage documentation\n\n## License\n\nBSD-3-Clause\n"
description-type: markdown
hash: 0e3e3f58171265b34bea185e4a4ea24ebba99b51e4572321731e8733219703cc
homepage: https://github.com/yaronf/sd-jwt#readme
latest: 0.1.0.1
license-name: BSD-3-Clause
maintainer: yaronf.ietf@gmail.com
synopsis: Selective Disclosure for JSON Web Tokens (RFC 9901)
test-bench-deps:
  QuickCheck: '>=2.14'
  aeson: '>=2.0 && <2.3'
  base: '>=4.14 && <5'
  base64-bytestring: '>=1.2 && <1.3'
  bytestring: '>=0.11 && <0.12'
  containers: '>=0.6 && <0.7'
  cryptonite: '>=0.30 && <0.31'
  directory: '>=1.3'
  doctest: '>=0.22'
  filepath: '>=1.4'
  hspec: '>=2.10'
  jose: '>=0.10 && <0.13'
  lens: '>=4.16 && <5.4'
  markdown-unlit: '>=0.5'
  memory: '>=0.18 && <0.19'
  mtl: '>=2.2 && <3'
  process: '>=1.6'
  scientific: '>=0.3 && <0.4'
  sd-jwt: '>=0'
  text: '>=2.0 && <2.1'
  time: '>=1.9'
  vector: '>=0.13 && <0.14'

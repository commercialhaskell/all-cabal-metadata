all-versions:
- 0.2.0.0
author: Ashok Kimmel
basic-deps:
  base: '>=4.20 && <5'
  semigroupoids: '>=6 && <7'
changelog: ''
changelog-type: markdown
description: "# units-list\nA simple library oriented around providing easy and usable
  string-based units while still remaining extensible. Tries to be both simpler than
  the `units` package, and be more extensible than the `dimensional` package.\n##
  Example\n\n    worldPopulationInBillions = dimension \"billion*people\" 8.142\n
  \   worldPopulation = fmap floor $ applyPos \"billion\" (*1e9) worldPopulationInBillions\n
  \   daysInYear = dimension \"days/years\" 365\n    caloriePerDay = dimension \"calories/days/people\"
  2000    \n    caloriesPerYear = caloriePerDay !* daysInYear !* worldPopulation \n
  \   > 5943659999270000 calories / years\nSince everything has units, I chose `Symbols`
  to be the core dimensional type of this project.\n## Debug tip:\nWhen getting an
  error like `Could not match kind symbol with *` in a polymorphic function like this
  `assertSame :: Dimension n a -> Dimension n a -> Dimension n a`, Try changing the
  type signature to `assertSame :: forall k a (n :: [(k,Int')]). Dimension n a ->
  Dimension n a -> Dimension n a`. This happened once, please report any other problems/solutions
  to ashok.kimmel@gmail.com, so I can add them to this README.   \n## Implementation\nA
  dimension is difined quite simply as: \n\n    type Dimension :: forall k. [(k,Int')]
  -> Type -> Type \n    newtype Dimension a b = MkDimension b\n        deriving stock
  (Eq,Ord,Functor)\n\nThere are two invariants: The `Int'` should never be zero, and
  the `Dimension` should be ordered. This means that there is only 1 valid type that
  satisfies the invariants per dimension.\n\n`k` represents the kind used to index
  dimensions. One example is `Symbols`, another would be a `Metric` kind, another
  might be `CaseInsenstiveStrings`,etc. \n`Int'` represents the datatype used in this
  repository to represent `Integers`. \n\n    data Int' = Pos Nat | Neg Nat \n    \n`Neg
  n` represents `-(n+1)`. \nIf you really need to create a dimension, you are encouraged
  to use `ToNegInt` and `ToPosInt` from `Numeric.Dimension.TypeLevelInt`, as implementation
  may change.\n## Creation\nThere are 8 ways to create dimensions\n\n\n    dim ::
  b -> forall a ->  Dimension (ValidParse @Symbol a) b \n    dims ::Functor f => f
  b -> forall a ->  f (Dimension (ValidParse @Symbol a) b) \n    dimension :: forall
  a -> forall b. b -> Dimension (ValidParse @Symbol a)  b\n    dimensions :: forall
  a -> forall f b. Functor f => f b -> f (Dimension (ValidParse @Symbol a) b)\n    dimensionPoly
  :: forall a -> forall b.  b -> Dimension (ValidParse a) b \n    dimensionsPoly ::
  forall a -> forall f b. Functor f => f b -> f (Dimension (ValidParse a) b) \n    dimNP
  :: forall a -> forall b. b -> Dimension (Format a) b\n    dimNPs :: forall a ->
  forall f b. Functor f => f b -> f (Dimension (Format a) b)\n\n`dim`,`dims`,`dimension`
  and `dimensions` are the most common ones. They only work on symbols however, so
  if you want to use a different base, they would fail. `dim` and `dims` are like
  their longer counterparts just with the arguments flipped. `dimensions` is just
  dimension but lifted over a functor. Inspired by the ReadMe for the `Dimensional`
  \ library. The polymorphic versions suffer from type ambiguity as the kind of the
  resulting `Dimension` is unknown. It is reccomended that you add a wrapper if you
  plan to use a seperate dimension. `dimNP` is if you don't want to use the built
  in parser and want to manually specify the dimensions. \n### Note on parser\nThe
  parser is very simple: \nit checks for `*`,and `/`, splits them into sections,\nchecks
  for `^` in the subsections and creates the dimensions accordingly.\nAs a result,
  all of the following are valid\n\n    :k! Parse \"*******\" -> ['(\"\", TI.Pos 1),
  '(\"\", TI.Pos 1), '(\"\", TI.Pos 1),'(\"\", TI.Pos 1), '(\"\", TI.Pos 1), '(\"\",
  TI.Pos 1), '(\"\", TI.Pos 1),'(\"\", TI.Pos 1)]\n    :k! Parse \"*/*/***^201\" ->
  ['(\"\", TI.Pos 1), '(\"\", TI.Pos 1), '(\"\", TI.Neg 0),'(\"\", TI.Pos 1), '(\"\",
  TI.Neg 0), '(\"\", TI.Pos 1), '(\"\", TI.Pos 1),'(\"\", TI.Pos 201)]\n    :k! Parse
  \"second/(meter*kilogram)\"  -> [(\"kilogram),Pos 1),(\"(meter\",Neg 0),(\"second\",Pos
  1)] \n\n`dimension` ensures that the invariants are upheld, but still allows annoyances.
  Check the types!\nGiven the annoyance inherent to type level coding, this may not
  change.\n\n### Note on printer\nThe printer will not print the actual type as it
  is stored. e.g. \n\n    dimension \"second/meter\" 2 -> 2 second/meter\n\nDespite
  the fact that the ordering of meter is actually before second, the printer tries
  to print the positive dimensions first. A useful note for debugging type errors.\n\n##
  Multiplying,dision,etc.\n\n`!+`,`!-`,`!*`,`!/`,`divD` can be used for multiplying
  and dividing dimensions. \nThey are mostly just specialized forms of `liftD2`, which
  works on two of the same and `combineD2`, which multiplies the two types. \n`rt`,`rtn`,`!^`,`!^^`
  all allow for exponentiation and roots. They need type level arguments. `rt`,`!^^`
  work on `Int'`s, while `rt` and `!^` work on `Nat`s.  \nThe type families `!*`,`!/`,`RT`,`RTN`
  all work at the type level and can be used with the NoParse functions to avoid parsing.\n##
  Transformations along dimensions\n\n```\ntransform :: forall s t x a. TT.ToInt (LookupD0
  s x) => (a -> a, a -> a) -> Dimension x a -> Dimension (Replace s t x) a \n```\nThis
  is used to completely switch a type parameter, whether it shows up in the positive
  or negative. Common usage would be with prefixes, `kilogram`  to `gram`,etc.\n\n```\ntransformPos
  :: forall s t x a. (TL.KnownNat (TI.ToNatural (LookupD0 s x))) => (a -> a) -> Dimension
  x a -> Dimension (Replace s t x) a\n```\nLike `transform` but only needs the switch
  in the positive direction. However, it requries that the dimension only occurs a
  positive number of times. Useful when you know that your unit occurs in the positive
  place.\n\n```\napply :: forall x a. forall s -> TT.ToInt (LookupD0 s x) => (a ->
  a, a -> a) -> Dimension x a -> Dimension (Delete s x) a\n```\nLike `transform`,
  but consumes the dimension. Can be useful with things like `billion`, or `mole`.\n\n```\napplyPos
  :: forall x a. forall s -> (TL.KnownNat (TI.ToNatural (LookupD0 s x))) => (a ->
  a) -> Dimension x a -> Dimension (Delete s x) a\n```\n`apply` but only needs 1 function.
  I used this to eliminate the `billion` in the example.\n\n```\nsame :: forall s
  t x. (forall a. Dimension x a -> Dimension (Replace s t x) a)\n```\nAssert that
  two things are the same, and replace one with another. Example: `g` `gram` `grams`
  all symbolize the same thing, but some places might use different ones.\n\n```\nmkisos
  :: forall y x a. Dimension x a -> Dimension (Isos y x) a\n```\nthe same as repeated
  usage of `same`, uses a type level list.\n\n```\ninject :: (n -> n) -> forall a
  -> Dimension b n -> Dimension (a !* b) n\n```\nAllows you to add a `dimension` to
  a type, using a function. Example, adding a mole,\n\n    replace :: forall a ->
  Dimension b n -> Dimension (a !* b) n\n    replace = inject id\n\nReplace can be
  used to replace simple things, even if you don't want to do it multiple times.\nExample:
  `replace (Parse \"billion/thousand^3\")`\n\n## Extracting dimensions\n`undimension`,
  \ requires all tags be eliminated already.\n\n`getDimension` allow you to specify
  the dimension, and `getDimensionNP` allows you to manually parse things.\n## Extending:\nTo
  extend this to a non-symbol base kind, define a `ToDimension`(for parsing), `FromDimension`
  (for printing), and `Compare` (for preserving invariants). Then you should probably
  define your own `dim`,`dims`,etc. functions and importing that module. The functionality
  should remain the same. \nYou can also use the `MatchAll` class and the `match`
  function to define custom transformations along `Symbols`. Example: Get rid of all
  `kilo` prefixes in a dimension. \n"
description-type: markdown
hash: 8cb00b8293f55c2e53115ebf1d4fe1bdd04acfd9a6045d3a03f99708c575123d
homepage: ''
latest: 0.2.0.0
license-name: BSD-3-Clause
maintainer: ashok.kimmel@gmail.com
synopsis: Extensible typed Dimensions
test-bench-deps:
  base: ^>=4.21
  units-list: '>=0'

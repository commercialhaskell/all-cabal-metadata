all-versions:
- '0.1'
author: Ashok Kimmel
basic-deps:
  base: ^>=4.21
changelog: ''
changelog-type: markdown
description: "# units-list\r\nA simple library oriented around providing easy and
  usable string-based units while still remaining extensible. Tries to be both simpler
  than the `units` package, and be more extensible than the `dimensional` package.\r\n##
  Example\r\n\r\n    worldPopulationInBillions = dimension \"billion*people\" 8.142\r\n
  \   worldPopulation = fmap floor $ applyPos \"billion\" (*1e9) worldPopulationInBillions\r\n
  \   daysInYear = dimension \"days/years\" 365\r\n    caloriePerDay = dimension \"calories/days/people\"
  2000    \r\n    caloriesPerYear = caloriePerDay !* daysInYear !* worldPopulation
  \r\n    > 5943659999270000 calories / years\r\nSince everything has units, I chose
  `Symbols` to be the core dimensional type of this project.\r\n## Debug tip:\r\nWhen
  getting an error like `Could not match kind symbol with *` in a polymorphic function
  like this `assertSame :: Dimension n a -> Dimension n a -> Dimension n a`, Try changing
  the type signature to `assertSame :: forall k a (n :: [(k,Int')]). Dimension n a
  -> Dimension n a -> Dimension n a`. This happened once, please report any other
  problems/solutions to ashok.kimmel@gmail.com, so I can add them to this README.
  \  \r\n## Implementation\r\nA dimension is difined quite simply as: \r\n\r\n    type
  Dimension :: forall k. [(k,Int')] -> Type -> Type \r\n    newtype Dimension a b
  = MkDimension b\r\n        deriving stock (Eq,Ord,Functor)\r\n\r\nThere are two
  invariants: The `Int'` should never be zero, and the `Dimension` should be ordered.
  This means that there is only 1 valid type that satisfies the invariants per dimension.\r\n\r\n`k`
  represents the kind used to index dimensions. One example is `Symbols`, another
  would be a `Metric` kind, another might be `CaseInsenstiveStrings`,etc. \r\n`Int'`
  represents the datatype used in this repository to represent `Integers`. \r\n\r\n
  \   data Int' = Pos Nat | Neg Nat \r\n    \r\n`Neg n` represents `-(n+1)`. \r\nIf
  you really need to create a dimension, you are encouraged to use `ToNegInt` and
  `ToPosInt` from `Dimensions.TypeLevelInt`, as implementation may change.\r\n## Creation\r\nThere
  are 8 ways to create dimensions\r\n\r\n\r\n    dim :: b -> forall a ->  Dimension
  (ValidParse @Symbol a) b \r\n    dims ::Functor f => f b -> forall a ->  f (Dimension
  (ValidParse @Symbol a) b) \r\n    dimension :: forall a -> forall b. b -> Dimension
  (ValidParse @Symbol a)  b\r\n    dimensions :: forall a -> forall f b. Functor f
  => f b -> f (Dimension (ValidParse @Symbol a) b)\r\n    dimensionPoly :: forall
  a -> forall b.  b -> Dimension (ValidParse a) b \r\n    dimensionsPoly :: forall
  a -> forall f b. Functor f => f b -> f (Dimension (ValidParse a) b) \r\n    dimNP
  :: forall a -> forall b. b -> Dimension (Format a) b\r\n    dimNPs :: forall a ->
  forall f b. Functor f => f b -> f (Dimension (Format a) b)\r\n\r\n`dim`,`dims`,`dimension`
  and `dimensions` are the most common ones. They only work on symbols however, so
  if you want to use a different base, they would fail. `dim` and `dims` are like
  their longer counterparts just with the arguments flipped. `dimensions` is just
  dimension but lifted over a functor. Inspired by the ReadMe for the `Dimensional`
  \ library. The polymorphic versions suffer from type ambiguity as the kind of the
  resulting `Dimension` is unknown. It is reccomended that you add a wrapper if you
  plan to use a seperate dimension. `dimNP` is if you don't want to use the built
  in parser and want to manually specify the dimensions. \r\n### Note on parser\r\nThe
  parser is very simple: \r\nit checks for `*`,and `/`, splits them into sections,\r\nchecks
  for `^` in the subsections and creates the dimensions accordingly.\r\nAs a result,
  all of the following are valid\r\n\r\n    :k! Parse \"*******\" -> ['(\"\", TI.Pos
  1), '(\"\", TI.Pos 1), '(\"\", TI.Pos 1),'(\"\", TI.Pos 1), '(\"\", TI.Pos 1), '(\"\",
  TI.Pos 1), '(\"\", TI.Pos 1),'(\"\", TI.Pos 1)]\r\n    :k! Parse \"*/*/***^201\"
  -> ['(\"\", TI.Pos 1), '(\"\", TI.Pos 1), '(\"\", TI.Neg 0),'(\"\", TI.Pos 1), '(\"\",
  TI.Neg 0), '(\"\", TI.Pos 1), '(\"\", TI.Pos 1),'(\"\", TI.Pos 201)]\r\n    :k!
  Parse \"second/(meter*kilogram)\"  -> [(\"kilogram),Pos 1),(\"(meter\",Neg 0),(\"second\",Pos
  1)] \r\n\r\n`dimension` ensures that the invariants are upheld, but still allows
  annoyances. Check the types!\r\nGiven the annoyance inherent to type level coding,
  this may not change.\r\n\r\n### Note on printer\r\nThe printer will not print the
  actual type as it is stored. e.g. \r\n\r\n    dimension \"second/meter\" 2 -> 2
  second/meter\r\n\r\nDespite the fact that the ordering of meter is actually before
  second, the printer tries to print the positive dimensions first. A useful note
  for debugging type errors.\r\n\r\n## Multiplying,dision,etc.\r\n\r\n`!+`,`!-`,`!*`,`!/`,`divD`
  can be used for multiplying and dividing dimensions. \r\nThey are mostly just specialized
  forms of `liftD2`, which works on two of the same and `combineD2`, which multiplies
  the two types. \r\n`rt`,`rtn`,`!^`,`!^^` all allow for exponentiation and roots.
  They need type level arguments. `rt`,`!^^` work on `Int'`s, while `rt` and `!^`
  work on `Nat`s.  \r\nThe type families `!*`,`!/`,`RT`,`RTN` all work at the type
  level and can be used with the NoParse functions to avoid parsing.\r\n## Transformations
  along dimensions\r\n\r\n```\r\ntransform :: forall s t x a. TT.ToInt (LookupD0 s
  x) => (a -> a, a -> a) -> Dimension x a -> Dimension (Replace s t x) a \r\n```\r\nThis
  is used to completely switch a type parameter, whether it shows up in the positive
  or negative. Common usage would be with prefixes, `kilogram`  to `gram`,etc.\r\n\r\n```\r\ntransformPos
  :: forall s t x a. (TL.KnownNat (TI.ToNatural (LookupD0 s x))) => (a -> a) -> Dimension
  x a -> Dimension (Replace s t x) a\r\n```\r\nLike `transform` but only needs the
  switch in the positive direction. However, it requries that the dimension only occurs
  a positive number of times. Useful when you know that your unit occurs in the positive
  place.\r\n\r\n```\r\napply :: forall x a. forall s -> TT.ToInt (LookupD0 s x) =>
  (a -> a, a -> a) -> Dimension x a -> Dimension (Delete s x) a\r\n```\r\nLike `transform`,
  but consumes the dimension. Can be useful with things like `billion`, or `mole`.\r\n\r\n```\r\napplyPos
  :: forall x a. forall s -> (TL.KnownNat (TI.ToNatural (LookupD0 s x))) => (a ->
  a) -> Dimension x a -> Dimension (Delete s x) a\r\n```\r\n`apply` but only needs
  1 function. I used this to eliminate the `billion` in the example.\r\n\r\n```\r\nsame
  :: forall s t x. (forall a. Dimension x a -> Dimension (Replace s t x) a)\r\n```\r\nAssert
  that two things are the same, and replace one with another. Example: `g` `gram`
  `grams` all symbolize the same thing, but some places might use different ones.\r\n\r\n```\r\nmkisos
  :: forall y x a. Dimension x a -> Dimension (Isos y x) a\r\n```\r\nthe same as repeated
  usage of `same`, uses a type level list.\r\n\r\n```\r\ninject :: (n -> n) -> forall
  a -> Dimension b n -> Dimension (a !* b) n\r\n```\r\nAllows you to add a `dimension`
  to a type, using a function. Example, adding a mole,\r\n\r\n    replace :: forall
  a -> Dimension b n -> Dimension (a !* b) n\r\n    replace = inject id\r\n\r\nReplace
  can be used to replace simple things, even if you don't want to do it multiple times.\r\nExample:
  `replace (Parse \"billion/thousand^3\")`\r\n\r\n## Extracting dimensions\r\n`undimension`,
  \ requires all tags be eliminated already.\r\n\r\n`getDimension` allow you to specify
  the dimension, and `getDimensionNP` allows you to manually parse things.\r\n## Extending:\r\nTo
  extend this to a non-symbol base kind, define a `ToDimension`(for parsing), `FromDimension`
  (for printing), and `Compare` (for preserving invariants). Then you should probably
  define your own `dim`,`dims`,etc. functions and importing that module. The functionality
  should remain the same. \r\nYou can also use the `MatchAll` class and the `match`
  function to define custom transformations along `Symbols`. Example: Get rid of all
  `kilo` prefixes in a dimension. \r\n"
description-type: markdown
hash: 644e6dd1d3d9f9f6c54e641153a5fb01525690ac1b0be3cf4d223d58c232a280
homepage: ''
latest: '0.1'
license-name: BSD-3-Clause
maintainer: ashok.kimmel@gmail.com
synopsis: Extensible typed Dimensions
test-bench-deps:
  base: ^>=4.21
  units-list: '>=0'

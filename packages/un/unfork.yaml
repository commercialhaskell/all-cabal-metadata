homepage: https://github.com/typeclasses/unfork
changelog-type: ''
hash: 7e8c2cd54e89956da09321ea50070c052fc7b75949d8ff1e5275e6cfb2f794ef
test-bench-deps: {}
maintainer: Chris Martin, Julie Moronuki
synopsis: Make any action thread safe
changelog: ''
basic-deps:
  stm: ^>=2.5
  base: ^>=4.14 || ^>=4.15 || ^>=4.16
  safe-exceptions: ^>=0.1.7
  async: ^>=2.2.2
all-versions:
- 1.0.0.0
author: Chris Martin
latest: 1.0.0.0
description-type: haddock
description: |-
  “Unfork” is the opposite of “fork”; whereas forking allows things to run concurrently, unforking prevents things from running concurrently. Use one of the functions in the "Unfork" module when you have an action that will be used by concurrent threads but needs to run serially.

  A typical use case is a multi-threaded program that writes log messages. If threads use @putStrLn@ directly, the strings may be interleaved in the combined output. Instead, create an unforked version of @putStrLn@:

  > import Unfork
  >
  > main :: IO ()
  > main =
  >     unforkAsyncIO_ putStrLn \putStrLn' ->
  >         _ -- Within this continuation, use
  >           -- putStrLn' instead of putStrLn

  The new @putStrLn'@ function writes to a queue. A separate thread reads from the queue and performs the actions, thus ensuring that the actions are all performed in one linear sequence. The main thread returns after the continuation has returned and the queue is empty. If an exception is raised in either thread, both threads halt and the exception is re-raised in the main thread.
license-name: Apache-2.0

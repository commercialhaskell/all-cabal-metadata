homepage: https://github.com/ejconlon/unfree#readme
changelog-type: ''
hash: c8cd0181a0a6386e00671963be318e5fbfdbb114c2aeece9552bef88d1af0b76
test-bench-deps:
  base: '>=4.12 && <5'
  unfree: -any
  hashable: '>=1.3 && <1.5'
  tasty-hunit: -any
  tasty: -any
  deepseq: ==1.4.*
  recursion-schemes: ==5.2.*
maintainer: ejconlon@gmail.com
synopsis: Simplistic free monad with deriving through UndecidableInstances
changelog: ''
basic-deps:
  base: '>=4.12 && <5'
  hashable: '>=1.3 && <1.5'
  deepseq: ==1.4.*
  recursion-schemes: ==5.2.*
all-versions:
- 0.1.0
author: Eric Conlon
latest: 0.1.0
description-type: markdown
description: |
  # unfree

  [![CircleCI](https://circleci.com/gh/ejconlon/unfree/tree/master.svg?style=svg)](https://circleci.com/gh/ejconlon/unfree/tree/master)

  Simplistic free monad with deriving through `UndecidableInstances`

  Why does this exist when `free` is ubiquitous? Sometimes you just want to easily derive `Eq` without having to define `Eq1` for your functor, or maybe you just want a `Hashable` instance. (Maybe someday the situation will improve with quantified constrant superclasses.)
license-name: BSD-3-Clause

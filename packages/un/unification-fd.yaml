homepage: https://wrengr.org/software/hackage.html
changelog-type: text
hash: 36667422f548a95294efe108b70e400d0e90ba3772209ff8bc40d19f31ef1afe
test-bench-deps: {}
maintainer: winterkoninkje@gmail.com
synopsis: Simple generic unification algorithms.
changelog: |
  0.11.0 (2021-02-23):
      - Made Unifiable derivable whenever we have a Generic1 instance.
        (h/t/ Roman Cheplyaka)
      - Removed the Alternative/MonadPlus instances for UTerm, because
        they're unlawful.
      - Added NOINLINE for Fix's Eq and Ord instances, to avoid an
        inliner bug affecting GHC 8.0.1 and 8.0.2 (fixed in 8.0.3)
        <https://ghc.haskell.org/trac/ghc/ticket/13081>
      - HOTFIX: added logict < 0.7.1 upper bound to avoid breakage.
        Will add a proper fix in the future. For more details see,
        <https://github.com/Bodigrim/logict/issues/20#issuecomment-774528439>
  0.10.0.1 (2015-05-30):
      - Moved VERSION to CHANGELOG
  0.10.0 (2015-03-29):
      - Cleaned up things to compile cleanly for GHC 7.10
      - Cleaned up deprecation warnings re Control.Monad.Error
      - Control.Monad.EitherK: liberalized Monad restriction to
        Applicative where possible.
      - Control.Monad.MaybeK: liberalized Monad restriction to
        Applicative where possible.
      - Control.Unification.Types: Completely revamped the old
        UnificationFailure data type as the new UFailure data type
        and Fallible type class.
  0.9.0 (2014-06-03):
      - Control.Unification.Types: changed the fundeps on BindingMonad
        and RankedBindingMonad so that things compile under GHC 7.8.2
      - Data.Functor.Fixedpoint: eta-expanded RULES to avoid GHC >=
        7.8 warnings about them potentially not firing due to (.)
        being inlined first.
  0.8.1 (2014-05-27):
      - Control.Unification.Types: added Functor, Foldable, and
        Traversable instances for UnificationFailure. (h/t Graham Rogers)
  0.8.0 (2012-07-11):
      - Control.Unification.Types: Changed the type of Unifiable.zipMatch
  0.7.0 (2012-03-19):
      - Renamed MutTerm to UTerm (and MutVar to UVar)
      - Replaced the Variable.eqVar method by plain old Eq.(==)
      - Control.Unification: added getFreeVarsAll, applyBindingsAll,
        freshenAll
      - Swapped type argument order for MutTerm, so that it can be a
        functor etc. Also changed BindingMonad, UnificationFailure,
        Rank, and RankedBindingMonad for consistency.
  0.6.0 (2012-02-17):
      - Removed the phantom type argument for Variables.
  0.5.0 (2011-07-12):
      - Moved UnificationFailure to Control.Unification.Types
      - Renamed NonUnifiable to TermMismatch
      - Control.Unification: exposed fullprune, semiprune, occursIn
      - Control.Unification: added unifyOccurs, subsumes
      - Control.Unification: (re)added symbolic names for binary operators
  0.4.0 (2011-07-07):
      - Removed heterogeneous unification, and rewrote practically everything.
      - Added semipruning instead of full pruning.
      - Added visited-sets instead of occurs-checks.
      - Added weightedness to path compression (a la union--find).
      - This is the version emailed for the 2011-07-07 talk at McMaster.
  0.3.6 (2011-06-18):
      - Forked from the Dyna2 project.
basic-deps:
  logict: '>=0.4 && <0.7.1'
  base: ==4.*
  containers: -any
  mtl: '>=2.0'
all-versions:
- 0.5.0
- 0.6.0
- 0.7.0
- 0.8.0
- 0.8.1
- 0.9.0
- 0.10.0
- 0.10.0.1
- 0.11.0
author: wren gayle romano
latest: 0.11.0
description-type: markdown
description: "unification-fd\n==============\n[![Hackage version](https://img.shields.io/hackage/v/unification-fd.svg?style=flat)](https://hackage.haskell.org/package/unification-fd)
  \n[![Hackage-Deps](https://img.shields.io/hackage-deps/v/unification-fd.svg?style=flat)](http://packdeps.haskellers.com/specific?package=unification-fd)\n[![TravisCI
  Build Status](https://img.shields.io/travis/wrengr/unification-fd.svg?style=flat)](https://travis-ci.org/wrengr/unification-fd)
  \n[![CircleCI Build Status](https://circleci.com/gh/wrengr/unification-fd.svg?style=shield&circle-token=b57517657c556be6fd8fca92b843f9e4cffaf8d1)](https://circleci.com/gh/wrengr/unification-fd)\n\nThe
  unification-fd package offers generic functions for single-sorted\nfirst-order structural
  unification (think of programming in Prolog,\nor of the metavariables in type inference)[^1][^2].
  The library\n*is* sufficient for implementing higher-rank type systems à la\nPeyton
  Jones, Vytiniotis, Weirich, Shields, but bear in mind that\nunification variables
  are the metavariables of type inference— not\nthe type-variables.\n\n\n## Install\n\nThis
  is a simple package and should be easy to install. You should\nbe able to use one
  of the following standard methods to install it.\n\n    -- With cabal-install and
  without the source:\n    $> cabal install unification-fd\n    \n    -- With cabal-install
  and with the source already:\n    $> cd unification-fd\n    $> cabal install\n    \n
  \   -- Without cabal-install, but with the source already:\n    $> cd unification-fd\n
  \   $> runhaskell Setup.hs configure --user\n    $> runhaskell Setup.hs build\n
  \   $> runhaskell Setup.hs test\n    $> runhaskell Setup.hs haddock --hyperlink-source\n
  \   $> runhaskell Setup.hs copy\n    $> runhaskell Setup.hs register\n\nThe test
  step is optional and currently does nothing. The Haddock\nstep is also optional.
  If you see some stray lines that look like\nthis:\n\n    mkUsageInfo: internal name?
  t{tv a7XM}\n\nFeel free to ignore them. They shouldn't cause any problems, even\nthough
  they're unsightly. This should be fixed in newer versions\nof GHC. For more details,
  see:\n\n    http://hackage.haskell.org/trac/ghc/ticket/3955\n\nIf you get a bunch
  of type errors about there being no `MonadLogic`\ninstance for `StateT`, this means
  that your copy of the logict\nlibrary is not compiled against the same mtl that
  we're using. To\nfix this, update logict to use the same mtl.\n\n\n## Portability\n\nAn
  effort has been made to make the package as portable as possible.\nHowever, because
  it uses the `ST` monad and the mtl-2 package it\ncan't be H98 nor H2010. However,
  it only uses the following common\nextensions which should be well supported[^3]:\n\n*
  Rank2Types\n* MultiParamTypeClasses\n* FunctionalDependencies - Alas, necessary
  for type inference\n* FlexibleContexts - Necessary for practical use of MPTCs\n*
  FlexibleInstances - Necessary for practical use of MPTCs\n* UndecidableInstances
  - Needed for Show instances due to two-level types\n\n\n## Description\n\nThe unification
  API is generic in the type of the structures being\nunified and in the implementation
  of unification variables, following\nthe two-level types pearl of Sheard (2001).
  This style mixes well\nwith Swierstra (2008), though an implementation of the latter
  is\nnot included in this package.\n\nThat is, all you have to do is define the functor
  whose fixed-point\nis the recursive type you're interested in:\n\n    -- The non-recursive
  structure of terms\n    data S a = ...\n\n    -- The recursive term type\n    type
  PureTerm = Fix S\n\nAnd then provide an instance for `Unifiable`, where `zipMatch`\nperforms
  one level of equality testing for terms and returns the\none-level spine filled
  with pairs of subterms to be recursively\nchecked (or `Nothing` if this level doesn't
  match).\n\n    class (Traversable t) => Unifiable t where\n        zipMatch :: t
  a -> t b -> Maybe (t (a,b))\n\nThe choice of which variable implementation to use
  is defined by\nsimilarly simple classes `Variable` and `BindingMonad`. We store\nthe
  variable bindings in a monad, for obvious reasons. In case it's\nnot obvious, see
  Dijkstra et al. (2008) for benchmarks demonstrating\nthe cost of naively applying
  bindings eagerly.\n\nThere are currently two implementations of variables provided:
  one\nbased on `STRef`s, and another based on a state monad carrying an\n`IntMap`.
  The former has the benefit of O(1) access time, but the\nlatter is plenty fast and
  has the benefit of supporting backtracking.\nBacktracking itself is provided by
  the logict package and is described\nin Kiselyov et al. (2005).\n\nIn addition to
  this modularity, unification-fd implements a number\nof optimizations over the algorithm
  presented in Sheard (2001)—\nwhich is also the algorithm presented in Cardelli (1987).\n\n*
  Their implementation uses path compression, which we retain.\n    Though we modify
  the compression algorithm in order to make\n    sharing observable.\n* In addition,
  we perform aggressive opportunistic observable\n    sharing, a potentially novel
  method of introducing even more\n    sharing than is provided by the monadic bindings.
  Basically,\n    we make it so that we can use the observable sharing provided\n
  \   by the modified path compression as much as possible (without\n    introducing
  any new variables).\n* And we remove the notoriously expensive occurs-check, replacing\n
  \   it with visited-sets (which detect cyclic terms more lazily and\n    without
  the asymptotic overhead of the occurs-check). A variant\n    of unification which
  retains the occurs-check is also provided,\n    in case you really need to fail
  fast.\n* Finally, a highly experimental branch of the API performs *weighted*\n
  \   path compression, which is asymptotically optimal. Unfortunately,\n    the current
  implementation is quite a bit uglier than the\n    unweighted version, and I haven't
  had a chance to perform\n    benchmarks to see how the constant factors compare.
  Hence moving\n    it to an experimental branch.\n\nThese optimizations pass a test
  suite for detecting obvious errors.\nIf you find any bugs, do be sure to let me
  know. Also, if you happen\nto have a test suite or benchmark suite for unification
  on hand,\nI'd love to get a copy.\n\n\n## Notes and limitations\n\n[^1]: At present
  the library does not appear amenable for implementing\nhigher-rank unification itself;
  i.e., for higher-ranked metavariables,\nor higher-ranked logic programming. To be
  fully general we'd have\nto abstract over which structural positions are co/contravariant,\nwhether
  the unification variables should be predicative or\nimpredicative, as well as the
  isomorphisms of moving quantifiers\naround. It's on my todo list, but it's certainly
  non-trivial. If\nyou have any suggestions, feel free to contact me.\n\n[^2]: At
  present it is only suitable for single-sorted (aka untyped)\nunification, à la Prolog.
  In the future I aim to support multi-sorted\n(aka typed) unification, however doing
  so is complicated by the\nfact that it can lead to the loss of MGUs; so it will
  likely be\noffered as an alternative to the single-sorted variant, similar to\nhow
  the weighted path-compression is currently offered as an\nalternative.\n\n[^3]:
  With the exception of fundeps which are notoriously difficult\nto implement. However,
  they are supported by Hugs and GHC 6.6, so\nI don't feel bad about requiring them.
  Once the API stabilizes a\nbit more I plan to release a unification-tf package which
  uses type\nfamilies instead, for those who feel type families are easier to\nimplement
  or use. There have been a couple requests for unification-tf,\nso I've bumped it
  up on my todo list.\n\n\n## References\n\n<dl>\n<dt\n    >Luca Cardelli (1987)</dt>\n<dd><i>Basic
  polymorphic typechecking</i>.\n    Science of Computer Programming, 8(2): 147–172.</dd>\n<dt\n
  \   ><a href=\"http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-027.pdf\"\n
  \   >Atze Dijkstra, Arie Middelkoop, S. Doaitse Swierstra (2008)</a></dt>\n<dd><i>Efficient
  Functional Unification and Substitution</i>.\n    Technical Report UU-CS-2008-027,
  Utrecht University.</dd>\n<dt\n    ><a href=\"http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf\"\n
  \   >Simon Peyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, Mark\n    Shields
  (2007)</a></dt>\n<dd><i>Practical type inference for arbitrary-rank types</i>.\n
  \   JFP 17(1). The online version has some minor corrections/clarifications.</dd>\n<dt\n
  \   ><a href=\"http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf\"\n
  \   >Oleg Kiselyov, Chung-chieh Shan, Daniel P. Friedman, and Amr Sabry (2005)</a></dt>\n<dd><i>Backtracking,
  Interleaving, and Terminating Monad Transformers</i>.\n    ICFP.</dd>\n<dt\n    ><a
  href=\"http://web.cecs.pdx.edu/~sheard/papers/generic.ps\"\n    >Tim Sheard (2001)</a></dt>\n<dd><i>Generic
  Unification via Two-Level Types and Parameterized Modules</i>,\n    Functional Pearl.
  ICFP.</dd>\n<dt\n    ><a href=\"http://web.cecs.pdx.edu/~sheard/papers/JfpPearl.ps\"\n
  \   >Tim Sheard and Emir Pasalic (2004)</a></dt>\n<dd><i>Two-Level Types and Parameterized
  Modules</i>.\n    JFP 14(5): 547–587.\n    This is an expanded version of Sheard
  (2001) with new examples.</dd>\n<dt\n    ><a href=\"http://www.cs.ru.nl/~wouters/Publications/DataTypesALaCarte.pdf\"\n
  \   >Wouter Swierstra (2008)</a></dt>\n<dd><i>Data types à la carte</i>,\n    Functional
  Pearl. JFP 18: 423–436.</dd>\n</dl>\n\n\n## Links\n\n* [Website](http://cl.indiana.edu/~wren/)\n*
  [Blog](http://winterkoninkje.dreamwidth.org/)\n* [Twitter](https://twitter.com/wrengr)\n*
  [Hackage](http://hackage.haskell.org/package/unification-fd)\n* [GitHub](https://github.com/wrengr/unification-fd)\n"
license-name: BSD-3-Clause

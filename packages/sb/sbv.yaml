all-versions:
- '10.11'
author: Levent Erkok
basic-deps:
  QuickCheck: '>=0'
  array: '>=0'
  async: '>=0'
  base: '>=4.16 && <5'
  containers: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  filepath: '>=0'
  libBF: '>=0.6.8'
  mtl: '>=0'
  pretty: '>=0'
  process: '>=0'
  random: '>=0'
  syb: '>=0'
  template-haskell: '>=0'
  text: '>=0'
  time: '>=0'
  transformers: '>=0'
  uniplate: '>=0'
changelog: "* Hackage: <http://hackage.haskell.org/package/sbv>\n* GitHub:  <http://github.com/LeventErkok/sbv>\n\n###
  Version 10.11, 2024-07-26\n\n  * Add Documentation.SBV.Examples.Puzzles.Tower module,
  solving the visible towers puzzle.\n\n  * Fix several representation bugs related
  to arbitrary-precision floats. Thanks to Sirui\n    Lu for the reports and patches.\n\n
  \ * Removed the generic Num a => Num (SBV a) instance. When used at a non-standard
  type, this\n    created type-checking but invalid SBV programs. See https://github.com/LeventErkok/sbv/issues/706\n
  \   for details.\n\n  * Add functions optLexicographic, optLexicographicWith, optPareto,
  optParetoWith, optIndependent, optIndependentWith\n    which makes using optimization
  functions easier. These are simple wrappers over the existing optimization routines,\n
  \   simplifying their interface.\n\n  * Change how optimization results are presented
  when the underlying metric space is different from the type\n    being optimized.
  As noted in https://github.com/LeventErkok/sbv/issues/716, the format SBV used was
  confusing.\n    We now be more explicit, and print the original value in its own
  right, along with the metric-space value.\n    Thanks to Andrew Anderson for reporting.\n\n###
  Version 10.10, 2024-05-11\n\n  * Add EqSymbolic, OrdSymbolic and Mergeable instances
  for NonEmpty type\n\n  * Better handling of spawned processes, avoiding zombies.
  Thanks to Sirui Lu for the patch.\n\n### Version 10.9, 2024-04-05\n\n  * Fix printing
  of floats to be more consistent, using lowercase letters\n\n### Version 10.8, 2024-04-05\n\n
  \ * Increase the number of digits used in printing floats in decimal base, which
  leads to\n    better output in most cases.\n\n### Version 10.7, 2024-03-23\n\n  *
  Fix SMTDefinable instances for functions of arity 8-12. Thanks to Nick Lewchenko
  for the patch.\n    \n### Version 10.6, 2024-03-16\n\n  * Added Data.SBV.Tools.BVOptimize
  module, which implements a custom optimizer for unsigned bit-vector\n    values.
  See 'minBV' and 'maxBV' methods. These algorithms use the incremental solver instead
  of\n    the optimizer engines, and they can be more performant in certain cases.
  (For instance, z3's\n    optimization engine isn't incremental, which makes it perform
  poorly on certain BV-optimization\n    problems.) These algorithms scan the bits
  from most to least significant bit, and individually\n    set/unset them in an incremental
  fashion to optimize quickly.\n\n  * SBV web-page is no longer maintained. The info
  is put into the README.md instead.\n\n### Version 10.5, 2024-02-20\n\n  * Export
  svFloatingPointAsSWord through Data.SBV.Internals\n\n  * crackNum: if verbose, alert
  the user if surface value of a NaN doesn't match its calculated value\n    due to
  the redundancy in NaN representations.\n\n### Version 10.4, 2024-02-15\n\n  * Before
  issuing a get-value, make sure there are no outstanding assert calls.\n    See:
  https://github.com/LeventErkok/sbv/issues/682 for details.\n\n  * crackNum mode
  now displays the surface form of NaNs more faithfully, if provided\n    with the
  input string. This functionality is used by the crackNum executable.\n\n### Version
  10.3, 2024-01-05\n\n  * Clean-up GHC extensions required in the cabal file, and
  changes required to compile cleanly with GHC 9.8 series.\n\n  * Added 'partition',
  which allows for partitioning all-sat search spaces when models are generated.\n\n
  \ * Added 'sSetBitTo', variant of 'setBitTo', but allows symbolic indexes.\n\n  *
  Added 'uninterpretWithArgs', which allows for user given argument names for uninterpreted
  functions. These\n    names come in handy when displaying models of uninterpreted
  functions.\n\n  * Added `Documentation.SBV.Examples.Misc.ProgramPaths`, showing
  an example use of all-sat partitioning.\n\n  * Added `Documentation.SBV.Examples.BitPrecise.PEXT_PDEP`,
  modeling x86 instructions PDEP and PEXT.\n\n  * Added `Documentation.SBV.Examples.Puzzles.Newspaper`,
  another puzzle example.\n\n  * Added `Documentation.SBV.Examples.ProofTools.AddHorn`,
  demonstrating the use of the horn-clause solver for\n    invariant generation.\n\n
  \ * Add 'sbv2smt', which renders the given sbv definition as an SMTLib definition.
  Mainly useful for debugging purposes.\n    It can render both ground definitions
  and functions, and the latter can be handy in producing SMTLib functions to\n    be
  used in other settings.\n\n  * Add support for OpenSMT from UniversitÃ  della Svizzera
  italiana https://verify.inf.usi.ch/opensmt\n\n  * Fix a bug in bit-vector rotation
  that manifested itself in small-bv sizes. Thanks to Sirui Lu for reporting.\n\n
  \ * [BACKWARDS COMPATIBILITY] Change the overflow detection API to match the new
  SMTLib predicates. These predicates\n    do not distinguish between over/underflow,
  so strictly speaking the new API is less powerful than the old one. However,\n    we
  choose to follow SMTLib here for portability purposes. If you need separate overflow/underflow
  checking you can\n    use the encodings from earlier implementations, please get
  in touch if this proves problematic.\n\n  * [BACKWARDS COMPATIBILITY] Dropped hasSize,
  which checked cardinality of sets. This call hasn't been supported by\n    z3 for
  some time, and its uses were thus limited, and behavior was problematic even when
  supported due to finiteness\n    issues.\n\n  * Removed a few examples, which were
  causing regression failures with changes in z3. These are trickier examples, and\n
  \   new releases of z3 had varying performance issues, making them not suitable
  regression and documentation purposes. In\n    particular, 'Documentation.SBV.Examples.Existentials.CRCPolynomial',
  'Documentation.SBV.Examples.Lists.Nested', and\n    'Documentation.SBV.Examples.BitPrecise.MultMask'
  were removed.\n\n  * SBV now keeps track of contexts, thus avoiding rare (but unsound)
  cases of incorrect API usage where contexts\n    are mixed. We now issue a run-time
  error. See https://github.com/LeventErkok/sbv/issues/71 for details.\n\n  * Improve
  the getFunction signature, to return more detailed info on the produced SMT functions,
  including the parse-tree.\n\n  * SBV now tracks whether a declared uninterpreted
  function is curried or not. This helps in more precise printing of\n    satisfying
  models with uninterpreted functions. (Previously all UI functions were displayed
  as if they were curried.)\n\n### Version 10.2, 2023-06-09\n\n  * Improve HLint pragmas.
  Thanks to George Thomas for the patch.\n\n  * Added an implementation of the Prince
  encryption algorithm. See Documentation/SBV/Examples/Crypto/Prince.hs.\n\n  * Added
  on-the-fly decryption mode for AES. See Documentation/SBV/Examples/Crypto/AES.hs
  for details.\n\n  * Added functions `sEDivMod`, `sEDiv`, and `sEMod` which perform
  euclidian division over symbolic integers.\n\n  * Added 'Data.SBV.Tools.NaturalInduction'
  which provides a proof method to perform induction over natural numbers. See the
  functions 'inductNat' and 'inductNatWith'.\n\n### Version 10.1, 2023-04-14\n\n  *
  [BACKWARDS COMPATIBILITY] SBV now handles quantifiers in a much more disciplined
  way. All of the previous\n    ways of creating quantified variables (i.e., the functions
  sbvForall, sbvExists, universal, existential) are\n    removed. Instead, we can
  now express quantifiers in a much straightforward way, by passing them to\n    'constrain'
  directly. A simple example is:\n\n        constrain $ \\(Forall x) (Exists y) ->
  y .> (x :: SInteger)\n\n    You can nest quantifiers as you wish, and the quantified
  parameters can be of arbitrary symbolic type.\n    Additionally, you can convert
  such a quantified formula to a regular boolean, via a call to 'quantifiedBool'\n
  \   function, essentially performing quantifier elimination:\n\n        other_condition
  .&& quantifiedBool (\\(Forall x) (Exists y) -> y .> (x :: SInteger))\n\n    Or you
  can prove/sat quantified formulas directly:\n\n        prove $ \\(Forall x) (Exists
  y) -> y .> (x :: SInteger)\n\n    This facility makes quantifiers part of the regular
  SBV language, allowing them to be mixed/matched with all\n    your other symbolic
  computations.\n\n    SBV also supports the constructors ExistsUnique to create unique
  existentials, in addition to\n    ForallN and ExistsN for creating multiple variables
  at the same time.\n\n    The new function skolemize can be used to skolemize quantified
  formulas: The skolemized version of a\n    formula has no existential (replaced
  by uninterpeted functions), and is equisatisfiable to the original.\n\n    See the
  following files demonstrating reasoning with quantifiers:\n    \n       * Documentation/SBV/Examples/Puzzles/Birthday.hs\n
  \      * Documentation/SBV/Examples/Puzzles/KnightsAndKnaves.hs\n       * Documentation/SBV/Examples/Puzzles/Rabbits.hs\n
  \      * Documentation/SBV/Examples/Misc/FirstOrderLogic.hs\n\n  * You can now define
  new functions in the generated SMTLib output, via an smtFunction call. Typically,
  we simply\n    unroll all definitions, but there are certain cases where we would
  like the functions\n    remain intact in the output. This is especially true of
  recursive functions, where the termination would\n    depend on a symbolic variable,
  which cannot be symbolically-simulated. By translating these to SMTLib\n    functions,
  we can now handle such definitions. Note that such definitions will no longer be
  constant-folded\n    on the Haskell side, and each call will induce a call in the
  solver instead. The new method smtFunction\n    can handle both recursive and non-recursive
  functions. See \"Documentation/SBV/Examples/Misc/Definitions.hs\"\n    for examples.\n\n
  \ * Added new SList functions: map, mapi, foldl, foldr, foldli, foldri, zip, zipWith,
  filter, all, any.\n    Note that these work on arbitrary--but finite--length lists,
  with all terminating elements, per\n    usual SBV interpretation. These functions
  map to the underlying solver's fold and map functions,\n    via lambda-abtractions.
  Note that the SMT engines remain incomplete with respect to sequence\n    theories.
  (That is, any property that requires induction for its proof will cause unknown\n
  \   answers, or will not terminate.) However, basic properties, especially when
  the solver can determine the\n    shape of the sequence arguments (i.e., number
  of elements), should go through.\n\n  * New function 'lambdaAsArray' allows creation
  of array values out of lambda-expressions. See\n    \"Documentation/SBV/Examples/Misc/LambdaArray.hs\"
  for an example use. This adds expressive power,\n    as we can now specify arrays
  with index dependent contents much more easily.\n\n  * Added support for abduct-generation,
  as supported by CVC5. See \"Documentation/SBV/Examples/Queries/Abducts.hs\"\n    for
  a basic example.\n\n  * Added support for special-relations. You can now check if
  a relation is partial, linear, tree,\n    or piecewise-linear orders in SBV. (Or
  you can constrain relations to satisfy the corresponding laws, thus\n    creating
  relations with these properties.) Additionally, you can create transitive-closures
  of relations.\n    See Documentation/SBV/Examples/Misc/FirstOrderLogic.hs for several
  examples.\n\n  * [BACKWARDS COMPATIBILITY] The signature of Data.SBV.List's concat
  has changed. In previous releases\n    this was a synonym for appending two lists,
  now it takes a list-of-lists and flattens it, matching the\n    Haskell list function
  with the same name.\n\n  * [BACKWARDS COMPATIBILITY] The function addAxiom is removed.
  Instead use quantified-constraints, as described\n    above.\n\n  * [BACKWARDS COMPATIBILITY]
  Renamed the Uninterpreted class to SMTDefinable, since its task has changed, handling\n
  \   both kinds of definitions. Unless you were referring to the name Uninterpreted
  in your code, this should not\n    impact you. Otherwise, simply rename it to SMTDefinable.\n\n
  \ * [BACKWARDS COMPATIBILITY] The configuration variable 'allowQuantifiedQueries'
  is removed. It is no\n    longer relevant with our new quantification strategy described
  above.\n\n  * [BACKWARDS COMPATIBILITY] The function 'isVacuous' is renamed to 'isVacuousProof'
  (and 'isVacuousWith'\n    became 'isVacuousProofWith') to better reflect this function
  applies to checking vacuity in a proof context.\n\n  * [BACKWARDS COMPATIBILITY]
  Satisfiability and proof checks are now put in different classes, instead of sharing\n
  \   the same class. This should not have any impact on user-level code, unless you
  were building libraries\n    on top of SBV. See the 'ProvableM' and 'SatisfiableM'
  classes.\n\n  * [BACKWARDS COMPATIBILITY] Renamed 'Goal' to 'ConstraintSet' which
  is more indicative of its purpose. A set\n    of constraints can be satisfied, but
  proving them does not make sense. The name goal, however, suggested\n    something
  we can prove.\n\n  * [BACKWARDS COMPATIBILITY] SBV is now more lenient in returning
  function-interpretations, returning the SMTLib\n    string in complicated cases
  in case of bailing out. Note that we still don't support complicated function\n
  \   values in allSat calls, as there's no way to reject existing interpretations.
  Consequently, the\n    parameter 'satTrackUFs' is renamed to 'allSatTrackUFs' to
  better capture its new role.\n\n  * Addressed an issue on Windows where solver synchronization
  fails due to unmapped diagnostic-challenge.\n    (See issue #644 for details.) Thanks
  to Ryan Scott for reporting and helping with debugging.\n\n  * Add missing Arbitrary
  instances for WordN and IntN types, enabling quickcheck on these types.\n\n  * Rewrote
  some of the older examples to use more modern SBV idioms.\n\n  * Changes needed
  to compile with upcoming GHC 9.6. Thanks to Lars Kuhtz and Ryan Scott for several
  patches.\n\n### Version 9.2, 2023-1-16\n\n  * Handle uninterpreted sorts better,
  avoiding kind-registration issue.\n    See #634 for details. Thanks to Nick Lewchenko
  for the report.\n\n### Version 9.1, 2023-01-09\n\n  * CVC5: Add support for algebraic
  reals in CVC5 models\n\n  * Export more solvers from Trans/Dynamic interfaces. Thanks
  to Ryan Scott for the patch.\n\n### Version 9.0, 2022-04-27\n\n  * Changes required
  to compile cleanly with GHC 9.2 series.\n\n  * In future versions, GHC will make
  `forall` a reserved word, which will create a conflict with SBV's use of the same.\n
  \   To accommodate for these changes and to be consistent, following identifiers
  were renamed:\n\n       - `forall`   --> `sbvForall`\n       - `forall_`  --> `sbvForall_`\n
  \      - `exists`   --> `sbvExists`\n       - `exists_`  --> `sbvExists_`\n       -
  `forAll`   --> `universal`\n       - `forAll_`  --> `universal_`\n       - `forSome`
  \ --> `existential`\n       - `forSome_` --> `existential_`\n\n   * Add support
  for `reverse` on symbolic lists and strings. Note that this definition uses a recursive
  function\n     declaration in SMTLib, so any proof involving inductive reasoning
  will likely not-terminate. However, it\n     should be usable at ground-level and
  for simpler non-inductive properties. Of course, as SMT-solvers mature\n     this
  can change in the future.\n\n   * Changed the String/List versions of `.++/.!!`
  to directly use the names `++/!!`. Since these modules\n     are intended to be
  used qualified only, there's no reason to add the dots.\n\n   * Added function `addSMTDefinition`,
  which allows users to give direct definitions of SMTLib functions. This\n     is
  useful for defining recursive functions that are not symbolically terminating.\n\n
  \  * Added `Documentation.SBV.Examples.Lists.CountOutAndTransfer` example, proving
  that the so-called\n     coating card trick works correctly.\n\n   * Added `Documentation.SBV.Examples.Puzzles.Jugs`
  example, solving the water-jug transfer puzzle.\n\n   * Added `Documentation.SBV.Examples.Puzzles.AOC_2021_24`
  example, showing how to model an EDSL in SBV,\n     solving the advent-of-code,
  2021, day 24 problem.\n\n   * Added `Documentation.SBV.Examples.Puzzles.Drinker`
  example, proving the famous Drinker paradox of\n     Raymond Smullyan.\n\n   * Added
  concrete type instances of Mergeable class.\n\n   * Fixed a bug in the implementation
  of the concrete-path for sPopCount\n   \n   * Added complement, power, and difference
  operators for regular expressions. Also added `everything`, `nothing`,\n     `anyChar`
  as new recognizers.\n\n   * Fixed the semantics of `All` regular expressions to
  recognize all-strings, and added `AllChar` as a\n     new regular-expression constructor
  to match any single regular expression. Thanks to Matt Torrence for\n     the patch.\n\n
  \  * Fixed a bug in the concrete implementation of bit-vector join, which didn't
  handle signed quantities\n     correctly. Thanks to Sirui Lu for the report and
  test cases.\n\n### Version 8.17, 2021-10-25\n\n  * SBV now supports cvc5; the latest
  incarnation of CVC. See https://github.com/cvc5/cvc5\n    for details.\n\n  * SBV
  now supports bitwuzla; the latest incarnation of Boolector. See https://bitwuzla.github.io\n
  \   for details.\n\n  * Fixed handling of CRational values in constant folding,
  which was missing a case.\n    Thanks to Jaro Reinders for reporting.\n\n  * Fixed
  calls to distinct for floating-point values, causing SBV to throw an exception.\n\n
  \ * Add missing instances of SatModel for Char and String. Thanks to eax- on github\n
  \   for the contribution.\n\n  * Add support for symbolic comparison of regular
  expressions.\n\n  * Export svToSV from Data.SBV.Dynamic. Thanks to Matt Parker for
  the PR.\n\n### Version 8.16, 2021-08-18\n\n  * Put extra annotations on data-type
  constructors, which makes\n    SBV generate problems that z3 can parse more easily.
  Thanks to\n    Greg Sullivan for reporting the issue in the first place.\n\n###
  Version 8.15, 2021-05-30\n\n  * Remove support for SFunArray abstraction. Turns
  out that the caching\n    mechanisms SBV used for SFunArray weren't entirely safe,
  and the code\n    has become unmaintainable over-time. Instead you should simply
  use\n    SArray, which has the exact same API. Thanks to frenchFrog42 on\n    github
  for reporting some of the problems.\n\n  * Fix the cmd line params for invocations
  of Boolector. You need\n    Boolector 3.2.2 to work with this version of SBV.\n\n
  \ * NB. Recent releases of z3 no longer support optimization of real-valued\n    goals
  in the presence of strict inequalities, i.e., .>, .<, and ./= operators.\n    So,
  you might get a bogus result if you are using optimization with\n    SReal parameters
  that have strict inequalities. See https://github.com/Z3Prover/z3/issues/5314\n
  \   for details. There is not much SBV can do to prevent these, unfortunately,\n
  \   as z3 optimization engine goals seem to have changed. Note that use of\n    non-strict
  inequalities (i.e., .>=, .<=) should be fine. Also, this\n    only impacts the optimize
  calls: regular sat/prove invocations are not\n    impacted.\n\n### Version 8.14,
  2021-03-29\n\n  * Improve the fast all-sat algorithm to also support uninterpreted
  values.\n\n  * Generalize svTestBit to work on floats, returning the respecting
  bit in the\n    representation of the float.\n\n  * Fixes to crack-num facility
  of how we display floats in detail.\n\n### Version 8.13, 2021-03-21\n\n  * Generalized
  floating point: Add support for brain-floats, with\n    type `SFPBFloat`, which
  has 8-bits of exponent and 8-bits of\n    significand. This format is affectionately
  called \"brain-float\"\n    because it's often used in modeling neural networks
  machine-learning\n    applications, offering a wider-range than IEEE's half-float,
  at the\n    exponse of reduced precision. It has 8-exponent bits and 8-significand\n
  \   bits, including the hidden bit.\n\n  * Add support for SRational type, rational
  values built out of the ratio\n    of two integers. Use the module \"Data.SBV.Rational\",
  which exports the\n    constructor .% to build rationals. Note that you cannot take
  numerator\n    and denominator of rationals apart, since SMTLib has no way of storing\n
  \   the rational in a canonical way. Otherwise, symbolic rationals follow\n    the
  same rules as Haskell's Rational type.\n\n  * SBV now implements a faster allSat
  algorithm, which applies in most common\n    use cases. (Essentially, when there
  are no uninterpreted values or sorts present.)\n    The new algorithm has been measured
  to be at least an order of magnitude\n    faster or more in common cases as it splits
  the search space into disjoint\n    models, reducing the burden of accummulated
  lemmas over multiple calls. (See\n    http://theory.stanford.edu/%7Enikolaj/programmingz3.html#sec-blocking-evaluations\n
  \   for details.)\n\n### Version 8.12, 2021-03-09\n\n  * Fix a bug in crackNum for
  unsigned-integer values, which incorrectly\n    showed a negation sign for values
  with msb set to 1.\n\n### Version 8.11, 2021-03-09\n\n  * SBV now supports floating-point
  numbers with arbitrary exponent and\n    significand sizes. The type is `SFloatingPoint
  eb sb`, where `eb`\n    and `sb` are type-level naturals. In particular, SBV can
  now reason about\n    half-floats, which are used much more frequently in ML applications.
  Through\n    the LibBF binding, you can also use these concretely, so if you have
  a use\n    case for computing with floats, you can use SBV as a vehicle for doing
  so.\n    The exponent/significand sizes are limited to those supported by the LibBF\n
  \   bindings, though the allowed range is rather large and should not be a limitation\n
  \   in practice. (In particular, you'll most likely run out of memory before you\n
  \   hit precision limits!)\n\n  * We now support a separate `crackNum` parameter
  in model display. If set to True\n    (default is False), SBV will display numeric
  values of bounded integers, words,\n    and all floats (SDouble, SFloat, and the
  new SFloatingPoint) in models in detail,\n    showing how they are laid out in memory.
  Numbers follow the usual 2's-complement\n    notation if they are signed, bit-vectors
  if they are not signed, and the floats\n    follow the usual IEEE754 binary layout
  rules. Similarly, there's now a function\n    crack :: SBV a -> String that does
  the same for non-model printing contexts.\n\n  * Changed the isNonModelVar config
  param to take a String (instead of Text).\n    Simplifies programming.\n\n  * Changes
  to make SBV compile with GHC9.0. Thanks to Ryan Scott for the patch.\n\n### Version
  8.10, 2021-02-13\n\n  * Add \"Documentation/SBV/Examples/Misc/NestedArray.hs\" to
  demonstrate how\n    to model multi-dimensional arrays in SBV.\n\n  * Add \"Documentation/SBV/Examples/Puzzles/Murder.hs\"
  as another puzzle example.\n\n  * Performance updates: Thanks to Jeff Young, SBV
  now uses better underlying\n    data structures, performing better for heavy use-case
  scenarios.\n\n  * SBV now tracks constants more closely in query mode, providing
  more support\n    for constant arrays in a seamless way. (See #574 for details.)\n\n
  \ * Pop-calls are now supported for Yices and Boolector. (#577)\n\n  * Changes required
  to make SBV work with latest version of z3 regarding\n    String and Characters,
  which now allow for unicode characters. This required\n    renaming of certain recognizers
  in 'Data.SBV.Char' to restrict them to the\n    Latin1 subset. Otherwise, the changes
  should be transparent to the end user.\n    Please report any issues you might run
  into when you use SChar and SString types.\n\n### Version 8.9, 2020-10-28\n\n  *
  Rename 'sbvAvailableSolvers' to 'getAvailableSolvers'.\n\n  * Use SMTLib's int2bv
  if supported by the backend solver. If not, we still\n    do a manual translation.
  (CVC4 and z3 support it natively, Yices and\n    MathSAT does not, for which we
  do the manual translation. ABC and dReal\n    doesn't support the coversion at all,
  since former doesn't support integers\n    and the latter doesn't support bit-vectors.)
  Thanks to Martin Lundfall\n    for the initial pull request.\n\n  * Add `sym` as
  a synonym for `uninterpret`. This allows us to write expressions\n    of the form
  `sat $ sym \"a\" - sym \"b\" .== (0::SInteger)`, without resorting to lambda\n    expressions
  or having to explicitly be in the Symbolic monad.\n\n  * Added missing instances
  for overflow-checking arithmetic of arbitrary\n    sized signed and unsigned bitvectors.\n\n
  \ * In a sat (or allSat) call, also return the values of the uninterpreted values,
  along with\n    all the explicitly named inputs. Strictly speaking, this is backwards-incompatible,\n
  \   but it the new behavior is consistent with how we handle uninterpreted values
  in general.\n\n  * Improve SMTLib logic-detection code to use generics.\n\n### Version
  8.8, 2020-09-04\n\n  * Reworked uninterpreted sorts. Added new function `mkUninterpretedSort`
  to make\n    declaration of completely uninterpreted sorts easier. In particular,
  we now\n    automatically introduce the symbolic variant of the type (by prefixing
  the\n    underlying type with `S`) so it becomes automatically available, both for
  uninterpreted\n    sorts and enumerations. In the latter case, we also automatically
  introduce the value `sX`\n    for each enumeration constant `X`, defined to be precisely
  `literal X`.\n\n  * Handle incremental mode table-declarations that depend on freshly
  declared variables. Thanks\n    to GergÅ Ãrdi for reporting.\n\n  * Fix a soundness
  bug in SFunArray caching. Thanks to GergÅ Ãrdi for reporting. See\n    https://github.com/LeventErkok/sbv/issues/541
  for details.\n\n  * Add support for the dReal solver, and introduce the notion of
  delta-satisfiability,\n    where you can now check properties to be satisfiable
  against delta-perturbations.\n    See \"Documentation.SBV.Examples.DeltaSat.DeltaSat\"
  for a basic example.\n\n  * Add \"extraArgs\" parameter to SMTConfig to simplify
  passing extra command line\n    arguments to the solver.\n\n  * Add a method \n\n
  \       sListArray :: (HasKind a, SymVal b) => b -> [(SBV a, SBV b)] -> array a
  b\n\n    to the `SymArray` class, which allows for creation of arrays from lists
  of constant or \n    symbolic lists of pairs. The first argument is the value to
  use for uninitialized entries.\n    Note that the initializer must be a known constant,
  i.e., it cannot be symbolic. Latter\n    elements of the list will overwrite the
  earlier ones, if there are repeated keys.\n\n  * Thanks to Jan Hrcek, a whole bunch
  of typos were fixed in the documentation and\n    the source code. Much appreciated!\n\n###
  Version 8.7, 2020-06-30\n\n  * Add support for concurrent versions of solvers for
  query problems. Similar to\n    `satWithAny`, `proveWithAny` etc., except when we
  have queries. Thanks to Jeffrey Young\n    for the idea and the implementation.\n\n
  \ * Add \"Documentation.SBV.Examples.Misc.Newtypes\", demonstrating how to use newtypes\n
  \   over existing symbolic types as symbolic quantities themselves. Thanks to Curran
  McConnell\n    for the example.\n\n  * Added new predicate `sNotElem`, negating
  `sElem`.\n\n  * Added new predicate `distinctExcept`. This is same as `distinct`\n
  \   except you can also provide an ignore list. The elements in\n    the first list
  will be checked to be distinct from each other,\n    or belong to the second list.
  This is good for writing constraints\n    that either require a default value or
  if picked be different\n    from each other for a set of variables. This sort of
  constraint\n    can be coded in user space, but SBV generates efficient code\n    instead
  of the obvious quadratic number of constraints.\n\n  * Add function 'algRealToRational'
  that can convert an algebraic-real\n    to a Haskell rational. We get an either
  value: If the algebraic real\n    is exact, then it returns a 'Left' value that
  represents the value\n    precisely. Otherwise, it returns a 'Right' value, which
  is only\n    an approximation. Note: Setting 'printRealPrec' in SMTConfig\n    to
  a higher value will increase the precision at the cost of more\n    computation
  by the SMT solver.\n\n  * Removed the 'SMTValue' class. It's functionality was not
  really\n    needed. If you ever used this class, removing it from your\n    type
  signatures should fix the issue. (You might have to\n    add SymVal constraint if
  you did not already have it.) Please\n    get in touch if you used this class in
  some cunning way and you\n    need its functionality back.\n\n  * Reworked SBVBenchSuite
  api, Phase 1 of BenchSuite completed.\n\n  * Add support for addAxiom command to
  work in the interactive mode.\n    Thanks to Martin Lundfall for the feedback.\n\n
  \ * Fixed `proveWithAny` and `satWithAny` functions so they properly\n    kill the
  solvers that did not terminate first. Previously, they\n    became zombies if they
  didn't end up quickly. Thanks to\n    Robert Dockins for the investigation and the
  fix.\n\n  * Fixed a bug where resetAssertions call was forgetting to restore the\n
  \   array and table contexts. Thanks to Martin Lundfall for reporting.\n\n### Version
  8.6, 2020-02-08\n\n  * Fix typo in error message. Thanks to Oliver Charles\n    for
  the patch.\n\n  * Fix parsing of sequence counter-examples to accommodate\n    recent
  changes in z3.\n\n  * Add missing exports related to N-bit words. Thanks to\n    Markus
  Barenhoff for the patch.\n\n  * Generalized code-generation functions to accept
  a function\n    with an arbitrary return type, which was previously just unit.\n
  \   This allows for complicated code-generation scenarios where\n    one code-gen
  run can produce input to the next.\n\n  * Scalability improvements for internal
  data structures. Thanks\n    to Brian Huffman for the patch.\n\n  * Add interpolation
  support for Z3, following changes to that\n    solver. Note that SBV now supports
  two different APIs for\n    interpolation extraction, one for Z3 and the other for\n
  \   MathSAT. This is unfortunate, but necessary since interpolant\n    extraction
  isn't quite standardized amongst solvers and\n    MathSAT and Z3 use sufficiently
  different calling mechanisms\n    to warrant their own calls. See 'Documentation.SBV.Examples.Queries.Interpolants'\n
  \   for examples that illustrate both cases.\n\n  * Add a new argument to `displayModels`
  function to allow rearranging\n    of the results in an 'allSat` call. Strictly
  speaking this is\n    a backwards breaking change, but substituting `id` for the\n
  \   new argument gives you old functionality, so easy to work-around.\n\n\n### Version
  8.5, 2019-10-16\n\n  * Changes to compile with GHC 8.8. Thanks to Oliver Charles\n
  \   for the patch.\n\n  * Minor fix to how kinds are shown for non-standard sizes.\n\n
  \ * Thanks to Jeffrey Young, SBV now has a performance benchmark\n    test-suite.
  The framework still new, but should help\n    in the long run to make sure SBV performance
  doesn't regress\n    on its test-suite, and by extension in general usage.\n\n###
  Version 8.4, 2019-08-31\n\n  * SBV now supports arbitrary-size bit-vectors, i.e.,\n
  \   SWord 17, SInt 9, SWord 128 etc. These work like any\n    other bit-vector,
  using the `DataKinds` feature of\n    GHC. Thanks to Ben Blaxill for the idea and
  the initial\n    implementation. Note that SBV still supports the traditional\n
  \   fixed-size bit-vectors, SInt8, SWord16 etc. Support for\n    these will not
  be removed; so existing programs will\n    continue to work.\n\n  * To convert between
  arbitrary sized bit-vectors and\n    the old style equivalents, use `fromSized`
  and `toSized`\n    functions. The behavior is controlled with a closed\n    type-family
  so you will get a (hopefully not too\n    horrendous) type error message if you
  try to convert,\n    say, a SInt16 to SInt 22; or vice versa.\n\n  * Added arbitrary-sized
  bit vector operations: extraction,\n    extension, and joining; these use proxy
  arguments to\n    determine precise size info, and are much better suited\n    for
  type safety. Consequently, removed the Splittable\n    class which provided similar
  operations but only on\n    predefined types. There is a new class called ByteConverter\n
  \   to convert to-and-from bytes for suitable bit-vector\n    sizes up to 512.\n\n
  \ * Tuple construction functions are given new types to strengthen\n    type checking.
  Previously the tuple argument was ignored,\n    causing things to be marked as tuples
  when they actually\n    cannot be. (NB. The system was always type-safe, it just\n
  \   didn't produce helpful type-error messages before.)\n\n  * Model validator:
  In the presence of universally quantified\n    variables, SBV used to refuse to
  validate given models. This\n    is the right thing to do since we would have to
  validate\n    the model for all possible values of all the universally\n    quantified
  variables. Obviously this is not useful. Instead,\n    SBV now simply assumes any
  universally quantified variable\n    is zero during model validation. This severely
  limits the\n    validation result, but it is better than nothing. (In the\n    verbose
  mode, a message to this effect will be printed.)\n\n  * Model validator: SBV can
  now validate models returned from\n    the backend solver for regular-expression
  match problems.\n    We also constant fold matches against constant strings without\n
  \   calling the solver at all, less useful perhaps but more inline\n    with the
  general SBV methodology.\n\n  * Add implementation of SHA-2 family of functions
  as an example\n    algorithm.  These are good for code-generation purposes as\n
  \   opposed to actual verification tasks as it is hard to state\n    any properties
  of these algorithms. But the SBV generated\n    code can be quite useful in other
  development and verification\n    environments. See 'Documentation.SBV.Examples.Crypto.SHA'
  for\n    details.\n\n  * Add 'cgShowU8UsingHex function, which controls if we print
  unsigned-8 bit\n    values in code generation driver code in hex or not. Previously
  we were\n    using decimal, but in crypto code hex is always better. Default is
  'False'\n    to keep backwards compatibility.\n\n  * Add `sObserve` from: `SymWord
  a => String -> SBV a -> Symbolic ()` which\n    comes in handy in symbolic contexts,
  especially with quick-check uses.\n\n  * Ramped up travis-appveyor build infrastructure.
  However, we no\n    longer test on the CI, since build-times are prohibitively long\n
  \   and myriad issues cause instability. If you can help out regarding\n    testing
  on CI, please reach out!\n\n### Version 8.3, 2019-06-08\n\n  * Increment base dependency
  to 4.11.\n\n  * Add support for `Data.Set.hasSize`.\n\n  * Add `supportsFP` to CVC4
  capabilities list. (#469)\n\n  * Fix a glitch in allSat computations that incorrectly\n
  \   used values of internal variables in model construction.\n\n  * SBV now directly
  uses the new `seq.nth` function from z3\n    for sequence element access, instead
  of implementing it\n    internally.\n\n### Version 8.2, 2019-04-07\n\n  * Fixed
  minor issue with getting observables in quantified contexts.\n\n  * Simplify data-type
  constructor usage and accessor formats. See\n    http://github.com/Z3Prover/z3/issues/2135
  for a discussion.\n\n  * Add support for model validation in optimization problems.
  Use the\n    config parameter: `optimizeValidateConstraints`. Default: False. This\n
  \   feature nicely complements the `validateModel` option, which works\n    for
  `sat` and `prove` calls. Note that when we validate the model\n    for an optimization
  problem, we only make sure that the given result\n    satisfies the constraints
  not that it is minimum (or maximum) such\n    model. (And hence the new configuration
  variable.) Validating optimality\n    is beyond the scope of SBV.\n\n### Version
  8.1, 2019-03-09\n\n  * Added support for `SEither` and `SMaybe` types: symbolic
  sums and symbolic\n    optional values. These can be accessed by importing `Data.SBV.Either`
  and\n    `Data.SBV.Maybe` respectively. They translate to SMTLib's data-type syntax,\n
  \   and thus require a solver capable of handling datatypes. (Currently z3 and\n
  \   cvc4 are the only solvers that do.) All the typical introduction and\n    elimination
  functions are provided, and these types integrate with all\n    other symbolic types.
  (So you can have a list of SMaybe of SEither\n    values, or at any nesting level.)
  Thanks to Joel Burget for the initial\n    implementation of this idea and his contributions.\n\n
  \ * Added support for symbolic sets. The API closely follows that of `Data.Set`\n
  \   of Haskell, with some major differences: Symbolic sets can be co-finite.\n    (That
  is, we can represent not only finite sets, but also sets whose complements\n    are
  finite.) The distinction shows up in the `complement` operation, which\n    is not
  supported in Haskell. All SBV sets can be complemented. On the flip\n    side, SBV
  sets do not support a size operation (as they can be infinite),\n    nor they can
  be converted to lists. See 'Data.SBV.Set' for the API documentation\n    and \"Documentation/SBV/Examples/Misc/SetAlgebra.hs\"
  for an example that proves\n    many familiar set properties.\n\n  * SBV models
  now contain values for uninterpreted functions. This was a long\n    requested feature,
  but there was no previous support since SMTLib does not\n    have a standard way
  of querying such values. We now support this for z3 and\n    cvc4: Note that SBV
  tries its best to interpret the output from these\n    solvers, but it may give
  up if the response is too complicated (or something\n    I haven't seen before!)
  due to non-standard format. Barring these details,\n    the calls to `sat` now include
  function models, and you can also get them\n    via `getFunction` in a query.\n\n
  \   For an example use case demonstrating how to use UF-models to synthesize a\n
  \   simple multiplier, see \"Documentation/SBV/Examples/Uninterpreted/Multiply.hs\".\n\n
  \ * SBV now comes with a model validator. In a 'sat', 'prove', or 'allSat' call,\n
  \   you can pass the configuration parameter 'z3{validateModel = True}' (or whichever\n
  \   solver you're using), and z3 will attempt to validate the returned model\n    from
  the solver. Note that validation only works if there are no uninterpreted\n    kinds
  of functions, and also in quantifier-free problems only. Please report\n    your
  experiences, as there's room for improvement in validation, always!\n\n  * [BACKWARDS
  COMPATIBILITY] The `allSat` function is similarly modified to\n    return uninterpreted-function
  models. There are a few technical restrictions,\n    however: Only the values of
  uninterpreted functions without any uninterpreted\n    arguments will participate
  in `allSat` computation. (For instance,\n    `uninterpret \"f\" :: SInteger -> SInteger`
  is OK, but\n    `uninterpret \"f\" :: MyType -> SInteger` is not, where `MyType`
  itself\n    is uninterpreted.) The reason for this is again there is no SMTLib way
  of\n    reflecting uninterpreted model values back into the solver. This restriction\n
  \   should not cause much trouble in practice, but do get in touch if it is a\n
  \   use-case for you.\n\n  * Added configuration option `allSatPrintAlong`. If set
  to True, calls to\n    allSat will print their models as they are found. The default
  is False.\n\n  * Added configuration parameter `satTrackUFs` (defaulting to True)
  to control\n    if SBV should try to extract models for uninterpreted functions.
  In theory,\n    this should always be True, but for most practical problems we typically\n
  \   don't care about the function values itself but that it exists. Set to 'False'\n
  \   if this is the case for your problem. Note that this setting is also respected\n
  \   in 'allSat' calls.\n\n  * Added function `registerUISMTFunction`, which can
  be used to directly register uninterpreted\n    functions. This is typically not
  necessary as uses of UI-functions do register them\n    automatically, but it can
  come in handy in certain scenarios where there are no\n    constraints on a UI-function
  other than its existence.\n\n  * Added `Data.SBV.Tools.WeakestPreconditions` module,
  which provides a toy imperative\n    language and an engine for checking partial
  and total correctness of imperative programs.\n    It uses Dijkstra's weakest preconditions
  methodology to establish correctness claims.\n    Loop invariants are required and
  must be supplied by the user. For total correctness,\n    user must also provide
  termination measure functions. However, if desired, these can\n    be skipped (by
  passing 'Nothing'), in which case partial correctness will be proven.\n    Checking
  input parameters for no-change is supported via stability checks. For example\n
  \   use cases, see the `Documentation.SBV.Examples.WeakestPreconditions` directory.\n\n
  \ * Added functions `elem`/`notElem` to `Data.SBV.List`.\n\n  * Added `snoc` (appending
  a single element at the end) to `Data.SBV.List` and `Data.SBV.String`.\n\n  * Rework
  the 'Queriable' class to allow projection/embedding pairs. Also\n    added a new
  'Fresh' class, which is more usable in simpler scenarios\n    where the default
  projection/embedding definitions are suitable.\n\n  * Added strong-equality (.===)
  and inequality (./==) to the 'EqSymbolic' class. This\n    method is equivalent
  to the usual (.==) and (./=) for all types except 'SFloat' and\n    'SDouble'. For
  the floating types, it is object equality, that is 'NaN .=== Nan'\n    and '0 ./==
  -0'. Use the regular equality for float/double's as they follow the\n    IEEE754
  rules, but occasionally we need to express object equality in a polymorphic\n    way.
  Essentially this method is the polymorphic equivalent of 'fpIsEqualObject'\n    except
  it works on all types.\n\n  * Removed the redundant 'SDivisible' constraint on rotate-left
  and rotate-right operations.\n\n  * Added unnamed equivalents of 'sBool', 'sWord8'
  etc; with a following underscore, i.e.,\n    'sBool_', 'sWord8_'. The new functions
  are supported for all base types, chars,\n    strings, lists, and tuples.\n\n  *
  SBV now supports implicit constraints in the query mode, which were previously only\n
  \   available before user queries started.\n\n  * Fixed a bug where hash-consing
  might reuse an expression even though the request might\n    have been made at a
  different type. This is a rare case in SBV to happen due to types,\n    but it was
  possible to exploit it in the Dynamic interface. Thanks to Brian Huffman\n    for
  reporting and diagnosing the issue.\n\n  * Fixed a bug where SBV was reporting incorrect
  \"elapsed\" time values, which are\n    printed when the 'timing' configuration
  parameter is specified.\n\n  * Documentation: Jan Path kindly fixed module headers
  of all the files to produce\n    much better looking Haddock documents. Thanks Jan!\n\n
  \ * Added barrel-rotations (sBarrelRotateLeft-Right, svBarrelRotateLeft-Right) which\n
  \   can produce better code for verification by bit-blasting the rotation amount.\n
  \   It accepts bit-vectors as arguments and an unsigned rotation quantity to keep\n
  \   things simple.\n\n  * Added new configuration option 'allowQuantifiedQueries',
  default is set to False.\n    SBV normally doesn't allow quantifiers in a query
  context, because there are\n    issues surrounding 'getValue'. However, Joel Burget
  pointed out this check\n    is too strict for certain scenarios. So, as an escape
  hatch, you can define\n    'allowQuantifiedQueries' to be 'True' and SBV will bypass
  this check. Of course,\n    if you do this, then you are on your own regarding calls
  to `getValue` with\n    quantified parameters! See http://github.com/LeventErkok/sbv/issues/459\n
  \   for details.\n\n  * [BACKWARDS COMPATIBILITY] Renamed the class `IEEEFloatConvertable`
  to\n    `IEEEFloatConvertible`. (Typo in name!) Matt Peddie pointed out issues\n
  \   regarding conversion of out-of-bounds float and double values to integral\n
  \   types. Unfortunately SMTLib does not support these conversions, and we\n    had
  issues in getting Haskell, SMTLib, and C to agree. Summary: These conversions\n
  \   are only guaranteed to work if they are done on numbers that lie within the\n
  \   representable range of the target type. Thanks to Matt Peddie for pointing out\n
  \   the out-of-bounds problem, his help in figuring out the issues.\n\n  * [BACKWARDS
  COMPATIBILITY] The 'AllSat' result now tracks if search has stopped\n    because
  the solver returned 'Unknown'. Previously this information was not\n    displayed.\n\n
  \ * [BACKWARDS COMPATIBILITY, Internal] Several constraints on internal\n    classes
  (such as SymVal, EqSymbolic, OrdSymbolic) were reworked to\n    reflect the dependencies
  better. Strictly speaking this is a backwards\n    compatibility breaking change,
  but I doubt it'll impact any user\n    code; though you might have to add some extra
  constraints if you were\n    writing sufficiently polymorphic SBV code. Yell if
  you find otherwise!\n\n  * [BACKWARDS COMPATIBILITY] SBV now allows user-given names
  to be duplicated.\n    It will implicitly add a suffix to them to distinguish without
  complaining. (In\n    previous versions, we would error out.) The reason for this
  change is that\n    sometimes it's nice to be able to simply give a prefix for a
  class of names\n    and not worry about the actual name itself. (Note that this
  will cause issues\n    if you use model-extraction-via-maps method if we ever make
  a name unique\n    and store it under a different name, but that's hardly ever used
  feature and\n    arguably the right thing to do anyway.) Thanks to Joel Burget for
  suggesting\n    the idea.\n\n  * [BACKWARDS COMPATIBILITY, Internal] SBV is now
  more strict in how user-queries\n    are used, performing certain extra-checks that
  were not done before. (For instance,\n    previously it was possible to mix prove-sat
  with a query call, which should\n    not have been allowed.) If you have any code
  that breaks for this reason, you\n    probably should've written it in some other
  way to start with. Please get\n    in touch if that is the case.\n\n  * [BACKWARDS
  COMPATIBILITY] You need at least GHC 8.4.1 to compile SBV.\n    If you're stuck
  with an older version, let me know and we'll see if\n    we can create a custom
  version for you; though I'd much rather avoid this\n    if at all possible.\n\n
  \ * SBV now supports optimization of goals of SDouble and SFloat types. This is\n
  \   done using the lexicographic ordering on floats, and adds on the additional\n
  \   constraint that the resulting float is not a NaN. If you use this feature,\n
  \   then your float value will be minimized as the corresponding 32 (or 64 for\n
  \   doubles) bit word. Note that this methods supports infinities properly, and\n
  \   does not distinguish between -0 and +0.\n\n  * Optimization routines have been
  generalized to work over arbitrary metric-spaces,\n    with user-definable mappings.
  The simplest instance we have added is optimization\n    over booleans, by the obvious
  numeric mapping. Tuples are also supported with\n    the usual lexicographic ordering.
  In addition, SBV can now optimize over\n    user-defined enumerations. See \"Documentation.SBV.Examples.Optimization.Enumerate\"
  for\n    an example.\n\n  * Improved the internal representation of constraints
  to address performance\n    issues See http://github.com/LeventErkok/sbv/issues/460
  for details. Thanks to\n    Thanks Jeffrey Young for reporting.\n\n### Version 8.0,
  2019-01-14\n\n  * This is a major release of SBV, with several BACKWARDS COMPATIBILITY
  breaking\n    changes. Lots of reworking of the internals to modernize the SBV code
  base.\n    A few external API changes happened as well, mainly in terms of renamed\n
  \   types/operators to reflect the current state of things. I expect most end user\n
  \   programs to carry over unchanged, perhaps needing a bunch of renames. See below\n
  \   for details.\n\n  * Transformer stack and `SymbolicT`: This major internal revamping
  was contributed\n    by Brian Schroeder. Brian reworked the internals of SBV to
  allow for custom monad\n    stacks. In particular, there is now a `SymbolicT` monad
  transformer, which\n    generalizes the `Symbolic` monad over an arbitrary base
  type, allowing users to\n    build SBV based symbolic execution engines on top of
  their own monad infrastructure.\n\n    Brian took the pains to ensure existing users
  (or those who do not have their\n    own monad stack), the transformer capabilities
  remain transparent. That is,\n    your existing code should recompile as is, or
  perhaps with minor aesthetic\n    changes. Please report if you find otherwise,
  or need help.\n\n    See `Documentation.SBV.Examples.Transformers.SymbolicEval`
  for an example of\n    how to use the transformer based code.\n\n    Thanks to Brian
  Schroeder for this massive effort to modernize the SBV code-base!\n\n  * Support
  for tuples: Thanks to Joel Burget, SBV now supports tuple types (up-to\n    8-tuples),
  and allows mixing and matching of lists and tuples arbitrarily\n    as symbolic
  values. For instance `SBV [(Integer, String)]` is a valid type as\n    is `SBV [(Integer,
  [(Char, (Float, String))])]`, with each component symbolically\n    represented.
  Along with `STuple` for regular 2-tuples, there are new types\n    for `STupleN`
  for `N` between 2 to 8, along with `untuple` destructor, and field\n    accessors
  similar to lens: For instance `p^._4` would project the 4th element of\n    a tuple
  that has at least 4 fields. The mixing and matching of field types and\n    nesting
  allows for very rich symbolic value representations. See\n    `Documentation.SBV.Examples.Misc.Tuple`
  for an example.\n\n  * [BACKWARDS COMPATIBILITY] The `Boolean` class is removed,
  which used to abstract\n    over logical connectives. Previously, this class handled
  'SBool' and 'Bool', but\n    the generality was hardly ever used and caused typing
  ambiguities. The new\n    implementation simplifies boolean operators to simply
  operate on the `SBool`\n    type. Also changed the operator names to fit with all
  the others by starting\n    them with dots. A simple conversion guide:\n\n        *
  Literal True : true    became   sTrue\n        * Literal False: false   became   sFalse\n
  \       * Negation     : bNot    became   sNot\n        * Conjunction  : &&&     became
  \  .&&\n        * Disjunction  : |||     became   .||\n        * XOr          :
  <+>     became   .<+>\n        * Nand         : ~&      became   .~&\n        *
  Nor          : ~|      became   .~|\n        * Implication  : ==>     became   .=>\n
  \       * Iff          : <=>     became   .<=>\n        * Aggregate and: bAnd    became
  \  sAnd\n        * Aggregate or : bOr     became   sOr\n        * Existential  :
  bAny    became   sAny\n        * Universal    : bAll    became   sAll\n\n  * [BACKWARDS
  COMPATIBILITY, INTERNAL] Historically, SBV focused on bit-vectors and machine\n
  \   words, which meant lots of internal types were named suggestive of this heritage.\n
  \   With the addition of `SInteger`, `SReal`, `SFloat`, `SDouble` we have expanded\n
  \   this, but still remained focused on atomic types. But, thanks largely to\n    Joel
  Burget, SBV now supports symbolic characters, strings, lists, and now\n    tuples,
  and nested tuples/lists, which makes this word-oriented naming confusing.\n    To
  reflect, we made the following internal renamings:\n\n        * SymWord     became
  \     SymVal\n        * SW          became      SV\n        * CW          became
  \     CV\n        * CWVal       became      CVal\n\n    Along with these, many of
  the internal constructor/variable names also changed in\n    a similar fashion.\n\n
  \   For most casual users, these changes should not require any changes. But if
  you were\n    developing libraries on top of SBV, then you will have to adapt to
  the new schema.\n    Please report if there are any gotchas we have forgotten about.\n\n
  \ * [BACKWARDS COMPATIBILITY] When user queries are present, SBV now picks the logic\n
  \   \"ALL\" (as opposed to a suitable variant of bit-vectors as in the past versions).\n
  \   This can be overridden by the 'setLogic' command as usual of course. While the
  new\n    choice breaks backwards compatibility, I expect the impact will be minimal,
  and\n    the new behavior matches better with user expectations on how external
  queries are\n    usually employed.\n\n  * [BACKWARDS COMPATIBILITY] Renamed the
  module `Data.SBV.List.Bounded` to\n    `Data.SBV.Tools.BoundedList`.\n\n  * Introduced
  a `Queriable` class, which simplifies symbolic programming with composite\n    user
  types. See `Documentation.SBV.Examples.ProofTools` directory for several\n    use
  cases and examples.\n\n  * Added function `observeIf`, companion to `observe`. Allows
  observing of values\n    if they satisfy a given predicate.\n\n  * Added function
  `ensureSat`, which makes sure the solver context is satisfiable\n    when called
  in the query mode. If not, an error will be thrown. Simplifies\n    programming
  when we expect a satisfiable result and want to bail out if otherwise.\n\n  * Added
  `nil` to `Data.SBV.List`. Added `nil` and `uncons` to `Data.SBV.String`.\n    These
  were inadvertently left out previously.\n\n  * Add `Data.SBV.Tools.BMC` module,
  which provides a BMC (bounded-model\n    checking engine) for traditional state
  transition systems. See\n    `Documentation.SBV.Examples.ProofTools.BMC` for example
  uses.\n\n  * Add `Data.SBV.Tools.Induction` module, which provides an induction
  engine\n    for traditional state transition systems. Also added several example
  use\n    cases in the directory `Documentation.SBV.Examples.ProofTools`.\n\n###
  Version 7.13, 2018-12-16\n\n  * Generalize the types of `bminimum` and `bmaximum`
  by removing the `Num`\n    constraint.\n\n  * Change the type of `observe` from:
  `SymWord a => String -> SBV a -> Symbolic ()`\n    to `SymWord a => String -> SBV
  a -> SBV a`. This allows for more concise observables,\n    like this:\n\n        prove
  $ \\x -> observe \"lhs\" (x+x) .== observe \"rhs\" (2*x+1)\n        Falsifiable.
  Counter-example:\n          s0  = 0 :: Integer\n          lhs = 0 :: Integer\n          rhs
  = 1 :: Integer\n\n  * Add `Data.SBV.Tools.Range` module which defines `ranges` and
  `rangesWith` functions: They\n    compute the satisfying contiguous ranges for predicates
  with a single variable. See\n    `Data.SBV.Tools.Range` for examples.\n\n  * Add
  `Data.SBV.Tools.BoundedFix` module, which defines the operator `bfix` that can be
  used\n    as a bounded fixed-point operator for use in bounded-model-checking like
  algorithms. See\n    `Data.SBV.Tools.BoundedFix` for some example use cases.\n\n
  \ * Fix list-element extraction code, which asserted too strong a constraint. See
  issue #421\n    for details. Thanks to Joel Burget for reporting.\n\n  * New bounded
  list functions: `breverse`, `bsort`, `bfoldrM`, `bfoldlM`, and `bmapM`.\n    Contributed
  by Joel Burget.\n\n  * Add two new puzzle examples:\n       * `Documentation.SBV.Examples.Puzzles.LadyAndTigers`\n
  \      * `Documentation.SBV.Examples.Puzzles.Garden`\n\n### Version 7.12, 2018-09-23\n\n
  \ * Modifications to make SBV compile with GHC 8.6.1. (SBV should\n    now compile
  fine with all versions of GHC since 8.0.1; and\n    possibly earlier. Please report
  if you are using a version\n    in this range and have issues.)\n\n  * Improve the
  BoundedMutex example to show a non-fair trace.\n    See `Documentation/SBV/Examples/Lists/BoundedMutex.hs`.\n\n
  \ * Improve Haddock documentation links throughout.\n\n### Version 7.11, 2018-09-20\n\n
  \ * Add support for symbolic lists. (That is, arbitrary but fixed length symbolic\n
  \   lists of integers, floats, reals, etc. Nested lists are allowed as well.)\n
  \   This is building on top of Joel Burget's initial work for supporting symbolic\n
  \   strings and sequences, as supported by Z3. Note that the list theory solvers\n
  \   are incomplete, so some queries might receive an unknown answer. See\n    `Documentation/SBV/Examples/Lists/Fibonacci.hs`
  for an example, and the\n    module `Data.SBV.List` for details.\n\n  * A new module
  `Data.SBV.List.Bounded` provides extra functions to manipulate\n    lists with given
  concrete bounds. Note that SMT solvers cannot deal with\n    recursive functions/inductive
  proofs in general, so the utilities in this\n    file can come in handy when expressing
  bounded-model-checking style\n    algorithms. See `Documentation/SBV/Examples/Lists/BoundedMutex.hs`
  for a\n    simple mutex algorithm proof.\n\n  * Remove dependency on data-binary-ieee754
  package; which is no longer\n    supported.\n\n### Version 7.10, 2018-07-20\n  *
  [BACKWARDS COMPATIBILITY] '==' and '/=' now always throw an error instead of\n    only
  throwing an error for non-concrete values.\n    http://github.com/LeventErkok/sbv/issues/301\n\n
  \ * [BACKWARDS COMPATIBILITY] Array declarations are reworked to take\n    an initial
  value. The call 'newArray' now accepts an optional default\n    value, which itself
  can be symbolic. If provided, the array will return\n    the given value for all
  reads from uninitialized locations. If not given,\n    then reads from unwritten
  locations produce uninterpreted constants. The\n    behavior of 'SFunArray' and
  'SArray' is exactly the same in this regard.\n    Note that this is a backwards-compatibility
  breaking change, as you need\n    to pass a 'Nothing' argument to 'newArray' to
  get the old behavior.\n    (Solver note: If you use 'SFunArray', then defaults are
  fully supported\n    by SBV since these are internally handled, concrete or symbolic.
  If you\n    use 'SArray', which gets translated to SMTLib, then MathSAT and Z3 supports\n
  \   default values with both concrete and symbolic cases, CVC4 only supports\n    if
  they are constants. Boolector and Yices don't support default values\n    at this
  point in time, and ABC doesn't support arrays at all.)\n\n  * [BACKWARDS COMPATIBILITY]
  SMTException type has been renamed to\n    SBVException. SBV now throws this exception
  in more cases to aid in\n    building tools on top of SBV that might want to deal
  with exceptions\n    in different ways. (Previously, we used to call 'error' instead.)\n\n
  \ * [BACKWARDS COMPATIBILITY] Rename 'assertSoft' to 'assertWithPenalty', which\n
  \   better reflects the nature of this function. Also add extra checks to warn\n
  \   the user if optimization constraints are present in a regular sat/prove call.\n\n
  \ * Implement `softConstrain`: Similar to 'constrain', except the solver is\n    free
  to leave it unsatisfied (i.e., leave it false) if necessary to\n    find a satisfying
  solution. Useful in modeling conditions that are\n    \"nice-to-have\" but not \"required.\"
  Note that this is similar to\n    'assertWithPenalty', except it works in non-optimization
  contexts.\n    See `Documentation.SBV.Examples.Misc.SoftConstrain` for a simple
  example.\n\n  * Add 'CheckedArithmetic' class, which provides bit-vector arithmetic\n
  \   operations that do automatic underflow/overflow checking. The operations\n    follow
  their regular counter-parts, with an exclamation mark added at\n    the end: +!,
  -!, *!, /!. There is also negateChecked, for the same\n    function on unary negation.
  If you program using these functions,\n    then you can call 'safe' on the resulting
  programs to make sure\n    these operations never cause underflow and overflow conditions.\n\n
  \ * Similar to above, add 'sFromIntegralChecked', providing overflow/underflow\n
  \   checks for cast operations.\n\n  * Add `Documentation.SBV.Examples.BitPrecise.BrokenSearch`
  module to show the\n    use of overflow checking utilities, using the classic broken
  binary search\n    example from http://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html\n\n
  \ * Fix an issue where SBV was not sending array declarations to the SMT-solver\n
  \   if there were no explicit constraints. Thanks to Oliver Charles for reporting.\n\n
  \ * Rework 'SFunArray' implementation, addressing performance issues. We now\n    carefully
  memoize elements as we do the look-ups. This addresses several\n    performance
  issues that came up; hopefully providing some relief. The\n    function 'mkSFunArray'
  is also removed, which used to lift Haskell\n    functions to such arrays, often
  used to implement initial values. Now,\n    if a read is done on an unwritten element
  of 'SFunArray' we get an\n    uninterpreted constant. This is inline with how 'SArray'
  works, and\n    is consistent. The old 'SFunArray' implementation based on functions\n
  \   is no longer available, though it is easy to implement it in user-space\n    if
  needed. Please get in contact if this proves to be an issue.\n\n  * Add 'freshArray'
  to allow for creation of existential fresh arrays in the query mode.\n    This is
  similar to 'newArray' which works in the Symbolic mode, and is analogous to\n    'freshVar'.
  Most users shouldn't need this as 'newArray' calls should suffice. Only\n    use
  if you need a brand new array after switching to query mode.\n\n  * SBV now rejects
  queries if universally quantified inputs are present. Previously\n    these were
  allowed to go through, but in general skolemization makes the corresponding\n    variables
  unusable in the query context. See http://github.com/LeventErkok/sbv/issues/407\n
  \   for details. If you have an actual use case for such a feature, please get in\n
  \   touch. Thanks to Brian Schroeder for reporting this anomaly.\n\n  * Export 'addSValOptGoal'
  from 'Data.SBV.Internals', to help with 'Metric' class\n    instantiations. Requested
  by Dan Rosen.\n\n  * Export 'registerKind' from 'Data.SBV.Internals', to help with
  custom array declarations.\n    Thanks to Brian Schroeder for the patch.\n\n  *
  If an asynchronous exception is caught, SBV now throws it back without further processing.\n
  \   (For instance, if the backend solver gets killed. Previously we were turning
  these into\n    synchronous errors.) Thanks to Oliver Charles for pointing out this
  corner case.\n\n### Version 7.9, 2018-06-15\n\n  * Add support for bit-vector arithmetic
  underflow/overflow detection. The new\n    'ArithmeticOverflow' class captures conditions
  under which addition, subtraction,\n    multiplication, division, and negation can
  underflow/overflow for\n    both signed and unsigned bit-vector values. The implementation
  is based on\n    http://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/z3prefix.pdf,\n
  \   and can be used to detect overflow caused bugs in machine arithmetic.\n    See
  `Data.SBV.Tools.Overflow` for details.\n\n  * Add 'sFromIntegralO', which is the
  overflow/underflow detecting variant\n    of 'sFromIntegral'. This function returns
  (along with the converted\n    result), a pair of booleans showing whether the conversion
  underflowed\n    or overflowed.\n\n  * Change the function 'getUnknownReason' to
  return a proper data-type\n    ('SMTReasonUnknown') as opposed to a mere string.
  This is at the\n    query level. Similarly, change `Unknown` result to return the
  same\n    data-type at the sat/prove level.\n\n  * Interpolants: With Z3 4.8.0 release,
  Z3 folks have dropped support\n    for producing interpolants. If you need interpolants,
  you will have\n    to use the MathSAT backend now. Also, the MathSAT API is slightly\n
  \   different from how Z3 supported interpolants as well, which means\n    your
  old code will need some modifications. See the example in\n    Documentation.SBV.Examples.Queries.Interpolants
  for the new usage.\n\n  * Add 'constrainWithAttribute' call, which can be used to
  attach\n    arbitrary attribute to a constraint. Main use case is in interpolant\n
  \   generation with MathSAT.\n\n  * C code generation: SBV now spits out linker
  flag -lm if needed.\n    Thanks to Matt Peddie for reporting.\n\n  * Code reorg:
  Simplify constant mapping table, by properly accounting\n    for negative-zero floats.\n\n
  \ * Export 'sexprToVal' for the class SMTValue, which allows for custom\n    definitions
  of value extractions. Thanks to Brian Schroeder for the\n    patch.\n\n  * Export
  'Logic' directly from Data.SBV. (Previously was from Control.)\n\n  * Fix a long
  standing issue (ever since we introduced queries) where\n    'sAssert' calls were
  run in the context of the final output boolean,\n    which is simply the wrong thing
  to do.\n\n### Version 7.8, 2018-05-18\n\n  * Fix printing of min-bounds for signed
  32/64 bit numbers in C\n    code generation: These are tricky since C does not allow\n
  \   -min_value as a valid literal!  Instead we use the macros provided in\n    stdint.h.
  Thanks to Matt Peddie for reporting this corner case.\n\n  * Fix translation of
  the `abs` function in C code generation, making\n    sure we use the correct variant.
  Thanks to Matt Peddie for reporting.\n\n  * Fix handling of tables and arrays in
  pushed-contexts. Previously,\n    we used initializers to get table/array values
  stored properly.\n    However, this trick does not work if we are in a pushed-context;\n
  \   since a pop can forget the corresponding assignments. SBV now\n    handles this
  corner case properly, by using tracker assertions\n    to keep track of what array
  values must be restored at each pop.\n    Thanks to Martin Brain on the SMTLib mailing
  list for the\n    suggestion. (See http://github.com/LeventErkok/sbv/issues/374\n
  \   for details.)\n\n  * Fix corner case in ite branch equality with float/double
  arguments,\n    where we were previously confusing +/-0 as equal to each other.\n
  \   Thanks to Matt Peddie for reporting.\n\n  * Add a call 'cgOverwriteFiles', which
  suppresses code-generation\n    prompts for overwriting files and quiets the prompts
  during\n    code generation. Thanks to Matt Peddie for the suggestion.\n\n  * Add
  support for uninterpreted function introductions in the query\n    mode. Previously,
  this was only allowed before the query started,\n    now we fully support uninterpreted
  functions in all modes.\n\n  * New example: Documentation/SBV/Examples/Puzzles/HexPuzzle.hs,\n
  \   showing how to code cover properties using SBV, using a form\n    of bounded
  model checking.\n\n### Version 7.7, 2018-04-29\n\n  * Add support for Symbolic characters
  ('SChar') and strings ('SString'.)\n    Thanks to Joel Burget for the initial implementation.\n\n
  \   The 'SChar' type currently corresponds to the Latin-1 character\n    set, and
  is thus a subset of the Haskell 'Char' type. This is\n    due to the current limitations
  in SMT-solvers. However, there\n    is a pending SMTLib proposal to support unicode,
  and SBV will track\n    these changes to have full unicode support: For further
  details\n    see: https://smt-lib.org/theories-UnicodeStrings.shtml\n\n    The 'SString'
  type is the type of symbolic strings, consisting\n    of characters from the Latin-1
  character set currently, just\n    like the planned 'SChar' improvements. Note that
  an 'SString'\n    is *not* simply a list of 'SChar' values: It is a symbolic\n    type
  of its own and is processed as a single item. Conversions\n    from list of characters
  is possible (via the 'implode' function).\n    In the other direction, one cannot
  generally 'explode' a string,\n    since it may be of arbitrary length and thus
  we would not know\n    what concrete list to map it to. This is a bit unlike Haskell,\n
  \   but the differences dissipate quickly in general, and the power\n    of being
  able to deal with a string as a symbolic entity on its\n    own opens up many verification
  possibilities.\n\n    Note that currently only Z3 and CVC4 has support for this
  logic,\n    and they do differ in some details. Various character/string\n    operations
  are supported, including length, concatenation,\n    regular-expression matching,
  substrig operations, recognizers, etc.\n    If you use this logic, you are likely
  to find bugs in solvers themselves\n    as support is rather new: Please report.\n\n
  \ * If unsat-core extraction is enabled, SBV now returns the unsat-core\n    directly
  with in a solver result. Thanks to Ara Adkins for the\n    suggestion.\n\n  * Add
  'observe'. This function allows internal expressions to be\n    given values, which
  will be part of the satisfying model or\n    the counter-example upon model construction.
  Useful for tracking\n    expected/returned values. Also works with quickCheck.\n\n
  \ * Revamp Haddock documentation, hopefully easier to follow now.\n\n  * Slightly
  modify the generated-C headers by removing whitespace.\n    This allows for certain
  \"lint\" rules to pass when SBV generated\n    code is used in conjunction with
  a larger code base. Thanks\n    to Greg Horn for the pull request.\n\n  * Improve
  implementation of 'svExp' to match that of '.^', making\n    it more defined when
  the exponent is constant. Thanks to Brian\n    Huffman for the patch.\n\n  * Export
  the underlying polynomial representation for algorithmic\n    reals from the Internals
  module for further user processing.\n    Thanks  to Jan Path for the patch.\n\n###
  Version 7.6, 2018-03-18\n\n  * GHC 8.4.1 compatibility: Work around compilation
  issues. SBV\n    now compiles cleanly with GHC 8.4.1.\n\n  * Define and export sWordN,
  sWordN_, sIntN_, from the Dynamic\n    interface, which simplifies creation of variables
  of arbitrary\n    bit sizes. These are similar to sWord8, sInt8, etc.; except\n
  \   they create dynamic counterparts that can be of arbitrary bit size.\n\n### Version
  7.5, 2018-01-13\n\n  * Remove obsolete references to tactics in a few haddock comments.
  Thanks\n    to Matthew Pickering for reporting.\n\n  * Added logic Logic_NONE, to
  be used in cases where SBV should not\n    try to set the logic. This is useful
  when there is no viable value to\n    set, and the back-end solver doesn't understand
  the SMT-Lib convention\n    of using \"ALL\" as the logic name. (One example of
  this is the Yices\n    solver.)\n\n  * SBV now returns SMTException (instead of
  just calling error) in case\n    the backend solver responds with error message.
  The type SMTException\n    can be caught by the user programs, and it includes many
  fields as an\n    indication of what went wrong. (The command sent, what was expected,\n
  \   what was seen, etc.) Note that if this exception is ever caught, the\n    backend
  solver is no longer alive: You should either just throw it,\n    or perform proper
  clean-up on your user code as required to set up\n    a new context. The provided
  show instance formats the exception nicely\n    for display purposes. See http://github.com/LeventErkok/sbv/issues/335\n
  \   for details and thanks to Brian Huffman for reporting.\n\n  * SIntegral class
  now has Integral as a super-class, which ensures the\n    base-type it's used at
  is Integral. This was already true for all instances,\n    so we are just making
  it more explicit.\n\n  * Improve the implementation of .^ (exponentiation) to cover
  more cases,\n    in particular signed exponents are now OK so long as they are concrete\n
  \   and positive, following Haskell convention.\n\n  * Removed the 'FromBits' class.
  Its functionality is now merged with the\n    new 'SFiniteBits' class, see below.\n\n
  \ * Introduce 'SFiniteBits' class, which only incorporates finite-words in it,\n
  \   i.e., SWord/SInt for 8-16-32-64. In particular it leaves out SInteger,\n    SFloat,
  SDouble, and SReal. Important in recognizing bit-vectors of\n    finite size, essentially.
  Here are the methods:\n\n        class (SymWord a, Num a, Bits a) => SFiniteBits
  a where\n            sFiniteBitSize      :: SBV a -> Int                     --
  ^ Bit size\n            lsb                 :: SBV a -> SBool                   --
  ^ Least significant bit of a word, always stored at index 0.\n            msb                 ::
  SBV a -> SBool                   -- ^ Most significant bit of a word, always stored
  at the last position.\n            blastBE             :: SBV a -> [SBool]                 --
  ^ Big-endian blasting of a word into its bits. Also see the 'FromBits' class.\n
  \           blastLE             :: SBV a -> [SBool]                 -- ^ Little-endian
  blasting of a word into its bits. Also see the 'FromBits' class.\n            fromBitsBE
  \         :: [SBool] -> SBV a                 -- ^ Reconstruct from given bits,
  given in little-endian\n            fromBitsLE          :: [SBool] -> SBV a                 --
  ^ Reconstruct from given bits, given in little-endian\n            sTestBit            ::
  SBV a -> Int -> SBool            -- ^ Replacement for 'testBit', returning 'SBool'
  instead of 'Bool'\n            sExtractBits        :: SBV a -> [Int] -> [SBool]
  \       -- ^ Variant of 'sTestBit', where we want to extract multiple bit positions.\n
  \           sPopCount           :: SBV a -> SWord8                  -- ^ Variant
  of 'popCount', returning a symbolic value.\n            setBitTo            :: SBV
  a -> Int -> SBool -> SBV a   -- ^ A combo of 'setBit' and 'clearBit', when the bit
  to be set is symbolic.\n            fullAdder           :: SBV a -> SBV a -> (SBool,
  SBV a) -- ^ Full adder, returns carry-out from the addition. Only for unsigned quantities.\n
  \           fullMultiplier      :: SBV a -> SBV a -> (SBV a, SBV a) -- ^ Full multiplier,
  returns both high and low-order bits. Only for unsigned quantities.\n            sCountLeadingZeros
  \ :: SBV a -> SWord8                  -- ^ Count leading zeros in a word, big-endian
  interpretation\n            sCountTrailingZeros :: SBV a -> SWord8                  --
  ^ Count trailing zeros in a word, big-endian interpretation\n\n    Note that the
  functions 'sFiniteBitSize', 'sCountLeadingZeros', and 'sCountTrailingZeros' are\n
  \   new. Others have existed in SBV before, we are just grouping them together now
  in this new class.\n\n  * Tightened certain signatures where SBV was too liberal,
  using the SFiniteBits class. New signatures are:\n\n         sSignedShiftArithRight
  :: (SFiniteBits a, SIntegral b) => SBV a -> SBV b -> SBV a\n         crc                    ::
  (SFiniteBits a, SFiniteBits b) => Int -> SBV a -> SBV b -> SBV b\n         readSTree
  \             :: (SFiniteBits i, SymWord e) => STree i e -> SBV i -> SBV e\n         writeSTree
  \            :: (SFiniteBits i, SymWord e) => STree i e -> SBV i -> SBV e -> STree
  i e\n\n    Thanks to Thomas DuBuisson for reporting.\n\n### Version 7.4, 2017-11-03\n\n
  \ * Export queryDebug from the Control module, allowing custom queries to print\n
  \   debugging messages with the verbose flag is set.\n\n  * Relax value-parsing
  to allow for non-standard output from solvers. For\n    instance, MathSAT/Yices
  prints reals as integers when they do not have a\n    fraction. We now support such
  cases, relaxing the standard slightly. Thanks\n    to Geoffrey Ramseyer for reporting.\n\n
  \ * Fix optimization routines when applied to signed-bitvector goals. Thanks\n    to
  Anders Kaseorg for reporting. Since SMT-Lib does not distinguish between\n    signed
  and unsigned bit-vectors, we have to be careful when expressing goals\n    that
  are over signed values. See http://github.com/LeventErkok/sbv/issues/333\n    for
  details.\n\n### Version 7.3, 2017-09-06\n\n  * Query mode: Add support for arrays
  in query mode. Thanks to Brad Hardy for\n    providing the use-case and debugging
  help.\n\n  * Query mode: Add support for tables. (As used by 'select' calls.)\n\n###
  Version 7.2, 2017-08-29\n\n  * Reworked implementation of shifts and rotates: When
  a signed quantity was\n    being shifted right by more than its size, SBV used to
  return 0. Robert Dockins pointed\n    out that the correct answer is actually -1
  in such cases. The new implementation\n    merges the dynamic and typed interfaces,
  and drops support for non-constant shifts\n    of unbounded integers, which is not
  supported by SMTLib. Thanks to Robert for\n    reporting the issue and identifying
  the root cause.\n\n  * Rework how quantifiers are handled: We now generate separate
  asserts for\n    prefix-existentials. This allows for better (smaller) quantified
  code, while\n    preserving semantics.\n\n  * Rework the interaction between quantifiers
  and optimization routines.\n    Optimization routines now properly handle quantified
  formulas, so long as the\n    quantified metric does not involve any universal quantification
  itself. Thanks\n    to Matthew Danish for reporting the issue.\n\n  * Development/Infrastructure:
  Lots of work around the continuous integration\n    for SBV. We now build/test on
  Linux/Mac/Windows on every commit. Thanks to\n    Travis/Appveyor for providing
  free remote infrastructure. There are still\n    gotchas and some reductions in
  tests due to host capacity issues. If you\n    would like to be involved and improve
  the test suite, please get in touch!\n\n### Version 7.1, 2017-07-29\n\n  * Add support
  for 'getInterpolant' in Query mode.\n\n  * Support for SMT-results that can contain
  multi-line strings, which\n    is rare but it does happen. Previously SBV incorrectly
  interpreted such\n    responses to be erroneous.\n\n  * Many improvements to build
  infrastructure and code clean-up.\n\n  * Fix a bug in the implementation of `svSetBit`.
  Thanks to Robert Dockins\n    for the report.\n\n### Version 7.0, 2017-07-19\n\n
  \ * NB. SBV now requires GHC >= 8.0.1 to compile. If you are stuck with an older\n
  \   version of GHC, please get in contact.\n\n  * This is a major rewrite of the
  internals of SBV, and is a backwards compatibility\n    breaking release. While
  we kept the top-level and most commonly used APIs the\n    same (both types and
  semantics), much of the internals and advanced features\n    have been rewritten
  to move SBV to a new model of execution: SBV no longer\n    runs your program symbolically
  and calls the SMT solver afterwards. Instead,\n    the interaction with the solver
  happens interleaved with the actual program execution.\n    The motivation is to
  allow the end-users to send/receive arbitrary SMTLib\n    commands to the solver,
  instead of the cooked-up recipes. SBV still provides\n    all the recipes for its
  existing functionality, but users can now interact\n    with the solver directly.
  See the module `Data.SBV.Control` for the main\n    API, together with the new functions
  'runSMT' and 'runSMTWith'.\n\n  * The 'Tactic' based solver control (introduced
  in v6.0) is completely removed, and\n    is replaced by the above described mechanism
  which gives the user a lot of\n    flexibility instead. Use queries for anything
  that required a tactic before.\n\n  * The call 'allSat' has been reworked so it
  performs only one call to the underlying\n    solver and repeatedly issues check-sat
  to get new assignments. This differs from the\n    previous implementation where
  we spun off a new call to the executable for each\n    successive model. While this
  is more efficient and much more preferable, it also\n    means that the results
  are no longer lazily computed: If there is an infinite number\n    of solutions
  (or a very large number), you can no longer merely do a 'take' on the result.\n
  \   While this is inconvenient, it fits better with our new methodology of query
  based\n    interaction. Note that the old behavior can be modeled, if required,
  by the user; by explicitly\n    interleaving the calls to 'sat.' Furthermore, we
  now provide a new configuration\n    parameter named 'allSatMaxModelCount' which
  can be used to limit the number models we\n    seek. The default is to get all models,
  however long that might take.\n\n  * The Bridge modules (`Data.SBV.Bridge.Yices`,
  `Data.SBV.Bridge.Z3`) etc. are\n    all removed. The bridge functionality was hardly
  used, where different solvers\n    were much easier to access using the `with` functions.
  (Such as `proveWith`,\n    `satWith` etc.) This should result in no loss of functionality,
  except for\n    occasional explicit mention of solvers in your code, if you were
  using\n    bridge modules to start with.\n\n  * Optimization routines have been
  changed to take a priority as an argument, (i.e.,\n    Lexicographic, Independent,
  etc.). The old method of supplying the priority\n    via tactics is no longer supported.\n\n
  \ * Pareto-front extraction has been reworked, reflecting the changes in Z3 for\n
  \   this functionality. Since pareto-fronts can be infinite in number, the user\n
  \   is now allowed to specify a \"limit\" to stop the solver from querying ad\n
  \   infinitum. If the limit is not specified, then sbv will query till it\n    exhausts
  all the pareto-fronts, or till it runs out of memory in case there\n    is an infinite
  number of them.\n\n  * Extraction of unsat-cores has changed. To use this feature,
  we now use\n    custom queries. See `Data.SBV.Examples.Misc.UnsatCore` for an example.\n
  \   Old style of unsat-core extraction is no longer supported.\n\n  * The 'timing'
  option of SMTConfig has been reworked. Since we now start the\n    solver immediately,
  it is no longer sensible to distinguish between \"SBV\" time,\n    \"translation\"
  time etc. Instead, we print one simple \"Elapsed\" time if requested.\n    If you
  need a detailed timing analysis, use the new 'transcript' option to\n    SMTConfig:
  It will produce a file with precise timing intervals for each\n    command issued
  to help you figure out how long each step took.\n\n  * The following functions have
  been reworked, so they now also return\n    the time-elapsed for each solver:\n\n
  \       satWithAll   :: Provable a => [SMTConfig] -> a -> IO [(Solver, NominalDiffTime,
  SatResult)]\n        satWithAny   :: Provable a => [SMTConfig] -> a -> IO  (Solver,
  NominalDiffTime, SatResult)\n        proveWithAll :: Provable a => [SMTConfig] ->
  a -> IO [(Solver, NominalDiffTime, ThmResult)]\n        proveWithAny :: Provable
  a => [SMTConfig] -> a -> IO  (Solver, NominalDiffTime, ThmResult)\n\n  * Changed
  the way `satWithAny` and `proveWithAny` works. Previously, these\n    two functions
  ran multiple solvers, and took the result of the first\n    one to finish, killing
  all the others. In addition, they *waited* for\n    the still-running solvers to
  finish cleaning-up, as sending a 'ThreadKilled'\n    is usually not instantaneous.
  Furthermore, a solver might simply take\n    its time! We now send the interrupt
  but do not wait for the process to\n    actually terminate. In rare occasions this
  could create zombie processes\n    if you use a solver that is not cooperating,
  but we have seen not insignificant\n    speed-ups for regular usage due to ThreadKilled
  wait times being rather long.\n\n  * Configuration option `useLogic` is removed.
  If required, this should\n    be done by a call to the new 'setLogic' function:\n\n
  \       setLogic QF_NRA\n\n  * Configuration option `timeOut` is removed. This was
  rarely used, and the solver\n    support was rather sketchy. We now have a better
  mechanism in the query mode\n    for timeouts, where it really matters. Please get
  in touch if you relied on\n    this old mechanism. Correspondingly, the functions
  `isTheorem`, `isSatisfiable`,\n    `isTheoremWith` and `isSatisfiableWith` had their
  time-out arguments removed\n    and return types simplified.\n\n  * The function
  'isSatisfiableInCurrentPath' is removed. Proper queries should be used\n    for
  what this function tentatively attempted to provide. Please get in touch\n    if
  you relied on this function and want to restructure your code to use proper queries.\n\n
  \ * Configuration option 'smtFile' is removed. Instead use 'transcript' now, which\n
  \   provides a much more detailed output that is directly loadable to a solver\n
  \   and has an accurate account of precisely what SBV sent.\n\n  * Enumerations
  are now much easier to use symbolically, with the addition\n    of the template-haskell
  splice mkSymbolicEnumeration. See `Data/SBV/Examples/Misc/Enumerate.hs`\n    for
  an example.\n\n  * Thanks to Kanishka Azimi, our external test suite is now run
  by\n    Tasty! Kanishka modernized the test suite, and reworked the\n    infrastructure
  that was showing its age. Thanks!\n\n  * The function pConstrain and the Data.SBV.Tools.ExpectedValue
  are\n    removed. Probabilistic constraints were rarely used, and if\n    necessary
  can be implemented outside of SBV. If you were using\n    this feature, please get
  in contact.\n\n  * SArray and SFunArray has been reworked, and they no longer take\n
  \   and initial value. Similarly resetArray has been removed, as it\n    did not
  really do what it advertised. If an initial value is needed,\n    it is best to
  code this explicitly in your model.\n\n### Version 6.1, 2017-05-26\n\n  * Add support
  for unsat-core extraction. To use this feature, use\n    the `namedConstraint` function:\n\n
  \       namedConstraint :: String -> SBool -> Symbolic ()\n\n    to associate a
  label to a constrain or a boolean term that\n    can later be labeled by the backend
  solver as belonging to the\n    unsat-core.\n\n    Unsat-cores are not enabled by
  default since they can be\n    expensive; to use:\n\n        satWith z3{getUnsatCore=True}
  $ do ...\n\n    In the programmatic API, the function:\n\n        extractUnsatCore
  :: Modelable a => a -> Maybe [String]\n\n    can be used to programmatically extract
  the unsat-core. Note that\n    backend solvers will only include the named expressions
  in the unsat-core,\n    i.e., any unnamed yet part-of-the-core-unsat expressions
  will be missing;\n    as speculated in the SMT-Lib document itself.\n\n    Currently,
  Z3, MathSAT, and CVC4 backends support unsat-cores.\n\n    (Thanks to Rohit Ramesh
  for the suggestion leading to this feature.)\n\n  * Added function `distinct`, which
  returns true if all the elements of the\n    given list are different. This function
  replaces the old `allDifferent`\n    function, which is now removed. The difference
  is that `distinct` will produce\n    much better code for SMT-Lib. If you used `allDifferent`
  before, simply\n    replacing it with `distinct` should work.\n\n  * Add support
  for pseudo-boolean operations:\n\n          pbAtMost           :: [SBool]        ->
  Int -> SBool\n          pbAtLeast          :: [SBool]        -> Int -> SBool\n          pbExactly
  \         :: [SBool]        -> Int -> SBool\n          pbLe               :: [(Int,
  SBool)] -> Int -> SBool\n          pbGe               :: [(Int, SBool)] -> Int ->
  SBool\n          pbEq               :: [(Int, SBool)] -> Int -> SBool\n          pbMutexed
  \         :: [SBool]               -> SBool\n          pbStronglyMutexed  :: [SBool]
  \              -> SBool\n\n    These functions, while can be directly coded in SBV,
  produce better\n    translations to SMTLib for more efficient solving of cardinality
  constraints.\n    Currently, only Z3 supports pseudo-booleans directly. For all
  other solvers,\n    SBV will translate these to equivalent terms that do not require
  special\n    functions.\n\n  * The function getModel has been renamed to getAssignment.
  (The former name is\n    now available as a query command.)\n\n  * Export `SolverCapabilities`
  from `Data.SBV.Internals`, in case users want access.\n\n  * Move code-generation
  facilities to `Data.SBV.Tools.CodeGen`, no longer exporting\n    the relevant functions
  directly from `Data.SBV`. This could break existing code,\n    but the fix should
  be as simple as `import Data.SBV.Tools.CodeGen`.\n\n  * Move the following two functions
  to `Data.SBV.Internals`:\n\n         compileToSMTLib\n         generateSMTBenchmarks\n\n
  \   If you use them, please `import Data.SBV.Internals`.\n\n  * Reorganized `EqSymbolic`
  and `EqOrd` classes to collect some of the\n    similarly named function together.
  Users should see no impact due to this change.\n\n\n### Version 6.0, 2017-05-07\n\n
  \ * This is a backwards compatibility breaking release, hence the major version\n
  \   bump from 5.15 to 6.0:\n\n       - Most of existing code should work with no
  changes.\n       - Old code relying on some features might require extra imports,\n
  \        since we no longer export some functionality directly from `Data.SBV`.\n
  \        This was done in order to reduce the number of exported items to\n         avoid
  extra clutter.\n       - Old optimization features are removed, as the new and much
  improved\n         capabilities should be used instead.\n\n  * The next two bullets
  cover new features in SBV regarding optimization, based\n    on the capabilities
  of the z3 SMT solver. With this release SBV gains the\n    capability optimize objectives,
  and solve MaxSAT problems; by appropriately\n    employing the corresponding capabilities
  in z3. A good review of these features\n    as implemented by Z3, and thus what
  is available in SBV is given in this\n    paper: http://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/nbjorner-scss2014.pdf\n\n
  \ * SBV now allows for  real or integral valued metrics. Goals can be lexicographically\n
  \   (default), independently, or pareto-front optimized. Currently, only the z3
  backend\n    supports optimization routines.\n\n    Optimization can be done over
  bit-vector, real, and integer goals. The relevant\n    functions are:\n\n        -
  `minimize`: Minimize a given arithmetic goal\n        - `maximize`: Minimize a given
  arithmetic goal\n\n    For instance, a call of the form\n\n         minimize \"name-of-goal\"
  $ x + 2*y\n\n    Minimizes the arithmetic goal x+2*y, where x and y can be bit-vectors,
  reals,\n    or integers. Such goals will be lexicographically optimized, i.e., in
  the order\n    given. If there are multiple goals, then user can also ask for independent\n
  \   optimization results, or pareto-fronts.\n\n    Once the objectives are given,
  a top level call to `optimize` (similar to `prove`\n    and `sat`) performs the
  optimization.\n\n  * SBV now implements soft-asserts. A soft assertion is a hint
  to the SMT solver that\n    we would like a particular condition to hold if *possible*.
  That is, if there is\n    a solution satisfying it, then we would like it to hold.
  However, if the set of\n    constraints is unsatisfiable, then a soft-assertion
  can be violated by incurring\n    a user-given numeric penalty to satisfy the remaining
  constraints. The solver then\n    tries to minimize the penalty, i.e., satisfy as
  many of the soft-asserts as possible\n    such that the total penalty for those
  that are not satisfied is minimized.\n\n    Note that `assertSoft` works well with
  optimization goals (minimize/maximize etc.),\n    and are most useful when we are
  optimizing a metric and thus some of the constraints\n    can be relaxed with a
  penalty to obtain a good solution.\n\n  * SBV no longer provides the old optimization
  routines, based on iterative and quantifier\n    based methods. Those methods were
  rarely used, and are now superseded by the above\n    mechanism. If the old code
  is needed, please contact for help: They can be resurrected\n    in your own code
  if absolutely necessary.\n\n  * (NB. This feature is deprecated in 7.0, see above
  for its replacement.)\n    SBV now implements tactics, which allow the user to navigate
  the proof process.\n    This is an advanced feature that most users will have no
  need of, but can become\n    handy when dealing with complicated problems. Users
  can, for instance, implement\n    case-splitting in a proof to guide the underlying
  solver through. Here is the list\n    of tactics implemented:\n\n        - `CaseSplit`
  \        : Case-split, with implicit coverage. Bool says whether we should be verbose.\n
  \       - `CheckCaseVacuity`  : Should the case-splits be checked for vacuity? (Default:
  True.)\n        - `ParallelCase`      : Run case-splits in parallel. (Default: Sequential.)\n
  \       - `CheckConstrVacuity`: Should constraints be checked for vacuity? (Default:
  False.)\n        - `StopAfter`         : Time-out given to solver, in seconds.\n
  \       - `CheckUsing`        : Invoke with check-sat-using command, instead of
  check-sat\n        - `UseLogic`          : Use this logic, a custom one can be specified
  too\n        - `UseSolver`         : Use this solver (z3, yices, etc.)\n        -
  `OptimizePriority`  : Specify priority for optimization: Lexicographic (default),
  Independent, or Pareto.\n\n  * Name-space clean-up. The following modules are no
  longer automatically exported\n    from Data.SBV:\n\n        - `Data.SBV.Tools.ExpectedValue`
  (computing with expected values)\n        - `Data.SBV.Tools.GenTest` (test case
  generation)\n        - `Data.SBV.Tools.Polynomial` (polynomial arithmetic, CRCs
  etc.)\n        - `Data.SBV.Tools.STree` (full symbolic binary trees)\n\n    To use
  the functionality of these modules, users must now explicitly import the corresponding\n
  \   module. Not other changes should be needed other than the explicit import.\n\n
  \ * Changed the signatures of:\n\n          isSatisfiableInCurrentPath :: SBool
  -> Symbolic Bool\n        svIsSatisfiableInCurrentPath :: SVal  -> Symbolic Bool\n\n
  \   to:\n\n          isSatisfiableInCurrentPath :: SBool -> Symbolic (Maybe SatResult)\n
  \       svIsSatisfiableInCurrentPath :: SVal  -> Symbolic (Maybe SatResult)\n\n
  \   which returns the result in case of SAT. This is more useful than before. This
  is\n    backwards-compatibility breaking, but is more useful. (Requested by Jared
  Ziegler.)\n\n  * Add instance `Provable (Symbolic ())`, which simply stands for
  returning true\n    for proof/sat purposes. This allows for simpler coding, as constrain/minimize/maximize\n
  \   calls (which return unit) can now be directly sat/prove processed, without needing\n
  \   a final call to return at the end.\n\n  * Add type synonym `Goal` (for `Symbolic
  ()`), in order to simplify type signatures\n\n  * SBV now properly adds check-sat
  commands and other directives in debugging output.\n\n  * New examples:\n      -
  Data.SBV.Examples.Optimization.LinearOpt: Simple linear-optimization example.\n
  \     - Data.SBV.Examples.Optimization.Production: Scheduling machines in a shop\n
  \     - Data.SBV.Examples.Optimization.VM: Scheduling virtual-machines in a data-center\n\n###
  Version 5.15, 2017-01-30\n\n  * Bump up dependency on CrackNum >= 1.9, to get access
  to hexadecimal floats.\n  * Improve time/tracking-print code. Thanks to Iavor Diatchki
  for the patch.\n\n### Version 5.14, 2017-01-12\n\n  * Bump up QuickCheck dependency
  to >= 2.9.2 to avoid the following quick-check\n    bug <http://github.com/nick8325/quickcheck/issues/113>,
  which transitively impacted\n    the quick-check as implemented by SBV.\n\n  * Generalize
  casts between integral-floats, using the rounding mode round-nearest-ties-to-even.\n
  \   Previously calls to sFromIntegral did not support conversion to floats since
  it needed\n    a rounding mode. But it does make sense to support them with the
  default mode. If a different\n    mode is needed, use the function 'toSFloat' as
  before, which takes an explicit rounding mode.\n\n### Version 5.13, 2016-10-29\n\n
  \ * Fix broken links, thanks to Stephan Renatus for the patch.\n\n  * Code generation:
  Create directory path if it does not exist. Thanks to Robert Dockins\n    for the
  patch.\n\n  * Generalize the type of sFromIntegral, dropping the Bits requirement.
  In turn, this\n    allowed us to remove sIntegerToSReal, since sFromIntegral can
  be used instead.\n\n  * Add support for sRealToSInteger. (Essentially the floor
  function for SReal.)\n\n  * Several space-leaks fixed for better performance. Patch
  contributed by Robert Dockins.\n\n  * Improved Random instance for Rational. Thanks
  to Joe Leslie-Hurd for the idea.\n\n### Version 5.12, 2016-06-06\n\n  * Fix GHC8.0
  compilation issues, and warning clean-up. Thanks to Adam Foltzer for the bulk\n
  \   of the work and Tom Sydney Kerckhove for the initial patch for 8.0 compatibility.\n\n
  \ * Minor fix to printing models with floats when the base is 2/16, making sure
  the alignment\n    is done properly accommodating for the crackNum output.\n\n  *
  Wait for external process to die on exception, to avoid spawning zombies. Thanks
  to\n    Daniel Wagner for the patch.\n\n  * Fix hash-consed arrays: Previously we
  were caching based only on elements, which is not\n    sufficient as you can have
  conflicts differing only on the address type, but same contents.\n    Thanks to
  Brian Huffman for reporting and the corresponding patch.\n\n### Version 5.11, 2016-01-15\n\n
  \ * Fix documentation issue; no functional changes\n\n### Version 5.10, 2016-01-14\n\n
  \ * Documentation: Fix a bunch of dead http links. Thanks to Andres Sicard-Ramirez\n
  \   for reporting.\n\n  * Additions to the Dynamic API:\n\n       * svSetBit                  :
  set a given bit\n       * svBlastLE, svBlastBE      : Bit-blast to big/little endian\n
  \      * svWordFromLE, svWordFromBE: Unblast from big/little endian\n       * svAddConstant
  \            : Add a constant to an SVal\n       * svIncrement, svDecrement  : Add/subtract
  1 from an SVal\n\n### Version 5.9, 2016-01-05\n\n  * Default definition for 'symbolicMerge',
  which allows types that are\n    instances of 'Generic' to have an automatically
  derivable merge (i.e.,\n    ite) instance. Thanks to Christian Conkle for the patch.\n\n
  \ * Add support for \"non-model-vars,\" where we can now tell SBV not\n    to take
  into account certain variables from a model-building\n    perspective. This comes
  handy in doing an `allSat` calls where\n    there might be witness variables that
  we do not care the uniqueness\n    for. See `Data/SBV/Examples/Misc/Auxiliary.hs`
  for an example, and\n    the discussion in http://github.com/LeventErkok/sbv/issues/208
  for\n    motivation.\n\n  * Yices interface: If Reals are used, then pick the logic
  QF_UFLRA, instead\n    of QF_AUFLIA. Unfortunately, logic selection remains tricky
  since the SMTLib\n    story for logic selection is rather messy. Other solvers are
  not impacted\n    by this change.\n\n### Version 5.8, 2016-01-01\n\n  * Fix some
  typos\n  * Add 'svEnumFromThenTo' to the Dynamic interface, allowing dynamic construction\n
  \   of [x, y .. z] and [x .. y] when the involved values are concrete.\n  * Add
  'svExp' to the Dynamic interface, implementing exponentiation\n\n### Version 5.7,
  2015-12-21\n\n  * Export `HasKind(..)` from the Dynamic interface. Thanks to Adam
  Foltzer for the patch.\n  * More careful handling of SMT-Lib reserved names.\n  *
  Update tested version of MathSAT to 5.3.9\n  * Generalize `sShiftLeft`/`sShiftRight`/`sRotateLeft`/`sRotateRight`
  to work with signed\n    shift/rotate amounts, where negative values revert the
  direction. Similar\n    generalizations are also done for the dynamic variants.\n\n###
  Version 5.6, 2015-12-06\n\n  * Minor changes to how we print models:\n  * Align
  by the type\n  * Always print the type (previously we were skipping for Bool)\n\n
  \ * Rework how SBV properties are quick-checked; much more usable and robust\n\n
  \ * Provide a function `sbvQuickCheck`, which is essentially the same as\n    quickCheck,
  except it also returns a boolean. Useful for the\n    programmable API. (The dynamic
  version is called `svQuickCheck`.)\n\n  * Several changes/additions in support of
  the sbvPlugin development:\n  * Data.SBV.Dynamic: Define/export `svFloat`/`svDouble`/`sReal`/`sNumerator`/`sDenominator`\n
  \ * Data.SBV.Internals: Export constructors of `Result`, `SMTModel`,\n    and the
  function `showModel`\n  * Simplify how Uninterpreted-types are internally represented.\n\n###
  Version 5.5, 2015-11-10\n\n  * This is essentially the same release as 5.4 below,
  except to allow SBV compile\n    with GHC 7.8 series. Thanks to Adam Foltzer for
  the patch.\n\n### Version 5.4, 2015-11-09\n\n  * Add 'sAssert', which allows users
  to pepper their code with boolean conditions, much like\n    the usual ASSERT calls.
  Note that the semantics of an 'sAssert' is that it is a NOOP, i.e.,\n    it simply
  returns its final argument. Use in coordination with 'safe' and 'safeWith', see
  below.\n\n  * Implement 'safe' and 'safeWith', which statically determine all calls
  to 'sAssert'\n    being safe to execute. Any violations will be flagged.\n\n  *
  SBV->C: Translate 'sAssert' calls to dynamic checks in the generated C code. If
  this is\n    not desired, use the 'cgIgnoreSAssert' function to turn it off.\n\n
  \ * Add 'isSafe': Which converts a 'SafeResult' to a 'Bool', when we are only interested\n
  \   in a boolean result.\n\n  * Add Data/SBV/Examples/Misc/NoDiv0 to demonstrate
  the use of the 'safe' function.\n\n### Version 5.3, 2015-10-20\n\n  * Main point
  of this release to make SBV compile with GHC 7.8 again, to accommodate mainly\n
  \   for Cryptol. As Cryptol moves to GHC >= 7.10, we intend to remove the \"compatibility\"
  changes\n    again. Thanks to Adam Foltzer for the patch.\n\n  * Minor mods to how
  bitvector equality/inequality are translated to SMTLib. No user visible\n    impact.\n\n###
  Version 5.2, 2015-10-12\n\n  * Regression on 5.1: Fix a minor bug in base 2/16 printing
  where uninterpreted constants were\n    not handled correctly.\n\n### Version 5.1,
  2015-10-10\n\n  * fpMin, fpMax: If these functions receive +0/-0 as their two arguments,
  i.e., both\n    zeros but alternating signs in any order, then SMTLib requires the
  output to be\n    nondeterministically chosen. Previously, we fixed this result
  as +0 following the\n    interpretation in Z3, but Z3 recently changed and now incorporates
  the nondeterministic\n    output. SBV similarly changed to allow for non-determinism
  here.\n\n  * Change the types of the following Floating-point operations:\n\n        *
  sFloatAsSWord32, sFloatAsSWord32, blastSFloat, blastSDouble\n\n    These were previously
  coded as relations, since NaN values were not representable\n    in the target domain
  uniquely. While it was OK, it was hard to use them. We now\n    simply implement
  these as functions, and they are underspecified if the inputs\n    are NaNs: In
  those cases, we simply get a symbolic output. The new types are:\n\n       * sFloatAsSWord32
  \ :: SFloat  -> SWord32\n       * sDoubleAsSWord64 :: SDouble -> SWord64\n       *
  blastSFloat      :: SFloat  -> (SBool, [SBool], [SBool])\n       * blastSDouble
  \    :: SDouble -> (SBool, [SBool], [SBool])\n\n  * MathSAT backend: Use the SMTLib
  interpretation of fp.min/fp.max by passing the\n    \"-theory.fp.minmax_zero_mode=4\"
  argument explicitly.\n\n  * Fix a bug in hash-consing of floating-point constants,
  where we were confusing +0 and\n    -0 since we were using them as keys into the
  map though they compare equal. We now\n    explicitly keep track of the negative-zero
  status to make sure this confusion does\n    not arise. Note that this bug only
  exhibited itself in rare occurrences of both\n    constants being present in a benchmark;
  a true corner case. Note that @NaN@ values\n    are also interesting in this context:
  Since NaN /= NaN, we never hash-cons floating\n    point constants that have the
  value NaN. But that is actually OK; it is a bit wasteful\n    in case you have a
  lot of NaN constants around, but there is no soundness issue: We\n    just waste
  a little bit of space.\n\n  * Remove the functions `allSatWithAny` and `allSatWithAll`.
  These two variants do *not*\n    make sense when run with multiple solvers, as they
  internally sequentialize the solutions\n    due to the nature of `allSat`. Not really
  needed anyhow; so removed. The variants\n    `satWithAny/All` and `proveWithAny/All`
  are still available.\n\n  * Export SMTLibVersion from the library, forgotten export
  needed by Cryptol. Thanks to Adam\n    Foltzer for the patch.\n\n  * Slightly modify
  model-outputs so the variables are aligned vertically. (Only matters\n    if we
  have model-variable names that are of differing length.)\n\n  * Move to Travis-CI
  \"docker\" based infrastructure for builds\n\n  * Enable local builds to use the
  Herbie plugin. Currently SBV does not have any\n    expressions that can benefit
  from Herbie, but it is nice to have this support in general.\n\n### Version 5.0,
  2015-09-22\n\n  * Note: This is a backwards-compatibility breaking release, see
  below for details.\n\n  * SBV now requires GHC 7.10.1 or newer to be compiled, taking
  advantage of newer features/bug-fixes\n    in GHC. If you really need SBV to compile
  with older GHCs, please get in touch.\n\n  * SBV no longer supports SMTLib1. We
  now exclusively use SMTLib2 for communicating with backend\n    solvers. Strictly
  speaking, this means some loss in functionality: Uninterpreted-function models\n
  \   that we supported via Yices-1 are no longer available. In practice this facility
  was not really\n    used, and required a very old version of Yices that was no longer
  supported by SRI and has\n    lacked in other features. So, in reality this change
  should hardly matter for end-users.\n\n  * Added function `label`, which is useful
  in emitting comments around expressions. It is essentially\n    a no-op, but does
  generate a comment with the given text in the SMT-Lib and C output, for diagnostic\n
  \   purposes.\n\n  * Added `sFromIntegral`: Conversions from all integral types
  (SInteger, SWord/SInts) between\n    each other. Similar to the `fromIntegral` function
  of Haskell. These generate simple casts when\n    used in code-generation to C,
  and thus are very efficient.\n\n  * SBV no longer supports the functions sBranch/sAssert,
  as we realized these functions can cause\n    soundness issues under certain conditions.
  While the triggering scenarios are not common use-cases\n    for these functions,
  we are opting for safety, and thus removing support. See\n    http://github.com/LeventErkok/sbv/issues/180
  for details; and see below for the new function\n    'isSatisfiableInCurrentPath'.\n\n
  \ * A new function 'isSatisfiableInCurrentPath' is added, which checks for satisfiability
  during a\n    symbolic simulation run. This function can be used as the basis of
  sBranch/sAssert like functionality\n    if needed. The difference is that this is
  a much lower level call, and also exposes the fact that\n    the result is in the
  'Symbolic' monad (which avoids the soundness issue). Of course, the new type\n    makes
  it less useful as it will not be a drop-in replacement for if-then-else like structure.
  Intended\n    to be used by tools built on top of SBV, as opposed to end-users.\n\n
  \ * SBV no longer implements the 'SignCast' class, as its functionality is replaced
  by the 'sFromIntegral'\n    function. Programs using the functions 'signCast' and
  'unsignCast' should simply replace both\n    with calls to 'sFromIntegral'. (Note
  that extra type-annotations might be necessary, similar to\n    the uses of the
  'fromIntegral' function in Haskell.)\n\n  * Backend solver related changes:\n\n
  \      * Yices: Upgraded to work with Yices release 2.4.1. Note that earlier versions
  of Yices\n         are *not* supported.\n\n       * Boolector: Upgraded to work
  with new Boolector release 2.0.7. Note that earlier versions\n         of Boolector
  are *not* supported.\n\n       * MathSAT: Upgraded to work with latest release 5.3.7.
  Note that earlier versions of MathSAT\n         are *not* supported (due to a buffering
  issue in MathSAT itself.)\n\n       * MathSAT: Enabled floating-point support in
  MathSAT.\n\n  * New examples:\n\n       * Add Data.SBV.Examples.Puzzles.Birthday,
  which solves the Cheryl-Birthday problem that\n         went viral in April 2015.
  Turns out really easy to solve for SMT, but the formalization\n         of the problem
  is still interesting as an exercise in formal reasoning.\n\n       * Add Data.SBV.Examples.Puzzles.SendMoreMoney,
  which solves the classic send + more = money\n         problem. Really a trivial
  example, but included since it is pretty much the hello-world for\n         basic
  constraint solving.\n\n       * Add Data.SBV.Examples.Puzzles.Fish, which solves
  a typical logic puzzle; finding the unique\n         solution to a set of assertions
  made about a bunch of people, their pets, beverage choices,\n         etc. Not particularly
  interesting, but could be fun to play around with for modeling purposes.\n\n       *
  Add Data.SBV.Examples.BitPrecise.MultMask, which demonstrates the use of the bitvector\n
  \        solver to an interesting bit-shuffling problem.\n\n  * Rework floating-point
  arithmetic, and add missing floating-point operations:\n\n      * fpRem            :
  remainder\n      * fpRoundToIntegral: truncating round\n      * fpMin            :
  min\n      * fpMax            : max\n      * fpIsEqualObject  : FP equality as object
  (i.e., NaN equals NaN, +0 does not equal -0, etc.)\n\n    This brings SBV up-to
  par with everything supported by the SMT-Lib FP theory.\n\n  * Add the IEEEFloatConvertable
  class, which provides conversions to/from Floats and other types. (i.e.,\n    value
  conversions from all other types to Floats and Doubles; and back.)\n\n  * Add SWord32/SWord64
  to/from SFloat/SDouble conversions, as bit-pattern reinterpretation; using the\n
  \   IEEE754 interchange format. The functions are: sWord32AsSFloat, sWord64AsSDouble,
  sFloatAsSWord32,\n    sDoubleAsSWord64. Note that the sWord32AsSFloat and sWord64ToSDouble
  are regular functions, but\n    sFloatToSWord32 and sDoubleToSWord64 are \"relations\",
  since NaN values are not uniquely convertible.\n\n  * Add 'sExtractBits', which
  takes a list of indices to extract bits from, essentially\n    equivalent to 'map
  sTestBit'.\n\n  * Rename a set of symbolic functions for consistency. Here are the
  old/new names:\n\n     * sbvTestBit               --> sTestBit\n     * sbvPopCount
  \             --> sPopCount\n     * sbvShiftLeft             --> sShiftLeft\n     *
  sbvShiftRight            --> sShiftRight\n     * sbvRotateLeft            --> sRotateLeft\n
  \    * sbvRotateRight           --> sRotateRight\n     * sbvSignedShiftArithRight
  --> sSignedShiftArithRight\n\n  * Rename all FP recognizers to be in sync with FP
  operations. Here are the old/new names:\n\n     * isNormalFP       --> fpIsNormal\n
  \    * isSubnormalFP    --> fpIsSubnormal\n     * isZeroFP         --> fpIsZero\n
  \    * isInfiniteFP     --> fpIsInfinite\n     * isNaNFP          --> fpIsNaN\n
  \    * isNegativeFP     --> fpIsNegative\n     * isPositiveFP     --> fpIsPositive\n
  \    * isNegativeZeroFP --> fpIsNegativeZero\n     * isPositiveZeroFP --> fpIsPositiveZero\n
  \    * isPointFP        --> fpIsPoint\n\n  * Lots of other work around floating-point,
  test cases, reorg, etc.\n\n  * Introduce shorter variants for rounding modes: sRNE,
  sRNA, sRTP, sRTN, sRTZ;\n    aliases for sRoundNearestTiesToEven, sRoundNearestTiesToAway,
  sRoundTowardPositive,\n    sRoundTowardNegative, and sRoundTowardZero; respectively.\n\n###
  Version 4.4, 2015-04-13\n\n  * Hook-up crackNum package; so counter-examples involving
  floats and\n    doubles can be printed in detail when the printBase is chosen to
  be\n    2 or 16. (With base 10, we still get the simple output.)\n\n      ```\n
  \     Prelude Data.SBV> satWith z3{printBase=2} $ \\x -> x .== (2::SFloat)\n      Satisfiable.
  Model:\n        s0 = 2.0 :: Float\n                        3  2          1         0\n
  \                       1 09876543 21098765432109876543210\n                        S
  ---E8--- ----------F23----------\n                Binary: 0 10000000 00000000000000000000000\n
  \                  Hex: 4000 0000\n             Precision: SP\n                  Sign:
  Positive\n              Exponent: 1 (Stored: 128, Bias: 127)\n                 Value:
  +2.0 (NORMAL)\n      ```\n\n  * Change how we print type info; for models instead
  of SType just print Type (i.e.,\n    for SWord8, instead print Word8) which makes
  more sense and is more consistent.\n    This change should be mostly relevant as
  how we see the counter-example output.\n\n  * Fix long standing bug #75, where we
  now support arrays with Boolean source/targets.\n    This is not a very commonly
  used case, but by letting the solver pick the logic,\n    we now allow arrays to
  be uniformly supported.\n\n### Version 4.3, 2015-04-10\n\n  * Introduce Data.SBV.Dynamic,
  by Brian Huffman. This is mostly an internal\n    reorg of the SBV codebase, and
  end-users should not be impacted by the\n    changes. The introduction of the Dynamic
  SBV variant (i.e., one that does\n    not mandate a phantom type as in `SBV Word8`
  etc. allows library writers\n    more flexibility as they deal with arbitrary bit-vector
  sizes. The main\n    customer of these changes are the Cryptol language and the
  associated\n    toolset, but other developers building on top of SBV can find it
  useful\n    as well. NB: The \"strongly-typed\" aspect of SBV is still the main
  way\n    end-users should interact with SBV, and nothing changed in that respect!\n\n
  \ * Add symbolic variants of floating-point rounding-modes for convenience\n\n  *
  Rename toSReal to sIntegerToSReal, which captures the intent more clearly\n\n  *
  Code clean-up: remove mbMinBound/mbMaxBound thus allowing less calls to\n    unliteral.
  Contributed by Brian Huffman.\n\n  * Introduce FP conversion functions:\n\n       *
  Between SReal and SFloat/SDouble\n           * fpToSReal\n           * sRealToSFloat\n
  \          * sRealToSDouble\n       * Between SWord32 and SFloat\n           * sWord32ToSFloat\n
  \          * sFloatToSWord32\n       * Between SWord64 and SDouble. (Relational,
  due to non-unique NaNs)\n           * sWord64ToSDouble\n       * sDoubleToSWord64\n
  \      * From float to sign/exponent/mantissa fields: (Relational, due to non-unique
  NaNs)\n           * blastSFloat\n           * blastSDouble\n\n  * Rework floating
  point classifiers. Remove isSNaN and isFPPoint (both renamed),\n    and add the
  following new recognizers:\n\n       * isNormalFP\n       * isSubnormalFP\n       *
  isZeroFP\n       * isInfiniteFP\n       * isNaNFP\n       * isNegativeFP\n       *
  isPositiveFP\n       * isNegativeZeroFP\n       * isPositiveZeroFP\n       * isPointFP
  (corresponds to a real number, i.e., neither NaN nor infinity)\n\n  * Re-implement
  sbvTestBit, by Brian Huffman. This version is much faster at large\n    word sizes,
  as it avoids the costly mask generation.\n\n  * Code changes to suppress warnings
  with GHC7.10. General clean-up.\n\n### Version 4.2, 2015-03-17\n\n  * Add exponentiation
  (.^). Thanks to Daniel Wagner for contributing the code!\n\n  * Better handling
  of SBV_$SOLVER_OPTIONS, in particular keeping track of\n    proper quoting in environment
  variables. Thanks to Adam Foltzer for\n    the patch!\n\n  * Silence some hlint/ghci
  warnings. Thanks to Trevor Elliott for the patch!\n\n  * Haddock documentation fixes,
  improvements, etc.\n\n  * Change ABC default option string to %blast; \"&sweep -C
  5000; &syn4; &cec -s -m -C 2000\"\n    which seems to give good results. Use SBV_ABC_OPTIONS
  environment variable (or\n    via abc.rc file and a combination of SBV_ABC_OPTIONS)
  to experiment.\n\n### Version 4.1, 2015-03-06\n\n  * Add support for the ABC solver
  from Berkeley. Thanks to Adam Foltzer\n    for the required infrastructure! See:
  https://github.com/berkeley-abc/abc\n    And Alan Mishchenko for adding infrastructure
  to ABC to work with SBV.\n\n  * Upgrade the Boolector connection to use a SMT-Lib2
  based interaction. NB. You\n    need at least Boolector 2.0.6 installed!\n\n  *
  Tracking changes in the SMT-Lib floating-point theory. If you are\n    using symbolic
  floating-point types (i.e., SFloat and SDouble), then\n    you should upgrade to
  this version and also get a very latest (unstable)\n    Z3 release. See https://smt-lib.org/theories-FloatingPoint.shtml\n
  \   for details.\n\n  * Introduce a new class, 'RoundingFloat', which supports floating-point\n
  \   operations with arbitrary rounding-modes. Note that Haskell only allows\n    RoundNearestTiesToAway,
  but with SBV, we get all 5 IEEE754 rounding-modes\n    and all the basic operations
  ('fpAdd', 'fpMul', 'fpDiv', etc.) with these\n    modes.\n\n  * Allow Floating-Point
  RoundingMode to be symbolic as well\n\n  * Improve the example `Data/SBV/Examples/Misc/Floating.hs`
  to include\n    rounding-mode based addition example.\n\n  * Changes required to
  make SBV compile with GHC 7.10; mostly around instance\n    NFData declarations.
  Thanks to Iavor Diatchki for the patch.\n\n  * Export a few extra symbols from the
  Internals module (mainly for\n    Cryptol usage.)\n\n### Version 4.0, 2015-01-22\n\nThis
  release mainly contains contributions from Brian Huffman, allowing\nend-users to
  define new symbolic types, such as Word4, that SBV does not\nnatively support. When
  GHC gets type-level literals, we shall most likely\nincorporate arbitrary bit-sized
  vectors and ints using this mechanism,\nbut in the interim, this release provides
  a means for the users to introduce\nindividual instances.\n\n  * Modifications to
  support arbitrary bit-sized vectors;\n    These changes have been contributed by
  Brian Huffman\n    of Galois. Thanks Brian.\n  * A new example `Data/SBV/Examples/Misc/Word4.hs`
  showing\n    how users can add new symbolic types.\n  * Support for rotate-left/rotate-right
  with variable\n    rotation amounts. (From Brian Huffman.)\n\n### Version 3.5, 2015-01-15\n\nThis
  release is mainly adding support for enumerated types in Haskell being\ntranslated
  to their symbolic counterparts; instead of going completely\nuninterpreted.\n\n
  \ * Keep track of data-type details for uninterpreted sorts.\n  * Rework the U2Bridge
  example to use enumerated types.\n  * The \"Uninterpreted\" name no longer makes
  sense with this change, so\n    rework the relevant names to ensure proper internal
  naming.\n  * Add Data/SBV/Examples/Misc/Enumerate.hs as an example for demonstrating\n
  \   how enumerations are translated.\n  * Fix a long-standing bug in the implementation
  of select when\n    translated as SMT-Lib tables. (Github issue #103.) Thanks to\n
  \   Brian Huffman for reporting.\n\n### Version 3.4, 2014-12-21\n\n  * This release
  is mainly addressing floating-point changes in SMT-Lib.\n\n      * Track changes
  in the QF_FPA logic standard; new constants and alike. If you are\n        using
  the floating-point logic, then you need a relatively new version of Z3\n        installed
  (4.3.3 or newer).\n\n      * Add unary-negation as an explicit operator. Previously,
  we merely used the \"0-x\"\n        semantics; but with floating point, this does
  not hold as 0-0 is 0, and is not -0!\n        (Note that negative-zero is a valid
  floating point value, that is different than\n        positive-zero; yet it compares
  equal to it. Sigh..)\n\n      * Similarly, add abs as a native method; to make sure
  we map it to fp.abs for\n        floating point values.\n\n      * Test suite improvements\n\n###
  Version 3.3, 2014-12-05\n\n  * Implement 'safe' and 'safeWith', which statically
  determine all calls to 'sAssert'\n    being safe to execute. This way, users can
  pepper their programs with liberal\n    calls to 'sAssert' and check they are all
  safe in one go without further worry.\n\n  * Robustify the interface to external
  solvers, by making sure we catch cases where\n    the external solver might exist
  but not be runnable (library dependency missing,\n    for example). It is impossible
  to be absolutely foolproof, but we now catch a\n    few more cases and fail gracefully.\n\n###
  Version 3.2, 2014-11-18\n\n  * Implement 'sAssert'. This adds conditional symbolic
  simulation, by ensuring arbitrary\n    boolean conditions hold during simulation;
  similar to ASSERT calls in other languages.\n    Note that failures will be detected
  at symbolic-simulation time, i.e., each assert will\n    generate a call to the
  external solver to ensure that the condition is never violated.\n    If violation
  is possible the user will get an error, indicating the failure conditions.\n\n  *
  Also implement 'sAssertCont' which allows for a programmatic way to extract/display
  results\n    for consumers of 'sAssert'. While the latter simply calls 'error' in
  case of an assertion\n    violation, the 'sAssertCont' variant takes a continuation
  which can be used to program\n    how the results should be interpreted/displayed.
  (This is useful for libraries built on top of\n    SBV.) Note that the type of the
  continuation is such that execution should still stop, i.e.,\n    once an assertion
  violation is detected, symbolic simulation will never continue.\n\n  * Rework/simplify
  the 'Mergeable' class to make sure 'sBranch' is sufficiently lazy\n    in case of
  structural merges. The original implementation was only\n    lazy at the Word instance,
  but not at lists/tuples etc. Thanks to Brian Huffman\n    for reporting this bug.\n\n
  \ * Add a few constant-folding optimizations for 'sDiv' and 'sRem'\n\n  * Boolector:
  Modify output parser to conform to the new Boolector output format. This\n    means
  that you need at least v2.0.0 of Boolector installed if you want to use that\n    particular
  solver.\n\n  * Fix long-standing translation bug regarding boolean Ord class comparisons.
  (i.e.,\n    'False > True' etc.) While Haskell allows for this, SMT-Lib does not;
  and hence\n    we have to be careful in translating. Thanks to Brian Huffman for
  reporting.\n\n  * C code generation: Correctly translate square-root and fusedMA
  functions to C.\n\n### Version 3.1, 2014-07-12\n\n NB: GHC 7.8.1 and 7.8.2 has a
  serious bug <http://ghc.haskell.org/trac/ghc/ticket/9078>\n     that causes SBV
  to crash under heavy/repeated calls. The bug is addressed\n     in GHC 7.8.3; so
  upgrading to GHC 7.8.3 is essential for using SBV!\n\n New features/bug-fixes in
  v3.1:\n\n * Using multiple-SMT solvers in parallel:\n      * Added functions that
  let the user run multiple solvers, using asynchronous\n        threads. All results
  can be obtained (proveWithAll, proveWithAny, satWithAll),\n        or SBV can return
  the fastest result (satWithAny, allSatWithAll, allSatWithAny).\n        These functions
  are good for playing with multiple-solvers, especially on\n        machines with
  multiple-cores.\n      * Add function: sbvAvailableSolvers; which returns the list
  of solvers currently\n        available, as installed on the machine we are running.
  (Not the list that SBV\n        supports, but those that are actually available
  at run-time.) This function\n        is useful with the multi-solve API.\n * Implement
  sBranch:\n      * sBranch is a variant of 'ite' that consults the external\n        SMT
  solver to see if a given branch condition is satisfiable\n        before evaluating
  it. This can make certain otherwise recursive\n        and thus not-symbolically-terminating
  inputs amenable to symbolic\n        simulation, if termination can be established
  this way. Needless\n        to say, this problem is always decidable as far as SBV
  programs\n        are concerned, but it does not mean the decision procedure is
  cheap!\n        Use with care.\n      * sBranchTimeOut config parameter can be used
  to curtail long runs when\n        sBranch is used. Of course, if time-out happens,
  SBV will\n        assume the branch is feasible, in which case symbolic-termination\n
  \       may come back to bite you.)\n * New API:\n      * Add predicate 'isSNaN'
  which allows testing 'SFloat'/'SDouble' values\n        for nan-ness. This is similar
  to the Prelude function 'isNaN', except\n        the Prelude version requires a
  RealFrac instance, which unfortunately is\n        not currently implementable for
  cases. (Requires trigonometric functions etc.)\n        Thus, we provide 'isSNaN'
  separately (along with the already existing\n        'isFPPoint') to simplify reasoning
  with floating-point.\n * Examples:\n     * Add Data/SBV/Examples/Misc/SBranch.hs,
  to illustrate the use of sBranch.\n * Bug fixes:\n     * Fix pipe-blocking issue,
  which exhibited itself in the presence of\n       large numbers of variables (>
  10K or so). See github issue #86. Thanks\n       to Philipp Meyer for the fine report.\n
  * Misc:\n     * Add missing SFloat/SDouble instances for SatModel class\n     *
  Explicitly support KBool as a kind, separating it from `KUnbounded False 1`.\n       Thanks
  to Brian Huffman for contributing the changes. This should have no\n       user-visible
  impact, but comes in handy for internal reasons.\n\n### Version 3.0, 2014-02-16\n\n
  * Support for floating-point numbers:\n      * Preliminary support for IEEE-floating
  point arithmetic, introducing\n        the types `SFloat` and `SDouble`. The support
  is still quite new,\n        and Z3 is the only solver that currently features a
  solver for\n        this logic. Likely to have bugs, both at the SBV level, and
  at the\n        Z3 level; so any bug reports are welcome!\n * New backend solvers:\n
  \     * SBV now supports MathSAT from Fondazione Bruno Kessler and\n        DISI-University
  of Trento. See: http://mathsat.fbk.eu/\n * Support all-sat calls in the presence
  of uninterpreted sorts:\n      * Implement better support for `allSat` in the presence
  of uninterpreted\n        sorts. Previously, SBV simply rejected running `allSat`
  queries\n        in the presence of uninterpreted sorts, since it was not possible\n
  \       to generate a refuting model. The model returned by the SMT solver\n        is
  simply not usable, since it names constants that is not visible\n        in a subsequent
  run. Eric Seidel came up with the idea that we can\n        actually compute equivalence
  classes based on a produced model, and\n        assert the constraint that the new
  model should disallow the previously\n        found equivalence classes instead.
  The idea seems to work well\n        in practice, and there is also an example program
  demonstrating\n        the functionality: Examples/Uninterpreted/UISortAllSat.hs\n
  * Programmable model extraction improvements:\n      * Add functions `getModelDictionary`
  and `getModelDictionaries`, which\n        provide low-level access to models returned
  from SMT solvers. Former\n        for `sat` and `prove` calls, latter for `allSat`
  calls. Together with\n        the exported utils from the `Data.SBV.Internals` module,
  this should\n        allow for expert users to dissect the models returned and do
  fancier\n        programming on top of SBV.\n      * Add `getModelValue`, `getModelValues`,
  `getModelUninterpretedValue`, and\n        `getModelUninterpretedValues`; which
  further aid in model value\n        extraction.\n * Other:\n      * Allow users
  to specify the SMT-Lib logic to use, if necessary. SBV will\n        still pick
  the logic automatically, but users can now override that choice.\n        Comes
  in handy when playing with custom logics.\n * Bug fixes:\n      * Address allsat-laziness
  issue (#78 in github issue tracker). Essentially,\n        simplify how all-sat
  is called so we can avoid calling the solver for\n        solutions that are not
  needed. Thanks to Eric Seidel for reporting.\n * Examples:\n      * Add Data/SBV/Examples/Misc/ModelExtract.hs
  as a simple example for\n        programmable model extraction and usage.\n      *
  Add Data/SBV/Examples/Misc/Floating.hs for some FP examples.\n      * Use the AUFLIA
  logic in Examples.Existentials.Diophantine which helps\n        z3 complete the
  proof quickly. (The BV logics take too long for this problem.)\n\n### Version 2.10,
  2013-03-22\n\n * Add support for the Boolector SMT solver\n    * See: https://boolector.github.io\n
  \   * Use `import Data.SBV.Bridge.Boolector` to use Boolector from SBV\n    * Boolector
  supports QF_BV (with an without arrays). In the last\n      SMT-Lib competition
  it won both bit-vector categories. It is definitely\n      worth trying it out for
  bitvector problems.\n * Changes to the library:\n    * Generalize types of `allDifferent`
  and `allEqual` to take\n      arbitrary EqSymbolic values. (Previously was just
  over SBV values.)\n    * Add `inRange` predicate, which checks if a value is bounded
  within\n      two others.\n    * Add `sElem` predicate, which checks for symbolic
  membership\n    * Add `fullAdder`: Returns the carry-over as a separate boolean
  bit.\n    * Add `fullMultiplier`: Returns both the lower and higher bits resulting\n
  \     from  multiplication.\n    * Use the SMT-Lib Bool sort to represent SBool,
  instead of bit-vectors of length 1.\n      While this is an under-the-hood mechanism
  that should be user-transparent, it\n      turns out that one can no longer write
  axioms that return booleans in a direct\n      way due to this translation. This
  change makes it easier to write axioms that\n      utilize booleans as there is
  now a 1-to-1 match. (Suggested by Thomas DuBuisson.)\n * Solvers changes:\n    *
  Z3: Update to the new parameter naming schema of Z3. This implies that\n      you
  need to have a really recent version of Z3 installed, something\n      in the Z3-4.3
  series.\n * Examples:\n    * Add Examples/Uninterpreted/Shannon.hs: Demonstrating
  Shannon expansion,\n      boolean derivatives, etc.\n * Bug-fixes:\n    * Gracefully
  handle the case if the backend-SMT solver does not put anything\n      in stdout.
  (Reported by Thomas DuBuisson.)\n    * Handle uninterpreted sort values, if they
  happen to be only created via\n      function calls, as opposed to being inputs.
  (Reported by Thomas DuBuisson.)\n\n### Version 2.9, 2013-01-02\n\n  * Add support
  for the CVC4 SMT solver from Stanford: <https://cvc4.github.io/>\n    NB. Z3 remains
  the default solver for SBV. To use CVC4, use the\n    *With variants of the interface
  (i.e., proveWith, satWith, ..)\n    by passing cvc4 as the solver argument. (Similarly,
  use 'yices'\n    as the argument for the *With functions for invoking yices.)\n
  \ * Latest release of Yices calls the SMT-Lib based solver executable\n    yices-smt.
  Updated the default value of the executable to have this\n    name for ease of use.\n
  \ * Add an extra boolean flag to compileToSMTLib and generateSMTBenchmarks\n    functions
  to control if the translation should keep the query as is\n    (for SAT cases),
  or negate it (for PROVE cases). Previously, this value\n    was hard-coded to do
  the PROVE case only.\n  * Add bridge modules, to simplify use of different solvers.
  You can now say:\n\n          import Data.SBV.Bridge.CVC4\n          import Data.SBV.Bridge.Yices\n
  \         import Data.SBV.Bridge.Z3\n\n    to pick the appropriate default solver.
  if you simply 'import Data.SBV', then\n    you will get the default SMT solver,
  which is currently Z3. The value\n    'defaultSMTSolver' refers to z3 (currently),
  and 'sbvCurrentSolver' refers\n    to the chosen solver as determined by the imported
  module. (The latter is\n    useful for modifying options to the SMT solver in an
  solver-agnostic way.)\n  * Various improvements to Z3 model parsing routines.\n\n###
  Version 2.8, 2012-11-29\n\n  * Rename the SNum class to SIntegral, and make it index
  over regular\n    types. This makes it much more useful, simplifying coding of\n
  \   polymorphic symbolic functions over integral types, which is\n    the common
  case.\n  * Add the functions:\n  * sbvShiftLeft\n  * sbvShiftRight\n    which can
  accommodate unsigned symbolic shift amounts. Note that\n    one cannot use the Haskell
  shiftL/shiftR functions from the Bits class since\n    they are hard-wired to take
  'Int' values as the shift amounts only.\n  * Add a new function 'sbvArithShiftRight',
  which is the same as\n    a shift-right, except it uses the MSB of the input as
  the bit to fill\n    in (instead of always filling in with 0 bits). Note that this
  is\n    the same as shiftRight for signed values, but differs from a shiftRight\n
  \   when the input is unsigned. (There is no Haskell analogue of this\n    function,
  as Haskell shiftR is always arithmetic for signed\n    types and logical for unsigned
  ones.) This variant is designed for\n    use cases when one uses the underlying
  unsigned SMT-Lib representation\n    to implement custom signed operations, for
  instance.\n  * Several typo fixes.\n\n### Version 2.7, 2012-10-21\n\n  * Add missing
  QuickCheck instance for SReal\n  * When dealing with concrete SReals, make sure
  to operate\n    only on exact algebraic reals on the Haskell side, leaving\n    true
  algebraic reals (i.e., those that are roots of polynomials\n    that cannot be expressed
  as a rational) symbolic. This avoids\n    issues with functions that we cannot implement
  directly on\n    the Haskell side, like exact square-roots.\n  * Documentation tweaks,
  typo fixes etc.\n  * Rename BVDivisible class to SDivisible; since SInteger\n    is
  also an instance of this class, and SDivisible is a\n    more appropriate name to
  start with. Also add sQuot and sRem\n    methods; along with sDivMod, sDiv, and
  sMod, with usual\n    semantics.\n  * Improve test suite, adding many constant-folding
  tests\n    and start using cabal based tests (--enable-tests option.)\n\n### Versions
  2.4, 2.5, and 2.6: Around mid October 2012\n\n  * Workaround issues related hackage
  compilation, in particular to the\n    problem with the new containers package release,
  which does provide\n    an NFData instance for sequences.\n  * Add explicit Num
  requirements when necessary, as the Bits class\n    no longer does this.\n  * Remove
  dependency on the hackage package strict-concurrency, as\n    hackage can no longer
  compile it due to some dependency mismatch.\n  * Add forgotten Real class instance
  for the type 'AlgReal'\n  * Stop putting bounds on hackage dependencies, as they
  cause\n    more trouble then they actually help. (See the discussion\n    here:
  <http://www.haskell.org/pipermail/haskell-cafe/2012-July/102352.html>.)\n\n### Version
  2.3, 2012-07-20\n\n  * Maintenance release, no new features.\n  * Tweak cabal dependencies
  to avoid using packages that are newer\n    than those that come with ghc-7.4.2.
  Apparently this is a no-no\n    that breaks many things, see the discussion in this
  thread:\n      http://www.haskell.org/pipermail/haskell-cafe/2012-July/102352.html\n
  \   In particular, the use of containers >= 0.5 is *not* OK until we have\n    a
  version of GHC that comes with that version.\n\n### Version 2.2, 2012-07-17\n\n
  \ * Maintenance release, no new features.\n  * Update cabal dependencies, in particular
  fix the\n    regression with respect to latest version of the\n    containers package.\n\n###
  Version 2.1, 2012-05-24\n\n * Library:\n    * Add support for uninterpreted sorts,
  together with user defined\n      domain axioms. See Data.SBV.Examples.Uninterpreted.Sort\n
  \     and Data.SBV.Examples.Uninterpreted.Deduce for basic examples of\n      this
  feature.\n    * Add support for C code-generation with SReals. The user picks\n
  \     one of 3 possible C types for the SReal type: CgFloat, CgDouble\n      or
  CgLongDouble, using the function cgSRealType. Naturally, the\n      resulting C
  program will suffer a loss of precision, as it will\n      be subject to IEE-754
  rounding as implied by the underlying type.\n    * Add toSReal :: SInteger -> SReal,
  which can be used to promote\n      symbolic integers to reals. Comes handy in mixed
  integer/real\n      computations.\n * Examples:\n    * Recast the dog-cat-mouse
  example to use the solver over reals.\n    * Add Data.SBV.Examples.Uninterpreted.Sort,
  and\n           Data.SBV.Examples.Uninterpreted.Deduce\n      for illustrating uninterpreted
  sorts and axioms.\n\n### Version 2.0, 2012-05-10\n\n  This is a major release of
  SBV, adding support for symbolic algebraic reals: SReal.\n  See http://en.wikipedia.org/wiki/Algebraic_number
  for details. In brief, algebraic\n  reals are solutions to univariate polynomials
  with rational coefficients. The arithmetic\n  on algebraic reals is precise, with
  no approximation errors. Note that algebraic reals\n  are a proper subset of all
  reals, in particular transcendental numbers are not\n  representable in this way.
  (For instance, \"sqrt 2\" is algebraic, but pi, e are not.)\n  However, algebraic
  reals is a superset of rationals, so SBV now also supports symbolic\n  rationals
  as well.\n\n  You *should* use Z3 v4.0 when working with real numbers. While the
  interface will\n  work with older versions of Z3 (or other SMT solvers in general),
  it uses Z3\n  root-obj construct to retrieve and query algebraic reals.\n\n  While
  SReal values have infinite precision, printing such values is not trivial since\n
  \ we might need an infinite number of digits if the result happens to be irrational.
  The\n  user controls printing precision, by specifying how many digits after the
  decimal point\n  should be printed. The default number of decimal digits to print
  is 10. (See the\n  'printRealPrec' field of SMT-solver configuration.)\n\n  The
  acronym SBV used to stand for Symbolic Bit Vectors. However, SBV has grown beyond\n
  \ bit-vectors, especially with the addition of support for SInteger and SReal types
  and\n  other code-generation utilities. Therefore, \"SMT Based Verification\" is
  now a better fit\n  for the expansion of the acronym SBV.\n\n  Other notable changes
  in the library:\n\n  * Add functions s[TYPE] and s[TYPE]s for each symbolic type
  we support (i.e.,\n    sBool, sBools, sWord8, sWord8s, etc.), to create symbolic
  variables of the\n    right kind.  Strictly speaking these are just synonyms for
  'free'\n    and 'mapM free' (plural versions), so they are not adding any additional\n
  \   power. Except, they are specialized at their respective types, and might be\n
  \   easier to remember.\n  * Add function solve, which is merely a synonym for (return
  . bAnd), but\n    it simplifies expressing problems.\n  * Add class SNum, which
  simplifies writing polymorphic code over symbolic values\n  * Increase haddock coverage
  metrics\n  * Major code refactoring around symbolic kinds\n  * SMTLib2: Emit \":produce-models\"
  call before setting the logic, as required\n    by the SMT-Lib2 standard. [Patch
  provided by arrowdodger on github, thanks!]\n\n  Bugs fixed:\n\n   * [Performance]
  Use a much simpler default definition for \"select\": While the\n     older version
  (based on binary search on the bits of the indexer) was correct,\n     it created
  unnecessarily big expressions. Since SBV does not have a notion\n     of concrete
  subwords, the binary-search trick was not bringing any advantage\n     in any case.
  Instead, we now simply use a linear walk over the elements.\n\n  Examples:\n\n   *
  Change dog-cat-mouse example to use SInteger for the counts\n   * Add merge-sort
  example: Data.SBV.Examples.BitPrecise.MergeSort\n   * Add diophantine solver example:
  Data.SBV.Examples.Existentials.Diophantine\n\n### Version 1.4, 2012-05-10\n\n   *
  Interim release for test purposes\n\n### Version 1.3, 2012-02-25\n\n  * Workaround
  cabal/hackage issue, functionally the same as release\n    1.2 below\n\n### Version
  1.2, 2012-02-25\n\n Library:\n\n  * Add a hook so users can add custom script segments
  for SMT solvers. The new\n    \"solverTweaks\" field in the SMTConfig data-type
  can be used for this purpose.\n    The need for this came about due to the need
  to workaround a Z3 v3.2 issue\n    detailed below:\n      http://stackoverflow.com/questions/9426420/soundness-issue-with-integer-bv-mixed-benchmarks\n
  \   As a consequence, mixed Integer/BV problems can cause soundness issues in Z3\n
  \   and does in SBV. Unfortunately, it is too severe for SBV to add the workaround\n
  \   option, as it slows down the solver as a side effect as well. Thus, we are\n
  \   making this optionally available if/when needed. (Note that the work-around\n
  \   should not be necessary with Z3 v3.3; which is not released yet.)\n  * Other
  minor clean-up\n\n### Version 1.1, 2012-02-14\n\n Library:\n\n  * Rename bitValue
  to sbvTestBit\n  * Add sbvPopCount\n  * Add a custom implementation of 'popCount'
  for the Bits class\n    instance of SBV (GHC >= 7.4.1 only)\n  * Add 'sbvCheckSolverInstallation',
  which can be used to check\n    that the given solver is installed and good to go.\n
  \ * Add 'generateSMTBenchmarks', simplifying the generation of\n    SMTLib benchmarks
  for offline sharing.\n\n### Version 1.0, 2012-02-13\n\n Library:\n\n  * Z3 is now
  the \"default\" SMT solver. Yices is still available, but\n    has to be specifically
  selected. (Use satWith, allSatWith, proveWith, etc.)\n  * Better handling of the
  pConstrain probability threshold for test\n    case generation and quickCheck purposes.\n
  \ * Add 'renderTest', which accompanies 'genTest' to render test\n    vectors as
  Haskell/C/Forte program segments.\n  * Add 'expectedValue' which can compute the
  expected value of\n    a symbolic value under the given constraints. Useful for
  statistical\n    analysis and probability computations.\n  * When saturating provable
  values, use forAll_ for proofs and forSome_\n    for sat/allSat. (Previously we
  were always using forAll_, which is\n    not incorrect but less intuitive.)\n  *
  add function:\n      extractModels :: SatModel a => AllSatResult -> [a]\n    which
  simplifies accessing allSat results greatly.\n\n Code-generation:\n\n  * add \"cgGenerateMakefile\"
  which allows the user to choose if SBV\n    should generate a Makefile. (default:
  True)\n\n Other\n\n  * Changes to make it compile with GHC 7.4.1.\n\n### Version
  0.9.24, 2011-12-28\n\n  Library:\n\n   * Add \"forSome,\" analogous to \"forAll.\"
  (The name \"exists\" would've\n     been better, but it's already taken.) This is
  not as useful as\n     one might think as forAll and forSome do not nest, as an
  inner\n     application of one pushes its argument to a Predicate, making\n     the
  outer one useless, but it is nonetheless useful by itself.\n   * Add a \"Modelable\"
  class, which simplifies model extraction.\n   * Add support for quick-check at the
  \"Symbolic SBool\" level. Previously\n     SBV only allowed functions returning
  SBool to be quick-checked, which\n     forced a certain style of coding. In particular
  with the addition\n     of quantifiers, the new coding style mostly puts the top-level\n
  \    expressions in the Symbolic monad, which were not quick-checkable\n     before.
  With new support, the quickCheck, prove, sat, and allSat\n     commands are all
  interchangeable with obvious meanings.\n   * Add support for concrete test case
  generation, see the genTest function.\n   * Improve optimize routines and add support
  for iterative optimization.\n   * Add \"constrain\", simplifying conjunctive constraints,
  especially\n     useful for adding constraints at variable generation time via\n
  \    forall/exists. Note that the interpretation of such constraints\n     is different
  for genTest and quickCheck functions, where constraints\n     will be used for appropriately
  filtering acceptable test values\n     in those two cases.\n   * Add \"pConstrain\",
  which probabilistically adds constraints. This\n     is useful for quickCheck and
  genTest functions for filtering acceptable\n     test values. (Calls to pConstrain
  will be rejected for sat/prove calls.)\n   * Add \"isVacuous\" which can be used
  to check that the constraints added\n     via constrain are satisfiable. This is
  useful to prevent vacuous passes,\n     i.e., when a proof is not just passing because
  the constraints imposed\n     are inconsistent. (Also added accompanying isVacuousWith.)\n
  \  * Add \"free\" and \"free_\", analogous to \"forall/forall_\" and \"exists/exists_\"\n
  \    The difference is that free behaves universally in a proof context, while\n
  \    it behaves existentially in a sat context. This allows us to express\n     properties
  more succinctly, since the intended semantics is usually this\n     way depending
  on the context. (i.e., in a proof, we want our variables\n     universal, in a sat
  call existential.) Of course, exists/forall are still\n     available when mixed
  quantifiers are needed, or when the user wants to\n     be explicit about the quantifiers.\n\n
  \ Examples\n\n   * Add Data/SBV/Examples/Puzzles/Coins.hs. (Shows the usage of \"constrain\".)\n\n
  \ Dependencies\n\n   * Bump up random package dependency to 1.0.1.1 (from 1.0.0.2)\n\n
  \ Internal\n\n   * Major reorganization of files to and build infrastructure to\n
  \    decrease build times and better layout\n   * Get rid of custom Setup.hs, just
  use simple build. The extra work\n     was not worth the complexity.\n\n### Version
  0.9.23, 2011-12-05\n\n  Library:\n\n   * Add support for SInteger, the type of signed
  unbounded integer\n     values. SBV can now prove theorems about unbounded numbers,\n
  \    following the semantics of Haskell Integer type. (Requires z3 to\n     be used
  as the backend solver.)\n   * Add functions 'optimize', 'maximize', and 'minimize'
  that can\n     be used to find optimal solutions to given constraints with\n     respect
  to a given cost function.\n   * Add 'cgUninterpret', which simplifies code generation
  when we want\n     to use an alternate definition in the target language (i.e.,
  C). This\n     is important for efficient code generation, when we want to\n     take
  advantage of native libraries available in the target platform.\n\n  Other:\n\n
  \  * Change getModel to return a tuple in the success case, where\n     the first
  component is a boolean indicating whether the model\n     is \"potential.\" This
  is used to indicate that the solver\n     actually returned \"unknown\" for the
  problem and the model\n     might therefore be bogus. Note that we did not need
  this before\n     since we only supported bounded bit-vectors, which has a decidable\n
  \    theory. With the addition of unbounded Integers and quantifiers, the\n     solvers
  can now return unknown. This should still be rare in practice,\n     but can happen
  with the use of non-linear constructs. (i.e.,\n     multiplication of two variables.)\n\n###
  Version 0.9.22, 2011-11-13\n\n  The major change in this release is the support
  for quantifiers. The\n  SBV library *no* longer assumes all variables are universals
  in a proof,\n  (and correspondingly existential in a sat) call. Instead, the user\n
  \ marks free-variables appropriately using forall/exists functions, and the\n  solver
  translates them accordingly. Note that this is a non-backwards\n  compatible change
  in sat calls, as the semantics of formulas is essentially\n  changing. While this
  is unfortunate, it is more uniform and simpler to understand\n  in general.\n\n
  \ This release also adds support for the Z3 solver, which is the main\n  SMT-solver
  used for solving formulas involving quantifiers. More formally,\n  we use the new
  AUFBV/ABV/UFBV logics when quantifiers are involved. Also,\n  the communication
  with Z3 is now done via SMT-Lib2 format. Eventually\n  the SMTLib1 connection will
  be severed.\n\n  The other main change is the support for C code generation with\n
  \ uninterpreted functions enabling users to interface with external\n  C functions
  defined elsewhere. See below for details.\n\n  Other changes:\n\n  Code:\n\n   *
  Change getModel, so it returns an Either value to indicate\n     something went
  wrong; instead of throwing an error\n   * Add support for computing CRCs directly
  (without needing\n     polynomial division).\n\n  Code generation:\n\n   * Add \"cgGenerateDriver\"
  function, which can be used to turn\n     on/off driver program generation. Default
  is to generate\n     a driver. (Issue \"cgGenerateDriver False\" to skip the driver.)\n
  \    For a library, a driver will be generated if any of the\n     constituent parts
  has a driver. Otherwise it will be skipped.\n   * Fix a bug in C code generation
  where \"Not\" over booleans were\n     incorrectly getting translated due to need
  for masking.\n   * Add support for compilation with uninterpreted functions. Users\n
  \    can now specify the corresponding C code and SBV will simply\n     call the
  \"native\" functions instead of generating it. This\n     enables interfacing with
  other C programs. See the functions:\n     cgAddPrototype, cgAddDecl, cgAddLDFlags\n\n
  \ Examples:\n\n   * Add CRC polynomial generation example via existentials\n   *
  Add USB CRC code generation example, both via polynomials and using the internal
  CRC functionality\n\n### Version 0.9.21, 2011-08-05\n\n Code generation:\n\n  *
  Allow for inclusion of user makefiles\n  * Allow for CCFLAGS to be set by the user\n
  \ * Other minor clean-up\n\n### Version 0.9.20, 2011-06-05\n\n  Regression on 0.9.19;
  add missing file to cabal\n\n### Version 0.9.19, 2011-06-05\n\n\n  * Add SignCast
  class for conversion between signed/unsigned\n    quantities for same-sized bit-vectors\n
  \ * Add full-binary trees that can be indexed symbolically (STree). The\n    advantage
  of this type is that the reads and writes take\n    logarithmic time. Suitable for
  implementing faster symbolic look-up.\n  * Expose HasSignAndSize class through Data.SBV.Internals\n
  \ * Many minor improvements, file re-orgs\n\nExamples:\n\n  * Add sentence-counting
  example\n  * Add an implementation of RC4\n\n### Version 0.9.18, 2011-04-07\n\nCode:\n\n
  \ * Re-engineer code-generation, and compilation to C.\n    In particular, allow
  arrays of inputs to be specified,\n    both as function arguments and output reference
  values.\n  * Add support for generation of generation of C-libraries,\n    allowing
  code generation for a set of functions that\n    work together.\n\nExamples:\n\n
  \ * Update code-generation examples to use the new API.\n  * Include a library-generation
  example for doing 128-bit\n    AES encryption\n\n### Version 0.9.17, 2011-03-29\n\nCode:\n\n
  \ * Simplify and reorganize the test suite\n\nExamples:\n\n  * Improve AES decryption
  example, by using\n    table-lookups in InvMixColumns.\n\n### Version 0.9.16, 2011-03-28\n\nCode:\n\n
  \ * Further optimizations on Bits instance of SBV\n\nExamples:\n\n  * Add AES algorithm
  as an example, showing how\n    encryption algorithms are particularly suitable\n
  \   for use with the code-generator\n\n### Version 0.9.15, 2011-03-24\n\nBug fixes:\n\n
  \ * Fix rotateL/rotateR instances on concrete\n    words. Previous versions was
  bogus since\n    it relied on the Integer instance, which\n    does the wrong thing
  after normalization.\n  * Fix conversion of signed numbers from bits,\n    previous
  version did not handle twos\n    complement layout correctly\n\nTesting:\n\n  *
  Add a sleuth of concrete test cases on\n    arithmetic to catch bugs. (There are
  many\n    of them, ~30K, but they run quickly.)\n\n### Version 0.9.14, 2011-03-19\n\n
  \ * Re-implement sharing using Stable names, inspired\n    by the Data.Reify techniques.
  This avoids tricks\n    with unsafe memory stashing, and hence is safe.\n    Thus,
  issues with respect to CAFs are now resolved.\n\n### Version 0.9.13, 2011-03-16\n\nBug
  fixes:\n\n  * Make sure SBool short-cut evaluations are done\n    as early as possible,
  as these help with coding\n    recursion-depth based algorithms, when dealing\n
  \   with symbolic termination issues.\n\nExamples:\n\n  * Add fibonacci code-generation
  example, original\n    code by Lee Pike.\n  * Add a GCD code-generation/verification
  example\n\n### Version 0.9.12, 2011-03-10\n\nNew features:\n\n  * Add support for
  compilation to C\n  * Add a mechanism for offline saving of SMT-Lib files\n\nBug
  fixes:\n\n  * Output naming bug, reported by Josef Svenningsson\n  * Specification
  bug in Legatos multiplier example\n\n### Version 0.9.11, 2011-02-16\n\n  * Make
  ghc-7.0 happy, minor re-org on the cabal file/Setup.hs\n\n### Version 0.9.10, 2011-02-15\n\n
  \ * Integrate commits from Iavor: Generalize SBVs to keep\n    track the integer
  directly without resorting to different\n    leaf types\n  * Remove the unnecessary
  CLC instruction from the Legato example\n  * More tests\n\n### Version 0.9.9, 2011-01-23\n\n
  \ * Support for user-defined SMT-Lib axioms to be\n    specified for uninterpreted
  constants/functions\n  * Move to using doctest style inline tests\n\n### Version
  0.9.8, 2011-01-22\n\n  * Better support for uninterpreted-functions\n  * Support
  counter-examples with SArrays\n  * Ladner-Fischer scheme example\n  * Documentation
  updates\n\n### Version 0.9.7, 2011-01-18\n\n  * First stable public hackage release\n\n###
  Versions 0.0.0 - 0.9.6, Mid 2010 through early 2011\n\n  * Basic infrastructure,
  design exploration\n"
changelog-type: markdown
description: "# SBV: SMT Based Verification in Haskell\n\n[![Build Status](https://github.com/LeventErkok/sbv/actions/workflows/haskell-ci.yml/badge.svg)](https://github.com/LeventErkok/sbv/actions/workflows/haskell-ci.yml)\n\nOn
  Hackage: http://hackage.haskell.org/package/sbv\n\nExpress properties about Haskell
  programs and automatically prove them using SMT solvers.\n\n```haskell\n$ ghci\nghci>
  :m Data.SBV\nghci> prove $ \\x -> x `shiftL` 2 .== 4 * (x::SWord8)\nQ.E.D.\nghci>
  prove $ \\x -> x `shiftL` 2 .== 2 * (x::SWord8)\nFalsifiable. Counter-example:\n
  \ s0 = 32 :: Word8\n```\n\nThe function `prove` establishes theorem-hood, while
  `sat` finds a satisfying model if it exists.\nAll satisfying models can be computed
  using `allSat`. \nSBV can also perform static assertion checks, such as absence
  of division-by-0, and other user given properties. \nFurthermore, SBV can perform
  optimization, minimizing/maximizing arithmetic goals for their optimal values.\n\nSBV
  also allows for an incremental mode: Users are given a handle to the SMT solver
  as their programs execute, and they can issue SMTLib commands programmatically,
  query values, and direct the interaction using a high-level typed API. The incremental
  mode also allows for creation of constraints based on the current model, and access
  to internals of SMT solvers for advanced users. See the `runSMT` and `query` commands
  for details.\n\n## Overview\n\n - [Hackage](http://hackage.haskell.org/package/sbv)\n
  - [Release Notes](http://github.com/LeventErkok/sbv/tree/master/CHANGES.md)\n   \nSBV
  library provides support for dealing with symbolic values in Haskell. It introduces
  the types:\n\n - `SBool`: Symbolic Booleans (bits).\n - `SWord8`, `SWord16`, `SWord32`,
  `SWord64`: Symbolic Words (unsigned).\n - `SInt8`, `SInt16`, `SInt32`, `SInt64`:
  Symbolic Ints (signed).\n - `SWord N`, `SInt N`, for `N > 0`: Arbitrary sized unsigned/signed
  bit-vectors, parameterized by the bitsize. (Using DataKinds extension.)\n - `SInteger`:
  Symbolic unbounded integers (signed).\n - `SReal`: Symbolic infinite precision algebraic
  reals (signed).\n - `SRational`: Symbolic rationals, ratio of two symbolic integers.
  (`Rational`.)\n - `SFloat`: IEEE-754 single precision floating point number. (`Float`.)\n
  - `SDouble`: IEEE-754 double precision floating point number. (`Double`.)\n - `SFloatingPoint`:
  IEEE-754 floating point number with user specified exponent and significand sizes.
  (`FloatingPoint`)\n - `SChar`: Symbolic characters, supporting unicode.\n - `SString`:
  Symbolic strings.\n - `SList`: Symbolic lists. (Which can be nested, i.e., lists
  of lists.)\n - `STuple`: Symbolic tuples (upto 8-tuples, can be nested)\n - `SEither`:
  Symbolic sums\n - `SMaybe`: Symbolic optional values\n - `SSet`: Symbolic sets\n
  - Arrays of symbolic values.\n - Symbolic enumerations, for arbitrary user-defined
  enumerated types.\n - Symbolic polynomials over GF(2^n ), polynomial arithmetic,
  and CRCs.\n - Uninterpreted constants and functions over symbolic values, with user
  defined axioms.\n - Uninterpreted sorts, and proofs over such sorts, potentially
  with axioms.\n - Ability to define SMTLib functions, generated directly from Haskell
  versions, including support for recursive and mutually recursive functions.\n -
  Reasoning with universal and existential quantifiers, including alternating quantifiers.\n
  \ \nThe user can construct ordinary Haskell programs using these types, which behave
  like ordinary Haskell values when used concretely. However, when used with symbolic
  arguments, functions built out of these types can also be:\n\n - proven correct
  via an external SMT solver (the `prove` function),\n - checked for satisfiability
  (the `sat`, and `allSat` functions),\n - checked for assertion violations (the `safe`
  function with `sAssert` calls),\n - checked for delta-satisfiability (the `dsat`
  and `dprove` functions),\n - used in synthesis (the `sat`function with existentials),\n
  - checked for machine-arithmetic overflow/underflow conditions,\n - optimized with
  respect to cost functions (the `optimize`, `maximize`, and `minimize` functions),\n
  - quick-checked,\n - used for generating Haskell and C test vectors (the `genTest`
  function),\n - compiled down to C, rendered as straight-line programs or libraries
  (`compileToC` and `compileToCLib` functions).\n   \n## Picking the SMT solver to
  use\n\nThe SBV library uses third-party SMT solvers via the standard SMT-Lib interface.
  The following solvers are supported:\n\n - [ABC](http://www.eecs.berkeley.edu/~alanmi/abc)
  from University of Berkeley\n - [Boolector](https://boolector.github.io/) from Johannes
  Kepler University\n - [Bitwuzla](https://bitwuzla.github.io/) from Stanford University\n
  - [CVC4](http://cvc4.github.io/) and [CVC5](http://cvc5.github.io/) from Stanford
  University and the University of Iowa\n - [DReal](https://dreal.github.io/) from
  CMU\n - [MathSAT](http://mathsat.fbk.eu/) from FBK and DISI-University of Trento\n
  - [OpenSMT](https://verify.inf.usi.ch/opensmt) from UniversitÃ  della Svizzera italiana\n
  - [Yices](http://yices.csl.sri.com/) from SRI\n - [Z3](http://github.com/Z3Prover/z3/wiki)
  from Microsoft\n   \nMost functions have two variants: For instance `prove`/`proveWith`.
  The former uses the default solver, which is currently Z3. The latter expects you
  to pass it a configuration that picks the solver.\nThe valid values are `abc`, `boolector`,
  `bitwuzla`, `cvc4`, `cvc5`, `dReal`, `mathSAT`, `openSMT`, `yices`, and `z3`.\n\nSee
  [versions](http://github.com/LeventErkok/sbv/blob/master/SMTSolverVersions.md) for
  a listing of the versions of these tools SBV has been tested with. Please report
  if you see any discrepancies!\n\nOther SMT solvers can be used with SBV as well,
  with a relatively easy hook-up mechanism. Please do get in touch if you plan to
  use SBV with any other solver.\n\n## Using multiple solvers, simultaneously\n\nSBV
  also allows for running multiple solvers at the same time, either picking the result
  of the first to complete, or getting results from all. \nSee `proveWithAny`/`proveWithAll`
  and `satWithAny`/`satWithAll` functions. The function `sbvAvailableSolvers` can
  be used to query the available solvers at run-time.\n\n## Copyright, License\n\nThe
  SBV library is distributed with the BSD3 license. See [COPYRIGHT](http://github.com/LeventErkok/sbv/tree/master/COPYRIGHT)
  for details.\nThe [LICENSE](http://github.com/LeventErkok/sbv/tree/master/LICENSE)
  file contains the [BSD3](http://en.wikipedia.org/wiki/BSD_licenses) verbiage.\n\n##
  Thanks\n\nThe following people made major contributions to SBV, by developing new
  features and contributing to the design in significant ways: Joel Burget, Brian
  Huffman, Brian Schroeder, and Jeffrey Young.\n\nThe following people reported bugs,
  provided comments/feedback, or contributed to the development of SBV in various
  ways:\nAndreas Abel,\nAra Adkins,\nAndrew Anderson,\nKanishka Azimi,\nMarkus Barenhoff,\nReid
  Barton,\nBen Blaxill,\nIan Blumenfeld,\nGuillaume Bouchard,\nMartin Brain,\nIan
  Calvert,\nOliver Charles,\nChristian Conkle,\nMatthew Danish,\nIavor Diatchki,\nAlex
  Dixon,\nRobert Dockins, \nThomas DuBuisson,\nTrevor Elliott,\nGergÅ Ãrdi,\nJohn
  Erickson,\nRichard Fergie,\nAdam Foltzer,\nJoshua Gancher,\nRemy Goldschmidt,\nBrad
  Hardy,\nTom Hawkins,\nGreg Horn,\nJan Hrcek,\nGeorges-Axel Jaloyan,\nAnders Kaseorg,\nTom
  Sydney Kerckhove,\nLars Kuhtz,\nPiÃ«rre van de Laar,\nPablo Lamela,\nKen Friis Larsen,\nAndrew
  Lelechenko,\nJoe Leslie-Hurd,\nNick Lewchenko,\nBrett Letner,\nSirui Lu,\nGeorgy
  Lukyanov,\nMartin Lundfall,\nJohn Matthews,\nCurran McConnell,\nPhilipp Meyer,\nFabian
  Mitterwallner,\nJoshua Moerman,\nMatt Parker,\nJan Path,\nMatt Peddie,\nLucas PeÃ±a,\nMatthew
  Pickering,\nLee Pike,\nGleb Popov,\nRohit Ramesh,\nGeoffrey Ramseyer,\nJaro Reinders,\nStephan
  Renatus,\nDan RosÃ©n,\nRyan Scott,\nEric Seidel,\nAustin Seipp,\nAndrÃ©s Sicard-RamÃ­rez,\nDon
  Stewart,\nGreg Sullivan,\nJosef Svenningsson,\nGeorge Thomas,\nMay Torrence,\nDaniel
  Wagner,\nSean Weaver,\nNis Wegmann,\nand Jared Ziegler.\n\nThanks!\n"
description-type: markdown
hash: caad66ddbdd57169eeb99d9413e67319bf6104a7101a468c370f9bd5fc49ffb1
homepage: http://github.com/LeventErkok/sbv
latest: '10.11'
license-name: BSD-3-Clause
maintainer: Levent Erkok (erkokl@gmail.com)
synopsis: 'SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.'
test-bench-deps:
  QuickCheck: '>=0'
  base: '>=4.16 && <5'
  bytestring: '>=0'
  containers: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  filepath: '>=0'
  mtl: '>=0'
  process: '>=0'
  random: '>=0'
  sbv: '>=0'
  tasty: '>=0'
  tasty-bench: '>=0'
  tasty-golden: '>=0'
  tasty-hunit: '>=0'
  tasty-quickcheck: '>=0'
  time: '>=0'

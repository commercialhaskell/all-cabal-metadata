homepage: http://leventerkok.github.com/sbv/
changelog-type: markdown
hash: a80a8ce2d9eaceffc23b862a55ea835c4c7b8018dc230238e177a279a9d944bd
test-bench-deps:
  hlint: -any
  sbv: -any
  bytestring: -any
  base: ! '>=4.11'
  tasty-golden: -any
  syb: -any
  filepath: -any
  doctest: -any
  crackNum: ! '>=2.3'
  containers: -any
  tasty-quickcheck: -any
  mtl: -any
  tasty-hunit: -any
  random: -any
  tasty: -any
  QuickCheck: -any
  Glob: -any
  template-haskell: -any
  directory: -any
maintainer: Levent Erkok (erkokl@gmail.com)
synopsis: ! 'SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.'
changelog: "* Hackage: <http://hackage.haskell.org/package/sbv>\n* GitHub:  <http://leventerkok.github.com/sbv/>\n\n*
  Latest Hackage released version: 8.3, 2019-06-08\n\n### Version 8.3, 2019-06-08\n\n
  \ * Increment base dependency to 4.11.\n\n  * Add support for `Data.Set.hasSize`.\n\n
  \ * Add `supportsFP` to CVC4 capabilities list. (#469)\n\n  * Fix a glitch in allSat
  computations that incorrectly\n    used values of internal variables in model construction.\n\n
  \ * SBV now directly uses the new `seq.nth` function from z3\n    for sequence element
  access, instead of implementing it\n    internally.\n\n### Version 8.2, 2019-04-07\n\n
  \ * Fixed minor issue with getting observables in quantified contexts.\n\n  * Simplify
  data-type constructor usage and accessor formats. See\n    http://github.com/Z3Prover/z3/issues/2135
  for a discussion.\n\n  * Add support for model validation in optimization problems.
  Use the\n    config parameter: `optimizeValidateConstraints`. Default: False. This\n
  \   feature nicely complements the `validateModel` option, which works\n    for
  `sat` and `prove` calls. Note that when we validate the model\n    for an optimization
  problem, we only make sure that the given result\n    satisfies the constraints
  not that it is minimum (or maximum) such\n    model. (And hence the new configuration
  variable.) Validating optimality\n    is beyond the scope of SBV.\n\n### Version
  8.1, 2019-03-09\n\n  * Added support for `SEither` and `SMaybe` types: symbolic
  sums and symbolic\n    optional values. These can be accessed by importing `Data.SBV.Either`
  and\n    `Data.SBV.Maybe` respectively. They translate to SMTLib's data-type syntax,\n
  \   and thus require a solver capable of handling datatypes. (Currently z3 and\n
  \   cvc4 are the only solvers that do.) All the typical introduction and\n    elimination
  functions are provided, and these types integrate with all\n    other symbolic types.
  (So you can have a list of SMaybe of SEither\n    values, or at any nesting level.)
  Thanks to Joel Burget for the initial\n    implementation of this idea and his contributions.\n\n
  \ * Added support for symbolic sets. The API closely follows that of `Data.Set`\n
  \   of Haskell, with some major differences: Symbolic sets can be co-finite.\n    (That
  is, we can represent not only finite sets, but also sets whose complements\n    are
  finite.) The distinction shows up in the `complement` operation, which\n    is not
  supported in Haskell. All SBV sets can be complemented. On the flip\n    side, SBV
  sets do not support a size operation (as they can be infinite),\n    nor they can
  be converted to lists. See 'Data.SBV.Set' for the API documentation\n    and \"Documentation/SBV/Examples/Misc/SetAlgebra.hs\"
  for an example that proves\n    many familiar set properties.\n\n  * SBV models
  now contain values for uninterpreted functions. This was a long\n    requested feature,
  but there was no previous support since SMTLib does not\n    have a standard way
  of querying such values. We now support this for z3 and\n    cvc4: Note that SBV
  tries its best to interpret the output from these\n    solvers, but it may give
  up if the response is too complicated (or something\n    I haven't seen before!)
  due to non-standard format. Barring these details,\n    the calls to `sat` now include
  function models, and you can also get them\n    via `getFunction` in a query.\n\n
  \   For an example use case demonstrating how to use UF-models to synthesize a\n
  \   simple multiplier, see \"Documentation/SBV/Examples/Uninterpreted/Multiply.hs\".\n\n
  \ * SBV now comes with a model validator. In a 'sat', 'prove', or 'allSat' call,\n
  \   you can pass the configuration parameter 'z3{validateModel = True}' (or whichever\n
  \   solver you're using), and z3 will attempt to validate the returned model\n    from
  the solver. Note that validation only works if there are no uninterpreted\n    kinds
  of functions, and also in quantifier-free problems only. Please report\n    your
  experiences, as there's room for improvement in validation, always!\n\n  * [BACKWARDS
  COMPATIBILITY] The `allSat` function is similarly modified to\n    return uninterpreted-function
  models. There are a few technical restrictions,\n    however: Only the values of
  uninterpreted functions without any uninterpreted\n    arguments will participate
  in `allSat` computation. (For instance,\n    `uninterpret \"f\" :: SInteger -> SInteger`
  is OK, but\n    `uninterpret \"f\" :: MyType -> SInteger` is not, where `MyType`
  itself\n    is uninterpreted.) The reason for this is again there is no SMTLib way
  of\n    reflecting uninterpreted model values back into the solver. This restriction\n
  \   should not cause much trouble in practice, but do get in touch if it is a\n
  \   use-case for you.\n\n  * Added configuration option `allSatPrintAlong`. If set
  to True, calls to\n    allSat will print their models as they are found. The default
  is False.\n\n  * Added configuration parameter `satTrackUFs` (defaulting to True)
  to control\n    if SBV should try to extract models for uninterpreted functions.
  In theory,\n    this should always be True, but for most practical problems we typically\n
  \   don't care about the function values itself but that it exists. Set to 'False'\n
  \   if this is the case for your problem. Note that this setting is also respected\n
  \   in 'allSat' calls.\n\n  * Added function `registerUISMTFunction`, which can
  be used to directly register uninterpreted\n    functions. This is typically not
  necessary as uses of UI-functions do register them\n    automatically, but it can
  come in handy in certain scenarios where there are no\n    constraints on a UI-function
  other than its existence.\n\n  * Added `Data.SBV.Tools.WeakestPreconditions` module,
  which provides a toy imperative\n    language and an engine for checking partial
  and total correctness of imperative programs.\n    It uses Dijkstra's weakest preconditions
  methodology to establish correctness claims.\n    Loop invariants are required and
  must be supplied by the user. For total correctness,\n    user must also provide
  termination measure functions. However, if desired, these can\n    be skipped (by
  passing 'Nothing'), in which case partial correctness will be proven.\n    Checking
  input parameters for no-change is supported via stability checks. For example\n
  \   use cases, see the `Documentation.SBV.Examples.WeakestPreconditions` directory.\n\n
  \ * Added functions `elem`/`notElem` to `Data.SBV.List`.\n\n  * Added `snoc` (appending
  a single element at the end) to `Data.SBV.List` and `Data.SBV.String`.\n\n  * Rework
  the 'Queriable' class to allow projection/embedding pairs. Also\n    added a new
  'Fresh' class, which is more usable in simpler scenarios\n    where the default
  projection/embedding definitions are suitable.\n\n  * Added strong-equality (.===)
  and inequality (./==) to the 'EqSymbolic' class. This\n    method is equivalent
  to the usual (.==) and (./=) for all types except 'SFloat' and\n    'SDouble'. For
  the floating types, it is object equality, that is 'NaN .=== Nan'\n    and '0 ./==
  -0'. Use the regular equality for float/double's as they follow the\n    IEEE754
  rules, but occasionally we need to express object equality in a polymorphic\n    way.
  Essentially this method is the polymorphic equaivalent of 'fpIsEqualObject'\n    except
  it works on all types.\n\n  * Removed the redundant 'SDivisible' constraint on rotate-left
  and rotate-right operations.\n\n  * Added unnamed equivalents of 'sBool', 'sWord8'
  etc; with a following underscore, i.e.,\n    'sBool_', 'sWord8_'. The new functions
  are supported for all base types, chars,\n    strings, lists, and tuples.\n\n  *
  SBV now supports implicit constraints in the query mode, which were previously only\n
  \   available before user queries started.\n\n  * Fixed a bug where hash-consing
  might reuse an expression even though the request might\n    have been made at a
  different type. This is a rare case in SBV to happen due to types,\n    but it was
  possible to exploit it in the Dynamic interface. Thanks to Brian Huffman\n    for
  reporting and diagnosing the issue.\n\n  * Fixed a bug where SBV was reporting incorrect
  \"elapsed\" time values, which are\n    printed when the 'timing' configuration
  parameter is specified.\n\n  * Documentation: Jan Path kindly fixed module headers
  of all the files to produce\n    much better looking Haddock documents. Thanks Jan!\n\n
  \ * Added barrel-rotations (sBarrelRotateLeft-Right, svBarrelRotateLeft-Right) which\n
  \   can produce better code for verification by bit-blasting the rotation amount.\n
  \   It accepts bit-vectors as arguments and an unsigned rotation quantity to keep\n
  \   things simple.\n\n  * Added new configuration option 'allowQueryQuantifers',
  default is set to False.\n    SBV normally doesn't allow quantifiers in a query
  context, because there are\n    issues surrounding 'getValue'. However, Joel Burget
  pointed out this check\n    is too strict for certain scenarios. So, as an escape
  hatch, you can define\n    'allowQueryQuantifers' to be 'True' and SBV will bypass
  this check. Of course,\n    if you do this, then you are on your own regarding calls
  to `getValue` with\n    quantified parameters! See http://github.com/LeventErkok/sbv/issues/459\n
  \   for details.\n\n  * [BACKWARDS COMPATIBILITY] Renamed the class `IEEEFloatConvertable`
  to\n    `IEEEFloatConvertible`. (Typo in name!) Matt Peddie pointed out issues\n
  \   regarding conversion of out-of-bounds float and double values to integral\n
  \   types. Unfortunately SMTLib does not support these conversions, and we\n    had
  issues in getting Haskell, SMTLib, and C to agree. Summary: These conversions\n
  \   are only guaranteed to work if they are done on numbers that lie within the\n
  \   representable range of the target type. Thanks to Matt Peddie for pointing out\n
  \   the out-of-bounds problem, his help in figuring out the issues.\n\n  * [BACKWARDS
  COMPATIBILITY] The 'AllSat' result now tracks if search has stopped\n    because
  the solver returned 'Unknown'. Previously this information was not\n    displayed.\n\n
  \ * [BACKWARDS COMPATIBILITY, Internal] Several constraints on internal\n    classes
  (such as SymVal, EqSymbolic, OrdSymbolic) were reworked to\n    reflect the dependencies
  better. Strictly speaking this is a backwards\n    compatibility breaking change,
  but I doubt it'll impact any user\n    code; though you might have to add some extra
  constraints if you were\n    writing sufficiently polymorphic SBV code. Yell if
  you find otherwise!\n\n  * [BACKWARDS COMPATIBILITY] SBV now allows user-given names
  to be duplicated.\n    It will implicitly add a suffix to them to distinguish without
  complaining. (In\n    previous versions, we would error out.) The reason for this
  change is that\n    sometimes it's nice to be able to simply give a prefix for a
  class of names\n    and not worry about the actual name itself. (Note that this
  will cause issues\n    if you use model-extraction-via-maps method if we ever make
  a name unique\n    and store it under a different name, but that's hardly ever used
  feature and\n    arguably the right thing to do anyway.) Thanks to Joel Burget for
  suggesting\n    the idea.\n\n  * [BACKWARDS COMPATIBILITY, Internal] SBV is now
  more strict in how user-queries\n    are used, performing certain extra-checks that
  were not done before. (For instance,\n    previously it was possible to mix prove-sat
  with a query call, which should\n    not have been allowed.) If you have any code
  that breaks for this reason, you\n    probably should've written it in some other
  way to start with. Please get\n    in touch if that is the case.\n\n  * [BACKWARDS
  COMPATIBILITY] You need at least GHC 8.4.1 to compile SBV.\n    If you're stuck
  with an older version, let me know and we'll see if\n    we can create a custom
  version for you; though I'd much rather avoid this\n    if at all possible.\n\n
  \ * SBV now supports optimization of goals of SDouble and SFloat types. This is\n
  \   done using the lexicographic ordering on floats, and adds on the additional\n
  \   constraint that the resulting float is not a NaN. If you use this feature,\n
  \   then your float value will be minimized as the corresponding 32 (or 64 for\n
  \   doubles) bit word. Note that this methods supports infinities properly, and\n
  \   does not distinguish between -0 and +0.\n    \n  * Optimization routines have
  been generalized to work over arbitrary metric-spaces,\n    with user-definable
  mappings. The simplest instance we have added is optimization\n    over booleans,
  by the obvious numeric mapping. Tuples are also supported with\n    the usual lexicographic
  ordering. In addition, SBV can now optimize over\n    user-defined enumerations.
  See \"Documentation.SBV.Examples.Optimization.Enumerate\" for\n    an example.\n\n
  \ * Improved the internal representation of constraints to address performance\n
  \   issues See http://github.com/LeventErkok/sbv/issues/460 for details. Thanks
  to\n    Thanks Jeffrey Young for reporting.\n\n### Version 8.0, 2019-01-14\n\n  *
  This is a major release of SBV, with several BACKWARDS COMPATIBILITY breaking\n
  \   changes. Lots of reworking of the internals to modernize the SBV code base.\n
  \   A few external API changes happened as well, mainly in terms of renamed\n    types/operators
  to reflect the current state of things. I expect most end user\n    programs to
  carry over unchanged, perhaps needing a bunch of renames. See below\n    for details.\n\n
  \ * Transformer stack and `SymbolicT`: This major internal revamping was contributed\n
  \   by Brian Schroeder. Brian reworked the internals of SBV to allow for custom
  monad\n    stacks. In particular, there is now a `SymbolicT` monad transformer,
  which\n    generalizes the `Symbolic` monad over an arbitrary base type, allowing
  users to\n    build SBV based symbolic execution engines on top of their own monad
  infrastructure.\n\n    Brian took the pains to ensure existing users (or those who
  do not have their\n    own monad stack), the transformer capabilities remain transparent.
  That is,\n    your existing code should recompile as is, or perhaps with minor aesthetic\n
  \   changes. Please report if you find otherwise, or need help.\n\n    See `Documentation.SBV.Examples.Transformers.SymbolicEval`
  for an example of\n    how to use the transformer based code.\n\n    Thanks to Brian
  Schroeder for this massive effort to modernize the SBV code-base!\n\n  * Support
  for tuples: Thanks to Joel Burget, SBV now supports tuple types (up-to\n    8-tuples),
  and allows mixing and matching of lists and tuples arbitrarily\n    as symbolic
  values. For instance `SBV [(Integer, String)]` is a valid type as\n    is `SBV [(Integer,
  [(Char, (Float, String))])]`, with each component symbolically\n    represented.
  Along with `STuple` for regular 2-tuples, there are new types\n    for `STupleN`
  for `N` between 2 to 8, along with `untuple` destructor, and field\n    accessors
  similar to lens: For instance `p^._4` would project the 4th element of\n    a tuple
  that has at least 4 fields. The mixing and matching of field types and\n    nesting
  allows for very rich symbolic value representations. See\n    `Documentation.SBV.Examples.Misc.Tuple`
  for an example.\n\n  * [BACKWARDS COMPATIBILITY] The `Boolean` class is removed,
  which used to abstract\n    over logical connectives. Previously, this class handled
  'SBool' and 'Bool', but\n    the generality was hardly ever used and caused typing
  ambiguities. The new\n    implementation simplifies boolean operators to simply
  operate on the `SBool`\n    type. Also changed the operator names to fit with all
  the others by starting\n    them with dots. A simple conversion guide:\n\n        *
  Literal True : true    became   sTrue\n        * Literal False: false   became   sFalse\n
  \       * Negation     : bNot    became   sNot\n        * Conjunction  : &&&     became
  \  .&&\n        * Disjunction  : |||     became   .||\n        * XOr          :
  <+>     became   .<+>\n        * Nand         : ~&      became   .~&\n        *
  Nor          : ~|      became   .~|\n        * Implication  : ==>     became   .=>\n
  \       * Iff          : <=>     became   .<=>\n        * Aggregate and: bAnd    became
  \  sAnd\n        * Aggregate or : bOr     became   sOr\n        * Existential  :
  bAny    became   sAny\n        * Universal    : bAll    became   sAll\n\n  * [BACKWARDS
  COMPATIBILITY, INTERNAL] Hostorically, SBV focused on bit-vectors and machine\n
  \   words, which meant lots of internal types were named suggestive of this heritage.\n
  \   With the addition of `SInteger`, `SReal`, `SFloat`, `SDouble` we have expanded\n
  \   this, but still remained focused on atomic types. But, thanks largely to\n    Joel
  Burget, SBV now supports symbolic characters, strings, lists, and now\n    tuples,
  and nested tuples/lists, which makes this word-oriented naming confusing.\n    To
  reflect, we made the following internal renamings:\n\n        * SymWord     became
  \     SymVal\n        * SW          became      SV\n        * CW          became
  \     CV\n        * CWVal       became      CVal\n\n    Along with these, many of
  the internal constructor/variable names also changed in\n    a similar fashion.\n\n
  \   For most casual users, these changes should not require any changes. But if
  you were\n    developing libraries on top of SBV, then you will have to adapt to
  the new schema.\n    Please report if there are any gotchas we have forgotten about.\n\n
  \ * [BACKWARDS COMPATIBILITY] When user queries are present, SBV now picks the logic\n
  \   \"ALL\" (as opposed to a suitable variant of bit-vectors as in the past versions).\n
  \   This can be overridden by the 'setLogic' command as usual of course. While the
  new\n    choice breaks backwards compatibility, I expect the impact will be minimal,
  and\n    the new behavior matches better with user expectations on how external
  queries are\n    usually employed.\n\n  * [BACKWARDS COMPATIBILITY] Renamed the
  module `Data.SBV.List.Bounded` to\n    `Data.SBV.Tools.BoundedList`.\n\n  * Introduced
  a `Queriable` class, which simplifies symbolic programming with composite\n    user
  types. See `Documentation.SBV.Examples.ProofTools` directory for several\n    use
  cases and examples.\n\n  * Added function `observeIf`, companion to `observe`. Allows
  observing of values\n    if they satisfy a given predicate.\n\n  * Added function
  `ensureSat`, which makes sure the solver context is satisfiable\n    when called
  in the query mode. If not, an error will be thrown. Simplifies\n    programming
  when we expect a satisfiable result and want to bail out if otherwise.\n\n  * Added
  `nil` to `Data.SBV.List`. Added `nil` and `uncons` to `Data.SBV.String`.\n    These
  were inadvertently left out previously.\n\n  * Add `Data.SBV.Tools.BMC` module,
  which provides a BMC (bounded-model\n    checking engine) for traditional state
  transition systems. See\n    `Documentation.SBV.Examples.ProofTools.BMC` for example
  uses.\n\n  * Add `Data.SBV.Tools.Induction` module, which provides an induction
  engine\n    for traditional state transition systems. Also added several example
  use\n    cases in the directory `Documentation.SBV.Examples.ProofTools`.\n\n###
  Version 7.13, 2018-12-16\n\n  * Generalize the types of `bminimum` and `bmaximum`
  by removing the `Num`\n    constraint.\n\n  * Change the type of `observe` from:
  `SymWord a => String -> SBV a -> Symbolic ()`\n    to `SymWord a => String -> SBV
  a -> SBV a`. This allows for more concise observables,\n    like this:\n\n        prove
  $ \\x -> observe \"lhs\" (x+x) .== observe \"rhs\" (2*x+1)\n        Falsifiable.
  Counter-example:\n          s0  = 0 :: Integer\n          lhs = 0 :: Integer\n          rhs
  = 1 :: Integer\n\n  * Add `Data.SBV.Tools.Range` module which defines `ranges` and
  `rangesWith` functions: They\n    compute the satisfying contiguous ranges for predicates
  with a single variable. See\n    `Data.SBV.Tools.Range` for examples.\n\n  * Add
  `Data.SBV.Tools.BoundedFix` module, which defines the operator `bfix` that can be
  used\n    as a bounded fixed-point operator for use in bounded-model-checking like
  algorithms. See\n    `Data.SBV.Tools.BoundedFix` for some example use cases.\n\n
  \ * Fix list-element extraction code, which asserted too strong a constraint. See
  issue #421\n    for details. Thanks to Joel Burget for reporting.\n\n  * New bounded
  list functions: `breverse`, `bsort`, `bfoldrM`, `bfoldlM`, and `bmapM`.\n    Contributed
  by Joel Burget.\n\n  * Add two new puzzle examples:\n       * `Documentation.SBV.Examples.Puzzles.LadyAndTigers`\n
  \      * `Documentation.SBV.Examples.Puzzles.Garden`\n\n### Version 7.12, 2018-09-23\n\n
  \ * Modifications to make SBV compile with GHC 8.6.1. (SBV should\n    now compile
  fine with all versions of GHC since 8.0.1; and\n    possibly earlier. Please report
  if you are using a version\n    in this range and have issues.)\n\n  * Improve the
  BoundedMutex example to show a non-fair trace.\n    See `Documentation/SBV/Examples/Lists/BoundedMutex.hs`.\n\n
  \ * Improve Haddock documentation links throughout.\n\n### Version 7.11, 2018-09-20\n\n
  \ * Add support for symbolic lists. (That is, arbitrary but fixed length symbolic\n
  \   lists of integers, floats, reals, etc. Nested lists are allowed as well.)\n
  \   This is building on top of Joel Burget's initial work for supporting symbolic\n
  \   strings and sequences, as supported by Z3. Note that the list theory solvers\n
  \   are incomplete, so some queries might receive an unknown answer. See\n    `Documentation/SBV/Examples/Lists/Fibonacci.hs`
  for an example, and the\n    module `Data.SBV.List` for details.\n\n  * A new module
  `Data.SBV.List.Bounded` provides extra functions to manipulate\n    lists with given
  concrete bounds. Note that SMT solvers cannot deal with\n    recursive functions/inductive
  proofs in general, so the utilities in this\n    file can come in handy when expressing
  bounded-model-checking style\n    algorithms. See `Documentation/SBV/Examples/Lists/BoundedMutex.hs`
  for a\n    simple mutex algorithm proof.\n\n  * Remove dependency on data-binary-ieee754
  package; which is no longer\n    supported.\n\n### Version 7.10, 2018-07-20\n  *
  [BACKWARDS COMPATIBILITY] '==' and '/=' now always throw an error instead of\n    only
  throwing an error for non-concrete values.\n    http://github.com/LeventErkok/sbv/issues/301\n\n
  \ * [BACKWARDS COMPATIBILITY] Array declarations are reworked to take\n    an initial
  value. The call 'newArray' now accepts an optional default\n    value, which itself
  can be symbolic. If provided, the array will return\n    the given value for all
  reads from uninitialized locations. If not given,\n    then reads from unwritten
  locations produce uninterpreted constants. The\n    behavior of 'SFunArray' and
  'SArray' is exactly the same in this regard.\n    Note that this is a backwards-compatibility
  breaking change, as you need\n    to pass a 'Nothing' argument to 'newArray' to
  get the old behavior.\n    (Solver note: If you use 'SFunArray', then defaults are
  fully supported\n    by SBV since these are internally handled, concrete or symbolic.
  If you\n    use 'SArray', which gets translated to SMTLib, then MathSAT and Z3 supports\n
  \   default values with both concrete and symbolic cases, CVC4 only supports\n    if
  they are constants. Boolector and Yices don't support default values\n    at this
  point in time, and ABC doesn't support arrays at all.)\n\n  * [BACKWARDS COMPATIBILITY]
  SMTException type has been renamed to\n    SBVException. SBV now throws this exception
  in more cases to aid in\n    building tools on top of SBV that might want to deal
  with exceptions\n    in different ways. (Previously, we used to call 'error' instead.)\n\n
  \ * [BACKWARDS COMPATIBILITY] Rename 'assertSoft' to 'assertWithPenalty', which\n
  \   better reflects the nature of this function. Also add extra checks to warn\n
  \   the user if optimization constraints are present in a regular sat/prove call.\n\n
  \ * Implement `softConstrain`: Similar to 'constrain', except the solver is\n    free
  to leave it unsatisfied (i.e., leave it false) if necessary to\n    find a satisfying
  solution. Useful in modeling conditions that are\n    \"nice-to-have\" but not \"required.\"
  Note that this is similar to\n    'assertWithPenalty', except it works in non-optimization
  contexts.\n    See `Documentation.SBV.Examples.Misc.SoftConstrain` for a simple
  example.\n\n  * Add 'CheckedArithmetic' class, which provides bit-vector arithmetic\n
  \   operations that do automatic underflow/overflow checking. The operations\n    follow
  their regular counter-parts, with an exclamation mark added at\n    the end: +!,
  -!, *!, /!. There is also negateChecked, for the same\n    function on unary negation.
  If you program using these functions,\n    then you can call 'safe' on the resulting
  programs to make sure\n    these operations never cause underflow and overflow conditions.\n\n
  \ * Similar to above, add 'sFromIntegralChecked', providing overflow/underflow\n
  \   checks for cast operations.\n\n  * Add `Documentation.SBV.Examples.BitPrecise.BrokenSearch`
  module to show the\n    use of overflow checking utilities, using the classic broken
  binary search\n    example from http://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html\n\n
  \ * Fix an issue where SBV was not sending array declarations to the SMT-solver\n
  \   if there were no explicit constraints. Thanks to Oliver Charles for reporting.\n\n
  \ * Rework 'SFunArray' implementation, addressing performance issues. We now\n    carefully
  memoize elements as we do the look-ups. This addresses several\n    perfomance issues
  that came up; hopefully providing some relief. The\n    function 'mkSFunArray' is
  also removed, which used to lift Haskell\n    functions to such arrays, often used
  to implement initial values. Now,\n    if a read is done on an unwritten element
  of 'SFunArray' we get an\n    uninterpreted constant. This is inline with how 'SArray'
  works, and\n    is consistent. The old 'SFunArray' implementation based on functions\n
  \   is no longer available, though it is easy to implement it in user-space\n    if
  needed. Please get in contact if this proves to be an issue.\n\n  * Add 'freshArray'
  to allow for creation of existential fresh arrays in the query mode.\n    This is
  similar to 'newArray' which works in the Symbolic mode, and is analogous to\n    'freshVar'.
  Most users shouldn't need this as 'newArray' calls should suffice. Only\n    use
  if you need a brand new array after switching to query mode.\n\n  * SBV now rejects
  queries if universally quantified inputs are present. Previously\n    these were
  allowed to go through, but in general skolemization makes the corresponding\n    variables
  unusable in the query context. See http://github.com/LeventErkok/sbv/issues/407\n
  \   for details. If you have an actual use case for such a feature, please get in\n
  \   touch. Thanks to Brian Schroeder for reporting this anomaly.\n\n  * Export 'addSValOptGoal'
  from 'Data.SBV.Internals', to help with 'Metric' class\n    instantiations. Requested
  by Dan Rosen.\n\n  * Export 'registerKind' from 'Data.SBV.Internals', to help with
  custom array declarations.\n    Thanks to Brian Schroeder for the patch.\n\n  *
  If an asynchronous exception is caught, SBV now throws it back without further processing.\n
  \   (For instance, if the backend solver gets killed. Previously we were turning
  these into\n    synchronous errors.) Thanks to Oliver Charles for pointing out this
  corner case.\n\n### Version 7.9, 2018-06-15\n\n  * Add support for bit-vector arithmetic
  underflow/overflow detection. The new\n    'ArithmeticOverflow' class captures conditions
  under which addition, subtraction,\n    multiplication, division, and negation can
  underflow/overflow for\n    both signed and unsigned bit-vector values. The implementation
  is based on\n    http://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/z3prefix.pdf,\n
  \   and can be used to detect overflow caused bugs in machine arithmetic.\n    See
  `Data.SBV.Tools.Overflow` for details.\n\n  * Add 'sFromIntegralO', which is the
  overflow/underflow detecting variant\n    of 'sFromIntegral'. This function returns
  (along with the converted\n    result), a pair of booleans showing whether the conversion
  underflowed\n    or overflowed.\n\n  * Change the function 'getUnknownReason' to
  return a proper data-type\n    ('SMTReasonUnknown') as opposed to a mere string.
  This is at the\n    query level. Similarly, change `Unknown` result to return the
  same\n    data-type at the sat/prove level.\n\n  * Interpolants: With Z3 4.8.0 release,
  Z3 folks have dropped support\n    for producing interpolants. If you need interpolants,
  you will have\n    to use the MathSAT backend now. Also, the MathSAT API is slightly\n
  \   different from how Z3 supported interpolants as well, which means\n    your
  old code will need some modifications. See the example in\n    Documentation.SBV.Examples.Queries.Interpolants
  for the new usage.\n\n  * Add 'constrainWithAttribute' call, which can be used to
  attach\n    arbitrary attribute to a constraint. Main use case is in interpolant\n
  \   generation with MathSAT.\n\n  * C code generation: SBV now spits out linker
  flag -lm if needed.\n    Thanks to Matt Peddie for reporting.\n\n  * Code reorg:
  Simplify constant mapping table, by properly accounting\n    for negative-zero floats.\n\n
  \ * Export 'sexprToVal' for the class SMTValue, which allows for custom\n    definitions
  of value extractions. Thanks to Brian Schroeder for the\n    patch.\n\n  * Export
  'Logic' directly from Data.SBV. (Previously was from Control.)\n\n  * Fix a long
  standing issue (ever since we introduced queries) where\n    'sAssert' calls were
  run in the context of the final output boolean,\n    which is simply the wrong thing
  to do.\n\n### Version 7.8, Released 2018-05-18\n\n  * Fix printing of min-bounds
  for signed 32/64 bit numbers in C\n    code generation: These are tricky since C
  does not allow\n    -min_value as a valid literal!  Instead we use the macros provided
  in\n    stdint.h. Thanks to Matt Peddie for reporting this corner case.\n\n  * Fix
  translation of the `abs` function in C code generation, making\n    sure we use
  the correct variant. Thanks to Matt Peddie for reporting.\n\n  * Fix handling of
  tables and arrays in pushed-contexts. Previously,\n    we used initializers to get
  table/array values stored properly.\n    However, this trick does not work if we
  are in a pushed-context;\n    since a pop can forget the corresponding assignments.
  SBV now\n    handles this corner case properly, by using tracker assertions\n    to
  keep track of what array values must be restored at each pop.\n    Thanks to Martin
  Brain on the SMTLib mailing list for the\n    suggestion. (See http://github.com/LeventErkok/sbv/issues/374\n
  \   for details.)\n\n  * Fix corner case in ite branch equality with float/double
  arguments,\n    where we were previously confusing +/-0 as equal to each other.\n
  \   Thanks to Matt Peddie for reporting.\n\n  * Add a call 'cgOverwriteFiles', which
  suppresses code-generation\n    prompts for overwriting files and quiets the prompts
  during\n    code generation. Thanks to Matt Peddie for the suggestion.\n\n  * Add
  support for uninterpreted function introductions in the query\n    mode. Previously,
  this was only allowed before the query started,\n    now we fully support uninterpreted
  functions in all modes.\n\n  * New example: Documentation/SBV/Examples/Puzzles/HexPuzzle.hs,\n
  \   showing how to code cover properties using SBV, using a form\n    of bounded
  model checking.\n\n### Version 7.7, Released 2018-04-29\n\n  * Add support for Symbolic
  characters ('SChar') and strings ('SString'.)\n    Thanks to Joel Burget for the
  initial implementation.\n\n    The 'SChar' type currently corresponds to the Latin-1
  character\n    set, and is thus a subset of the Haskell 'Char' type. This is\n    due
  to the current limitations in SMT-solvers. However, there\n    is a pending SMTLib
  proposal to support unicode, and SBV will track\n    these changes to have full
  unicode support: For further details\n    see: http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml\n\n
  \   The 'SString' type is the type of symbolic strings, consisting\n    of characters
  from the Latin-1 character set currently, just\n    like the planned 'SChar' improvements.
  Note that an 'SString'\n    is *not* simply a list of 'SChar' values: It is a symbolic\n
  \   type of its own and is processed as a single item. Conversions\n    from list
  of characters is possible (via the 'implode' function).\n    In the other direction,
  one cannot generally 'explode' a string,\n    since it may be of arbitrary length
  and thus we would not know\n    what concrete list to map it to. This is a bit unlike
  Haskell,\n    but the differences dissipate quickly in general, and the power\n
  \   of being able to deal with a string as a symbolic entity on its\n    own opens
  up many verification possibilities.\n\n    Note that currently only Z3 and CVC4
  has support for this logic,\n    and they do differ in some details. Various character/string\n
  \   operations are supported, including length, concatenation,\n    regular-expression
  matching, substrig operations, recognizers, etc.\n    If you use this logic, you
  are likely to find bugs in solvers themselves\n    as support is rather new: Please
  report.\n\n  * If unsat-core extraction is enabled, SBV now returns the unsat-core\n
  \   directly with in a solver result. Thanks to Ara Adkins for the\n    suggestion.\n\n
  \ * Add 'observe'. This function allows internal expressions to be\n    given values,
  which will be part of the satisfyin model or\n    the counter-example upon model
  construction. Useful for tracking\n    expected/returned values. Also works with
  quickCheck.\n\n  * Revamp Haddock documentation, hopefully easier to follow now.\n\n
  \ * Slightly modify the generated-C headers by removing whitespace.\n    This allows
  for certain \"lint\" rules to pass when SBV generated\n    code is used in conjunction
  with a larger code base. Thanks\n    to Greg Horn for the pull request.\n\n  * Improve
  implementation of 'svExp' to match that of '.^', making\n    it more defined when
  the exponent is constant. Thanks to Brian\n    Huffman for the patch.\n\n  * Export
  the underlying polynomial representation for algorithmic\n    reals from the Internals
  module for further user processing.\n    Thanks  to Jan Path for the patch.\n\n###
  Version 7.6, Released 2018-03-18\n\n  * GHC 8.4.1 compatibility: Work around compilation
  issues. SBV\n    now compiles cleanly with GHC 8.4.1.\n\n  * Define and export sWordN,
  sWordN_, sIntN_, from the Dynamic\n    interface, which simplifies creation of variables
  of arbitrary\n    bit sizes. These are similar to sWord8, sInt8, etc.; except\n
  \   they create dynamic counterparts that can be of arbitrary bit size.\n\n### Version
  7.5, Released 2018-01-13\n\n  * Remove obsolote references to tactics in a few haddock
  comments. Thanks\n    to Matthew Pickering for reporting.\n\n  * Added logic Logic_NONE,
  to be used in cases where SBV should not\n    try to set the logic. This is useful
  when there is no viable value to\n    set, and the back-end solver doesn't understand
  the SMT-Lib convention\n    of using \"ALL\" as the logic name. (One example of
  this is the Yices\n    solver.)\n\n  * SBV now returns SMTException (instead of
  just calling error) in case\n    the backend solver responds with error message.
  The type SMTException\n    can be caught by the user programs, and it includes many
  fields as an\n    indication of what went wrong. (The command sent, what was expected,\n
  \   what was seen, etc.) Note that if this exception is ever caught, the\n    backend
  solver is no longer alive: You should either just throw it,\n    or perform proper
  clean-up on your user code as required to set up\n    a new context. The provided
  show instance formats the exception nicely\n    for display purposes. See http://github.com/LeventErkok/sbv/issues/335\n
  \   for details and thanks to Brian Huffman for reporting.\n\n  * SIntegral class
  now has Integral as a super-class, which ensures the\n    base-type it's used at
  is Integral. This was already true for all instances,\n    so we are just making
  it more explicit.\n\n  * Improve the implementation of .^ (exponentiation) to cover
  more cases,\n    in particular signed exponents are now OK so long as they are concrete\n
  \   and positive, following Haskell convention.\n\n  * Removed the 'FromBits' class.
  Its functionality is now merged with the\n    new 'SFiniteBits' class, see below.\n\n
  \ * Introduce 'SFiniteBits' class, which only incorporates finite-words in it,\n
  \   i.e., SWord/SInt for 8-16-32-64. In particular it leaves out SInteger,\n    SFloat,
  SDouble, and SReal. Important in recognizing bit-vectors of\n    finite size, essentially.
  Here are the methods:\n\n        class (SymWord a, Num a, Bits a) => SFiniteBits
  a where\n            sFiniteBitSize      :: SBV a -> Int                     --
  ^ Bit size\n            lsb                 :: SBV a -> SBool                   --
  ^ Least significant bit of a word, always stored at index 0.\n            msb                 ::
  SBV a -> SBool                   -- ^ Most significant bit of a word, always stored
  at the last position.\n            blastBE             :: SBV a -> [SBool]                 --
  ^ Big-endian blasting of a word into its bits. Also see the 'FromBits' class.\n
  \           blastLE             :: SBV a -> [SBool]                 -- ^ Little-endian
  blasting of a word into its bits. Also see the 'FromBits' class.\n            fromBitsBE
  \         :: [SBool] -> SBV a                 -- ^ Reconstruct from given bits,
  given in little-endian\n            fromBitsLE          :: [SBool] -> SBV a                 --
  ^ Reconstruct from given bits, given in little-endian\n            sTestBit            ::
  SBV a -> Int -> SBool            -- ^ Replacement for 'testBit', returning 'SBool'
  instead of 'Bool'\n            sExtractBits        :: SBV a -> [Int] -> [SBool]
  \       -- ^ Variant of 'sTestBit', where we want to extract multiple bit positions.\n
  \           sPopCount           :: SBV a -> SWord8                  -- ^ Variant
  of 'popCount', returning a symbolic value.\n            setBitTo            :: SBV
  a -> Int -> SBool -> SBV a   -- ^ A combo of 'setBit' and 'clearBit', when the bit
  to be set is symbolic.\n            fullAdder           :: SBV a -> SBV a -> (SBool,
  SBV a) -- ^ Full adder, returns carry-out from the addition. Only for unsigned quantities.\n
  \           fullMultiplier      :: SBV a -> SBV a -> (SBV a, SBV a) -- ^ Full multipler,
  returns both high and low-order bits. Only for unsigned quantities.\n            sCountLeadingZeros
  \ :: SBV a -> SWord8                  -- ^ Count leading zeros in a word, big-endian
  interpretation\n            sCountTrailingZeros :: SBV a -> SWord8                  --
  ^ Count trailing zeros in a word, big-endian interpretation\n\n    Note that the
  functions 'sFiniteBitSize', 'sCountLeadingZeros', and 'sCountTrailingZeros' are\n
  \   new. Others have existed in SBV before, we are just grouping them together now
  in this new class.\n\n  * Tightened certain signatures where SBV was too liberal,
  using the SFiniteBits class. New signatures are:\n\n         sSignedShiftArithRight
  :: (SFiniteBits a, SIntegral b) => SBV a -> SBV b -> SBV a\n         crc                    ::
  (SFiniteBits a, SFiniteBits b) => Int -> SBV a -> SBV b -> SBV b\n         readSTree
  \             :: (SFiniteBits i, SymWord e) => STree i e -> SBV i -> SBV e\n         writeSTree
  \            :: (SFiniteBits i, SymWord e) => STree i e -> SBV i -> SBV e -> STree
  i e\n\n    Thanks to Thomas DuBuisson for reporting.\n\n### Version 7.4, 2017-11-03\n\n
  \ * Export queryDebug from the Control module, allowing custom queries to print\n
  \   debugging messages with the verbose flag is set.\n\n  * Relax value-parsing
  to allow for non-standard output from solvers. For\n    instance, MathSAT/Yices
  prints reals as integers when they do not have a\n    fraction. We now support such
  cases, relaxing the standard slightly. Thanks\n    to Geoffrey Ramseyer for reporting.\n\n
  \ * Fix optimization routines when applied to signed-bitvector goals. Thanks\n    to
  Anders Kaseorg for reporting. Since SMT-Lib does not distinguish between\n    signed
  and unsigned bit-vectors, we have to be careful when expressing goals\n    that
  are over signed values. See http://github.com/LeventErkok/sbv/issues/333\n    for
  details.\n\n### Version 7.3, 2017-09-06\n\n  * Query mode: Add support for arrays
  in query mode. Thanks to Brad Hardy for\n    providing the use-case and debugging
  help.\n\n  * Query mode: Add support for tables. (As used by 'select' calls.)\n\n###
  Version 7.2, 2017-08-29\n\n  * Reworked implementation of shifts and rotates: When
  a signed quantity was\n    being shifted right by more than its size, SBV used to
  return 0. Robert Dockins pointed\n    out that the correct answer is actually -1
  in such cases. The new implementation\n    merges the dynamic and typed interfaces,
  and drops support for non-constant shifts\n    of unbounded integers, which is not
  supported by SMTLib. Thanks to Robert for\n    reporting the issue and identifying
  the root cause.\n\n  * Rework how quantifiers are handled: We now generate separate
  asserts for\n    prefix-existentials. This allows for better (smaller) quantified
  code, while\n    preserving semantics.\n\n  * Rework the interaction between quantifiers
  and optimization routines.\n    Optimization routines now properly handle quantified
  formulas, so long as the\n    quantified metric does not involve any universal quantification
  itself. Thanks\n    to Matthew Danish for reporting the issue.\n\n  * Development/Infrastructure:
  Lots of work around the continuous integration\n    for SBV. We now build/test on
  Linux/Mac/Windows on every commit. Thanks to\n    Travis/Appveyor for providing
  free remote infrastructure. There are still\n    gotchas and some reductions in
  tests due to host capacity issues. If you\n    would like to be involved and improve
  the test suite, please get in touch!\n\n### Version 7.1, 2017-07-29\n\n  * Add support
  for 'getInterpolant' in Query mode.\n\n  * Support for SMT-results that can contain
  multi-line strings, which\n    is rare but it does happen. Previously SBV incorrectly
  interpreted such\n    responses to be erroneous.\n\n  * Many improvements to build
  infrastructure and code clean-up.\n\n  * Fix a bug in the implementation of `svSetBit`.
  Thanks to Robert Dockins\n    for the report.\n\n### Version 7.0, 2017-07-19\n\n
  \ * NB. SBV now requires GHC >= 8.0.1 to compile. If you are stuck with an older\n
  \   version of GHC, please get in contact.\n\n  * This is a major rewrite of the
  internals of SBV, and is a backwards compatibility\n    breaking release. While
  we kept the top-level and most commonly used APIs the\n    same (both types and
  semantics), much of the internals and advanced features\n    have been rewritten
  to move SBV to a new model of execution: SBV no longer\n    runs your program symbolically
  and calls the SMT solver afterwards. Instead,\n    the interaction with the solver
  happens interleaved with the actual program execution.\n    The motivation is to
  allow the end-users to send/receive arbitrary SMTLib\n    commands to the solver,
  instead of the cooked-up recipes. SBV still provides\n    all the recipes for its
  existing functionality, but users can now interact\n    with the solver directly.
  See the module `Data.SBV.Control` for the main\n    API, together with the new functions
  'runSMT' and 'runSMTWith'.\n\n  * The 'Tactic' based solver control (introduced
  in v6.0) is completely removed, and\n    is replaced by the above described mechanism
  which gives the user a lot of\n    flexibility instead. Use queries for anything
  that required a tactic before.\n\n  * The call 'allSat' has been reworked so it
  performs only one call to the underlying\n    solver and repeatedly issues check-sat
  to get new assignments. This differs from the\n    previous implementation where
  we spun off a new call to the executable for each\n    successive model. While this
  is more efficient and much more preferable, it also\n    means that the results
  are no longer lazily computed: If there is an infinite number\n    of solutions
  (or a very large number), you can no longer merely do a 'take' on the result.\n
  \   While this is inconvenient, it fits better with our new methodology of query
  based\n    interaction. Note that the old behavior can be modeled, if required,
  by the user; by explicitly\n    interleaving the calls to 'sat.' Furthermore, we
  now provide a new configuration\n    parameter named 'allSatMaxModelCount' which
  can be used to limit the number models we\n    seek. The default is to get all models,
  however long that might take.\n\n  * The Bridge modules (`Data.SBV.Bridge.Yices`,
  `Data.SBV.Bridge.Z3`) etc. are\n    all removed. The bridge functionality was hardly
  used, where different solvers\n    were much easier to access using the `with` functions.
  (Such as `proveWith`,\n    `satWith` etc.) This should result in no loss of functionality,
  except for\n    occasional explicit mention of solvers in your code, if you were
  using\n    bridge modules to start with.\n\n  * Optimization routines have been
  changed to take a priority as an argument, (i.e.,\n    Lexicographic, Independent,
  etc.). The old method of supplying the priority\n    via tactics is no longer supported.\n\n
  \ * Pareto-front extraction has been reworked, reflecting the changes in Z3 for\n
  \   this functionality. Since pareto-fronts can be infinite in number, the user\n
  \   is now allowed to specify a \"limit\" to stop the solver from querying ad\n
  \   infinitum. If the limit is not specified, then sbv will query till it\n    exhausts
  all the pareto-fronts, or till it runs out of memory in case there\n    is an infinite
  number of them.\n\n  * Extraction of unsat-cores has changed. To use this feature,
  we now use\n    custom queries. See `Data.SBV.Examples.Misc.UnsatCore` for an example.\n
  \   Old style of unsat-core extraction is no longer supported.\n\n  * The 'timing'
  option of SMTConfig has been reworked. Since we now start the\n    solver immediately,
  it is no longer sensible to distinguish between \"SBV\" time,\n    \"translation\"
  time etc. Instead, we print one simple \"Elapsed\" time if requested.\n    If you
  need a detailed timing analysis, use the new 'transcript' option to\n    SMTConfig:
  It will produce a file with precise timing intervals for each\n    command issued
  to help you figure out how long each step took.\n\n  * The following functions have
  been reworked, so they now also return\n    the time-elapsed for each solver:\n\n
  \       satWithAll   :: Provable a => [SMTConfig] -> a -> IO [(Solver, NominalDiffTime,
  SatResult)]\n        satWithAny   :: Provable a => [SMTConfig] -> a -> IO  (Solver,
  NominalDiffTime, SatResult)\n        proveWithAll :: Provable a => [SMTConfig] ->
  a -> IO [(Solver, NominalDiffTime, ThmResult)]\n        proveWithAny :: Provable
  a => [SMTConfig] -> a -> IO  (Solver, NominalDiffTime, ThmResult)\n\n  * Changed
  the way `satWithAny` and `proveWithAny` works. Previously, these\n    two functions
  ran multiple solvers, and took the result of the first\n    one to finish, killing
  all the others. In addition, they *waited* for\n    the still-running solvers to
  finish cleaning-up, as sending a 'ThreadKilled'\n    is usually not instantaneous.
  Furthermore, a solver might simply take\n    its time! We now send the interrupt
  but do not wait for the process to\n    actually terminate. In rare occasions this
  could create zombie processes\n    if you use a solver that is not cooperating,
  but we have seen not insignificant\n    speed-ups for regular usage due to ThreadKilled
  wait times being rather long.\n\n  * Configuration option `useLogic` is removed.
  If required, this should\n    be done by a call to the new 'setLogic' function:\n\n
  \       setLogic QF_NRA\n\n  * Configuration option `timeOut` is removed. This was
  rarely used, and the solver\n    support was rather sketchy. We now have a better
  mechanism in the query mode\n    for timeouts, where it really matters. Please get
  in touch if you relied on\n    this old mechanism. Correspondingly, the functions
  `isTheorem`, `isSatisfiable`,\n    `isTheoremWith` and `isSatisfiableWith` had their
  time-out arguments removed\n    and return types simplified.\n\n  * The function
  'isSatisfiableInCurrentPath' is removed. Proper queries should be used\n    for
  what this function tentatively attempted to provide. Please get in touch\n    if
  you relied on this function and want to restructure your code to use proper queries.\n\n
  \ * Configuration option 'smtFile' is removed. Instead use 'transcript' now, which\n
  \   provides a much more detailed output that is directly loadable to a solver\n
  \   and has an accurate account of precisely what SBV sent.\n\n  * Enumerations
  are now much easier to use symbolically, with the addition\n    of the template-haskell
  splice mkSymbolicEnumeration. See `Data/SBV/Examples/Misc/Enumerate.hs`\n    for
  an example.\n\n  * Thanks to Kanishka Azimi, our external test suite is now run
  by\n    Tasty! Kanishka modernized the test suite, and reworked the\n    infrastructure
  that was showing its age. Thanks!\n\n  * The function pConstrain and the Data.SBV.Tools.ExpectedValue
  are\n    removed. Probabilistic constraints were rarely used, and if\n    necessary
  can be implemented outside of SBV. If you were using\n    this feature, please get
  in contact.\n\n  * SArray and SFunArray has been reworked, and they no longer take\n
  \   and initial value. Similarly resetArray has been removed, as it\n    did not
  really do what it advertised. If an initial value is needed,\n    it is best to
  code this explicitly in your model.\n\n### Version 6.1, 2017-05-26\n\n  * Add support
  for unsat-core extraction. To use this feature, use\n    the `namedConstraint` function:\n\n
  \       namedConstraint :: String -> SBool -> Symbolic ()\n\n    to associate a
  label to a constrain or a boolean term that\n    can later be labeled by the backend
  solver as belonging to the\n    unsat-core.\n\n    Unsat-cores are not enabled by
  default since they can be\n    expensive; to use:\n\n        satWith z3{getUnsatCore=True}
  $ do ...\n\n    In the programmatic API, the function:\n\n        extractUnsatCore
  :: Modelable a => a -> Maybe [String]\n\n    can be used to programmatically extract
  the unsat-core. Note that\n    backend solvers will only include the named expressions
  in the unsat-core,\n    i.e., any unnamed yet part-of-the-core-unsat expressions
  will be missing;\n    as speculated in the SMT-Lib document itself.\n\n    Currently,
  Z3, MathSAT, and CVC4 backends support unsat-cores.\n\n    (Thanks to Rohit Ramesh
  for the suggestion leading to this feature.)\n\n  * Added function `distinct`, which
  returns true if all the elements of the\n    given list are different. This function
  replaces the old `allDifferent`\n    function, which is now removed. The difference
  is that `distinct` will produce\n    much better code for SMT-Lib. If you used `allDifferent`
  before, simply\n    replacing it with `distinct` should work.\n\n  * Add support
  for pseudo-boolean operations:\n\n          pbAtMost           :: [SBool]        ->
  Int -> SBool\n          pbAtLeast          :: [SBool]        -> Int -> SBool\n          pbExactly
  \         :: [SBool]        -> Int -> SBool\n          pbLe               :: [(Int,
  SBool)] -> Int -> SBool\n          pbGe               :: [(Int, SBool)] -> Int ->
  SBool\n          pbEq               :: [(Int, SBool)] -> Int -> SBool\n          pbMutexed
  \         :: [SBool]               -> SBool\n          pbStronglyMutexed  :: [SBool]
  \              -> SBool\n\n    These functions, while can be directly coded in SBV,
  produce better\n    translations to SMTLib for more efficient solving of cardinality
  constraints.\n    Currently, only Z3 supports pseudo-booleans directly. For all
  other solvers,\n    SBV will translate these to equivalent terms that do not require
  special\n    functions.\n\n  * The function getModel has been renamed to getAssignment.
  (The former name is\n    now available as a query command.)\n\n  * Export `SolverCapabilities`
  from `Data.SBV.Internals`, in case users want access.\n\n  * Move code-generation
  facilities to `Data.SBV.Tools.CodeGen`, no longer exporting\n    the relevant functions
  directly from `Data.SBV`. This could break existing code,\n    but the fix should
  be as simple as `import Data.SBV.Tools.CodeGen`.\n\n  * Move the following two functions
  to `Data.SBV.Internals`:\n\n         compileToSMTLib\n         generateSMTBenchmarks\n\n
  \   If you use them, please `import Data.SBV.Internals`.\n\n  * Reorganized `EqSymbolic`
  and `EqOrd` classes to collect some of the\n    similarly named function together.
  Users should see no impact due to this change.\n\n\n### Version 6.0, 2017-05-07\n\n
  \ * This is a backwards compatibility breaking release, hence the major version\n
  \   bump from 5.15 to 6.0:\n\n       - Most of existing code should work with no
  changes.\n       - Old code relying on some features might require extra imports,\n
  \        since we no longer export some functionality directly from `Data.SBV`.\n
  \        This was done in order to reduce the number of exported items to\n         avoid
  extra clutter.\n       - Old optimization features are removed, as the new and much
  improved\n         capabilities should be used instead.\n\n  * The next two bullets
  cover new features in SBV regarding optimization, based\n    on the capabilities
  of the z3 SMT solver. With this release SBV gains the\n    capability optimize objectives,
  and solve MaxSAT problems; by appropriately\n    employing the corresponding capabilities
  in z3. A good review of these features\n    as implemented by Z3, and thus what
  is available in SBV is given in this\n    paper: http://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/nbjorner-scss2014.pdf\n\n
  \ * SBV now allows for  real or integral valued metrics. Goals can be lexicographically\n
  \   (default), independently, or pareto-front optimized. Currently, only the z3
  backend\n    supports optimization routines.\n\n    Optimization can be done over
  bit-vector, real, and integer goals. The relevant\n    functions are:\n\n        -
  `minimize`: Minimize a given arithmetic goal\n        - `maximize`: Minimize a given
  arithmetic goal\n\n    For instance, a call of the form\n\n         minimize \"name-of-goal\"
  $ x + 2*y\n\n    Minimizes the arithmetic goal x+2*y, where x and y can be bit-vectors,
  reals,\n    or integers. Such goals will be lexicographically optimized, i.e., in
  the order\n    given. If there are multiple goals, then user can also ask for independent\n
  \   optimization results, or pareto-fronts.\n\n    Once the objectives are given,
  a top level call to `optimize` (similar to `prove`\n    and `sat`) performs the
  optimization.\n\n  * SBV now implements soft-asserts. A soft assertion is a hint
  to the SMT solver that\n    we would like a particular condition to hold if *possible*.
  That is, if there is\n    a solution satisfying it, then we would like it to hold.
  However, if the set of\n    constraints is unsatisfiable, then a soft-assertion
  can be violated by incurring\n    a user-given numeric penalty to satisfy the remaining
  constraints. The solver then\n    tries to minimize the penalty, i.e., satisfy as
  many of the soft-asserts as possible\n    such that the total penalty for those
  that are not satisfied is minimized.\n\n    Note that `assertSoft` works well with
  optimization goals (minimize/maximize etc.),\n    and are most useful when we are
  optimizing a metric and thus some of the constraints\n    can be relaxed with a
  penalty to obtain a good solution.\n\n  * SBV no longer provides the old optimization
  routines, based on iterative and quantifier\n    based methods. Those methods were
  rarely used, and are now superseded by the above\n    mechanism. If the old code
  is needed, please contact for help: They can be resurrected\n    in your own code
  if absolutely necessary.\n\n  * (NB. This feature is deprecated in 7.0, see above
  for its replacement.)\n    SBV now implements tactics, which allow the user to navigate
  the proof process.\n    This is an advanced feature that most users will have no
  need of, but can become\n    handy when dealing with complicated problems. Users
  can, for instance, implement\n    case-splitting in a proof to guide the underlying
  solver through. Here is the list\n    of tactics implemented:\n\n        - `CaseSplit`
  \        : Case-split, with implicit coverage. Bool says whether we should be verbose.\n
  \       - `CheckCaseVacuity`  : Should the case-splits be checked for vacuity? (Default:
  True.)\n        - `ParallelCase`      : Run case-splits in parallel. (Default: Sequential.)\n
  \       - `CheckConstrVacuity`: Should constraints be checked for vacuity? (Default:
  False.)\n        - `StopAfter`         : Time-out given to solver, in seconds.\n
  \       - `CheckUsing`        : Invoke with check-sat-using command, instead of
  check-sat\n        - `UseLogic`          : Use this logic, a custom one can be specified
  too\n        - `UseSolver`         : Use this solver (z3, yices, etc.)\n        -
  `OptimizePriority`  : Specify priority for optimization: Lexicographic (default),
  Independent, or Pareto.\n\n  * Name-space clean-up. The following modules are no
  longer automatically exported\n    from Data.SBV:\n\n        - `Data.SBV.Tools.ExpectedValue`
  (computing with expected values)\n        - `Data.SBV.Tools.GenTest` (test case
  generation)\n        - `Data.SBV.Tools.Polynomial` (polynomial arithmetic, CRCs
  etc.)\n        - `Data.SBV.Tools.STree` (full symbolic binary trees)\n\n    To use
  the functionality of these modules, users must now explicitly import the corresponding\n
  \   module. Not other changes should be needed other than the explicit import.\n\n
  \ * Changed the signatures of:\n\n          isSatisfiableInCurrentPath :: SBool
  -> Symbolic Bool\n        svIsSatisfiableInCurrentPath :: SVal  -> Symbolic Bool\n\n
  \   to:\n\n          isSatisfiableInCurrentPath :: SBool -> Symbolic (Maybe SatResult)\n
  \       svIsSatisfiableInCurrentPath :: SVal  -> Symbolic (Maybe SatResult)\n\n
  \   which returns the result in case of SAT. This is more useful than before. This
  is\n    backwards-compatibility breaking, but is more useful. (Requested by Jared
  Ziegler.)\n\n  * Add instance `Provable (Symbolic ())`, which simply stands for
  returning true\n    for proof/sat purposes. This allows for simpler coding, as constrain/minimize/maximize\n
  \   calls (which return unit) can now be directly sat/prove processed, without needing\n
  \   a final call to return at the end.\n\n  * Add type synonym `Goal` (for `Symbolic
  ()`), in order to simplify type signatures\n\n  * SBV now properly adds check-sat
  commands and other directives in debugging output.\n\n  * New examples:\n      -
  Data.SBV.Examples.Optimization.LinearOpt: Simple linear-optimization example.\n
  \     - Data.SBV.Examples.Optimization.Production: Scheduling machines in a shop\n
  \     - Data.SBV.Examples.Optimization.VM: Scheduling virtual-machines in a data-center\n\n###
  Version 5.15, 2017-01-30\n\n  * Bump up dependency on CrackNum >= 1.9, to get access
  to hexadecimal floats.\n  * Improve time/tracking-print code. Thanks to Iavor Diatchki
  for the patch.\n\n### Version 5.14, 2017-01-12\n\n  * Bump up QuickCheck dependency
  to >= 2.9.2 to avoid the following quick-check\n    bug <http://github.com/nick8325/quickcheck/issues/113>,
  which transitively impacted\n    the quick-check as implemented by SBV.\n\n  * Generalize
  casts between integral-floats, using the rounding mode round-nearest-ties-to-even.\n
  \   Previously calls to sFromIntegral did not support conversion to floats since
  it needed\n    a rounding mode. But it does make sense to support them with the
  default mode. If a different\n    mode is needed, use the function 'toSFloat' as
  before, which takes an explicit rounding mode.\n\n### Version 5.13, 2016-10-29\n\n
  \ * Fix broken links, thanks to Stephan Renatus for the patch.\n\n  * Code generation:
  Create directory path if it does not exist. Thanks to Robert Dockins\n    for the
  patch.\n\n  * Generalize the type of sFromIntegral, dropping the Bits requirement.
  In turn, this\n    allowed us to remove sIntegerToSReal, since sFromIntegral can
  be used instead.\n\n  * Add support for sRealToSInteger. (Essentially the floor
  function for SReal.)\n\n  * Several space-leaks fixed for better performance. Patch
  contributed by Robert Dockins.\n\n  * Improved Random instance for Rational. Thanks
  to Joe Leslie-Hurd for the idea.\n\n### Version 5.12, 2016-06-06\n\n  * Fix GHC8.0
  compliation issues, and warning clean-up. Thanks to Adam Foltzer for the bulk\n
  \   of the work and Tom Sydney Kerckhove for the initial patch for 8.0 compatibility.\n\n
  \ * Minor fix to printing models with floats when the base is 2/16, making sure
  the alignment\n    is done properly accommodating for the crackNum output.\n\n  *
  Wait for external process to die on exception, to avoid spawning zombies. Thanks
  to\n    Daniel Wagner for the patch.\n\n  * Fix hash-consed arrays: Previously we
  were caching based only on elements, which is not\n    sufficient as you can have
  conflicts differing only on the address type, but same contents.\n    Thanks to
  Brian Huffman for reporting and the corresponding patch.\n\n### Version 5.11, 2016-01-15\n\n
  \ * Fix documentation issue; no functional changes\n\n### Version 5.10, 2016-01-14\n\n
  \ * Documentation: Fix a bunch of dead http links. Thanks to Andres Sicard-Ramirez\n
  \   for reporting.\n\n  * Additions to the Dynamic API:\n\n       * svSetBit                  :
  set a given bit\n       * svBlastLE, svBlastBE      : Bit-blast to big/little endian\n
  \      * svWordFromLE, svWordFromBE: Unblast from big/little endian\n       * svAddConstant
  \            : Add a constant to an SVal\n       * svIncrement, svDecrement  : Add/subtract
  1 from an SVal\n\n### Version 5.9, 2016-01-05\n\n  * Default definition for 'symbolicMerge',
  which allows types that are\n    instances of 'Generic' to have an automatically
  derivable merge (i.e.,\n    ite) instance. Thanks to Christian Conkle for the patch.\n\n
  \ * Add support for \"non-model-vars,\" where we can now tell SBV not\n    to take
  into account certain variables from a model-building\n    perspective. This comes
  handy in doing an `allSat` calls where\n    there might be witness variables that
  we do not care the uniqueness\n    for. See `Data/SBV/Examples/Misc/Auxiliary.hs`
  for an example, and\n    the discussion in http://github.com/LeventErkok/sbv/issues/208
  for\n    motivation.\n\n  * Yices interface: If Reals are used, then pick the logic
  QF_UFLRA, instead\n    of QF_AUFLIA. Unfortunately, logic selection remains tricky
  since the SMTLib\n    story for logic selection is rather messy. Other solvers are
  not impacted\n    by this change.\n\n### Version 5.8, 2016-01-01\n\n  * Fix some
  typos\n  * Add 'svEnumFromThenTo' to the Dynamic interface, allowing dynamic construction\n
  \   of [x, y .. z] and [x .. y] when the involved values are concrete.\n  * Add
  'svExp' to the Dynamic interface, implementing exponentiation\n\n### Version 5.7,
  2015-12-21\n\n  * Export `HasKind(..)` from the Dynamic interface. Thanks to Adam
  Foltzer for the patch.\n  * More careful handling of SMT-Lib reserved names.\n  *
  Update tested version of MathSAT to 5.3.9\n  * Generalize `sShiftLeft`/`sShiftRight`/`sRotateLeft`/`sRotateRight`
  to work with signed\n    shift/rotate amounts, where negative values revert the
  direction. Similar\n    generalizations are also done for the dynamic variants.\n\n###
  Version 5.6, 2015-12-06\n\n  * Minor changes to how we print models:\n  * Align
  by the type\n  * Always print the type (previously we were skipping for Bool)\n\n
  \ * Rework how SBV properties are quick-checked; much more usable and robust\n\n
  \ * Provide a function `sbvQuickCheck`, which is essentially the same as\n    quickCheck,
  except it also returns a boolean. Useful for the\n    programmable API. (The dynamic
  version is called `svQuickCheck`.)\n\n  * Several changes/additions in support of
  the sbvPlugin development:\n  * Data.SBV.Dynamic: Define/export `svFloat`/`svDouble`/`sReal`/`sNumerator`/`sDenominator`\n
  \ * Data.SBV.Internals: Export constructors of `Result`, `SMTModel`,\n    and the
  function `showModel`\n  * Simplify how Uninterpreted-types are internally represented.\n\n###
  Version 5.5, 2015-11-10\n\n  * This is essentially the same release as 5.4 below,
  except to allow SBV compile\n    with GHC 7.8 series. Thanks to Adam Foltzer for
  the patch.\n\n### Version 5.4, 2015-11-09\n\n  * Add 'sAssert', which allows users
  to pepper their code with boolean conditions, much like\n    the usual ASSERT calls.
  Note that the semantics of an 'sAssert' is that it is a NOOP, i.e.,\n    it simply
  returns its final argument. Use in coordination with 'safe' and 'safeWith', see
  below.\n\n  * Implement 'safe' and 'safeWith', which statically determine all calls
  to 'sAssert'\n    being safe to execute. Any violations will be flagged.\n\n  *
  SBV->C: Translate 'sAssert' calls to dynamic checks in the generated C code. If
  this is\n    not desired, use the 'cgIgnoreSAssert' function to turn it off.\n\n
  \ * Add 'isSafe': Which converts a 'SafeResult' to a 'Bool', when we are only interested\n
  \   in a boolean result.\n\n  * Add Data/SBV/Examples/Misc/NoDiv0 to demonstrate
  the use of the 'safe' function.\n\n### Version 5.3, 2015-10-20\n\n  * Main point
  of this release to make SBV compile with GHC 7.8 again, to accommodate mainly\n
  \   for Cryptol. As Cryptol moves to GHC >= 7.10, we intend to remove the \"compatibility\"
  changes\n    again. Thanks to Adam Foltzer for the patch.\n\n  * Minor mods to how
  bitvector equality/inequality are translated to SMTLib. No user visible\n    impact.\n\n###
  Version 5.2, 2015-10-12\n\n  * Regression on 5.1: Fix a minor bug in base 2/16 printing
  where uninterpreted constants were\n    not handled correctly.\n\n### Version 5.1,
  2015-10-10\n\n  * fpMin, fpMax: If these functions receive +0/-0 as their two arguments,
  i.e., both\n    zeros but alternating signs in any order, then SMTLib requires the
  output to be\n    nondeterministicly chosen. Previously, we fixed this result as
  +0 following the\n    interpretation in Z3, but Z3 recently changed and now incorporates
  the nondeterministic\n    output. SBV similarly changed to allow for non-determinism
  here.\n\n  * Change the types of the following Floating-point operations:\n\n        *
  sFloatAsSWord32, sFloatAsSWord32, blastSFloat, blastSDouble\n\n    These were previously
  coded as relations, since NaN values were not representable\n    in the target domain
  uniquely. While it was OK, it was hard to use them. We now\n    simply implement
  these as functions, and they are underspecified if the inputs\n    are NaNs: In
  those cases, we simply get a symbolic output. The new types are:\n\n       * sFloatAsSWord32
  \ :: SFloat  -> SWord32\n       * sDoubleAsSWord64 :: SDouble -> SWord64\n       *
  blastSFloat      :: SFloat  -> (SBool, [SBool], [SBool])\n       * blastSDouble
  \    :: SDouble -> (SBool, [SBool], [SBool])\n\n  * MathSAT backend: Use the SMTLib
  interpretation of fp.min/fp.max by passing the\n    \"-theory.fp.minmax_zero_mode=4\"
  argument explicitly.\n\n  * Fix a bug in hash-consing of floating-point constants,
  where we were confusing +0 and\n    -0 since we were using them as keys into the
  map though they compare equal. We now\n    explicitly keep track of the negative-zero
  status to make sure this confusion does\n    not arise. Note that this bug only
  exhibited itself in rare occurrences of both\n    constants being present in a benchmark;
  a true corner case. Note that @NaN@ values\n    are also interesting in this context:
  Since NaN /= NaN, we never hash-cons floating\n    point constants that have the
  value NaN. But that is actually OK; it is a bit wasteful\n    in case you have a
  lot of NaN constants around, but there is no soundness issue: We\n    just waste
  a little bit of space.\n\n  * Remove the functions `allSatWithAny` and `allSatWithAll`.
  These two variants do *not*\n    make sense when run with multiple solvers, as they
  internally sequentialize the solutions\n    due to the nature of `allSat`. Not really
  needed anyhow; so removed. The variants\n    `satWithAny/All` and `proveWithAny/All`
  are still available.\n\n  * Export SMTLibVersion from the library, forgotten export
  needed by Cryptol. Thanks to Adam\n    Foltzer for the patch.\n\n  * Slightly modify
  model-outputs so the variables are aligned vertically. (Only matters\n    if we
  have model-variable names that are of differing length.)\n\n  * Move to Travis-CI
  \"docker\" based infrastructure for builds\n\n  * Enable local builds to use the
  Herbie plugin. Currently SBV does not have any\n    expressions that can benefit
  from Herbie, but it is nice to have this support in general.\n\n### Version 5.0,
  2015-09-22\n\n  * Note: This is a backwards-compatibility breaking release, see
  below for details.\n\n  * SBV now requires GHC 7.10.1 or newer to be compiled, taking
  advantage of newer features/bug-fixes\n    in GHC. If you really need SBV to compile
  with older GHCs, please get in touch.\n\n  * SBV no longer supports SMTLib1. We
  now exclusively use SMTLib2 for communicating with backend\n    solvers. Strictly
  speaking, this means some loss in functionality: Uninterpreted-function models\n
  \   that we supported via Yices-1 are no longer available. In practice this facility
  was not really\n    used, and required a very old version of Yices that was no longer
  supported by SRI and has\n    lacked in other features. So, in reality this change
  should hardly matter for end-users.\n\n  * Added function `label`, which is useful
  in emitting comments around expressions. It is essentially\n    a no-op, but does
  generate a comment with the given text in the SMT-Lib and C output, for diagnostic\n
  \   purposes.\n\n  * Added `sFromIntegral`: Conversions from all integral types
  (SInteger, SWord/SInts) between\n    each other. Similar to the `fromIntegral` function
  of Haskell. These generate simple casts when\n    used in code-generation to C,
  and thus are very efficient.\n\n  * SBV no longer supports the functions sBranch/sAssert,
  as we realized these functions can cause\n    soundness issues under certain conditions.
  While the triggering scenarios are not common use-cases\n    for these functions,
  we are opting for safety, and thus removing support. See\n    http://github.com/LeventErkok/sbv/issues/180
  for details; and see below for the new function\n    'isSatisfiableInCurrentPath'.\n\n
  \ * A new function 'isSatisfiableInCurrentPath' is added, which checks for satisfiability
  during a\n    symbolic simulation run. This function can be used as the basis of
  sBranch/sAssert like functionality\n    if needed. The difference is that this is
  a much lower level call, and also exposes the fact that\n    the result is in the
  'Symbolic' monad (which avoids the soundness issue). Of course, the new type\n    makes
  it less useful as it will not be a drop-in replacement for if-then-else like structure.
  Intended\n    to be used by tools built on top of SBV, as opposed to end-users.\n\n
  \ * SBV no longer implements the 'SignCast' class, as its functionality is replaced
  by the 'sFromIntegral'\n    function. Programs using the functions 'signCast' and
  'unsignCast' should simply replace both\n    with calls to 'sFromIntegral'. (Note
  that extra type-annotations might be necessary, similar to\n    the uses of the
  'fromIntegral' function in Haskell.)\n\n  * Backend solver related changes:\n\n
  \      * Yices: Upgraded to work with Yices release 2.4.1. Note that earlier versions
  of Yices\n         are *not* supported.\n\n       * Boolector: Upgraded to work
  with new Boolector release 2.0.7. Note that earlier versions\n         of Boolector
  are *not* supported.\n\n       * MathSAT: Upgraded to work with latest release 5.3.7.
  Note that earlier versions of MathSAT\n         are *not* supported (due to a buffering
  issue in MathSAT itself.)\n\n       * MathSAT: Enabled floating-point support in
  MathSAT.\n\n  * New examples:\n\n       * Add Data.SBV.Examples.Puzzles.Birthday,
  which solves the Cheryl-Birthday problem that\n         went viral in April 2015.
  Turns out really easy to solve for SMT, but the formalization\n         of the problem
  is still interesting as an exercise in formal reasoning.\n\n       * Add Data.SBV.Examples.Puzzles.SendMoreMoney,
  which solves the classic send + more = money\n         problem. Really a trivial
  example, but included since it is pretty much the hello-world for\n         basic
  constraint solving.\n\n       * Add Data.SBV.Examples.Puzzles.Fish, which solves
  a typical logic puzzle; finding the unique\n         solution to a set of assertions
  made about a bunch of people, their pets, beverage choices,\n         etc. Not particularly
  interesting, but could be fun to play around with for modeling purposes.\n\n       *
  Add Data.SBV.Examples.BitPrecise.MultMask, which demonstrates the use of the bitvector\n
  \        solver to an interesting bit-shuffling problem.\n\n  * Rework floating-point
  arithmetic, and add missing floating-point operations:\n\n      * fpRem            :
  remainder\n      * fpRoundToIntegral: truncating round\n      * fpMin            :
  min\n      * fpMax            : max\n      * fpIsEqualObject  : FP equality as object
  (i.e., NaN equals NaN, +0 does not equal -0, etc.)\n\n    This brings SBV up-to
  par with everything supported by the SMT-Lib FP theory.\n\n  * Add the IEEEFloatConvertable
  class, which provides conversions to/from Floats and other types. (i.e.,\n    value
  conversions from all other types to Floats and Doubles; and back.)\n\n  * Add SWord32/SWord64
  to/from SFloat/SDouble conversions, as bit-pattern reinterpretation; using the\n
  \   IEEE754 interchange format. The functions are: sWord32AsSFloat, sWord64AsSDouble,
  sFloatAsSWord32,\n    sDoubleAsSWord64. Note that the sWord32AsSFloat and sWord64ToSDouble
  are regular functions, but\n    sFloatToSWord32 and sDoubleToSWord64 are \"relations\",
  since NaN values are not uniquely convertable.\n\n  * Add 'sExtractBits', which
  takes a list of indices to extract bits from, essentially\n    equivalent to 'map
  sTestBit'.\n\n  * Rename a set of symbolic functions for consistency. Here are the
  old/new names:\n\n     * sbvTestBit               --> sTestBit\n     * sbvPopCount
  \             --> sPopCount\n     * sbvShiftLeft             --> sShiftLeft\n     *
  sbvShiftRight            --> sShiftRight\n     * sbvRotateLeft            --> sRotateLeft\n
  \    * sbvRotateRight           --> sRotateRight\n     * sbvSignedShiftArithRight
  --> sSignedShiftArithRight\n\n  * Rename all FP recognizers to be in sync with FP
  operations. Here are the old/new names:\n\n     * isNormalFP       --> fpIsNormal\n
  \    * isSubnormalFP    --> fpIsSubnormal\n     * isZeroFP         --> fpIsZero\n
  \    * isInfiniteFP     --> fpIsInfinite\n     * isNaNFP          --> fpIsNaN\n
  \    * isNegativeFP     --> fpIsNegative\n     * isPositiveFP     --> fpIsPositive\n
  \    * isNegativeZeroFP --> fpIsNegativeZero\n     * isPositiveZeroFP --> fpIsPositiveZero\n
  \    * isPointFP        --> fpIsPoint\n\n  * Lots of other work around floating-point,
  test cases, reorg, etc.\n\n  * Introduce shorter variants for rounding modes: sRNE,
  sRNA, sRTP, sRTN, sRTZ;\n    aliases for sRoundNearestTiesToEven, sRoundNearestTiesToAway,
  sRoundTowardPositive,\n    sRoundTowardNegative, and sRoundTowardZero; respectively.\n\n###
  Version 4.4, 2015-04-13\n\n  * Hook-up crackNum package; so counter-examples involving
  floats and\n    doubles can be printed in detail when the printBase is chosen to
  be\n    2 or 16. (With base 10, we still get the simple output.)\n\n      ```\n
  \     Prelude Data.SBV> satWith z3{printBase=2} $ \\x -> x .== (2::SFloat)\n      Satisfiable.
  Model:\n        s0 = 2.0 :: Float\n                        3  2          1         0\n
  \                       1 09876543 21098765432109876543210\n                        S
  ---E8--- ----------F23----------\n                Binary: 0 10000000 00000000000000000000000\n
  \                  Hex: 4000 0000\n             Precision: SP\n                  Sign:
  Positive\n              Exponent: 1 (Stored: 128, Bias: 127)\n                 Value:
  +2.0 (NORMAL)\n      ```\n\n  * Change how we print type info; for models insted
  of SType just print Type (i.e.,\n    for SWord8, instead print Word8) which makes
  more sense and is more consistent.\n    This change should be mostly relevant as
  how we see the counter-example output.\n\n  * Fix long standing bug #75, where we
  now support arrays with Boolean source/targets.\n    This is not a very commonly
  used case, but by letting the solver pick the logic,\n    we now allow arrays to
  be uniformly supported.\n\n### Version 4.3, 2015-04-10\n\n  * Introduce Data.SBV.Dynamic,
  by Brian Huffman. This is mostly an internal\n    reorg of the SBV codebase, and
  end-users should not be impacted by the\n    changes. The introduction of the Dynamic
  SBV variant (i.e., one that does\n    not mandate a phantom type as in `SBV Word8`
  etc. allows library writers\n    more flexibility as they deal with arbitrary bit-vector
  sizes. The main\n    customer of these changes are the Cryptol language and the
  associated\n    toolset, but other developers building on top of SBV can find it
  useful\n    as well. NB: The \"strongly-typed\" aspect of SBV is still the main
  way\n    end-users should interact with SBV, and nothing changed in that respect!\n\n
  \ * Add symbolic variants of floating-point rounding-modes for convenience\n\n  *
  Rename toSReal to sIntegerToSReal, which captures the intent more clearly\n\n  *
  Code clean-up: remove mbMinBound/mbMaxBound thus allowing less calls to\n    unliteral.
  Contributed by Brian Huffman.\n\n  * Introduce FP conversion functions:\n\n       *
  Between SReal and SFloat/SDouble\n           * fpToSReal\n           * sRealToSFloat\n
  \          * sRealToSDouble\n       * Between SWord32 and SFloat\n           * sWord32ToSFloat\n
  \          * sFloatToSWord32\n       * Between SWord64 and SDouble. (Relational,
  due to non-unique NaNs)\n           * sWord64ToSDouble\n       * sDoubleToSWord64\n
  \      * From float to sign/exponent/mantissa fields: (Relational, due to non-unique
  NaNs)\n           * blastSFloat\n           * blastSDouble\n\n  * Rework floating
  point classifiers. Remove isSNaN and isFPPoint (both renamed),\n    and add the
  following new recognizers:\n\n       * isNormalFP\n       * isSubnormalFP\n       *
  isZeroFP\n       * isInfiniteFP\n       * isNaNFP\n       * isNegativeFP\n       *
  isPositiveFP\n       * isNegativeZeroFP\n       * isPositiveZeroFP\n       * isPointFP
  (corresponds to a real number, i.e., neither NaN nor infinity)\n\n  * Re-implement
  sbvTestBit, by Brian Huffman. This version is much faster at large\n    word sizes,
  as it avoids the costly mask generation.\n\n  * Code changes to suppress warnings
  with GHC7.10. General clean-up.\n\n### Version 4.2, 2015-03-17\n\n  * Add exponentiation
  (.^). Thanks to Daniel Wagner for contributing the code!\n\n  * Better handling
  of SBV_$SOLVER_OPTIONS, in particular keeping track of\n    proper quoting in environment
  variables. Thanks to Adam Foltzer for\n    the patch!\n\n  * Silence some hlint/ghci
  warnings. Thanks to Trevor Elliott for the patch!\n\n  * Haddock documentation fixes,
  improvements, etc.\n\n  * Change ABC default option string to %blast; \"&sweep -C
  5000; &syn4; &cec -s -m -C 2000\"\n    which seems to give good results. Use SBV_ABC_OPTIONS
  environment variable (or\n    via abc.rc file and a combination of SBV_ABC_OPTIONS)
  to experiment.\n\n### Version 4.1, 2015-03-06\n\n  * Add support for the ABC solver
  from Berkeley. Thanks to Adam Foltzer\n    for the required infrastructure! See:
  http://www.eecs.berkeley.edu/~alanmi/abc/\n    And Alan Mishchenko for adding infrastructure
  to ABC to work with SBV.\n\n  * Upgrade the Boolector connection to use a SMT-Lib2
  based interaction. NB. You\n    need at least Boolector 2.0.6 installed!\n\n  *
  Tracking changes in the SMT-Lib floating-point theory. If you are\n    using symbolic
  floating-point types (i.e., SFloat and SDouble), then\n    you should upgrade to
  this version and also get a very latest (unstable)\n    Z3 release. See http://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml\n
  \   for details.\n\n  * Introduce a new class, 'RoundingFloat', which supports floating-point\n
  \   operations with arbitrary rounding-modes. Note that Haskell only allows\n    RoundNearestTiesToAway,
  but with SBV, we get all 5 IEEE754 rounding-modes\n    and all the basic operations
  ('fpAdd', 'fpMul', 'fpDiv', etc.) with these\n    modes.\n\n  * Allow Floating-Point
  RoundingMode to be symbolic as well\n\n  * Improve the example `Data/SBV/Examples/Misc/Floating.hs`
  to include\n    rounding-mode based addition example.\n\n  * Changes required to
  make SBV compile with GHC 7.10; mostly around instance\n    NFData declarations.
  Thanks to Iavor Diatchki for the patch.\n\n  * Export a few extra symbols from the
  Internals module (mainly for\n    Cryptol usage.)\n\n### Version 4.0, 2015-01-22\n\nThis
  release mainly contains contributions from Brian Huffman, allowing\nend-users to
  define new symbolic types, such as Word4, that SBV does not\nnatively support. When
  GHC gets type-level literals, we shall most likely\nincorporate arbitrary bit-sized
  vectors and ints using this mechanism,\nbut in the interim, this release provides
  a means for the users to introduce\nindividual instances.\n\n  * Modifications to
  support arbitrary bit-sized vectors;\n    These changes have been contributed by
  Brian Huffman\n    of Galois. Thanks Brian.\n  * A new example `Data/SBV/Examples/Misc/Word4.hs`
  showing\n    how users can add new symbolic types.\n  * Support for rotate-left/rotate-right
  with variable\n    rotation amounts. (From Brian Huffman.)\n\n### Version 3.5, 2015-01-15\n\nThis
  release is mainly adding support for enumerated types in Haskell being\ntranslated
  to their symbolic counterparts; instead of going completely\nuninterpreted.\n\n
  \ * Keep track of data-type details for uninterpreted sorts.\n  * Rework the U2Bridge
  example to use enumerated types.\n  * The \"Uninterpreted\" name no longer makes
  sense with this change, so\n    rework the relevant names to ensure proper internal
  naming.\n  * Add Data/SBV/Examples/Misc/Enumerate.hs as an example for demonstrating\n
  \   how enumerations are translated.\n  * Fix a long-standing bug in the implementation
  of select when\n    translated as SMT-Lib tables. (Github issue #103.) Thanks to\n
  \   Brian Huffman for reporting.\n\n### Version 3.4, 2014-12-21\n\n  * This release
  is mainly addressing floating-point changes in SMT-Lib.\n\n      * Track changes
  in the QF_FPA logic standard; new constants and alike. If you are\n        using
  the floating-point logic, then you need a relatively new version of Z3\n        installed
  (4.3.3 or newer).\n\n      * Add unary-negation as an explicit operator. Previously,
  we merely used the \"0-x\"\n        semantics; but with floating point, this does
  not hold as 0-0 is 0, and is not -0!\n        (Note that negative-zero is a valid
  floating point value, that is different than\n        positive-zero; yet it compares
  equal to it. Sigh..)\n\n      * Similarly, add abs as a native method; to make sure
  we map it to fp.abs for\n        floating point values.\n\n      * Test suite improvements\n\n###
  Version 3.3, 2014-12-05\n\n  * Implement 'safe' and 'safeWith', which statically
  determine all calls to 'sAssert'\n    being safe to execute. This way, users can
  pepper their programs with liberal\n    calls to 'sAssert' and check they are all
  safe in one go without further worry.\n\n  * Robustify the interface to external
  solvers, by making sure we catch cases where\n    the external solver might exist
  but not be runnable (library dependency missing,\n    for example). It is impossible
  to be absolutely foolproof, but we now catch a\n    few more cases and fail gracefully.\n\n###
  Version 3.2, 2014-11-18\n\n  * Implement 'sAssert'. This adds conditional symbolic
  simulation, by ensuring arbitrary\n    boolean conditions hold during simulation;
  similar to ASSERT calls in other languages.\n    Note that failures will be detected
  at symbolic-simulation time, i.e., each assert will\n    generate a call to the
  external solver to ensure that the condition is never violated.\n    If violation
  is possible the user will get an error, indicating the failure conditions.\n\n  *
  Also implement 'sAssertCont' which allows for a programmatic way to extract/display
  results\n    for consumers of 'sAssert'. While the latter simply calls 'error' in
  case of an assertion\n    violation, the 'sAssertCont' variant takes a continuation
  which can be used to program\n    how the results should be interpreted/displayed.
  (This is useful for libraries built on top of\n    SBV.) Note that the type of the
  continuation is such that execution should still stop, i.e.,\n    once an assertion
  violation is detected, symbolic simulation will never continue.\n\n  * Rework/simplify
  the 'Mergeable' class to make sure 'sBranch' is sufficiently lazy\n    in case of
  structural merges. The original implementation was only\n    lazy at the Word instance,
  but not at lists/tuples etc. Thanks to Brian Huffman\n    for reporting this bug.\n\n
  \ * Add a few constant-folding optimizations for 'sDiv' and 'sRem'\n\n  * Boolector:
  Modify output parser to conform to the new Boolector output format. This\n    means
  that you need at least v2.0.0 of Boolector installed if you want to use that\n    particular
  solver.\n\n  * Fix long-standing translation bug regarding boolean Ord class comparisons.
  (i.e.,\n    'False > True' etc.) While Haskell allows for this, SMT-Lib does not;
  and hence\n    we have to be careful in translating. Thanks to Brian Huffman for
  reporting.\n\n  * C code generation: Correctly translate square-root and fusedMA
  functions to C.\n\n### Version 3.1, 2014-07-12\n\n NB: GHC 7.8.1 and 7.8.2 has a
  serious bug <http://ghc.haskell.org/trac/ghc/ticket/9078>\n     that causes SBV
  to crash under heavy/repeated calls. The bug is addressed\n     in GHC 7.8.3; so
  upgrading to GHC 7.8.3 is essential for using SBV!\n\n New features/bug-fixes in
  v3.1:\n\n * Using multiple-SMT solvers in parallel:\n      * Added functions that
  let the user run multiple solvers, using asynchronous\n        threads. All results
  can be obtained (proveWithAll, proveWithAny, satWithAll),\n        or SBV can return
  the fastest result (satWithAny, allSatWithAll, allSatWithAny).\n        These functions
  are good for playing with multiple-solvers, especially on\n        machines with
  multiple-cores.\n      * Add function: sbvAvailableSolvers; which returns the list
  of solvers currently\n        available, as installed on the machine we are running.
  (Not the list that SBV\n        supports, but those that are actually available
  at run-time.) This function\n        is useful with the multi-solve API.\n * Implement
  sBranch:\n      * sBranch is a variant of 'ite' that consults the external\n        SMT
  solver to see if a given branch condition is satisfiable\n        before evaluating
  it. This can make certain otherwise recursive\n        and thus not-symbolically-terminating
  inputs amenable to symbolic\n        simulation, if termination can be established
  this way. Needless\n        to say, this problem is always decidable as far as SBV
  programs\n        are concerned, but it does not mean the decision procedure is
  cheap!\n        Use with care.\n      * sBranchTimeOut config parameter can be used
  to curtail long runs when\n        sBranch is used. Of course, if time-out happens,
  SBV will\n        assume the branch is feasible, in which case symbolic-termination\n
  \       may come back to bite you.)\n * New API:\n      * Add predicate 'isSNaN'
  which allows testing 'SFloat'/'SDouble' values\n        for nan-ness. This is similar
  to the Prelude function 'isNaN', except\n        the Prelude version requires a
  RealFrac instance, which unfortunately is\n        not currently implementable for
  cases. (Requires trigonometric functions etc.)\n        Thus, we provide 'isSNaN'
  separately (along with the already existing\n        'isFPPoint') to simplify reasoning
  with floating-point.\n * Examples:\n     * Add Data/SBV/Examples/Misc/SBranch.hs,
  to illustrate the use of sBranch.\n * Bug fixes:\n     * Fix pipe-blocking issue,
  which exhibited itself in the presence of\n       large numbers of variables (>
  10K or so). See github issue #86. Thanks\n       to Philipp Meyer for the fine report.\n
  * Misc:\n     * Add missing SFloat/SDouble instances for SatModel class\n     *
  Explicitly support KBool as a kind, separating it from `KUnbounded False 1`.\n       Thanks
  to Brian Huffman for contributing the changes. This should have no\n       user-visible
  impact, but comes in handy for internal reasons.\n\n### Version 3.0, 2014-02-16\n\n
  * Support for floating-point numbers:\n      * Preliminary support for IEEE-floating
  point arithmetic, introducing\n        the types `SFloat` and `SDouble`. The support
  is still quite new,\n        and Z3 is the only solver that currently features a
  solver for\n        this logic. Likely to have bugs, both at the SBV level, and
  at the\n        Z3 level; so any bug reports are welcome!\n * New backend solvers:\n
  \     * SBV now supports MathSAT from Fondazione Bruno Kessler and\n        DISI-University
  of Trento. See: http://mathsat.fbk.eu/\n * Support all-sat calls in the presence
  of uninterpreted sorts:\n      * Implement better support for `allSat` in the presence
  of uninterpreted\n        sorts. Previously, SBV simply rejected running `allSat`
  queries\n        in the presence of uninterpreted sorts, since it was not possible\n
  \       to generate a refuting model. The model returned by the SMT solver\n        is
  simply not usable, since it names constants that is not visible\n        in a subsequent
  run. Eric Seidel came up with the idea that we can\n        actually compute equivalence
  classes based on a produced model, and\n        assert the constraint that the new
  model should disallow the previously\n        found equivalence classes instead.
  The idea seems to work well\n        in practice, and there is also an example program
  demonstrating\n        the functionality: Examples/Uninterpreted/UISortAllSat.hs\n
  * Programmable model extraction improvements:\n      * Add functions `getModelDictionary`
  and `getModelDictionaries`, which\n        provide low-level access to models returned
  from SMT solvers. Former\n        for `sat` and `prove` calls, latter for `allSat`
  calls. Together with\n        the exported utils from the `Data.SBV.Internals` module,
  this should\n        allow for expert users to dissect the models returned and do
  fancier\n        programming on top of SBV.\n      * Add `getModelValue`, `getModelValues`,
  `getModelUninterpretedValue`, and\n        `getModelUninterpretedValues`; which
  further aid in model value\n        extraction.\n * Other:\n      * Allow users
  to specify the SMT-Lib logic to use, if necessary. SBV will\n        still pick
  the logic automatically, but users can now override that choice.\n        Comes
  in handy when playing with custom logics.\n * Bug fixes:\n      * Address allsat-laziness
  issue (#78 in github issue tracker). Essentially,\n        simplify how all-sat
  is called so we can avoid calling the solver for\n        solutions that are not
  needed. Thanks to Eric Seidel for reporting.\n * Examples:\n      * Add Data/SBV/Examples/Misc/ModelExtract.hs
  as a simple example for\n        programmable model extraction and usage.\n      *
  Add Data/SBV/Examples/Misc/Floating.hs for some FP examples.\n      * Use the AUFLIA
  logic in Examples.Existentials.Diophantine which helps\n        z3 complete the
  proof quickly. (The BV logics take too long for this problem.)\n\n### Version 2.10,
  2013-03-22\n\n * Add support for the Boolector SMT solver\n    * See: http://fmv.jku.at/boolector/\n
  \   * Use `import Data.SBV.Bridge.Boolector` to use Boolector from SBV\n    * Boolector
  supports QF_BV (with an without arrays). In the last\n      SMT-Lib competition
  it won both bit-vector categories. It is definitely\n      worth trying it out for
  bitvector problems.\n * Changes to the library:\n    * Generalize types of `allDifferent`
  and `allEqual` to take\n      arbitrary EqSymbolic values. (Previously was just
  over SBV values.)\n    * Add `inRange` predicate, which checks if a value is bounded
  within\n      two others.\n    * Add `sElem` predicate, which checks for symbolic
  membership\n    * Add `fullAdder`: Returns the carry-over as a separate boolean
  bit.\n    * Add `fullMultiplier`: Returns both the lower and higher bits resulting\n
  \     from  multiplication.\n    * Use the SMT-Lib Bool sort to represent SBool,
  instead of bit-vectors of length 1.\n      While this is an under-the-hood mechanism
  that should be user-transparent, it\n      turns out that one can no longer write
  axioms that return booleans in a direct\n      way due to this translation. This
  change makes it easier to write axioms that\n      utilize booleans as there is
  now a 1-to-1 match. (Suggested by Thomas DuBuisson.)\n * Solvers changes:\n    *
  Z3: Update to the new parameter naming schema of Z3. This implies that\n      you
  need to have a really recent version of Z3 installed, something\n      in the Z3-4.3
  series.\n * Examples:\n    * Add Examples/Uninterpreted/Shannon.hs: Demonstrating
  Shannon expansion,\n      boolean derivatives, etc.\n * Bug-fixes:\n    * Gracefully
  handle the case if the backend-SMT solver does not put anything\n      in stdout.
  (Reported by Thomas DuBuisson.)\n    * Handle uninterpreted sort values, if they
  happen to be only created via\n      function calls, as opposed to being inputs.
  (Reported by Thomas DuBuisson.)\n\n### Version 2.9, 2013-01-02\n\n  * Add support
  for the CVC4 SMT solver from Stanford: <http://cvc4.cs.stanford.edu/web/>\n    NB.
  Z3 remains the default solver for SBV. To use CVC4, use the\n    *With variants
  of the interface (i.e., proveWith, satWith, ..)\n    by passing cvc4 as the solver
  argument. (Similarly, use 'yices'\n    as the argument for the *With functions for
  invoking yices.)\n  * Latest release of Yices calls the SMT-Lib based solver executable\n
  \   yices-smt. Updated the default value of the executable to have this\n    name
  for ease of use.\n  * Add an extra boolean flag to compileToSMTLib and generateSMTBenchmarks\n
  \   functions to control if the translation should keep the query as is\n    (for
  SAT cases), or negate it (for PROVE cases). Previously, this value\n    was hard-coded
  to do the PROVE case only.\n  * Add bridge modules, to simplify use of different
  solvers. You can now say:\n\n          import Data.SBV.Bridge.CVC4\n          import
  Data.SBV.Bridge.Yices\n          import Data.SBV.Bridge.Z3\n\n    to pick the appropriate
  default solver. if you simply 'import Data.SBV', then\n    you will get the default
  SMT solver, which is currently Z3. The value\n    'defaultSMTSolver' refers to z3
  (currently), and 'sbvCurrentSolver' refers\n    to the chosen solver as determined
  by the imported module. (The latter is\n    useful for modifying options to the
  SMT solver in an solver-agnostic way.)\n  * Various improvements to Z3 model parsing
  routines.\n  * New web page for SBV: http://leventerkok.github.com/sbv/ is now online.\n\n###
  Version 2.8, 2012-11-29\n\n  * Rename the SNum class to SIntegral, and make it index
  over regular\n    types. This makes it much more useful, simplifying coding of\n
  \   polymorphic symbolic functions over integral types, which is\n    the common
  case.\n  * Add the functions:\n  * sbvShiftLeft\n  * sbvShiftRight\n    which can
  accommodate unsigned symbolic shift amounts. Note that\n    one cannot use the Haskell
  shiftL/shiftR functions from the Bits class since\n    they are hard-wired to take
  'Int' values as the shift amounts only.\n  * Add a new function 'sbvArithShiftRight',
  which is the same as\n    a shift-right, except it uses the MSB of the input as
  the bit to fill\n    in (instead of always filling in with 0 bits). Note that this
  is\n    the same as shiftRight for signed values, but differs from a shiftRight\n
  \   when the input is unsigned. (There is no Haskell analogue of this\n    function,
  as Haskell shiftR is always arithmetic for signed\n    types and logical for unsigned
  ones.) This variant is designed for\n    use cases when one uses the underlying
  unsigned SMT-Lib representation\n    to implement custom signed operations, for
  instance.\n  * Several typo fixes.\n\n### Version 2.7, 2012-10-21\n\n  * Add missing
  QuickCheck instance for SReal\n  * When dealing with concrete SReals, make sure
  to operate\n    only on exact algebraic reals on the Haskell side, leaving\n    true
  algebraic reals (i.e., those that are roots of polynomials\n    that cannot be expressed
  as a rational) symbolic. This avoids\n    issues with functions that we cannot implement
  directly on\n    the Haskell side, like exact square-roots.\n  * Documentation tweaks,
  typo fixes etc.\n  * Rename BVDivisible class to SDivisible; since SInteger\n    is
  also an instance of this class, and SDivisible is a\n    more appropriate name to
  start with. Also add sQuot and sRem\n    methods; along with sDivMod, sDiv, and
  sMod, with usual\n    semantics.\n  * Improve test suite, adding many constant-folding
  tests\n    and start using cabal based tests (--enable-tests option.)\n\n### Versions
  2.4, 2.5, and 2.6: Around mid October 2012\n\n  * Workaround issues related hackage
  compilation, in particular to the\n    problem with the new containers package release,
  which does provide\n    an NFData instance for sequences.\n  * Add explicit Num
  requirements when necessary, as the Bits class\n    no longer does this.\n  * Remove
  dependency on the hackage package strict-concurrency, as\n    hackage can no longer
  compile it due to some dependency mismatch.\n  * Add forgotten Real class instance
  for the type 'AlgReal'\n  * Stop putting bounds on hackage dependencies, as they
  cause\n    more trouble then they actually help. (See the discussion\n    here:
  <http://www.haskell.org/pipermail/haskell-cafe/2012-July/102352.html>.)\n\n### Version
  2.3, 2012-07-20\n\n  * Maintenance release, no new features.\n  * Tweak cabal dependencies
  to avoid using packages that are newer\n    than those that come with ghc-7.4.2.
  Apparently this is a no-no\n    that breaks many things, see the discussion in this
  thread:\n      http://www.haskell.org/pipermail/haskell-cafe/2012-July/102352.html\n
  \   In particular, the use of containers >= 0.5 is *not* OK until we have\n    a
  version of GHC that comes with that version.\n\n### Version 2.2, 2012-07-17\n\n
  \ * Maintenance release, no new features.\n  * Update cabal dependencies, in particular
  fix the\n    regression with respect to latest version of the\n    containers package.\n\n###
  Version 2.1, 2012-05-24\n\n * Library:\n    * Add support for uninterpreted sorts,
  together with user defined\n      domain axioms. See Data.SBV.Examples.Uninterpreted.Sort\n
  \     and Data.SBV.Examples.Uninterpreted.Deduce for basic examples of\n      this
  feature.\n    * Add support for C code-generation with SReals. The user picks\n
  \     one of 3 possible C types for the SReal type: CgFloat, CgDouble\n      or
  CgLongDouble, using the function cgSRealType. Naturally, the\n      resulting C
  program will suffer a loss of precision, as it will\n      be subject to IEE-754
  rounding as implied by the underlying type.\n    * Add toSReal :: SInteger -> SReal,
  which can be used to promote\n      symbolic integers to reals. Comes handy in mixed
  integer/real\n      computations.\n * Examples:\n    * Recast the dog-cat-mouse
  example to use the solver over reals.\n    * Add Data.SBV.Examples.Uninterpreted.Sort,
  and\n           Data.SBV.Examples.Uninterpreted.Deduce\n      for illustrating uninterpreted
  sorts and axioms.\n\n### Version 2.0, 2012-05-10\n\n  This is a major release of
  SBV, adding support for symbolic algebraic reals: SReal.\n  See http://en.wikipedia.org/wiki/Algebraic_number
  for details. In brief, algebraic\n  reals are solutions to univariate polynomials
  with rational coefficients. The arithmetic\n  on algebraic reals is precise, with
  no approximation errors. Note that algebraic reals\n  are a proper subset of all
  reals, in particular transcendental numbers are not\n  representable in this way.
  (For instance, \"sqrt 2\" is algebraic, but pi, e are not.)\n  However, algebraic
  reals is a superset of rationals, so SBV now also supports symbolic\n  rationals
  as well.\n\n  You *should* use Z3 v4.0 when working with real numbers. While the
  interface will\n  work with older versions of Z3 (or other SMT solvers in general),
  it uses Z3\n  root-obj construct to retrieve and query algebraic reals.\n\n  While
  SReal values have infinite precision, printing such values is not trivial since\n
  \ we might need an infinite number of digits if the result happens to be irrational.
  The\n  user controls printing precision, by specifying how many digits after the
  decimal point\n  should be printed. The default number of decimal digits to print
  is 10. (See the\n  'printRealPrec' field of SMT-solver configuration.)\n\n  The
  acronym SBV used to stand for Symbolic Bit Vectors. However, SBV has grown beyond\n
  \ bit-vectors, especially with the addition of support for SInteger and SReal types
  and\n  other code-generation utilities. Therefore, \"SMT Based Verification\" is
  now a better fit\n  for the expansion of the acronym SBV.\n\n  Other notable changes
  in the library:\n\n  * Add functions s[TYPE] and s[TYPE]s for each symbolic type
  we support (i.e.,\n    sBool, sBools, sWord8, sWord8s, etc.), to create symbolic
  variables of the\n    right kind.  Strictly speaking these are just synonyms for
  'free'\n    and 'mapM free' (plural versions), so they are not adding any additional\n
  \   power. Except, they are specialized at their respective types, and might be\n
  \   easier to remember.\n  * Add function solve, which is merely a synonym for (return
  . bAnd), but\n    it simplifies expressing problems.\n  * Add class SNum, which
  simplifies writing polymorphic code over symbolic values\n  * Increase haddock coverage
  metrics\n  * Major code refactoring around symbolic kinds\n  * SMTLib2: Emit \":produce-models\"
  call before setting the logic, as required\n    by the SMT-Lib2 standard. [Patch
  provided by arrowdodger on github, thanks!]\n\n  Bugs fixed:\n\n   * [Performance]
  Use a much simpler default definition for \"select\": While the\n     older version
  (based on binary search on the bits of the indexer) was correct,\n     it created
  unnecessarily big expressions. Since SBV does not have a notion\n     of concrete
  subwords, the binary-search trick was not bringing any advantage\n     in any case.
  Instead, we now simply use a linear walk over the elements.\n\n  Examples:\n\n   *
  Change dog-cat-mouse example to use SInteger for the counts\n   * Add merge-sort
  example: Data.SBV.Examples.BitPrecise.MergeSort\n   * Add diophantine solver example:
  Data.SBV.Examples.Existentials.Diophantine\n\n### Version 1.4, 2012-05-10\n\n   *
  Interim release for test purposes\n\n### Version 1.3, 2012-02-25\n\n  * Workaround
  cabal/hackage issue, functionally the same as release\n    1.2 below\n\n### Version
  1.2, 2012-02-25\n\n Library:\n\n  * Add a hook so users can add custom script segments
  for SMT solvers. The new\n    \"solverTweaks\" field in the SMTConfig data-type
  can be used for this purpose.\n    The need for this came about due to the need
  to workaround a Z3 v3.2 issue\n    detailed below:\n      http://stackoverflow.com/questions/9426420/soundness-issue-with-integer-bv-mixed-benchmarks\n
  \   As a consequence, mixed Integer/BV problems can cause soundness issues in Z3\n
  \   and does in SBV. Unfortunately, it is too severe for SBV to add the workaround\n
  \   option, as it slows down the solver as a side effect as well. Thus, we are\n
  \   making this optionally available if/when needed. (Note that the work-around\n
  \   should not be necessary with Z3 v3.3; which is not released yet.)\n  * Other
  minor clean-up\n\n### Version 1.1, 2012-02-14\n\n Library:\n\n  * Rename bitValue
  to sbvTestBit\n  * Add sbvPopCount\n  * Add a custom implementation of 'popCount'
  for the Bits class\n    instance of SBV (GHC >= 7.4.1 only)\n  * Add 'sbvCheckSolverInstallation',
  which can be used to check\n    that the given solver is installed and good to go.\n
  \ * Add 'generateSMTBenchmarks', simplifying the generation of\n    SMTLib benchmarks
  for offline sharing.\n\n### Version 1.0, 2012-02-13\n\n Library:\n\n  * Z3 is now
  the \"default\" SMT solver. Yices is still available, but\n    has to be specifically
  selected. (Use satWith, allSatWith, proveWith, etc.)\n  * Better handling of the
  pConstrain probability threshold for test\n    case generation and quickCheck purposes.\n
  \ * Add 'renderTest', which accompanies 'genTest' to render test\n    vectors as
  Haskell/C/Forte program segments.\n  * Add 'expectedValue' which can compute the
  expected value of\n    a symbolic value under the given constraints. Useful for
  statistical\n    analysis and probability computations.\n  * When saturating provable
  values, use forAll_ for proofs and forSome_\n    for sat/allSat. (Previously we
  were allways using forAll_, which is\n    not incorrect but less intuitive.)\n  *
  add function:\n      extractModels :: SatModel a => AllSatResult -> [a]\n    which
  simplifies accessing allSat results greatly.\n\n Code-generation:\n\n  * add \"cgGenerateMakefile\"
  which allows the user to choose if SBV\n    should generate a Makefile. (default:
  True)\n\n Other\n\n  * Changes to make it compile with GHC 7.4.1.\n\n### Version
  0.9.24, 2011-12-28\n\n  Library:\n\n   * Add \"forSome,\" analogous to \"forAll.\"
  (The name \"exists\" would've\n     been better, but it's already taken.) This is
  not as useful as\n     one might think as forAll and forSome do not nest, as an
  inner\n     application of one pushes its argument to a Predicate, making\n     the
  outer one useless, but it is nonetheless useful by itself.\n   * Add a \"Modelable\"
  class, which simplifies model extraction.\n   * Add support for quick-check at the
  \"Symbolic SBool\" level. Previously\n     SBV only allowed functions returning
  SBool to be quick-checked, which\n     forced a certain style of coding. In particular
  with the addition\n     of quantifiers, the new coding style mostly puts the top-level\n
  \    expressions in the Symbolic monad, which were not quick-checkable\n     before.
  With new support, the quickCheck, prove, sat, and allSat\n     commands are all
  interchangeable with obvious meanings.\n   * Add support for concrete test case
  generation, see the genTest function.\n   * Improve optimize routines and add support
  for iterative optimization.\n   * Add \"constrain\", simplifying conjunctive constraints,
  especially\n     useful for adding constraints at variable generation time via\n
  \    forall/exists. Note that the interpretation of such constraints\n     is different
  for genTest and quickCheck functions, where constraints\n     will be used for appropriately
  filtering acceptable test values\n     in those two cases.\n   * Add \"pConstrain\",
  which probabilistically adds constraints. This\n     is useful for quickCheck and
  genTest functions for filtering acceptable\n     test values. (Calls to pConstrain
  will be rejected for sat/prove calls.)\n   * Add \"isVacuous\" which can be used
  to check that the constraints added\n     via constrain are satisfiable. This is
  useful to prevent vacuous passes,\n     i.e., when a proof is not just passing because
  the constraints imposed\n     are inconsistent. (Also added accompanying isVacuousWith.)\n
  \  * Add \"free\" and \"free_\", analogous to \"forall/forall_\" and \"exists/exists_\"\n
  \    The difference is that free behaves universally in a proof context, while\n
  \    it behaves existentially in a sat context. This allows us to express\n     properties
  more succinctly, since the intended semantics is usually this\n     way depending
  on the context. (i.e., in a proof, we want our variables\n     universal, in a sat
  call existential.) Of course, exists/forall are still\n     available when mixed
  quantifiers are needed, or when the user wants to\n     be explicit about the quantifiers.\n\n
  \ Examples\n\n   * Add Data/SBV/Examples/Puzzles/Coins.hs. (Shows the usage of \"constrain\".)\n\n
  \ Dependencies\n\n   * Bump up random package dependency to 1.0.1.1 (from 1.0.0.2)\n\n
  \ Internal\n\n   * Major reorganization of files to and build infrastructure to\n
  \    decrease build times and better layout\n   * Get rid of custom Setup.hs, just
  use simple build. The extra work\n     was not worth the complexity.\n\n### Version
  0.9.23, 2011-12-05\n\n  Library:\n\n   * Add support for SInteger, the type of signed
  unbounded integer\n     values. SBV can now prove theorems about unbounded numbers,\n
  \    following the semantics of Haskell Integer type. (Requires z3 to\n     be used
  as the backend solver.)\n   * Add functions 'optimize', 'maximize', and 'minimize'
  that can\n     be used to find optimal solutions to given constraints with\n     respect
  to a given cost function.\n   * Add 'cgUninterpret', which simplifies code generation
  when we want\n     to use an alternate definition in the target language (i.e.,
  C). This\n     is important for efficient code generation, when we want to\n     take
  advantage of native libraries available in the target platform.\n\n  Other:\n\n
  \  * Change getModel to return a tuple in the success case, where\n     the first
  component is a boolean indicating whether the model\n     is \"potential.\" This
  is used to indicate that the solver\n     actually returned \"unknown\" for the
  problem and the model\n     might therefore be bogus. Note that we did not need
  this before\n     since we only supported bounded bit-vectors, which has a decidable\n
  \    theory. With the addition of unbounded Integers and quantifiers, the\n     solvers
  can now return unknown. This should still be rare in practice,\n     but can happen
  with the use of non-linear constructs. (i.e.,\n     multiplication of two variables.)\n\n###
  Version 0.9.22, 2011-11-13\n\n  The major change in this release is the support
  for quantifiers. The\n  SBV library *no* longer assumes all variables are universals
  in a proof,\n  (and correspondingly existential in a sat) call. Instead, the user\n
  \ marks free-variables appropriately using forall/exists functions, and the\n  solver
  translates them accordingly. Note that this is a non-backwards\n  compatible change
  in sat calls, as the semantics of formulas is essentially\n  changing. While this
  is unfortunate, it is more uniform and simpler to understand\n  in general.\n\n
  \ This release also adds support for the Z3 solver, which is the main\n  SMT-solver
  used for solving formulas involving quantifiers. More formally,\n  we use the new
  AUFBV/ABV/UFBV logics when quantifiers are involved. Also,\n  the communication
  with Z3 is now done via SMT-Lib2 format. Eventually\n  the SMTLib1 connection will
  be severed.\n\n  The other main change is the support for C code generation with\n
  \ uninterpreted functions enabling users to interface with external\n  C functions
  defined elsewhere. See below for details.\n\n  Other changes:\n\n  Code:\n\n   *
  Change getModel, so it returns an Either value to indicate\n     something went
  wrong; instead of throwing an error\n   * Add support for computing CRCs directly
  (without needing\n     polynomial division).\n\n  Code generation:\n\n   * Add \"cgGenerateDriver\"
  function, which can be used to turn\n     on/off driver program generation. Default
  is to generate\n     a driver. (Issue \"cgGenerateDriver False\" to skip the driver.)\n
  \    For a library, a driver will be generated if any of the\n     constituent parts
  has a driver. Otherwise it will be skipped.\n   * Fix a bug in C code generation
  where \"Not\" over booleans were\n     incorrectly getting translated due to need
  for masking.\n   * Add support for compilation with uninterpreted functions. Users\n
  \    can now specify the corresponding C code and SBV will simply\n     call the
  \"native\" functions instead of generating it. This\n     enables interfacing with
  other C programs. See the functions:\n     cgAddPrototype, cgAddDecl, cgAddLDFlags\n\n
  \ Examples:\n\n   * Add CRC polynomial generation example via existentials\n   *
  Add USB CRC code generation example, both via polynomials and using the internal
  CRC functionality\n\n### Version 0.9.21, 2011-08-05\n\n Code generation:\n\n  *
  Allow for inclusion of user makefiles\n  * Allow for CCFLAGS to be set by the user\n
  \ * Other minor clean-up\n\n### Version 0.9.20, 2011-06-05\n\n  Regression on 0.9.19;
  add missing file to cabal\n\n### Version 0.9.19, 2011-06-05\n\n\n  * Add SignCast
  class for conversion between signed/unsigned\n    quantities for same-sized bit-vectors\n
  \ * Add full-binary trees that can be indexed symbolically (STree). The\n    advantage
  of this type is that the reads and writes take\n    logarithmic time. Suitable for
  implementing faster symbolic look-up.\n  * Expose HasSignAndSize class through Data.SBV.Internals\n
  \ * Many minor improvements, file re-orgs\n\nExamples:\n\n  * Add sentence-counting
  example\n  * Add an implementation of RC4\n\n### Version 0.9.18, 2011-04-07\n\nCode:\n\n
  \ * Re-engineer code-generation, and compilation to C.\n    In particular, allow
  arrays of inputs to be specified,\n    both as function arguments and output reference
  values.\n  * Add support for generation of generation of C-libraries,\n    allowing
  code generation for a set of functions that\n    work together.\n\nExamples:\n\n
  \ * Update code-generation examples to use the new API.\n  * Include a library-generation
  example for doing 128-bit\n    AES encryption\n\n### Version 0.9.17, 2011-03-29\n\nCode:\n\n
  \ * Simplify and reorganize the test suite\n\nExamples:\n\n  * Improve AES decryption
  example, by using\n    table-lookups in InvMixColumns.\n\n### Version 0.9.16, 2011-03-28\n\nCode:\n\n
  \ * Further optimizations on Bits instance of SBV\n\nExamples:\n\n  * Add AES algorithm
  as an example, showing how\n    encryption algorithms are particularly suitable\n
  \   for use with the code-generator\n\n### Version 0.9.15, 2011-03-24\n\nBug fixes:\n\n
  \ * Fix rotateL/rotateR instances on concrete\n    words. Previous versions was
  bogus since\n    it relied on the Integer instance, which\n    does the wrong thing
  after normalization.\n  * Fix conversion of signed numbers from bits,\n    previous
  version did not handle twos\n    complement layout correctly\n\nTesting:\n\n  *
  Add a sleuth of concrete test cases on\n    arithmetic to catch bugs. (There are
  many\n    of them, ~30K, but they run quickly.)\n\n### Version 0.9.14, 2011-03-19\n\n
  \ * Re-implement sharing using Stable names, inspired\n    by the Data.Reify techniques.
  This avoids tricks\n    with unsafe memory stashing, and hence is safe.\n    Thus,
  issues with respect to CAFs are now resolved.\n\n### Version 0.9.13, 2011-03-16\n\nBug
  fixes:\n\n  * Make sure SBool short-cut evaluations are done\n    as early as possible,
  as these help with coding\n    recursion-depth based algorithms, when dealing\n
  \   with symbolic termination issues.\n\nExamples:\n\n  * Add fibonacci code-generation
  example, original\n    code by Lee Pike.\n  * Add a GCD code-generation/verification
  example\n\n### Version 0.9.12, 2011-03-10\n\nNew features:\n\n  * Add support for
  compilation to C\n  * Add a mechanism for offline saving of SMT-Lib files\n\nBug
  fixes:\n\n  * Output naming bug, reported by Josef Svenningsson\n  * Specification
  bug in Legatos multiplier example\n\n### Version 0.9.11, 2011-02-16\n\n  * Make
  ghc-7.0 happy, minor re-org on the cabal file/Setup.hs\n\n### Version 0.9.10, 2011-02-15\n\n
  \ * Integrate commits from Iavor: Generalize SBVs to keep\n    track the integer
  directly without resorting to different\n    leaf types\n  * Remove the unnecessary
  CLC instruction from the Legato example\n  * More tests\n\n### Version 0.9.9, 2011-01-23\n\n
  \ * Support for user-defined SMT-Lib axioms to be\n    specified for uninterpreted
  constants/functions\n  * Move to using doctest style inline tests\n\n### Version
  0.9.8, 2011-01-22\n\n  * Better support for uninterpreted-functions\n  * Support
  counter-examples with SArrays\n  * Ladner-Fischer scheme example\n  * Documentation
  updates\n\n### Version 0.9.7, 2011-01-18\n\n  * First stable public hackage release\n\n###
  Versions 0.0.0 - 0.9.6, Mid 2010 through early 2011\n\n  * Basic infrastructure,
  design exploration\n"
basic-deps:
  ghc: -any
  base: ! '>=4.11 && <5'
  time: -any
  syb: -any
  generic-deriving: -any
  filepath: -any
  process: -any
  async: -any
  crackNum: ! '>=2.3'
  array: -any
  containers: -any
  mtl: -any
  transformers: -any
  random: -any
  deepseq: -any
  QuickCheck: -any
  pretty: -any
  template-haskell: -any
  directory: -any
all-versions:
- '6.0'
- '6.1'
- '7.0'
- '7.1'
- '7.2'
- '7.3'
- '7.4'
- '7.5'
- '7.6'
- '7.7'
- '7.8'
- '7.9'
- '7.10'
- '7.11'
- '7.12'
- '7.13'
- '8.0'
- '8.1'
- '8.2'
- '8.3'
author: Levent Erkok
latest: '8.3'
description-type: markdown
description: |
  ## SBV: SMT Based Verification in Haskell

  [![Hackage version](http://img.shields.io/hackage/v/sbv.svg?label=Hackage)](http://hackage.haskell.org/package/sbv)

  Please see: http://leventerkok.github.io/sbv/

  ### Build Status

   - Linux:
       - GHC 8.4.4 [![Build1][3]][1]
       - GHC 8.6.3 [![Build1][4]][1]
   - Mac OSX:
       - GHC 8.6.3 [![Build1][5]][1]
   - Windows:
       - GHC 8.6.2 [![Build5][6]][2]

  [1]: https://travis-ci.org/LeventErkok/sbv
  [2]: https://ci.appveyor.com/project/LeventErkok/sbv
  [3]: https://travis-matrix-badges.herokuapp.com/repos/LeventErkok/sbv/branches/master/1
  [4]: https://travis-matrix-badges.herokuapp.com/repos/LeventErkok/sbv/branches/master/2
  [5]: https://travis-matrix-badges.herokuapp.com/repos/LeventErkok/sbv/branches/master/3
  [6]: https://ci.appveyor.com/api/projects/status/github/LeventErkok/sbv?svg=true
license-name: BSD-3-Clause

homepage: https://github.com/pa-ba/AsyncRattus/
changelog-type: markdown
hash: 056d3a3b655de68aed9a49f472f3c51111434f2b6e2de56afa0845a74c145760
test-bench-deps:
  base: -any
  text: -any
  containers: -any
  AsyncRattus: -any
maintainer: Patrick Bahr <paba@itu.dk>
synopsis: An asynchronous modal FRP language
changelog: |
  # 0.1.0.3

  Fix concurrency bug in the interaction of output and input channels.
  This occurred when using mkInput (and thus also filter functions on
  signals).

  # 0.1.0.2

  Make Integer and Text stable types

  # 0.1.0.1

  Compatibility with GHC 9.8

  # 0.1

  First release.
basic-deps:
  ghc: '>=9.2 && <9.9'
  base: '>=4.16 && <5'
  simple-affine-space: '>=0.2.1 && <0.3'
  containers: '>=0.6.5 && <0.8'
  ghc-boot: '>=9.2 && <9.9'
  hashtables: '>=1.3.1 && <1.4'
  transformers: '>=0.5.6 && <0.7'
all-versions:
- '0.1'
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
author: Emil Houlborg, Gregers RÃ¸rdam, Patrick Bahr
latest: 0.1.0.3
description-type: haddock
description: |-
  This library implements the Async Rattus programming
  language as an embedded DSL. To this end the library
  provides a GHC plugin that checks the stricter typing
  rules of Async Rattus.
  What follows is a brief introduction to the language and
  its usage. A more detailed introduction can be found in
  this <src/docs/paper.pdf paper>.

  Async Rattus is a functional reactive programming (FRP)
  language that uses modal types to express temporal
  dependencies. In return the language will guarantee that
  programs are productive (in each computation step, the
  program makes progress), causal (output depends only on
  current and earlier input), and have no space leaks
  (programs do not implicitly retain memory over time).

  The modal type constructor @O@ (pronounced "later") is
  used to express the passage of time at the type
  level. Intuitively speaking, a value of type @O a@
  represents a computation that will produce a value of type
  @a@ in the next time step. Additionally, the language also
  features the @Box@ modal type constructor. A value of type
  @Box a@ is a time-independent computation that can be
  executed at any time to produce a value of type @a@.

  For example, the type of signals is defined as

  > data Sig a = a ::: (O (Sig a))

  So the current value of the signal is available now, but
  its future state is only available in the next time
  step. Writing a @map@ function for this type of streams,
  requires us to use the @Box@ modality:

  > map :: Box (a -> b) -> Sig a -> Sig b
  > map f (x ::: xs) = unbox f x ::: delay (map f (adv xs))

  This makes sure that the function @f@ that we give to
  @map@ is available at any time in the future.

  The core of the language is defined in the module
  "AsyncRattus.Primitives". Note that the operations on @O@
  and @Box@ have non-standard typing rules. Therefore, this
  library provides a compiler plugin that checks these
  non-standard typing rules. To write Async Rattus programs,
  you must enable this plugin via the GHC option
  @-fplugin=AsyncRattus.Plugin@, e.g. by including the following
  line in the source file:

  > {-# OPTIONS -fplugin=AsyncRattus.Plugin #-}

  In addition, you have to annotate functions that are
  written in Async Rattus:

  > {-# ANN myFunction AsyncRattus #-}

  You can also annotate the whole module as an Async Rattus module:

  > {-# ANN module AsyncRattus #-}

  Below is a minimal Async Rattus program using the
  "AsyncRattus.Signal" module for programming with signals:

  > {-# OPTIONS -fplugin=AsyncRattus.Plugin #-}
  >
  > import AsyncRattus
  > import AsyncRattus.Signal
  >
  > {-# ANN sums AsyncRattus #-}
  > sums :: Sig Int -> Sig Int
  > sums = scan (box (+)) 0

  The <docs/src/AsyncRattus.Signal.html source code of the AsyncRattus.Signal module>
  provides more examples on how to program in Async Rattus.
  An example project using Async Rattus can be found
  <https://github.com/pa-ba/AsyncRattus/tree/master/examples/console here>.
license-name: BSD-3-Clause

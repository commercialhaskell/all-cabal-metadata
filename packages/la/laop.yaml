homepage: https://github.com/bolt12/laop#readme
changelog-type: markdown
hash: c28f4f8ab1fe218579daba8380064361f05547a42450f71118b14db04d469f54
test-bench-deps:
  laop: -any
  base: ! '>=4.7 && <5'
  deepseq: -any
maintainer: armandoifsantos@gmail.com
synopsis: ''
changelog: |
  # Changelog for laop

  ## Unreleased changes
basic-deps:
  laop: -any
  base: ! '>=4.7 && <5'
  criterion: -any
  deepseq: -any
  QuickCheck: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
- 0.1.0.4
author: Armando Santos
latest: 0.1.0.4
description-type: markdown
description: "# laop - Linear Algebra of Programming library\n\nThe LAoP discipline
  generalises relations and functions treating them as\nBoolean matrices and in turn
  consider these as arrows.\n\n__LAoP__ is a library for algebraic (inductive) construction
  and manipulation of matrices\nin Haskell. See [my Msc Thesis](https://github.com/bolt12/master-thesis)
  for the\nmotivation behind the library, the underlying theory, and implementation
  details.\n\nThis module offers many of the combinators mentioned in the work of\n[Macedo
  (2012)](https://repositorium.sdum.uminho.pt/handle/1822/22894) and [Oliveira (2012)](https://pdfs.semanticscholar.org/ccf5/27fa9179081223bffe8067edd81948644fc0.pdf).
  \n\nSee the candidate package in hackage [here](https://hackage.haskell.org/package/laop-0.1.0.0)\n\n##
  Features\n\nThis library offers:\n\n- An internal module representation that uses
  normal datatypes (`Void`, `()`, `Either`) for matrix dimensions and two\n  type
  families `FromNat` and `Count` to make it easier to work with these type of matrices.\n-
  An interfacing module that uses generalised types for the dimensions and is just
  a newtype wrapper\n  around the internal matrix data type.\n- An interfacing module
  that uses type level naturals for the dimensions and is just a newtype wrapper\n
  \ around the internal matrix data type.\n- An interfacing module that restricts
  the matrix contents to being only 0's or 1's (True\n  and False). This module is
  called 'Relation' and offers many of the combinators seen in\n  AoP and Relational
  Calculus/Algebra.\n- A very simple Probabilistic Programming module and several
  functions and data types to\n  make it easier to deal with sample space.\n\nGiven
  this, this new matrix formulation compared to other libraries one has much more
  advantages, such as:\n\n- Has an inductive definition enabling writing matrix manipulation
  functions in a much more elegant and calculational way;\n- Statically typed dimensions;\n-
  Polymorphic data type dimensions;\n- Polymorphic matrix content;\n- Awesome dimension
  type inference;\n- Fast type natural conversion via `FromNat` type family;\n- Matrix
  `Junc` and `Split`-ing in O(1);\n- Matrix composition takes advantage of divide-and-conquer
  and fusion laws.\n\nUnfortunately, this approach does not solve the issue of type
  dimensions being in some way constrainted making it impossible to write Arrow instances,
  for example. Type inference isn't perfect, when it comes to infer the types of matrices
  which dimensions are computed using type level naturals multiplication, the compiler
  needs type annotations in order to succeed.\n\n## Notes\n\nThis is still a work
  in progress, any feedback is welcome!\n\n## Example\n\n```Haskell\n{-# LANGUAGE
  DeriveGeneric #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeOperators
  #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE DataKinds #-}\n\nmodule Main
  where\n\nimport Matrix.Type\nimport Utils\nimport Dist\nimport GHC.TypeLits\nimport
  Data.Coerce\nimport GHC.Generics\nimport Control.Category hiding (id)\nimport Prelude
  hiding ((.))\n\n-- Monty Hall Problem\ndata Outcome = Win | Lose\n    deriving (Bounded,
  Enum, Eq, Show, Generic)\n\nswitch :: Outcome -> Outcome\nswitch Win = Lose\nswitch
  Lose = Win\n\nfirstChoice :: Matrix Double () Outcome\nfirstChoice = col [1/3, 2/3]\n\nsecondChoice
  :: Matrix Double Outcome Outcome\nsecondChoice = fromF' switch \n\n-- Dice sum\n\ntype
  SS = Natural 1 6 -- Sample Space\n\nsumSS :: SS -> SS -> Natural 2 12\nsumSS = coerceNat
  (+)\n\nsumSSM = fromF' (uncurry sumSS)\n\ncondition :: (Int, Int) -> Int -> Int\ncondition
  (fst, snd) thrd = if fst == snd\n                               then fst * 3\n                               else
  fst + snd + thrd\n\nconditionSS :: (SS, SS) -> SS -> Natural 3 18\nconditionSS =
  coerceNat2 condition\n\nconditionalThrows = fromF' (uncurry conditionSS) . khatri
  (khatri die die) die\n\ndie :: Matrix Double () SS\ndie = col $ map (const (1/6))
  [nat @1 @6 1 .. nat 6]\n\n-- Sprinkler\n\nrain :: Matrix Double () Bool\nrain =
  col [0.8, 0.2]\n\nsprinkler :: Matrix Double Bool Bool\nsprinkler = fromLists [[0.6,
  0.99], [0.4, 0.01]]\n\ngrass :: Matrix Double (Bool, Bool) Bool\ngrass = fromLists
  [[1, 0.2, 0.1, 0.01], [0, 0.8, 0.9, 0.99]]\n\nstate :: Matrix Double () (Bool, (Bool,
  Bool))\nstate = khatri grass identity . khatri sprinkler identity . rain\n\ngrass_wet
  :: Matrix Double (Bool, (Bool, Bool)) One\ngrass_wet = row [0,1] . kp1\n\nrainning
  :: Matrix Double (Bool, (Bool, Bool)) One\nrainning = row [0,1] . kp2 . kp2 \n\n--
  Alcuin Puzzle\n\ndata Being = Farmer | Fox | Goose | Beans\n  deriving (Bounded,
  Enum, Eq, Show, Generic)\n\ndata Bank = LeftB | RightB\n  deriving (Bounded, Enum,
  Eq, Show, Generic)\n\neats :: Being -> Being -> Bool\neats Fox Goose   = True\neats
  Goose Beans = True\neats _ _         = False\n\neatsR :: R.Relation Being Being\neatsR
  = R.toRel eats\n\ncross :: Bank -> Bank\ncross LeftB = RightB\ncross RightB = LeftB\n\ncrossR
  :: R.Relation Bank Bank\ncrossR = R.fromF' cross\n\n-- | Initial state, everyone
  in the left bank\nlocationLeft :: Being -> Bank\nlocationLeft _ = LeftB\n\nlocationLeftR
  :: R.Relation Being Bank\nlocationLeftR = R.fromF' locationLeft\n\n-- | Initial
  state, everyone in the right bank\nlocationRight :: Being -> Bank\nlocationRight
  _ = RightB\n\nlocationRightR :: R.Relation Being Bank\nlocationRightR = R.fromF'
  locationRight\n\n-- Properties\n\n-- Being at the same bank\nsameBank :: R.Relation
  Being Bank -> R.Relation Being Being\nsameBank = R.ker \n\n-- Risk of somebody eating
  somebody else\ncanEat :: R.Relation Being Bank -> R.Relation Being Being\ncanEat
  w = sameBank w `R.intersection` eatsR\n\n-- \"Starvation\" property.\ninv :: R.Relation
  Being Bank -> Bool\ninv w = (w `R.comp` canEat w) `R.sse` (w `R.comp` farmer)\n
  \ where\n    farmer :: R.Relation Being Being\n    farmer = R.fromF' (const Farmer)\n\n--
  Arbitrary state\nbankState :: Being -> Bank -> Bool\nbankState Farmer LeftB = True\nbankState
  Fox LeftB = True\nbankState Goose RightB = True\nbankState Beans RightB = True\nbankState
  _ _ = False\n\nbankStateR :: R.Relation Being Bank\nbankStateR = R.toRel bankState\n\n--
  Main\n\nmain :: IO ()\nmain = do\n    putStrLn \"Monty Hall Problem solution:\"\n
  \   prettyPrint (secondChoice . firstChoice)\n    putStrLn \"\\n Sum of dices probability:\"\n
  \   prettyPrint (sumSSM `comp` khatri die die)\n    putStrLn \"\\n Conditional dice
  throw:\"\n    prettyPrint conditionalThrows\n    putStrLn \"\\n Checking that the
  last result is indeed a distribution: \"\n    prettyPrint (bang . sumSSM . khatri
  die die)\n    putStrLn \"\\n Probability of grass being wet:\"\n    prettyPrint
  (grass_wet . state)\n    putStrLn \"\\n Probability of rain:\"\n    prettyPrint
  (rainning . state)\n    putStrLn \"\\n Is the arbitrary state a valid state? (Alcuin
  Puzzle)\"\n    print (inv bankStateR)\n```\n\n```Shell\nMonty Hall Problem solution:\n┌
  \                   ┐\n│ 0.6666666666666666 │\n│ 0.3333333333333333 │\n└                    ┘\n\n
  Sum of dices probability:\n┌                       ┐\n│ 2.7777777777777776e-2 │\n│
  \ 5.555555555555555e-2 │\n│  8.333333333333333e-2 │\n│    0.1111111111111111 │\n│
  \   0.1388888888888889 │\n│   0.16666666666666666 │\n│    0.1388888888888889 │\n│
  \   0.1111111111111111 │\n│  8.333333333333333e-2 │\n│  5.555555555555555e-2 │\n│
  2.7777777777777776e-2 │\n└                       ┘\n\n Conditional dice throw:\n┌
  \                      ┐\n│ 2.7777777777777776e-2 │\n│  9.259259259259259e-3 │\n│
  1.8518518518518517e-2 │\n│  6.481481481481481e-2 │\n│  5.555555555555555e-2 │\n│
  \ 8.333333333333333e-2 │\n│   0.12962962962962962 │\n│    0.1111111111111111 │\n│
  \   0.1111111111111111 │\n│   0.12962962962962962 │\n│  8.333333333333333e-2 │\n│
  \ 5.555555555555555e-2 │\n│  6.481481481481481e-2 │\n│ 1.8518518518518517e-2 │\n│
  \ 9.259259259259259e-3 │\n│ 2.7777777777777776e-2 │\n└                       ┘\n\n
  Checking that the last result is indeed a distribution: \n┌     ┐\n│ 1.0 │\n└     ┘\n\n
  Probability of grass being wet:\n┌                    ┐\n│ 0.4483800000000001 │\n└
  \                   ┘\n\n Probability of rain:\n┌     ┐\n│ 0.2 │\n└     ┘\n\nIs
  the arbitrary state a valid state? (Alcuin Puzzle)\nFalse\n```\n"
license-name: BSD-3-Clause

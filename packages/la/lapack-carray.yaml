homepage: http://hub.darcs.net/thielema/lapack-carray/
changelog-type: ''
hash: 2b608b192c79baa9e65b79946ca714ea09bd6365d475f77f497f97ff559597ab
test-bench-deps: {}
maintainer: Henning Thielemann <haskell@henning-thielemann.de>
synopsis: Auto-generated interface to Fortran LAPACK via CArrays
changelog: ''
basic-deps:
  netlib-ffi: '>=0.0 && <0.2'
  netlib-carray: '>=0.1 && <0.2'
  carray: '>=0.1.5 && <0.2'
  base: '>=4.5 && <5'
  storable-complex: '>=0.2.2 && <0.3'
  lapack-ffi: '>=0.0 && <0.1'
  transformers: '>=0.4 && <0.7'
all-versions:
- '0.0'
- 0.0.1
- 0.0.2
- 0.0.2.1
- 0.0.3
author: Henning Thielemann <haskell@henning-thielemann.de>
latest: 0.0.3
description-type: haddock
description: |-
  LAPACK is a package for efficient numerically robust linear algebra.
  The original implementation is written in FORTRAN.
  This is a semi-automatically generated mid-level wrapper.
  The functions are not ready to use for high-level applications,
  but they are a step closer.

  The functions are all in IO monad because they are auto-generated and
  we cannot make sure automatically that unsafePerformIO is always safe.
  Instead of raw pointers we use CArrays and IOCArrays
  and assign and check array bounds to LAPACK function parameters,
  as far we can retrieve this information from the FORTRAN comments.
  We check consistency of dimensions where consistent dimensions are required,
  but we cannot do all kind of bound checks.
  We use immutable CArray for input and output parameters
  and mutable IOCArray for input/output parameters.
  LAPACK plays some nasty tricks of in-place array updates
  on input/output arrays
  even if the dimensions of input and output array differ (see e.g. GELS).
  The wrappers also manage allocation of memory for function parameters.
  This is necessary since FORTRAN passes all parameters by reference.
  Further on, the wrappers convert from Haskell values like @Int@
  to low-level values like @CInt@.

  We provide bindings to functions of all variants
  for @Float@, @Double@, @Complex Float@ and @Complex Double@.
  We do not use TemplateHaskell nor HSC nor CHS, but instead Haskell 98 code
  generated by the custom @lapack-ffi-tools@ package.
license-name: BSD-3-Clause

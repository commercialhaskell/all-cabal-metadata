homepage: http://hub.darcs.net/thielema/lapack-carray/
changelog-type: ''
hash: 9529cb9e7b131f2de891b179659d7bf14c8314b47bb82d01ed0ca0922dc4c0eb
test-bench-deps: {}
maintainer: Henning Thielemann <haskell@henning-thielemann.de>
synopsis: Auto-generated interface to Fortran LAPACK via CArrays
changelog: ''
basic-deps:
  netlib-ffi: ! '>=0.0 && <0.1'
  netlib-carray: ! '>=0.0 && <0.1'
  carray: ! '>=0.1.5 && <0.2'
  base: ! '>=4.5 && <5'
  storable-complex: ! '>=0.2.2 && <0.3'
  lapack-ffi: ! '>=0.0 && <0.1'
  transformers: ! '>=0.4 && <0.6'
all-versions:
- '0.0'
author: Henning Thielemann <haskell@henning-thielemann.de>
latest: '0.0'
description-type: haddock
description: ! 'LAPACK is a package for efficient numerically robust linear algebra.

  The original implementation is written in FORTRAN.

  This is a semi-automatically generated mid-level wrapper.

  The functions are not ready to use for high-level applications,

  but they are a step closer.


  The functions are all in IO monad because they are auto-generated and

  we cannot make sure automatically that unsafePerformIO is always safe.

  Instead of raw pointers we use CArrays and IOCArrays

  and assign and check array bounds to LAPACK function parameters,

  as far we can retrieve this information from the FORTRAN comments.

  We check consistency of dimensions where consistent dimensions are required,

  but we cannot do all kind of bound checks.

  We use immutable CArray for input and output parameters

  and mutable IOCArray for input/output parameters.

  LAPACK plays some nasty tricks of in-place array updates

  on input/output arrays

  even if the dimensions of input and output array differ (see e.g. GELS).

  The wrappers also manage allocation of memory for function parameters.

  This is necessary since FORTRAN passes all parameters by reference.

  Further on, the wrappers convert from Haskell values like @Int@

  to low-level values like @CInt@.


  We provide bindings to functions of all variants

  for @Float@, @Double@, @Complex Float@ and @Complex Double@.

  We do not use TemplateHaskell nor HSC nor CHS, but instead Haskell 98 code

  generated by the custom @lapack-ffi-tools@ package.'
license-name: BSD3

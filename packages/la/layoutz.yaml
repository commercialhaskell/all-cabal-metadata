all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.2.0.0
author: Matthieu Court
basic-deps:
  base: '>=4.7 && <5'
changelog: ''
changelog-type: ''
description: "<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/layoutz-hs/pix/layoutz-demo.png\"
  width=\"750\">\n</p>\n\n# <img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/pix/layoutz.png\"
  width=\"60\"> layoutz\n\n**Simple, beautiful CLI output for Haskell \U0001FAB6**\n\nBuild
  declarative and composable sections, trees, tables, dashboards, and interactive
  Elm-style TUI's.\n\nPart of [d4](https://github.com/mattlianje/d4) • Also in: [JavaScript](https://github.com/mattlianje/layoutz/tree/master/layoutz-ts),
  [Scala](https://github.com/mattlianje/layoutz)\n\n## Features\n- Zero dependencies,
  use `Layoutz.hs` like a header file\n- Rich text formatting: alignment, underlines,
  padding, margins\n- Lists, trees, tables, charts, spinners...\n- ANSI colors and
  wide character support\n- Easily create new primitives (no component-library limitations)\n-
  [`LayoutzApp`](#interactive-apps) for Elm-style TUI's\n\n<p align=\"center\">\n<img
  src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/pix/layoutzapp-demo.gif\"
  height=\"350\"><img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/pix/game-demo.gif\"
  height=\"350\">\n<br>\n<sub><a href=\"TaskListDemo.hs\">TaskListDemo.hs</a> • <a
  href=\"SimpleGame.hs\">SimpleGame.hs</a></sub>\n</p>\n\n## Table of Contents\n-
  [Installation](#installation)\n- [Quickstart](#quickstart)\n- [Why layoutz?](#why-layoutz)\n-
  [Core Concepts](#core-concepts)\n- [Elements](#elements)\n- [Border Styles](#border-styles)\n-
  [Colors](#colors-ansi-support)\n- [Styles](#styles-ansi-support)\n- [Custom Components](#custom-components)\n-
  [Interactive Apps](#interactive-apps)\n\n## Installation\n\n**Add Layoutz on [Hackage](https://hackage.haskell.org/package/layoutz)
  to your project's `.cabal` file:**\n```haskell\nbuild-depends: layoutz\n```\n\nAll
  you need:\n```haskell\nimport Layoutz\n```\n\n## Quickstart\n\n**(1/2) Static rendering**
  - Beautiful, compositional strings:\n\n```haskell\nimport Layoutz\n\ndemo = layout\n
  \ [ center $ row \n      [ withStyle StyleBold $ text \"Layoutz\"\n      , withColor
  ColorCyan $ underline' \"ˆ\" $ text \"DEMO\"\n      ]\n  , br\n  , row\n    [ statusCard
  \"Users\" \"1.2K\"\n    , withBorder BorderDouble $ statusCard \"API\" \"UP\"\n
  \   , withColor ColorRed $ withBorder BorderThick $ statusCard \"CPU\" \"23%\"\n
  \   , withStyle StyleReverse $ withBorder BorderRound $ table [\"Name\", \"Role\",
  \"Skills\"] \n\t[ [\"Gegard\", \"Pugilist\", ul [\"Armenian\", ul [\"bad\", ul[\"man\"]]]]\n
  \       , [\"Eve\", \"QA\", \"Testing\"]\n        ]\n    ]\n  ]\n\nputStrLn $ render
  demo\n```\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/layoutz-hs/pix/intro-demo.png\"
  width=\"700\">\n</p>\n\n\n**(2/2) Interactive apps** - Build Elm-style TUI's:\n\n```haskell\nimport
  Layoutz\n\ndata Msg = Inc | Dec\n\ncounterApp :: LayoutzApp Int Msg\ncounterApp
  = LayoutzApp\n  { appInit = (0, None)\n  , appUpdate = \\msg count -> case msg of\n
  \     Inc -> (count + 1, None)\n      Dec -> (count - 1, None)\n  , appSubscriptions
  = \\_ -> onKeyPress $ \\key -> case key of\n      CharKey '+' -> Just Inc\n      CharKey
  '-' -> Just Dec\n      _           -> Nothing\n  , appView = \\count -> layout\n
  \     [ section \"Counter\" [text $ \"Count: \" <> show count]\n      , ul [\"Press
  '+' or '-'\", \"ESC to quit\"]\n      ]\n  }\n\nmain = runApp counterApp\n```\n<p
  align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/pix/counter-demo.gif\"
  width=\"500\">\n</p>\n\n## Why layoutz?\n- We have `printf` and [full-blown](https://hackage.haskell.org/package/brick)
  TUI libraries - but there's a gap in-between\n- **layoutz** is a tiny, declarative
  DSL for structured CLI output\n- On the side, it has a little Elm-style runtime
  + keyhandling DSL to animate your elements, much like a flipbook...\n     - But
  you can just use **Layoutz** without any of the TUI stuff\n\n## Core concepts\n-
  Every piece of content is an `Element`\n- Elements are **immutable** and **composable**
  - build complex layouts by combining simple elements\n- A `layout` arranges elements
  **vertically**:\n```haskell\nlayout [elem1, elem2, elem3]  -- Joins with \"\\n\"\n```\nCall
  `render` on any element to get a string\n\nThe power comes from **uniform composition**
  - since everything has the `Element` typeclass, everything can be combined.\n\n###
  String Literals\nWith `OverloadedStrings` enabled, you can use string literals directly:\n```haskell\nlayout
  [\"Hello\", \"World\"]  -- Instead of layout [text \"Hello\", text \"World\"]\n```\n\n**Note:**
  When passing to functions that take polymorphic `Element a` parameters (like `underline'`,
  `center'`, `pad`), use `text` explicitly:\n```haskell\nunderline' \"=\" $ text \"Title\"
  \ -- Correct\nunderline' \"=\" \"Title\"         -- Ambiguous type error\n```\n\n##
  Elements\n\n### Text\n```haskell\ntext \"Simple text\"\n-- Or with OverloadedStrings:\n\"Simple
  text\"\n```\n```\nSimple text\n```\n\n### Line Break\nAdd line breaks with `br`:\n```haskell\nlayout
  [\"Line 1\", br, \"Line 2\"]\n```\n```\nLine 1\n\nLine 2\n```\n\n### Section: `section`\n```haskell\nsection
  \"Config\" [kv [(\"env\", \"prod\")]]\nsection' \"-\" \"Status\" [kv [(\"health\",
  \"ok\")]]\nsection'' \"#\" \"Report\" 5 [kv [(\"items\", \"42\")]]\n```\n```\n===
  Config ===\nenv: prod\n\n--- Status ---\nhealth: ok\n\n##### Report #####\nitems:
  42\n```\n\n### Layout (vertical): `layout`\n```haskell\nlayout [\"First\", \"Second\",
  \"Third\"]\n```\n```\nFirst\nSecond\nThird\n```\n\n### Row (horizontal): `row`\nArrange
  elements side-by-side horizontally:\n```haskell\nrow [\"Left\", \"Middle\", \"Right\"]\n```\n```\nLeft
  Middle Right\n```\n\nMulti-line elements are aligned at the top:\n```haskell\nrow
  \n  [ layout [\"Left\", \"Column\"]\n  , layout [\"Middle\", \"Column\"]\n  , layout
  [\"Right\", \"Column\"]\n  ]\n```\n\n### Tight Row: `tightRow`\nLike `row`, but
  with no spacing between elements (useful for gradients and progress bars):\n```haskell\ntightRow
  [withColor ColorRed $ text \"█\", withColor ColorGreen $ text \"█\", withColor ColorBlue
  $ text \"█\"]\n```\n```\n███\n```\n\n### Text alignment: `alignLeft`, `alignRight`,
  `alignCenter`, `justify`\nAlign text within a specified width:\n```haskell\nlayout\n
  \ [ alignLeft 40 \"Left aligned\"\n  , alignCenter 40 \"Centered\"\n  , alignRight
  40 \"Right aligned\"\n  , justify 40 \"This text is justified evenly\"\n  ]\n```\n```\nLeft
  aligned                            \n               Centered                 \n
  \                          Right aligned\nThis  text  is  justified         evenly\n```\n\n###
  Horizontal rule: `hr`\n```haskell\nhr\nhr' \"~\"\nhr'' \"-\" 10\n```\n```\n──────────────────────────────────────────────────\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n----------\n```\n\n###
  Vertical rule: `vr`\n```haskell\nrow [vr, vr' \"║\", vr'' \"x\" 5]\n```\n```\n│
  ║ x\n│ ║ x\n│ ║ x\n│ ║ x\n│ ║ x\n│ ║\n│ ║\n│ ║\n│ ║\n│ ║\n```\n\n### Key-value pairs:
  `kv`\n```haskell\nkv [(\"name\", \"Alice\"), (\"role\", \"admin\")]\n```\n```\nname:
  Alice\nrole: admin\n```\n\n### Table: `table`\nTables automatically handle alignment
  and borders:\n```haskell\ntable [\"Name\", \"Age\", \"City\"] \n  [ [\"Alice\",
  \"30\", \"New York\"]\n  , [\"Bob\", \"25\", \"\"]\n  , [\"Charlie\", \"35\", \"London\"]\n
  \ ]\n```\n```\n┌─────────┬─────┬─────────┐\n│ Name    │ Age │ City    │\n├─────────┼─────┼─────────┤\n│
  Alice   │ 30  │ New York│\n│ Bob     │ 25  │         │\n│ Charlie │ 35  │ London
  \ │\n└─────────┴─────┴─────────┘\n```\n\n### Unordered Lists: `ul`\nClean unordered
  lists with automatic nesting:\n```haskell\nul [\"Feature A\", \"Feature B\", \"Feature
  C\"]\n```\n```\n• Feature A\n• Feature B\n• Feature C\n```\n\nNested lists with
  auto-styling:\n```haskell\nul [ \"Backend\"\n   , ul [\"API\", \"Database\"]\n   ,
  \"Frontend\"\n   , ul [\"Components\", ul [\"Header\", ul [\"Footer\"]]]\n   ]\n```\n```\n•
  Backend\n  ◦ API\n  ◦ Database\n• Frontend\n  ◦ Components\n    ▪ Header\n      •
  Footer\n```\n\n### Ordered Lists: `ol`\nNumbered lists with automatic nesting:\n```haskell\nol
  [\"First step\", \"Second step\", \"Third step\"]\n```\n```\n1. First step\n2. Second
  step\n3. Third step\n```\n\nNested ordered lists with automatic style cycling (numbers
  → letters → roman numerals):\n```haskell\nol [ \"Setup\"\n   , ol [\"Install dependencies\",
  \"Configure\", ol [\"Check version\"]]\n   , \"Build\"\n   , \"Deploy\"\n   ]\n```\n```\n1.
  Setup\n  a. Install dependencies\n  b. Configure\n    i. Check version\n2. Build\n3.
  Deploy\n```\n\n### Underline: `underline`\nAdd underlines to any element:\n```haskell\nunderline
  \"Important Title\"\nunderline' \"=\" $ text \"Custom\"  -- Use text for custom
  underline char\n```\n```\nImportant Title\n───────────────\n\nCustom\n══════\n```\n\n###
  Box: `box`\nWith title:\n```haskell\nbox \"Summary\" [kv [(\"total\", \"42\")]]\n```\n```\n┌──Summary───┐\n│
  total: 42  │\n└────────────┘\n```\n\nWithout title:\n```haskell\nbox \"\" [kv [(\"total\",
  \"42\")]]\n```\n```\n┌────────────┐\n│ total: 42  │\n└────────────┘\n```\n\n###
  Status card: `statusCard`\n```haskell\nstatusCard \"CPU\" \"45%\"\n```\n```\n┌───────┐\n│
  CPU   │\n│ 45%   │\n└───────┘\n```\n\n### Progress bar: `inlineBar`\n```haskell\ninlineBar
  \"Download\" 0.75\n```\n```\nDownload [███████████████─────] 75%\n```\n\n### Tree:
  `tree`\n```haskell\ntree \"Project\" \n  [ branch \"src\" \n      [ leaf \"main.hs\"\n
  \     , leaf \"test.hs\"\n      ]\n  , branch \"docs\"\n      [ leaf \"README.md\"\n
  \     ]\n  ]\n```\n```\nProject\n├── src\n│   ├── main.hs\n│   └── test.hs\n└──
  docs\n    └── README.md\n```\n\n### Chart: `chart`\n```haskell\nchart [(\"Web\",
  10), (\"Mobile\", 20), (\"API\", 15)]\n```\n```\nWeb    │████████████████████ 10\nMobile
  │████████████████████████████████████████ 20\nAPI    │██████████████████████████████
  15\n```\n\n### Padding: `pad`\nAdd uniform padding around any element:\n```haskell\npad
  2 $ text \"content\"\n```\n```\n        \n        \n  content  \n        \n        \n```\n\n###
  Spinners: `spinner`\nAnimated loading spinners for TUI apps:\n```haskell\nspinner
  \"Loading...\" frameNum SpinnerDots\nspinner \"Processing\" frameNum SpinnerLine\nspinner
  \"Working\" frameNum SpinnerClock\nspinner \"Thinking\" frameNum SpinnerBounce\n```\n\nStyles:\n-
  **`SpinnerDots`** - Braille dot spinner: ⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏\n- **`SpinnerLine`**
  - Classic line spinner: | / - \\\n- **`SpinnerClock`** - Clock face spinner: \U0001F550
  \U0001F551 \U0001F552 ...\n- **`SpinnerBounce`** - Bouncing dots: ⠁ ⠂ ⠄ ⠂\n\nIncrement
  the frame number on each render to animate:\n```haskell\n-- In your app state, track
  a frame counter\ndata AppState = AppState { spinnerFrame :: Int, ... }\n\n-- In
  your view function\nspinner \"Loading\" (spinnerFrame state) SpinnerDots\n\n-- In
  your update function (triggered by a tick or key press)\nstate { spinnerFrame =
  spinnerFrame state + 1 }\n```\n\nWith colors:\n```haskell\nwithColor ColorGreen
  $ spinner \"Success!\" frame SpinnerDots\nwithColor ColorYellow $ spinner \"Warning\"
  frame SpinnerLine\n```\n\n### Centering: `center`\nSmart auto-centering and manual
  width:\n```haskell\ncenter \"Auto-centered\"     -- Uses layout context\ncenter'
  20 \"Manual width\"  -- Fixed width\n```\n```\n        Auto-centered        \n\n
  \   Manual width    \n```\n\n### Margin: `margin`\nAdd prefix margins to elements
  for compiler-style error messages:\n\n```haskell\nmargin \"[error]\"\n  [ text \"Ooops\"\n
  \ , text \"\"\n  , row [ text \"result :: Int = \"\n        , underline' \"^\" $
  text \"getString\"\n        ]\n  , text \"Expected Int, found String\"\n  ]\n```\n```\n[error]
  Ooops\n[error]\n[error] result :: Int =  getString\n[error]                  ^^^^^^^^^\n[error]
  Expected Int, found String\n```\n\n## Border Styles\nElements like `box`, `table`,
  and `statusCard` support different border styles:\n\n**BorderNormal** (default):\n```haskell\nbox
  \"Title\" [\"content\"]\n```\n```\n┌──Title──┐\n│ content │\n└─────────┘\n```\n\n**BorderDouble**:\n```haskell\nwithBorder
  BorderDouble $ statusCard \"API\" \"UP\"\n```\n```\n╔═══════╗\n║ API   ║\n║ UP    ║\n╚═══════╝\n```\n\n**BorderThick**:\n```haskell\nwithBorder
  BorderThick $ table [\"Name\"] [[\"Alice\"]]\n```\n```\n┏━━━━━━━┓\n┃ Name  ┃\n┣━━━━━━━┫\n┃
  Alice ┃\n┗━━━━━━━┛\n```\n\n**BorderRound**:\n```haskell\nwithBorder BorderRound
  $ box \"Info\" [\"content\"]\n```\n```\n╭──Info───╮\n│ content │\n╰─────────╯\n```\n\n**BorderNone**
  (invisible borders):\n```haskell\nwithBorder BorderNone $ box \"Info\" [\"content\"]\n```\n```\n
  \ Info   \n content \n         \n```\n\n## Colors (ANSI Support)\n\nAdd ANSI colors
  to any element:\n\n```haskell\nlayout[\n  withColor ColorRed $ text \"The quick
  brown fox...\",\n  withColor ColorBrightCyan $ text \"The quick brown fox...\",\n
  \ underlineColored \"~\" ColorRed $ text \"The quick brown fox...\",\n  margin \"[INFO]\"
  [withColor ColorCyan $ text \"The quick brown fox...\"]\n]\n```\n<p align=\"center\">\n
  \ <img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/layoutz-hs/pix/layoutz-color-2.png\"
  width=\"700\">\n</p>\n\n\n**Standard Colors:**\n- `ColorBlack` `ColorRed` `ColorGreen`
  `ColorYellow` `ColorBlue` `ColorMagenta` `ColorCyan` `ColorWhite`\n- `ColorBrightBlack`
  `ColorBrightRed` `ColorBrightGreen` `ColorBrightYellow` `ColorBrightBlue` `ColorBrightMagenta`
  `ColorBrightCyan` `ColorBrightWhite`\n- `ColorNoColor` *(for conditional formatting)*\n\n**Extended
  Colors:**\n- `ColorFull n` - 256-color palette (0-255)\n- `ColorTrue r g b` - 24-bit
  RGB true color\n\n### Color Gradients\n\nCreate beautiful gradients with extended
  colors:\n\n```haskell\nlet palette   = tightRow $ map (\\i -> withColor (ColorFull
  i) $ text \"█\") [16, 19..205]\n    redToBlue = tightRow $ map (\\i -> withColor
  (ColorTrue i 100 (255 - i)) $ text \"█\") [0, 4..255]\n    greenFade = tightRow
  $ map (\\i -> withColor (ColorTrue 0 (255 - i) i) $ text \"█\") [0, 4..255]\n    rainbow
  \  = tightRow $ map colorBlock [0, 4..255]\n      where\n        colorBlock i =\n
  \         let r = if i < 128 then i * 2 else 255\n              g = if i < 128 then
  255 else (255 - i) * 2\n              b = if i > 128 then (i - 128) * 2 else 0\n
  \         in withColor (ColorTrue r g b) $ text \"█\"\n\nputStrLn $ render $ layout
  [palette, redToBlue, greenFade, rainbow]\n```\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/layoutz-hs/pix/layoutz-color-1.png\"
  width=\"700\">\n</p>\n\n\n## Styles (ANSI Support)\n\nAdd ANSI styles to any element:\n\n```haskell\nlayout[\n
  \ withStyle StyleBold $ text \"The quick brown fox...\",\n  withColor ColorRed $
  withStyle StyleBold $ text \"The quick brown fox...\",\n  withStyle StyleReverse
  $ withStyle StyleItalic $ text \"The quick brown fox...\"\n]\n```\n<p align=\"center\">\n
  \ <img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/layoutz-hs/pix/layoutz-styles-1.png\"
  width=\"700\">\n</p>\n\n**Styles:**\n- `StyleBold` `StyleDim` `StyleItalic` `StyleUnderline`\n-
  `StyleBlink` `StyleReverse` `StyleHidden` `StyleStrikethrough`\n- `StyleNoStyle`
  *(for conditional formatting)*\n\n**Combining Styles:**\n\nUse `<>` to combine multiple
  styles at once:\n\n```haskell\nlayout[\n  withStyle (StyleBold <> StyleItalic <>
  StyleUnderline) $ text \"The quick brown fox...\",\n  withStyle (StyleBold <> StyleReverse)
  $ text \"The quick brown fox...\"\n]\n```\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/mattlianje/layoutz/refs/heads/master/layoutz-hs/pix/layoutz-styles-2.png\"
  width=\"700\">\n</p>\n\nYou can also combine colors and styles:\n\n```haskell\nwithColor
  ColorBrightYellow $ withStyle (StyleBold <> StyleItalic) $ text \"The quick brown
  fox...\"\n```\n\n## Custom Components\n\nCreate your own components by implementing
  the `Element` typeclass\n\n```haskell\ndata Square = Square Int\n\ninstance Element
  Square where\n  renderElement (Square size) \n    | size < 2 = \"\"\n    | otherwise
  = intercalate \"\\n\" (top : middle ++ [bottom])\n    where\n      w = size * 2
  - 2\n      top = \"┌\" ++ replicate w '─' ++ \"┐\"\n      middle = replicate (size
  - 2) (\"│\" ++ replicate w ' ' ++ \"│\")\n      bottom = \"└\" ++ replicate w '─'
  ++ \"┘\"\n\n-- Helper to avoid wrapping with L\nsquare :: Int -> L\nsquare n = L
  (Square n)\n\n-- Use it like any other element\nputStrLn $ render $ row\n  [ square
  3\n  , square 5\n  , square 7\n  ]\n```\n```\n┌────┐ ┌────────┐ ┌────────────┐\n│
  \   │ │        │ │            │\n└────┘ │        │ │            │\n       │        │
  │            │\n       └────────┘ │            │\n                  │            │\n
  \                 └────────────┘\n```\n\n## REPL\n\nDrop into GHCi to experiment:\n```bash\ncabal
  repl\n```\n\n```haskell\nλ> :set -XOverloadedStrings\nλ> import Layoutz\nλ> putStrLn
  $ render $ center $ box \"Hello\" [\"World!\"]\n┌──Hello──┐\n│ World!  │\n└─────────┘\nλ>
  putStrLn $ render $ table [\"A\", \"B\"] [[\"1\", \"2\"]]\n┌───┬───┐\n│ A │ B │\n├───┼───┤\n│
  1 │ 2 │\n└───┴───┘\n```\n\n## Interactive Apps\n\nBuild **Elm-style terminal applications**
  with the built-in TUI runtime.\n\n```haskell\nimport Layoutz\n\ndata Msg = Inc |
  Dec\n\ncounterApp :: LayoutzApp Int Msg\ncounterApp = LayoutzApp\n  { appInit =
  (0, None)\n  , appUpdate = \\msg count -> case msg of\n      Inc -> (count + 1,
  None)\n      Dec -> (count - 1, None)\n  , appSubscriptions = \\_ -> onKeyPress
  $ \\key -> case key of\n      CharKey '+' -> Just Inc\n      CharKey '-' -> Just
  Dec\n      _           -> Nothing\n  , appView = \\count -> layout\n      [ section
  \"Counter\" [text $ \"Count: \" <> show count]\n      , ul [\"Press '+' or '-'\",
  \"ESC to quit\"]\n      ]\n  }\n\nmain = runApp counterApp\n```\n\n### How the Runtime
  Works\n\nThe `runApp` function spawns three daemon threads:\n- **Render thread**
  - Continuously renders `appView state` to terminal (~30fps)\n- **Input thread**
  - Reads keys, maps via `appSubscriptions`, calls `appUpdate`\n- **Command thread**
  - Executes `Cmd` side effects async, feeds results back\n\nAs per the above, commands
  run without blocking the UI.\n\nPress **ESC** to exit.\n\n### `LayoutzApp state
  msg`\n\n```haskell\ndata LayoutzApp state msg = LayoutzApp\n  { appInit          ::
  (state, Cmd msg)                 -- Initial state + startup command\n  , appUpdate
  \       :: msg -> state -> (state, Cmd msg) -- Pure state transitions\n  , appSubscriptions
  :: state -> Sub msg                 -- Event sources\n  , appView          :: state
  -> L                       -- Render to UI\n  }\n```\n\n### Subscriptions\n\n| Subscription
  | Description |\n|--------------|-------------|\n| `onKeyPress (Key -> Maybe msg)`
  | Keyboard input |\n| `onTick msg` | Periodic ticks (~100ms) for animations |\n|
  `batch [sub1, sub2, ...]` | Combine subscriptions |\n\n### Commands\n\n| Command
  | Description |\n|---------|-------------|\n| `None` | No effect |\n| `Cmd (IO (Maybe
  msg))` | Run IO, optionally produce message |\n| `Batch [cmd1, cmd2, ...]` | Multiple
  commands |\n| `cmd :: IO () -> Cmd msg` | Fire and forget |\n| `cmdMsg :: IO msg
  -> Cmd msg` | IO that returns a message |\n\n**Example: Logger with file I/O**\n```haskell\nimport
  Layoutz\n\ndata Msg = Log | Saved\ndata State = State { count :: Int, status ::
  String }\n\nloggerApp :: LayoutzApp State Msg\nloggerApp = LayoutzApp\n  { appInit
  = (State 0 \"Ready\", None)\n  , appUpdate = \\msg s -> case msg of\n      Log   ->
  (s { count = count s + 1 }, \n                cmd $ appendFile \"log.txt\" (\"Entry
  \" <> show (count s) <> \"\\n\"))\n      Saved -> (s { status = \"Saved!\" }, None)\n
  \ , appSubscriptions = \\_ -> onKeyPress $ \\key -> case key of\n      CharKey 'l'
  -> Just Log\n      _           -> Nothing\n  , appView = \\s -> layout\n      [
  section \"Logger\" [text $ \"Entries: \" <> show (count s)]\n      , text (status
  s)\n      , ul [\"'l' to log\", \"ESC to quit\"]\n      ]\n  }\n\nmain = runApp
  loggerApp\n```\n\n### Key Types\n\n```haskell\nCharKey Char       -- 'a', '1', '
  '\nEnterKey, BackspaceKey, TabKey, EscapeKey, DeleteKey\nArrowUpKey, ArrowDownKey,
  ArrowLeftKey, ArrowRightKey\nSpecialKey String  -- \"Ctrl+C\", etc.\n```\n\n## Inspiration\n-
  Original Scala [layoutz](https://github.com/mattlianje/layoutz)\n"
description-type: markdown
hash: 33acc795157b95eb0dc43633896678323bb5a03122df6691340339a08ab9f66b
homepage: https://github.com/mattlianje/layoutz
latest: 0.2.0.0
license-name: Apache-2.0
maintainer: matthieu.court@protonmail.com
synopsis: Simple, beautiful CLI output for Haskell
test-bench-deps:
  base: '>=4.7 && <5'
  layoutz: '>=0'
  tasty: '>=1.4'
  tasty-hunit: '>=0.10'

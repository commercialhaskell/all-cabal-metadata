homepage: https://github.com/typeclasses/lazy-async
changelog-type: text
hash: 1f1ab72f54b9b22001591968c3a1f4f5d6a500a2be37c715303ffc9c42f5e4e6
test-bench-deps:
  rank2classes: ^>=1.4.0.1
  exceptions: ^>=0.10.4
  optics-core: ^>=0.3 || ^>=0.4
  stm: ^>=2.5
  base: ^>=4.14 || ^>=4.15 || ^>=4.16
  monad-control: ^>=1.0.2.3
  hedgehog: ^>=1.0.4 || ^>=1.1
  lazy-async: -any
  lifted-async: ^>=0.10.0.6
  transformers-base: ^>=0.4.5.1
  transformers: ^>=0.5.6.2
  optics-th: ^>=0.3 || ^>=0.4
maintainer: Chris Martin, Julie Moronuki
synopsis: Asynchronous actions that don't start right away
changelog: |
  v1.0.0.0 - Initial release
  v1.0.0.1 - Support GHC 9.2
basic-deps:
  rank2classes: ^>=1.4.0.1
  exceptions: ^>=0.10.4
  stm: ^>=2.5
  base: ^>=4.14 || ^>=4.15 || ^>=4.16
  monad-control: ^>=1.0.2.3
  lifted-async: ^>=0.10.0.6
  transformers-base: ^>=0.4.5.1
  transformers: ^>=0.5.6.2
all-versions:
- 1.0.0.0
- 1.0.0.1
author: Chris Martin
latest: 1.0.0.1
description-type: haddock
description: |-
  Sometimes we have a bunch of 'IO' actions that do things like
  read files, make HTTP requests, or query a database. Some of the
  information that these actions produce might not end up being
  needed, depending on the breaks. In the interest of avoiding
  unnecessary effort, we don't want to simply run all the actions
  and collect their results upfront. We also don't want to simply
  run an action right before its result is needed, because it might
  be needed in more than one place, which opens the possibility of
  unnecessarily running the same action more than once. In
  situations like these, we use "LazyAsync".

  Under the hood, an 'IO' action is turned into a @LazyAsync@ by
  constructing two things: An @Async@ (from the @async@ package),
  and a @TVar Bool@ (from the @stm@ package). The TVar, initialized
  to @False@, indicates whether the action is wanted yet. The async
  thread waits until the TVar turns @True@ and then runs the action.
license-name: MIT

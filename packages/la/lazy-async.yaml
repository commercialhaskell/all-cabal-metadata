homepage: https://github.com/typeclasses/lazy-async
changelog-type: ''
hash: 3a85dd36589ca9c2c53b1131e7dfda57843568a3355b20b41c903e5901b4c35b
test-bench-deps:
  rank2classes: ^>=1.4.0.1
  exceptions: ^>=0.10.4
  optics-core: ^>=0.3 || ^>=0.4
  stm: ^>=2.5
  base: ^>=4.14 || ^>=4.15
  monad-control: ^>=1.0.2.3
  hedgehog: ^>=1.0.4
  lazy-async: -any
  lifted-async: ^>=0.10.0.6
  transformers-base: ^>=0.4.5.1
  transformers: ^>=0.5.6.2
  optics-th: ^>=0.3 || ^>=0.4
maintainer: Chris Martin, Julie Moronuki
synopsis: Asynchronous actions that don't start right away
changelog: ''
basic-deps:
  rank2classes: ^>=1.4.0.1
  exceptions: ^>=0.10.4
  stm: ^>=2.5
  base: ^>=4.14 || ^>=4.15
  monad-control: ^>=1.0.2.3
  lifted-async: ^>=0.10.0.6
  transformers-base: ^>=0.4.5.1
  transformers: ^>=0.5.6.2
all-versions:
- 1.0.0.0
author: Chris Martin
latest: 1.0.0.0
description-type: haddock
description: |-
  Sometimes we have a bunch of 'IO' actions that do things like
  read files, make HTTP requests, or query a database. Some of the
  information that these actions produce might not end up being
  needed, depending on the breaks. In the interest of avoiding
  unnecessary effort, we don't want to simply run all the actions
  and collect their results upfront. We also don't want to simply
  run an action right before its result is needed, because it might
  be needed in more than one place, which opens the possibility of
  unnecessarily running the same action more than once. In
  situations like these, we use "LazyAsync".

  Under the hood, an 'IO' action is turned into a @LazyAsync@ by
  constructing two things: An @Async@ (from the @async@ package),
  and a @TVar Bool@ (from the @stm@ package). The TVar, initialized
  to @False@, indicates whether the action is wanted yet. The async
  thread waits until the TVar turns @True@ and then runs the action.
license-name: MIT

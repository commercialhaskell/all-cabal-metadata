homepage: http://hub.darcs.net/thielema/lapack-comfort-array/
changelog-type: ''
hash: 3451eb36fc17b51000144de850b9ee18858a541a512a632d33cd75f91ff9def3
test-bench-deps: {}
maintainer: Henning Thielemann <haskell@henning-thielemann.de>
synopsis: Auto-generated interface to Fortran LAPACK via comfort-array
changelog: ''
basic-deps:
  netlib-ffi: ! '>=0.0 && <0.2'
  netlib-comfort-array: ! '>=0.0 && <0.1'
  base: ! '>=4.5 && <5'
  storable-complex: ! '>=0.2.2 && <0.3'
  lapack-ffi: ! '>=0.0 && <0.1'
  comfort-array: ! '>=0.3 && <0.5'
  transformers: ! '>=0.4 && <0.6'
all-versions:
- '0.0'
- 0.0.0.1
author: Henning Thielemann <haskell@henning-thielemann.de>
latest: 0.0.0.1
description-type: haddock
description: |-
  LAPACK is a package for efficient numerically robust linear algebra.
  The original implementation is written in FORTRAN.
  This is a semi-automatically generated mid-level wrapper.
  The functions are not ready to use for high-level applications,
  but they are a step closer.

  The functions are all in IO monad because they are auto-generated and
  we cannot make sure automatically that unsafePerformIO is always safe.
  Instead of raw pointers we use Arrays and Mutable.Arrays
  and assign and check array bounds to LAPACK function parameters,
  as far we can retrieve this information from the FORTRAN comments.
  We check consistency of dimensions where consistent dimensions are required,
  but we cannot do all kind of bound checks.
  We use immutable Array for input and output parameters
  and mutable Mutable.Array for input/output parameters.
  LAPACK plays some nasty tricks of in-place array updates
  on input/output arrays
  even if the dimensions of input and output array differ (see e.g. GELS).
  The wrappers also manage allocation of memory for function parameters.
  This is necessary since FORTRAN passes all parameters by reference.
  Further on, the wrappers convert from Haskell values like @Int@
  to low-level values like @CInt@.

  We provide bindings to functions of all variants
  for @Float@, @Double@, @Complex Float@ and @Complex Double@.
  We do not use TemplateHaskell nor HSC nor CHS, but instead Haskell 98 code
  generated by the custom @lapack-ffi-tools@ package.
license-name: BSD-3-Clause

homepage: https://github.com/cnr/cgroup-rts-threads
changelog-type: markdown
hash: 90dec21bff2e39e3f1fdb13c90d549cb6639510ebc350e1184f6b8434a467287
test-bench-deps:
  cgroup-rts-threads: -any
  path: -any
  base: -any
  hspec-core: ^>=2.8.3
  path-io: -any
  hspec-expectations: ^>=0.8.2
maintainer: connornjames@gmail.com
synopsis: A container-/cgroup-aware substitute for the GHC RTS `-N` flag
changelog: |
  # Revision history for cgroup-rts-threads

  ## 0.1.0.0

  - Initial release
basic-deps:
  path: '>=0.7 && <0.10'
  base: '>=4.13 && <5'
  text: -any
  megaparsec: '>=8 && <10'
all-versions:
- 0.1.0.0
author: Connor James
latest: 0.1.0.0
description-type: markdown
description: |
  # cgroup-rts-threads

  ![Hackage](https://img.shields.io/hackage/v/cgroup-rts-threads)
  ![tests](https://github.com/cnr/cgroup-rts-threads/actions/workflows/tests.yml/badge.svg)

  This library provides a container-/cgroup-aware substitute for GHC's [RTS `-N` flag][rts-n], used to set the number of runtime threads.

  Similar to the RTS `-N` flag, this library considers the number of cpu cores (as reported by `GHC.Conc.getNumProcessors`) to set this number.

  Unlike the RTS `-N` flag, this library observes the process' [cgroup cpu quota][cgroup-quota] to constrain the number of runtime threads, as applicable.

  When running outside of a cgroup, or on a platform other than linux, this library matches the behavior of `-N`.

  See the [Why?](#why) section for details.

  ## Usage

  1. Remove `-N` from your executable's `rtsopts`. In `yourproject.cabal`:

  ```cabal-config
  -- before
  executable my-executable
    ghc-options: -threaded -with-rtsopts=-N

  -- after
  executable my-executable
    ghc-options: -threaded
  ```

  2. In your program's `main` function, call `initRTSThreads`:

  ```haskell
  module Main (main) where

  import Control.Concurrent.CGroup (initRTSThreads)

  main :: IO ()
  main = do
    initRTSThreads
    [...]
  ```

  ## Why?

  It's common in containerized environments to limit cpu consumption of individual containers. There are two primary ways of doing this:

  1. The `cpuset` option within a cgroup, which can be used to pin a process to specific cpu cores.
  2. The `cfs.cpu_quota_us` option within a cgroup, which can be used to set a limit on the cpu time a process is allowed to consume.

  The GHC threaded RTS offers [a flag, `-N`,][rts-n] that can be used to automatically determine the number of threads to use, based on the number of physical processors.

  The RTS `-N` flag, [as of GHC `9.0.1`][cpuset-commit], respects the `cpuset` option when automatically determining the number of threads to use.

  Unfortunately, the RTS `-N` flag **does not respect cgroup `cfs` quotas**. This leads to substantially degraded performance when there's a large disparity between a `cfs` quota and the number of physical cpu cores -- a very common scenario in, e.g., production kubernetes clusters.

  [cpuset-commit]: https://gitlab.haskell.org/ghc/ghc/-/commit/4413828b7c507872c56719fb8920e1c2322830f8
  [rts-n]: https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/using-concurrent.html#rts-options-for-smp-parallelism
  [cgroup-quota]: https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html#management
license-name: MPL-2.0

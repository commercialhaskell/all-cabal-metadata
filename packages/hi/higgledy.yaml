homepage: https://github.com/i-am-tom/higgledy
changelog-type: markdown
hash: 778a0bcc67017bbcf90efcaa8bab8a20759bd69176444179c4e9a0a06091992e
test-bench-deps:
  base: -any
  higgledy: -any
  hspec: ^>=2.6.1
  doctest: ^>=0.16.0
  lens: ^>=4.17
  QuickCheck: ^>=2.12.6
maintainer: tom.harding@habito.com
synopsis: Partial types as a type constructor.
changelog: |
  # Revision history for partial-structures

  ## 0.1.0.0 -- YYYY-mm-dd

  * First version. Released on an unsuspecting world.
basic-deps:
  barbies: ^>=1.1.0
  base: ^>=4.12
  generic-lens: ^>=1.1.0
  QuickCheck: ^>=2.12.6
all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.1.1
- 0.2.0.0
author: Tom Harding
latest: 0.2.0.0
description-type: markdown
description: "# Higgledy \U0001F4DA\n\nHigher-kinded data via generics: all\\* the
  benefits, but none\\* of the\nboilerplate.\n\n## Introduction\n\nWhen we work with
  [higher-kinded\ndata](https://reasonablypolymorphic.com/blog/higher-kinded-data),
  we find\nourselves writing types like:\n\n```haskell\ndata User f\n  = User\n      {
  name :: f String\n      , age  :: f Int\n      , ...\n      }\n```\n\nThis is good
  - we can use `f ~ Maybe` for partial data, `f ~ Identity` for\ncomplete data, etc
  - but it introduces a fair amount of noise, and we have a\nlot of boilerplate deriving
  to do. Wouldn't it be nice if we could get back to\nwriting simple types as we know
  and love them, and get all this stuff for\n_free_?\n\n```haskell\ndata User\n  =
  User\n      { name :: String\n      , age  :: Int\n      , ...\n      }\n  deriving
  Generic\n\n-- HKD for free!\ntype UserF f = HKD User f\n```\n\nAs an added little
  bonus, any `HKD`-wrapped object is automatically an instance\nof all the [Barbie](http://hackage.haskell.org/package/barbies)
  classes, so no\nneed to derive anything more than `Generic`!\n\n## API\n\nAll examples
  below were compiled with the following extensions, modules, and\nexample data types:\n\n```haskell\n{-#
  LANGUAGE DataKinds        #-}\n{-# LANGUAGE DeriveGeneric    #-}\n{-# LANGUAGE TypeApplications
  #-}\nmodule Example where\n\nimport Control.Lens ((.~), (^.), (&), Const (..), Identity,
  anyOf)\nimport Data.Funtor.Const (Const (..))\nimport Data.Funtor.Identity (Identity
  (..))\nimport Data.Generic.HKD\nimport Data.Maybe (isJust, isNothing)\nimport Data.Monoid
  (Last (..))\nimport GHC.Generics (Generic)\n\n-- An example of a record (with named
  fields):\ndata User\n  = User\n      { name      :: String\n      , age       ::
  Int\n      , likesDogs :: Bool\n      }\n  deriving (Generic, Show)\n\nuser :: User\nuser
  = User \"Tom\" 25 True\n\n-- An example of a product (without named fields):\ndata
  Triple\n  = Triple Int () String\n  deriving (Generic, Show)\n\ntriple :: Triple\ntriple
  = Triple 123 () \"ABC\"\n```\n\n### The HKD type constructor\n\nThe `HKD` type takes
  two parameters: your model type, and the functor in which\nwe want to wrap all our
  inputs. By picking different functors for the second\nparameter, we can recover
  various behaviours:\n\n```haskell\ntype Partial a = HKD a  Last          -- Fields
  may be missing.\ntype Bare    a = HKD a  Identity      -- All must be present.\ntype
  Labels  a = HKD a (Const String) -- Every field holds a string.\n```\n\n### Fresh
  objects\n\nWhen we want to start working with the `HKD` interface, we have a couple
  of\noptions, depending on the functor in question. The first option is to use\n`mempty`:\n\n```haskell\neg0
  :: Partial User\neg0 = mempty\n-- User\n--   { name      = Last {getLast = Nothing}\n--
  \  , age       = Last {getLast = Nothing}\n--   , likesDogs = Last {getLast = Nothing}\n--
  \  }\n```\n\nOther 'Alternative'-style functors lead to very different results:\n\n```haskell\neg1
  :: Labels Triple\neg1 = mempty\n-- Triple\n--   Const \"\"\n--   Const \"\"\n--
  \  Const \"\"\n```\n\nOf course, this method requires every field to be monoidal.
  If we try with\n`Identity`, for example, we're in trouble if all our fields aren't
  themselves\nmonoids:\n\n```haskell\neg2 :: Bare Triple\neg2 = mempty\n-- error:\n--
  • No instance for (Monoid Int) arising from a use of ‘mempty’\n```\n\nThe other
  option is to `deconstruct` a complete object. This effectively lifts\na type into
  the `HKD` structure with `pure` applied to each field:\n\n```haskell\neg3 :: Bare
  User\neg3 = deconstruct user\n-- User\n--   { name      = Identity \"Tom\"\n--   ,
  age       = Identity 25\n--   , likesDogs = Identity True\n--   }\n```\n\nThis approach
  works with any applicative we like, so we can recover the other\nbehaviours:\n\n```haskell\neg4
  :: Partial Triple\neg4 = deconstruct @Last triple\n-- Triple\n--   Last {getLast
  = Just 123}\n--   Last {getLast = Just ()}\n--   Last {getLast = Just \"ABC\"}\n```\n\nThere's
  also `construct` for when we want to escape our `HKD` wrapper, and\nattempt to _construct_
  our original type:\n\n```haskell\neg5 :: Last Triple\neg5 = construct eg4\n-- Last
  {getLast = Just (Triple 123 () \"ABC\")}\n```\n\nIf none of the above suit your
  needs, maybe you want to try `build` on for\nsize. This function constructs an `HKD`-wrapped
  version of the type supplied to\nit by taking all its parameters. In other words:\n\n```haskell\neg6
  :: f Int -> f () -> f String -> HKD Triple f\neg6 = build @Triple\n\neg7 :: HKD
  Triple []\neg7 = eg6 [1] [] [\"Tom\", \"Tim\"]\n-- Triple [1] [] [\"Tom\",\"Tim\"]\n```\n\n###
  Field Access\n\nThe `field` lens, when given a type-applied field name, allows us
  to focus on\nfields within a record:\n\n```haskell\neg8 :: Last Int\neg8 = eg0 ^.
  field @\"age\"\n-- Last {getLast = Nothing}\n```\n\nAs this is a true `Lens`, it
  also means that we can _set_ values within our\nrecord (note that these set values
  will _also_ need to be in our functor of\nchoice):\n\n```haskell\neg9 :: Partial
  User\neg9 = eg0 & field @\"name\"      .~ pure \"Evil Tom\"\n          & field @\"likesDogs\"
  .~ pure False     \n-- User\n--   { name      = Last {getLast = Just \"Evil Tom\"}\n--
  \  , age       = Last {getLast = Nothing}\n--   , likesDogs = Last {getLast = Just
  False}\n--   }\n```\n\nThis also means, for example, we can check whether a particular
  value has been\ncompleted for a given partial type:\n\n```haskell\neg10 :: Bool\neg10
  = anyOf (field @\"name\") (isJust . getLast) eg0\n-- False\n```\n\nFinally, thanks
  to the fact that this library exploits some of the internals of\n`generic-lens`,
  we'll also get a nice type error when we mention a field that\ndoesn't exist in
  our type:\n\n```haskell\neg11 :: Identity ()\neg11 = eg3 ^. field @\"oops\"\n--
  error:\n-- • The type User does not contain a field named 'oops'.\n```\n\n### Position
  Access\n\nJust as with field names, we can use positions when working with non-record\nproduct
  types:\n\n```haskell\neg12 :: Labels Triple\neg12 = mempty & position @1 .~ Const
  \"hello\"\n              & position @2 .~ Const \"world\"\n-- Triple\n--   Const
  \"hello\"\n--   Const \"world\"\n--   Const \"\"\n```\n\nAgain, this is a `Lens`,
  so we can just as easily _set_ values:\n\n```haskell\neg13 :: Partial User\neg13
  = eg9 & position @2 .~ pure 25\n-- User\n--   { name      = Last {getLast = Just
  \"Evil Tom\"}\n--   , age       = Last {getLast = Just 25}\n--   , likesDogs = Last
  {getLast = Just False}\n--   }\n```\n\nSimilarly, the internals here come to us
  courtesy of `generic-lens`, so the\ntype errors are a delight:\n\n```haskell\neg14
  :: Identity ()\neg14 = deconstruct @Identity triple ^. position @4\n-- error:\n--
  • The type Triple does not contain a field at position 4\n```\n\n### Labels\n\nOne
  neat trick we can do - thanks to the generic representation - is get the\nnames
  of the fields into the functor we're using. The `label` function gives us\nthis
  interface:\n\n```haskell\neg15 :: Labels User\neg15 = label eg13\n-- User\n--   {
  name = Const \"name\"\n--   , age = Const \"age\"\n--   , likesDogs = Const \"likesDogs\"\n--
  \  }\n```\n\nBy combining this with some of the\n[Barbies](http://hackage.haskell.org/package/barbies)
  interface (the entirety\nof which is available to any `HKD`-wrapped type) such as
  `bprod` and `bmap`, we\ncan implement functions such as `labelsWhere`, which returns
  the names of all\nfields whose values satisfy some predicate:\n\n```haskell\neg16
  :: [String]\neg16 = labelsWhere (isNothing . getLast) eg9\n-- [\"age\"]\n```\n"
license-name: MIT

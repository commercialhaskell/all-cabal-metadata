all-versions:
- 1.0.0.1
author: ncaq
basic-deps:
  aeson: ^>=2.2.3.0
  aeson-pretty: ^>=0.8.10
  base: '>=4.19.2.0 && <4.22'
  bytestring: ^>=0.12.2.0
  containers: ^>=0.7
  convertible: ^>=1.1.1.1
  deepseq: ^>=1.5.0.0
  deriving-aeson: ^>=0.2.10
  exceptions: ^>=0.10.9
  filepath: ^>=1.5.4.0
  hashable: ^>=1.5.0.0
  lens: ^>=5.3.5
  monad-logger: ^>=0.3.42
  mtl: ^>=2.3.1
  pretty-simple: ^>=4.1.3
  primitive: ^>=0.9.1.0
  safe: ^>=0.3.21
  text: ^>=2.1.2
  time: ^>=1.12.2
  typed-process: ^>=0.2.13.0
  unliftio: ^>=0.2.25.1
  unordered-containers: ^>=0.2.20
  vector: ^>=0.13.2.0
changelog: |
  # Changelog

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
  and this project adheres to [Haskell Package Versioning Policy](https://pvp.haskell.org/).

  ## [Unreleased]

  ## [1.0.0.1] - 2026-01-01

  ### Changed

  - Move `-j` (parallel compilation) option from `himari.cabal` ghc-options to `cabal.project` to fix Hackage upload compatibility

  ## [1.0.0.0] - 2026-01-01

  ### Added

  - `Himari` module that re-exports all submodules
  - `Himari.Prelude` module as a custom Prelude
  - `Himari.Char` module with `digitToIntMay`, `intToDigitMay`, `chrMay`
  - `Himari.Env` module with `Himari` newtype, `runHimari`, `liftHimari`, `mapHimari`
  - `Himari.Env.Simple` module with `SimpleEnv`, `runSimpleEnv`, `runSimpleEnvWith`
  - `Himari.Logger` module with `HasLogAction` type class and `LogAction` type alias
  - Re-exports from `Control.Lens`, `Control.Monad.*`, `Data.*`, `UnliftIO` in Prelude
  - Re-exports from `safe`, `aeson`, `pretty-simple`, `monad-logger`, `typed-process` in Prelude
  - Common type exports: `ByteString`, `Text`, `Vector`, `Map`, `HashMap`, etc.
  - Bundled `.hlint.yaml` as `data-files` with comprehensive rules managed in Dhall
  - HLint rules for partial function warnings in base, containers, text, bytestring, vector
  - HLint rules for unsafe function warnings in primitive, UnliftIO
  - HLint rules preferring UnliftIO over base IO modules
  - HLint rules preferring typed-process over System.Process
  - HLint rules preferring `convert` from convertible
  - HLint rules preferring `pTrace*` over `Debug.Trace`
  - HLint rules for qualified import naming conventions
  - HLint rules for aeson, lens, mtl, yaml, and more
  - Support for GHC 9.10.2, 9.10.3, and 9.12.2
  - GHC2024 as the default language with `NoImplicitPrelude` extension
changelog-type: markdown
description: |
  # himari

  A standard library for Haskell to replace rio

  ## 注意

  > [!IMPORTANT]
  > himariはrioとは完全に同じように使えるわけではありません。
  > ここで主な注意点を挙げます。

  ### 重大なランタイムの非互換性

  #### ログの出力先の変更

  rioは基本的に標準出力にログを出力しますが、
  himariはデフォルトのガイドラインに従うと標準エラー出力にログを出力します。

  ログは標準エラー出力に出すべきだと考えているためです。

  変更したい時は出力先を`stderr`から`stdout`などに変更することで簡単に変更可能です。

  ### 部分関数への対処方法の違い

  rioは部分関数を独自のモジュールでexportして提供していますが、
  himariはそのままオリジナルのモジュールを使ってもらいます。

  よってhimariは部分関数を除去していません。

  なのでhimariはhlintのルールで警告を出すことで対処しています。

  プロジェクトルートにある[.hlint.yaml](./.hlint.yaml)ファイルを、
  あなたのプロジェクトにコピーしてください。

  ## 背景

  私は、
  [commercialhaskell/rio: A standard library for Haskell](https://github.com/commercialhaskell/rio)
  の思想が好みで長く使っています。

  しかしrioの好みではない点もいくつかあります。
  単純に質の問題であれば私がコントリビュートすれば良いのですが、
  非互換な選択である部分が多いため、
  それは受け入れられないだろうと考えて、
  rioに似たライブラリであるhimariを作成することにしました。

  ## 目標

  ### 依存関係が大きくなることを恐れない

  rioは依存関係を小さくしようと考えているのか、
  [lens: Lenses, Folds and Traversals](https://hackage.haskell.org/package/lens)
  ではなく、
  [microlens: A tiny lens library with no dependencies](https://hackage.haskell.org/package/microlens)
  を採用しています。

  しかし実際のライブラリでは本家のlensに依存していることも多く、
  結局使おうとしてコンフリクトすることが多いです。

  Haskellは静的にビルドする言語なので、
  依存関係が多いことはあまり怖くありません。

  使うとは限らない依存関係もドシドシimportしてしまいます。

  バージョンごとの依存関係の解決が大変なのはNixなどのパッケージマネージャのレイヤーで解決することにします。

  ### なるべく一行で済ませたい

  himariは基本的には以下の一行で代替Preludeを提供することを目指します。

  ```haskell
  import Himari
  ```

  色々と書くのは面倒ですからね。
  これで衝突しない範囲はたくさんimportしてしまいます。

  同じシンボル名をexportしていて衝突してしまうものは仕方がないのでqualified importを使ってもらいます。

  ### なるべく独自のシンボルを定義しない

  himariはrioで言う`RIO.Text`のような独自のシンボルを定義することをなるべく避けます。
  LLMのコーディングエージェントに独自のシンボルを使うことを守ってもらうのが難しいからです。
  しばしばオリジナルのシンボルをimportしてしまいます。
description-type: markdown
hash: 77ee2efca6f72d2af922e016923e89bbe90b81dfa3caef60988907f10340ebc0
homepage: https://github.com/ncaq/himari
latest: 1.0.0.1
license-name: Apache-2.0
maintainer: ncaq@ncaq.net
synopsis: A standard library for Haskell as an alternative to rio
test-bench-deps:
  QuickCheck: ^>=2.15.0.1
  aeson: ^>=2.2.3.0
  aeson-pretty: ^>=0.8.10
  base: '>=4.19.2.0 && <4.22'
  bytestring: ^>=0.12.2.0
  containers: ^>=0.7
  convertible: ^>=1.1.1.1
  deepseq: ^>=1.5.0.0
  deriving-aeson: ^>=0.2.10
  exceptions: ^>=0.10.9
  filepath: ^>=1.5.4.0
  hashable: ^>=1.5.0.0
  himari: '>=0'
  lens: ^>=5.3.5
  monad-logger: ^>=0.3.42
  mtl: ^>=2.3.1
  pretty-simple: ^>=4.1.3
  primitive: ^>=0.9.1.0
  safe: ^>=0.3.21
  sydtest: ^>=0.18.0.0
  text: ^>=2.1.2
  time: ^>=1.12.2
  typed-process: ^>=0.2.13.0
  unliftio: ^>=0.2.25.1
  unordered-containers: ^>=0.2.20
  vector: ^>=0.13.2.0

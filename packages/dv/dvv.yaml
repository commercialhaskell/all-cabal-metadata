all-versions:
- 0.1.0.0
- 0.1.1.0
author: James R. Thompson
basic-deps:
  base: '>=4.14 && <5'
  hashable: '>=1.4.0.0 && <1.6'
  lattices: '>=2.0 && <2.3'
  unordered-containers: '>=0.2.0.0 && <0.3'
changelog: |
  # 0.1.1.0 [James R. Thompson](mailto:jamesthompsonoxford@gmail.com) January 2026
  Fix broken ordering instances

  # 0.1.0.0 [James R. Thompson](mailto:jamesthompsonoxford@gmail.com) January 2026
  Initial library for basic DVV definitions and operations.
changelog-type: markdown
description: "# Dotted Version Vectors (DVV)\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nA
  GHC-Haskell implementation of [**Dotted Version Vectors (DVV)**](https://gsd.di.uminho.pt/members/vff/dotted-version-vectors-2012.pdf),
  a data structure for tracking causality and resolving conflicts in distributed systems.
  This library is inspired by the canonical Erlang example implementation and leverages
  GHC to provide a safe and expressive API.\n\n## Table of Contents\n\n- [Introduction](#introduction)\n-
  [Key Concepts](#key-concepts)\n- [Usage](#usage)\n  - [Construction](#construction)\n
  \ - [Recording Events](#recording-events)\n  - [Synchronization](#synchronization)\n
  \ - [Conflict Resolution](#conflict-resolution)\n- [Type Safety](#type-safety)\n\n##
  Introduction\n\nIn distributed systems, multiple actors can concurrently update
  a piece of data. Traditional version vectors can track which updates happened after
  others, but they struggle to represent multiple concurrent \"siblings\" when conflicts
  occur.\n\n**Dotted Version Vectors** solve this by combining:\n1.  **History (Context):**
  A summary of all events seen by the system.\n2.  **Dots:** Discrete events (actor
  + sequence number) that created specific values.\n3.  **Siblings:** A set of values
  that are concurrent (i.e., none of them has \"seen\" the others).\n\n## Key Concepts\n\n-
  \  **Dot:** A pair `{Actor, Counter}` representing a single write.\n-   **History
  (Version Vector):** A mapping from actors to their latest sequence numbers.\n-   **DVV:**
  A structure containing a history and a set of active siblings.\n\n### How it Works\n\nDVV
  provides a mechanism for **causal ordering**. When an actor writes a value, it creates
  a \"Dot\" â€“ a unique identifier for that specific version of the data. \n\n```mermaid\ngraph
  TD\n    A[DVV State] --> B(Causal History)\n    A --> C(Active Siblings)\n    B
  --> B1[Actor A: 5]\n    B --> B2[Actor B: 3]\n    C --> C1[\"Dot(A, 6): Value 'X'\"]\n
  \   C --> C2[\"Dot(B, 4): Value 'Y'\"]\n```\n\n1.  **Event Creation:** When actor
  `A` updates a value, it increments its counter in the DVV's history. The new value
  is stored associated with the new Dot `(A, next_counter)`.\n2.  **Causality:** If
  version `V2` is created knowing about version `V1` (e.g., `V2` was created using
  `V1` as context), `V2` supersedes `V1`.\n3.  **Synchronization:** When two DVVs
  are merged (`sync`), the resulting history is the point-wise maximum of both. Any
  sibling from one DVV is retained in the merged result *only if* it hasn't been superseded
  by the other DVV's history.\n\n## Usage\n\n### 1. Construction and Initialization\n\nYou
  can start with an empty DVV or a singleton:\n\n```haskell\nimport Data.DVV\nimport
  qualified Data.HashMap.Strict as Map\n\n-- An empty DVV\nempty :: DVV String Int\nempty
  = EmptyDVV\n\n-- A singleton DVV (initial write)\ninitial :: DVV String Int\ninitial
  = SingletonDVV \"actor1\" 42\n```\n\n### 2. Recording Events\n\nUse `event` to record
  new updates. You can optionally provide a `VersionVector` as context to indicate
  which versions the new update supersedes.\n\n```haskell\n-- Recording a new event
  on top of existing state\n-- This will increment actor1's counter.\nv1 = event initial
  Nothing \"actor1\" 43\n\n-- Providing context to prune siblings\n-- If 'v1' had
  multiple siblings, passing its 'context' here would replace them\nv2 = event v1
  (Just (context v1)) \"actor2\" 44\n```\n\n### 3. Synchronization (Merging)\n\nMerge
  two DVVs to resolve their histories and collect concurrent siblings.\n\n```haskell\nlet
  d1 = SingletonDVV \"A\" 10\n    d2 = SingletonDVV \"B\" 20\n    merged = sync d1
  d2\n-- 'merged' now contains both values as siblings because they are concurrent.\n--
  values merged == [10, 20]\n```\n\n### 4. Conflict Resolution\n\nWhen a `sync` results
  in multiple siblings (a conflict), you can reconcile them.\n\n#### Manual Reconciliation\n\n```haskell\n--
  Pick the maximum value from siblings\nlet resolved = reconcile max \"resolver-actor\"
  merged\n```\n\n#### Last-Write-Wins (LWW)\n\nIf your values have timestamps or you
  just want a deterministic winner:\n\n```haskell\n-- Assuming values are (Timestamp,
  ActualValue)\nlet lwwResolved = lww (\\(t1, _) (t2, _) -> compare t1 t2) \"actor\"
  conflictDvv\n```\n\n### Partial Ordering and Causality\n\nDVVs implement a **Partial
  Order** to represent the causal relationship between versions. This is exposed via
  the `PartialOrd` typeclass (from `lattices` or `Algebra.PartialOrd`).\n\n-   **`leq`
  (Less than or Equal):** `A <= B` means that `A` is a causal ancestor of (or equal
  to) `B`. In other words, `B` \"knows\" everything `A` knows.\n    -   Implementation:
  For every actor in `A`'s history, `B`'s history must have a counter greater than
  or equal to `A`'s.\n-   **Strict Inequality:** `A < B` means `A <= B` AND `A /=
  B`. `A` happened strictly before `B`.\n-   **Concurrent (Incomparable):** If neither
  `A <= B` nor `B <= A` holds, then `A` and `B` are **concurrent** (`||`). This indicates
  a conflict that needs to be resolved.\n\nThe `sync` operation computes the Least
  Upper Bound (LUB) of two DVVs, effectively merging their histories and preserving
  all concurrent values (siblings) until they are reconciled.\n\n## Type Safety\n\nThis
  library uses `HashMap` internally for efficiency and requires actor IDs to be instances
  of `Hashable`. The `DVV` type is also an instance of `Functor`, `Foldable`, and
  `Traversable`, making it easy to manipulate the stored values.\n\n## Performance
  Considerations\n\n-   **Singleton Optimization:** `SingletonDVV` is a specialized
  constructor for the common case of a single value with no complex history, reducing
  memory overhead.\n-   **Pruning:** Use the `prune` function to truncate old causal
  history if the number of actors grows too large, though this should be used with
  caution as it affects future synchronization accuracy.\n\n## License\n\nThis project
  is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n"
description-type: markdown
hash: bd4cac913c8c29e775a229e50f004c93dcfc1ac2ee06eb800048f590e3ed52cc
homepage: https://github.com/jamesthompson/dvv
latest: 0.1.1.0
license-name: MIT
maintainer: James R. Thompson <jamesthompsonoxford@gmail.com>
synopsis: Dotted Version Vectors (DVV)
test-bench-deps:
  QuickCheck: '>=0'
  base: '>=4.14 && <5'
  dvv: '>=0'
  hashable: '>=0'
  hspec: '>=0'
  lattices: '>=0'
  unordered-containers: '>=0'

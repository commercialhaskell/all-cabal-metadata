all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.2.0.0
- 0.2.1.0
author: Jeremy Nuttall
basic-deps:
  base: '>=4.16 && <5'
  primitive: '>=0.8 && <0.10'
changelog: |
  # Changelog for `pure-noise`

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
  and this project adheres to the
  [Haskell Package Versioning Policy](https://pvp.haskell.org/).

  ## Unreleased

  ## 0.2.1.0 2025-10-31

  ### Added

  - 1D noise support with `noise1At` evaluation function
  - Noise slicing functions (`sliceX2`, `sliceY2`, `sliceX3`, `sliceY3`, `sliceZ3`) for reducing noise dimensionality
  - Comprehensive Haddock documentation for:
    - Core `Noise p v` type with usage examples
    - All utility functions (`warp`, `reseed`, `remap`, `blend`)
    - All slicing functions with examples
  - Exported utility functions:
    - `warp` - transform coordinate space
    - `reseed` - modify seed for independent layers (generalizes `alterSeed2`/`alterSeed3`)
    - `remap` - transform noise values (alias for `fmap`)
    - `blend` - combine noise functions with custom blending (alias for `liftA2`)
  - Exported `Noise` type for advanced usage and type annotations

  ### Changed

  - Refactored to unified noise representation using `newtype Noise p v`
    - `Noise2` and `Noise3` are now type aliases: `Noise (a,a) a` and `Noise (a,a,a) a`
    - Provides `Functor`, `Applicative`, `Monad`, `Num`, `Fractional`, and `Floating` instances
    - All dimensions share the same instance implementations for consistency
  - Updated module documentation with examples of new features (slicing, warping, layering)
  - Improved README with advanced usage examples

  ### Performance

  - **Overall**: 90% of benchmarks improved with +32.4% average performance gain
  - **Ping-pong fractals**: Branchless optimization yields 110-148% improvement (perlin, value, openSimplex)
  - **Cellular noise**: REWRITE RULES for gradient lookups provide 61-70% improvement
  - **3D ValueCubic fractals**: Fixed performance regression, achieving 45-80% improvement
  - **Perlin noise**: 10-63% improvements from optimized lerp/cubic interpolation with REWRITE RULES
  - **Value noise**: 11-43% improvements from interpolation optimizations
  - **OpenSimplex2**: 6-16% improvement for Float; minor regression (~5%) for Double variants
  - **SuperSimplex2**: Shows 3-21% regression due to improved benchmark methodology
    - Previous benchmarks used same X/Y offset (diagonal sampling), which favored SuperSimplex's triangular lattice
    - New benchmarks use independent X/Y offsets for realistic 2D coordinate distributions
    - Algorithm remains functionally correct; numbers now reflect true 2D performance

  ## 0.2.0.0 - 2025-10-21

  ### Added

  - Comprehensive haddock documentation for main `Numeric.Noise` module with usage examples

  ### Changed

  - Migrated internal implementation from `vector` to `primitive` (PrimArray)
  - Removed `vector` dependency from library (still used in benchmarks)
  - Require GHC 9.2+ (base >= 4.16)
  - Hide internal modules from public API (`Numeric.Noise.Internal`, `Numeric.Noise.Internal.Math`)
  - Improved cellular noise performance by 20-30% through specialized computation paths for different result types

  ### Fixed

  - Fixed intermediate list allocation in fractal functions on GHC 9.6+
  - Improved division performance for `Noise3` instances

  ## 0.1.0.1 - 2024-10-15

  - Add bounds for vector
  - Add `next` combinator

  ## 0.1.0.0 - 2024-10-15

  - Initial release
changelog-type: markdown
description: |
  # pure-noise

  Performant, modern noise generation for Haskell with a minimal dependency footprint.

  ## Core features

  - **algebraic composition** of noise functions. You can combine,
    layer, and transform noise sources using standard operators (E.g., `Num`,
    `Fractional`, `Monad`, etc).
  - **Complex effects** like domain warping and multi-octave fractals with clean,
    type-safe composition.
  - **84-95% of C++ FastNoiseLite performance** through aggressive optimization and
    LLVM compilation.

  **For detailed FastNoiseLite comparison, methodology, and reproducibility instructions,
  see the [benchmark README](https://github.com/jtnuttall/pure-noise/blob/main/bench/README.md).**

  The public interface for this library is unlikely to change much, although the
  implementations (`noiseBaseN` functions and anything in `Numeric.Noise.Internal`)
  are subject to change and may change between minor versions.

  ## Acknowledgments

  - This project grew from a port of the excellent
    [FastNoiseLite](https://github.com/Auburn/FastNoiseLite) library. The library
    structure has been tuned to perform well in Haskell and fit well with Haskell
    semantics, but the core noise implementations are the same.
  - All credit for the original design, algorithms, and implementation goes to its
    creator **[Jordan Peck (@Auburn)](https://github.com/Auburn)**. I'm grateful for
    their work and the opportunity to learn from it.
  - The original FastNoiseLite code, from which the core algorithms in this library
    were originally ported, is (C) 2020 Jordan Peck and is licensed under the MIT
    license, a copy of which is included in this repository.

  ## Usage

  The library provides composable noise functions `Noise2` and `Noise3` are type
  aliases for 2D and 3D noise. Noise functions can be composed transparently using
  standard operators with minimal performance cost.

  Noise values are generally clamped to `[-1, 1]`, although some noise functions
  may occasionally produce values slightly outside this range.

  ### Basic Example

  ```haskell
  import Numeric.Noise qualified as Noise

  -- Compose multiple noise sources
  myNoise2 :: (RealFrac a) => Noise.Seed -> a -> a -> a
  myNoise2 =
    let fractalConfig = Noise.defaultFractalConfig
        combined = (Noise.perlin2 + Noise.superSimplex2) / 2
    in Noise.noise2At $ Noise.fractal2 fractalConfig combined
  ```

  ### Advanced Features

  The library's unified `Noise p v` type enables powerful composition patterns:

  #### Complex Compositions

  The `Monad` instance is useful to create noise that depends on other noise values:

  ```haskell
  -- Use one noise function's output to modulate another
  complexNoise :: Noise.Noise2 Float
  complexNoise = do
    baseNoise <- Noise.perlin2
    detailNoise <- Noise.next2 Noise.superSimplex2
    -- Blend based on base noise: smooth areas get less detail
    pure $ baseNoise * 0.7 + detailNoise * (0.3 * (1 + baseNoise) / 2)
  ```

  This is especially useful for creating organic, varied terrain where one noise pattern
  influences the characteristics of another.

  #### 1D Noise via Slicing

  Generate 1D noise by slicing higher-dimensional noise at a fixed coordinate:

  ```haskell
  -- Create 1D noise by fixing one dimension
  noise1d :: Noise.Noise1 Float
  noise1d = Noise.sliceY2 0.0 Noise.perlin2

  -- Evaluate at a point
  value = Noise.noise1At noise1d seed 5.0
  ```

  **Coordinate Transformation:**

  Scale, rotate, or warp the coordinate space:

  ```haskell
  -- Double the frequency
  scaled = Noise.warp (\(x, y) -> (x * 2, y * 2)) Noise.perlin2

  -- Rotate 45 degrees
  rotated = Noise.warp (\(x, y) ->
    let a = pi / 4
    in (x * cos a - y * sin a, x * sin a + y * cos a)) Noise.perlin2
  ```

  #### Layering Independent Noise

  Use `reseed` or `next2`/`next3` to create independent layers:

  ```haskell
  layered = (Noise.perlin2 + Noise.next2 Noise.perlin2) / 2
  ```

  More examples can be found in `bench` and `demo`.

  #### Domain Warping

  Domain warping uses one noise function to distort the coordinate space of another,
  creating organic, flowing patterns ideal for terrain, clouds, and natural textures:

  ```haskell
  domainWarped :: Noise.Noise2 Float
  domainWarped = do
    -- Generate 3D fractal for warp offsets
    let warpNoise = Noise.fractal3 Noise.defaultFractalConfig{Noise.octaves = 5} Noise.perlin3
    -- Extract X and Y warp offsets by slicing at z=0
    warpX <- Noise.sliceX3 0.0 warpNoise
    warpY <- Noise.sliceY3 0.0 warpNoise
    -- Apply warping to base noise coordinates
    Noise.warp (\(x, y) -> (x + 30 * warpX, y + 30 * warpY))
      $ Noise.fractal2 Noise.defaultFractalConfig{Noise.octaves = 5} Noise.openSimplex2
  ```

  ![Domain Warped Noise](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/domain-warp.png)

  See the [demo app](demo/) for an interactive version with adjustable parameters.

  ## Performance notes

  - In single-threaded scenarios with LLVM enabled, this library achieves **84-95%
    of C++ FastNoiseLite performance**.
  - This library benefits considerably from compilation with the LLVM backend
    (`-fllvm`). Benchmarks suggest a ~50-80% difference depending on the kind of noise.

  ### Parallel noise generation

  This library integrates well with [massiv](https://hackage.haskell.org/package/massiv)
  for parallel computation. Parallel performance can reach 10-15x single-threaded
  performance.

  **This is the recommended approach for generating large noise textures or datasets.**

  ### Benchmarks

  #### Results

  Measured by values / second generated by the noise functions. These results come
  from a benchmark with `-fllvm` enabled.

  There's inevitably some noise in the measurements because all of the results are
  forced into an unboxed vector.

  ##### 2D

  | name          | Float (values/sec) | Double (values/sec) |
  | ------------- | ------------------ | ------------------- |
  | value2        | 173_511_654        | 189_119_731         |
  | perlin2       | 154_674_464        | 161_114_532         |
  | openSimplex2  | 74_747_031         | 74_332_345          |
  | valueCubic2   | 61_415_544         | 62_481_313          |
  | superSimplex2 | 51_295_369         | 50_383_577          |
  | cellular2     | 34_996_382         | 32_652_899          |

  ##### 3D

  | name        | Float (values/sec) | Double (values/sec) |
  | ----------- | ------------------ | ------------------- |
  | value3      | 90_805_572         | 93_188_363          |
  | perlin3     | 74_080_032         | 82_477_882          |
  | valueCubic3 | 18_765_912         | 18_284_749          |

  ## Examples

  There's an interactive [demo app](https://github.com/jtnuttall/pure-noise/tree/main/demo) in the `demo` directory.

  ### OpenSimplex2

  ![OpenSimplex2](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/opensimplex.png)
  ![OpenSimplex2 ridged](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/opensimplex-ridged.png)

  ### Perlin

  ![Perlin fBm](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/perlin-fbm.png)

  ### Cellular

  ![value](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/cell-value.png)
  ![distance2add](https://raw.githubusercontent.com/jtnuttall/pure-noise/main/demo/images/cell-d2.png)
description-type: markdown
hash: d9988326182da0e828db22294e06a5ed51d187b9eb2f23893edc329d9a0805f9
homepage: https://github.com/jtnuttall/pure-noise#readme
latest: 0.2.1.0
license-name: BSD-3-Clause
maintainer: jeremy@jeremy-nuttall.com
synopsis: High-performance composable noise generation (Perlin, Simplex, Cellular)
test-bench-deps:
  JuicyPixels: '>=3.3 && <3.4'
  aeson: '>=2.0 && <2.3'
  aeson-pretty: '>=0'
  base: '>=4.16 && <5'
  bytestring: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  filepath: '>=0'
  massiv: '>=1.0 && <2.0'
  primitive: '>=0.8 && <0.10'
  pure-noise: '>=0'
  random: '>=0'
  tasty: '>=0'
  tasty-bench: '>=0'
  tasty-discover: '>=0'
  tasty-golden: '>=0'
  tasty-hunit: '>=0'
  tasty-quickcheck: '>=0'
  text: '>=0'
  typed-process: '>=0'
  vector: <=0.14

homepage: https://github.com/purview-framework/purview#readme
changelog-type: markdown
hash: 500e9e5188ed59c0603b94d74d28e5e890df464aa8617c31e3b5444c88567f8f
test-bench-deps:
  warp: '>=3.3.20 && <3.4'
  wai-websockets: '>=3.0.1 && <3.1'
  bytestring: '>=0.10.12.1 && <0.12'
  wai: '>=3.2.3 && <3.3'
  purview: -any
  stm: '>=2.5.0 && <2.6'
  base: '>=4.7 && <5'
  time: '>=1.9.3 && <1.12'
  hspec: '>=2.8.5 && <2.10'
  text: '>=1.2.5 && <1.3'
  criterion: '>=1.5.13 && <1.6'
  websockets: '>=0.12.7 && <0.13'
  raw-strings-qq: ==1.1.*
  wai-extra: '>=3.1.8 && <3.2'
  QuickCheck: '>=2.14.2 && <2.15'
  scotty: ==0.12.*
  aeson: '>=2.0.3 && <2.1'
maintainer: bontaq@gmail.com
synopsis: Build server rendered, interactive websites
changelog: |
  # Changelog for bridge

  ## Unreleased changes
basic-deps:
  warp: '>=3.3.20 && <3.4'
  wai-websockets: '>=3.0.1 && <3.1'
  bytestring: '>=0.10.12.1 && <0.12'
  wai: '>=3.2.3 && <3.3'
  stm: '>=2.5.0 && <2.6'
  base: '>=4.7 && <5'
  text: '>=1.2.5 && <1.3'
  websockets: '>=0.12.7 && <0.13'
  raw-strings-qq: ==1.1.*
  wai-extra: '>=3.1.8 && <3.2'
  scotty: ==0.12.*
  aeson: '>=2.0.3 && <2.1'
all-versions:
- 0.1.0.0
author: Ian Davidson
latest: 0.1.0.0
description-type: markdown
description: "# Purview\n\nA framework to build interactive UIs with Haskell.  It's
  inspired by Phoenix LiveView, React, and Redux + Sagas.\n\nThe main points:\n* It's
  server side rendered and uses websockets to communicate HTML updates and to receive
  events.\n* State can be broken up into small components.\n* The approach is to provide
  useful atoms, with the user building up a kind of AST.\n* Attributes flow down to
  concrete HTML, events bubble up to state handlers.\n\nIt's still in early development
  so expect things to break or be missing!\n\n## What it looks like\n\nHere's what
  a component looks like (see `experiments/Counter.hs`):\n\n```haskell\n\nmodule Main
  where\n\nimport Prelude hiding (div)\nimport Data.Aeson\nimport Data.Aeson.TH\n\nimport
  Purview\n\ndata Direction = Up | Down\n\n$(deriveJSON defaultOptions ''Direction)\n\nupButton
  = onClick Up $ div [ text \"up\" ]\ndownButton = onClick Down $ div [ text \"down\"
  ]\n\nhandler = messageHandler (0 :: Int) reducer\n  where\n    reducer Up   state
  = (const $ state + 1, [])\n    reducer Down state = (const $ state - 1, [])\n\ncounter
  state = div\n  [ upButton\n  , text $ \"count: \" <> show state\n  , downButton\n
  \ ]\n\nview = handler counter\n\nmain = Purview.run defaultConfiguration { component=view
  }\n```\n\n## Overview\n\n### Adding attributes to HTML elements\n\nAttributes flow
  down to concrete HTML.\n\nFor example, if you wanted to add a `style=\"color: blue;\"`
  to a `div`:\n\n``` haskell\nblue = style \"color: blue;\"\n\nblueDiv = blue (div
  [])\n```\n\nCalling `render blueDiv` will produce `<div style=\"color: blue;\"></div>\"`\n\nIf
  you wanted to have a blue div that's 50% of the width,\n\n``` haskell\nblue = style
  \"color: blue;\"\nhalfWidth = style \"width: 50%;\"\n\nview = blue (halfWidth (div
  [])\n```\n\nNow `render view` will produce `<div style=\"color: blue; width: 50%;></div>`\n\nAs
  purview is non-prescriptive in what attributes you can give a `div`, or any other
  HTML element, you can create your own.\n\nIf you need `name` attribute put on `div`s
  or other HTML, you can do:\n\n``` haskell\nnameAttr = Attribute . Generic \"name\"\n\nnamedDiv
  = nameAttr \"wumbo\" (div [])\n```\n\nAnd `render namedDiv` will produce `<div name=\"wumbo\"></div>`.
  \ Eventually there will be more attributes-by-default like `style`, but for now
  expect to build up what you need!\n\n### Creating new HTML elements\n\nJust like
  you can add new attributes, you can also add new html elements.  For example, if
  you need a button\n\n``` haskell\nbutton = Html \"button\"\n\nview = button [ text
  \"click\" ]\n```\n\nNow `render view` will produce `<button>click</button>`.  Like
  all the built in ones, attributes will flow down and be added to the button.\n\n###
  Events\n\nAt the core of Purview are three event handlers, in order of increasing
  power:\n1. `simpleHandler`: Used for just returning a new state.  No messages or
  effects.\n2. `messageHandler`: Used when you need to send messages to the component
  itself or to its parent.\n3. `effectHandler`: Used when you need the above and access
  to IO / your monad stack / algebraic effects.\n\nThe first two are just some sugar
  around `effectHandler`.\n\nHandlers take an initial state and a reducer.  The reducer
  receives actions from anywhere below them in the tree, and returns the new state
  with a list of actions to send either to itself or up the tree to the parent.  The
  handler passes down the state to its child.  This is the core idea to make it all
  interactive.\n\nFor example, if we wanted to build something that fetched the server
  time on each click:\n\n``` haskell\nreducer action state = case action of\n  \"getTime\"
  -> do\n      time <- getCurrentTime\n      pure (const $ Just time, [])\n\nhandler
  = effectHandler Nothing reducer\n\nview time = div \n  [ onClick \"getTime\" $ button
  [ text \"check time\" ]\n  , p [ text (show time) ]\n  ]\n  \ncomponent = handler
  view\n```\n\nSome things to note:\n* The state is passed down to children.\n* Events
  bubble up to the nearest handler where they are captured.\n* `onClick` can wrap
  anything -- like other attributes it flows down to concrete HTML.\n* The reducer
  is run in its own thread when an event is received, so you don't have to worry about
  slow operations locking the page.\n\n### Overview of how it works\n\nUsing the above
  example of getting the time, here's how events flow when the user clicks \"check
  time\"\n\n1. The event is sent from the browser in a form like `\n\n   ```{ event:
  click, message: \"checkTime\", location: [0] }```\n2. The event is put onto the
  channel for the event loop to process\n3. By going down the tree it applies the
  event to the matched handler\n\n   a. Any HTML changes are sent to the browser,
  completing the loop\n5. The handler does its work in a green thread, creating a
  new event that looks like\n   \n   ```{ event: stateChange, fn: state -> state,
  location: [0] }```\n7. The state change event is put onto the channel for the event
  loop to process\n8. By going down the tree it applies the state change fn to the
  latest state in the tree, returning a new tree\n9. Any HTML changes are sent to
  the browser, completing the loop\n\n### Contributing\n\nAnything is welcome, including
  examples or patterns you found nice.  There's still a lot to discover.\n\nThe roadmap
  is, loosely, determined by adding things required to build real websites.  The first
  two site-based goals:\n1. The Purview website itself, which will have more in depth
  tutorials (so requiring at least navigation)\n2. A stripe-based checkout (requiring
  communication with javascript)\n\n### Installation\n\n1. Install [stack](https://docs.haskellstack.org/en/stable/README/)\n2.
  `stack build`\n3. `stack exec purview-exe` for just running the example above\n\n###
  Running Tests\n\n1. The same as above with stack and build\n2. `stack test`\n"
license-name: BSD-3-Clause

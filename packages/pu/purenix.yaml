homepage: https://github.com/purenix-org/purenix
changelog-type: markdown
hash: e3729a516deeaef5aa953fdc5544fa64327159fa9597843fb144d1eaf29e8fc6
test-bench-deps: {}
maintainer: Dennis Gosnell <cdep.illabout@gmail.com>
synopsis: Nix backend for PureScript.  Transpile PureScript code to Nix.
changelog: |
  # Changelog

  Versioning is `MAJOR.MINOR`.
  Major changes are generally backwards-incompatible changes to the interface, minor changes are incremental improvements.

  ## 1.0

  ### [Added]
  - Initial release
basic-deps:
  purescript-cst: -any
  microlens-platform: -any
  bytestring: -any
  base: '>=4.9 && <5'
  text: -any
  filepath: -any
  containers: -any
  purescript: ==0.14.4
  mtl: -any
  pretty-simple: -any
  purenix: -any
  aeson: -any
  directory: -any
all-versions:
- '1.0'
author: Dennis Gosnell, Jonas Carpay
latest: '1.0'
description-type: markdown
description: "<p align=\"center\">\n  <img src=\"img/purenix-icon.svg\" width=\"150\"
  height=\"150\" />\n</ p>\n<h1 align=\"center\">PureNix</h1>\n\nPureNix is a Nix
  backend for PureScript.\n\nSometimes, you find yourself having to write Nix code
  that's more complicated than what the language was designed for.\nPureNix allows
  you to write that code in a fully-featured, strongly-typed language instead, and
  then compile to Nix.\nA typical example is parsing of configuration files, like
  [the port of cabal2nix that inspired PureNix](https://github.com/cdepillabout/cabal2nixWithoutIFD).\n\nPureNix
  has full support for all of PureScript's features, including data types, type classes,
  and calling back into Nix using the FFI.\n\nOn the [organization page for PureNix](https://github.com/purenix-org)
  you will find a number of packages intended to be used with PureNix, including ports
  of libraries like [purescript-prelude](https://github.com/purenix-org/purescript-prelude).\n\n##
  Code sample\n\nPureScript source, `Main.purs`:\n\n```purescript\nmodule Main where\n\nimport
  Data.A as A\nimport Data.B as B\n\ngreeting :: String\ngreeting = \"Hello, world!\"\n\ndata
  Maybe a = Nothing | Just a\n\nfromMaybe :: forall a. a -> Maybe a -> a\nfromMaybe
  a Nothing = a\nfromMaybe _ (Just a) = a\n\nforeign import add :: Int -> Int -> Int\n\nfoo
  :: Int\nfoo = add A.bar B.baz\n```\n\nNix FFI file, `Main.nix`:\n\n```nix\n{ add
  = a: b: a + b; }\n```\n\nGenerated Nix:\n\n```nix\nlet\n  module = \n    { \"Data.A\"
  = import ../Data.A;\n      \"Data.B\" = import ../Data.B;\n    };\n  foreign = import
  ./foreign.nix;\n  add = foreign.add;\n  Nothing = {__tag = \"Nothing\";};\n  Just
  = value0: \n    { __tag = \"Just\";\n      __field0 = value0;\n    };\n  greeting
  = \"Hello, world!\";\n  fromMaybe = v: v1: \n    let\n      __pattern0 = __fail:
  if v1.__tag == \"Nothing\" then let a = v; in a else __fail;\n      __pattern1 =
  __fail: if v1.__tag == \"Just\" then let a = v1.__field0; in a else __fail;\n      __patternFail
  = builtins.throw \"Pattern match failure in src/Main.purs at 11:1 - 11:41\";\n    in\n
  \     __pattern0 (__pattern1 __patternFail);\n  foo = add module.\"Data.A\".bar
  module.\"Data.B\".baz;\nin\n  {inherit greeting Nothing Just fromMaybe add foo;}\n```\n\nThere
  are a couple things to notice here:\n\n- PureScript built-in types like `String`,
  `Int`, objects, and lists are converted to their corresponding Nix types, as in
  `greeting`.\n- Data constructors from sum types are available to easily work with
  in the output Nix file, like `Just` and `Nothing`, although you might want to define
  named field accessors.\n- Foreign imports are straightforward to define and use,
  like in `add` and `foo`. The FFI file gets copied into the module's output directory
  as `foreign.nix`.\n\n## Usage\n\nThe easiest way to use PureNix is through Spago.\nSimply
  set `backend = \"purenix\"`, make sure `purenix` is available in the `PATH`, and
  build as normal.\n\nWhen you run `purenix`, manually or through Spago, it will look
  for the Purescript output directory `./output` in the current working directory.\nIt
  then traverses this directory structure, looks for Purescript's intermediate `corefn.json`
  files, transpiles the `corefn.json` files to the equivalent Nix code, and writes
  the output Nix code to `default.nix`.\n\n## Warnings\n\n### What PureNix is and
  is not\n\nPureNix allows you to write code in PureScript, and then compile to Nix.\nThe
  degree to which you can replace existing Nix code depends on how well you can express
  that code in PureScript.\nFor some things, that's pretty easy, but there are many
  things in Nix and nixpkgs that are much harder to provide (useful) types for.\nAs
  such, PureNix is _not_ a complete typed replacement for Nix.\nThe goal for now is
  simply to allow you to take code that's tricky to write in an untyped language,
  and write it in a typed language instead.\n\n[The ecosystem around PureNix](https://github.com/purenix-org)
  is currently focused on providing PureNix ports of existing PureScript libraries.\nOver
  time, we hope to expand in the other direction as well, with libraries that provide
  typed versions of Nix-only constructs, thereby expanding the amount of Nix you can
  feasibly replace with PureNix, but there's still a lot to be done.\nAny help is
  welcome!\n\n### Laziness and memory management\n\nPureScript generally assumes that
  its backends perform strict evaluation, and some degree of memory management.\nNix
  is a lazy language however, and is happy to leak memory.\nFor most use cases this
  doesn't cause any issues, and in fact the laziness allows you to write more Haskell-like
  code than you usually would in PureScript.\n\nStill, it's good to keep these things
  in mind:\n\n- Like in every lazy language, you need to watch out for space leaks
  caused by accidentally building up large thunks.\n  PureScript does not natively
  have tools to deal with laziness, like bang patterns or `seq`, but you can define
  them yourself by e.g. pulling in `builtins.seq` through the FFI.\n\n- Long-running
  programs may run out of memory due to the lack of garbage collection and tail recursion.\n
  \ If you end up writing long-running programs, like a parser that needs to process
  very large files, you might have to rewrite it in a way that minimizes recursion
  and allocation.\n"
license-name: BSD-3-Clause

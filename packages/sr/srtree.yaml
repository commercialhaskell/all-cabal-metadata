homepage: https://github.com/folivetti/srtree#readme
changelog-type: markdown
hash: ca3ceb2f745c56966e54b21df8b98a8ff3812ce7062ac3eb39196b70264ddc3b
test-bench-deps:
  srtree: -any
  base: ==4.16.*
  containers: ==0.6.*
  mtl: ==2.2.*
  random: ==1.2.*
  vector: ==0.12.*
maintainer: fabricio.olivetti@gmail.com
synopsis: A general framework to work with Symbolic Regression expression trees.
changelog: |
  # Changelog for srtree

  ## 0.1.1.0

  - Fixed compilation bug

  ## 0.1.0.0

  - Initial version
basic-deps:
  base: ==4.16.*
  containers: ==0.6.*
  mtl: ==2.2.*
  random: ==1.2.*
  vector: ==0.12.*
all-versions:
- 0.1.0.0
- 0.1.1.0
author: Fabricio Olivetti de Fran√ßa
latest: 0.1.1.0
description-type: markdown
description: |+
  # srtree: A symbolic regression expression tree structure.

  `srtree` is a Haskell library with a data structure and supporting functions to manipulate expression trees for symbolic regression.

  The tree-like structure is parameterized by the type of the variables indexing and the return value when evaluating the tree. The most common is to index the variables with `Int` starting at $0$ and to return a `Double`. The Functor instance changes the type of the stored/returned values.

  The tree supports leaf nodes containing a variable, a free parameter, or a constant value; internal nodes that represents binary operators such as the four basic math operations, logarithm with custom base, and the power of two expressions; and unary functions specified by `Function` data type.

  This library also defines the `OptInt` class with the operator `^.` that represents the integral power. This is needed to automatically simplify some constructs of the tree and also when using interval arithmetic, that requires a special case of integral power.

  The `SRTree` structure has instances for `Num, Fractional, Floating` which allows to create an expression as a valid Haskell expression such as:

  ```haskell
  x = Var 0
  y = Var 1
  expr = x * 2 + sin(y * pi + x) :: SRTree Int Double
  ```

  There is also a `Bifunctor` instance that allows to change the type of both parameters, and an `Applicative, Foldable, Traversable` instances. To traverse by the index type, there is a function called `traverseIx`.

  ## Other features:

  - simplification algorithm (`simplify`)
  - derivative w.r.t. a variable (`deriveBy`)
  - evaluation (`evalTree`)
  - relabel free parameters sequentially (`relabelParams`)
  - relabel variables couting their occurrence (`relabelOccurrences`, used with interval arithmetic)

  ## TODO:

  - derivative w.r.t. free parameters
  - support more advanced functions
  - support conditional branching (`IF-THEN-ELSE`)

license-name: BSD-3-Clause

all-versions:
- 0.1.0.0
author: Yoshikuni Jujo
basic-deps:
  base: '>=4.7 && <5'
  ftcqueue: '>=0.1 && <0.2'
  higher-order-freer-monad: '>=0.1 && <0.2'
  higher-order-open-union: '>=0.1 && <0.2'
  yaftee: '>=0.1 && <0.2'
changelog: |
  # Changelog for `yaftee-basic-monads`

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
  and this project adheres to the
  [Haskell Package Versioning Policy](https://pvp.haskell.org/).

  ## Unreleased

  ## 0.1.0.0 - YYYY-MM-DD
changelog-type: markdown
description: "# yaftee-basic-monads\n\n## Reader, Writer and State\n\n### Reader\n\n```Haskell:TryYaftee/Reader.hs\n{-#
  LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE BlockArguments #-}\n{-# LANGUAGE
  TypeApplications #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts
  #-}\n{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}\n\nmodule TryYaftee.Reader where\n\nimport
  Control.Monad.Yaftee.Eff qualified as Eff\nimport Control.Monad.Yaftee.Reader qualified
  as Reader\nimport Control.Monad.Yaftee.IO qualified as IO\nimport Control.HigherOpenUnion
  qualified as U\n\nrun :: Monad m => Eff.E '[Reader.R Int, U.FromFirst m] i o a ->
  m a\nrun = Eff.runM . (`Reader.run` 123)\n\nsample :: (U.Member (Reader.R Int) es,
  U.Base IO.I es) => Eff.E es i o ()\nsample = do\n\te <- Reader.ask @Int\n\tIO.print
  e\n\tReader.local @Int (* 2) do\n\t\te' <- Reader.ask @Int\n\t\tIO.print e'\n```\n\n###
  Writer\n\n```Haskell:TryYaftee/Writer.hs\n{-# LANGUAGE ImportQualifiedPost #-}\n{-#
  LANGUAGE BlockArguments #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts
  #-}\n{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}\n\nmodule TryYaftee.Writer where\n\nimport
  Control.Monad\nimport Control.Monad.Yaftee.Eff qualified as Eff\nimport Control.Monad.Yaftee.Writer
  qualified as Writer\nimport Control.Monad.Yaftee.IO qualified as IO\nimport Control.HigherOpenUnion
  qualified as U\n\naction :: IO ((), [String])\naction = run @[String] getLines\n\nrun
  :: Monoid w => Eff.E '[Writer.W w, IO.I] i o r -> IO (r, w)\nrun = Eff.runM . Writer.run\n\ngetLines
  :: (U.Member (Writer.W [String]) es, U.Base IO.I es) => Eff.E es i o ()\ngetLines
  = IO.getLine >>= \\ln ->\n\twhen (not $ null ln) (Writer.tell [ln] >> getLines)\n```\n\n###
  State\n\n```Haskell:TryYaftee/State.hs\n{-# LANGUAGE ImportQualifiedPost #-}\n{-#
  LANGUAGE TypeApplications #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts
  #-}\n{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}\n\nmodule TryYaftee.State where\n\nimport
  Control.Monad\nimport Control.Monad.Yaftee.Eff qualified as Eff\nimport Control.Monad.Yaftee.Reader
  qualified as Reader\nimport Control.Monad.Yaftee.State qualified as State\nimport
  Control.HigherOpenUnion qualified as U\n\nsample :: ((), Int)\nsample = run @Int
  3 5 $ increaseNTimes 7\n\nrun :: d -> a -> Eff.E '[Reader.R d, State.S a] i o r
  -> (r, a)\nrun d x0 = Eff.run . (`State.run` x0) . (`Reader.run` d)\n\nincrease
  ::\n\t(U.Member (Reader.R Int) es, U.Member (State.S Int) es) =>\n\tEff.E es i o
  ()\nincrease = do\n\td <- Reader.ask @Int\n\tState.modify (+ d)\n\nincreaseNTimes
  :: (U.Member (Reader.R Int) es, U.Member (State.S Int) es) =>\n\tInt -> Eff.E es
  i o ()\nincreaseNTimes n = replicateM_ n increase\n```\n\n## Except and Fail\n\n###
  Except\n\n```Haskell:TryYaftee/Except.hs\n{-# LANGUAGE ImportQualifiedPost #-}\n{-#
  LANGUAGE TypeApplications #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts
  #-}\n{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}\n\nmodule TryYaftee.State where\n\nimport
  Control.Monad\nimport Control.Monad.Yaftee.Eff qualified as Eff\nimport Control.Monad.Yaftee.Reader
  qualified as Reader\nimport Control.Monad.Yaftee.State qualified as State\nimport
  Control.HigherOpenUnion qualified as U\n\nsample :: ((), Int)\nsample = run @Int
  3 5 $ increaseNTimes 7\n\nrun :: d -> a -> Eff.E '[Reader.R d, State.S a] i o r
  -> (r, a)\nrun d x0 = Eff.run . (`State.run` x0) . (`Reader.run` d)\n\nincrease
  ::\n\t(U.Member (Reader.R Int) es, U.Member (State.S Int) es) =>\n\tEff.E es i o
  ()\nincrease = do\n\td <- Reader.ask @Int\n\tState.modify (+ d)\n\nincreaseNTimes
  :: (U.Member (Reader.R Int) es, U.Member (State.S Int) es) =>\n\tInt -> Eff.E es
  i o ()\nincreaseNTimes n = replicateM_ n increase\n```\n\n### Fail\n\n```Haskell:TryYaftee/Fail.hs\n{-#
  LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts
  #-}\n{-# OPTIOnS_GHC -Wall -fno-warn-tabs #-}\n\nmodule TryYaftee.Fail where\n\nimport
  Control.Monad.Yaftee.Eff qualified as Eff\nimport Control.Monad.Yaftee.Except qualified
  as Except\nimport Control.Monad.Yaftee.Fail qualified as Fail\nimport Control.Monad.Yaftee.IO
  qualified as IO\nimport Control.HigherOpenUnion qualified as U\nimport Control.Exception\n\nrun
  :: Monad m => Eff.E '[Fail.F, U.FromFirst m] i o a -> m (Either String a)\nrun =
  Eff.runM . Fail.run\n\nrunIO :: Eff.E '[Fail.F, Except.E ErrorCall, IO.I] i o a
  -> IO a\nrunIO = Eff.runM\n\t. Except.runIO . Fail.runExc ErrorCall (\\(ErrorCall
  str) -> str)\n\nsample0 :: MonadFail m => m ()\nsample0 = do\n\tfail \"foobar\"\n\ncatch
  :: (U.Member Fail.F es, U.Base IO.I es) =>\n\tEff.E es i o () -> Eff.E es i o ()\ncatch
  = (`Fail.catch` \\msg -> IO.putStrLn $ \"FAIL OCCUR: \" ++ msg)\n```\n\n## NonDet\n\n```Haskell:TryYaftee/NonDet.hs\n{-#
  LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE DataKinds #-}\n{-# OPTIONS_GHC -Wall
  -fno-warn-tabs #-}\n\nmodule TryYaftee.NonDet where\n\nimport Control.Applicative\nimport
  Control.Monad\nimport Control.Monad.Yaftee.Eff qualified as Eff\nimport Control.Monad.Yaftee.NonDet
  qualified as NonDet\n\nrun :: (Traversable f, MonadPlus f) => Eff.E '[NonDet.N]
  i o r -> f r\nrun = Eff.run . NonDet.run\n\nfoo :: Alternative f => f Int\nfoo =
  pure 123\n\nbar :: Alternative f => f Int\nbar = empty\n\nfoobar :: Alternative
  f => f Int\nfoobar = foo <|> bar\n```\n\n## Base Monad\n\n### IO\n\n### ST\n\n```Haskell:TryYaftee/ST.hs\n{-#
  LANGUAGE ImportQualifiedPost #-}\n{-# LANGUAGE ScopedTypeVariables, TypeApplications,
  RankNTypes #-}\n{-# LANGUAGE RequiredTypeArguments #-}\n{-# LANGUAGE DataKinds #-}\n{-#
  LANGUAGE FlexibleContexts #-}\n{-# OPTIONS_GHC -Wall -fno-warn-tabs #-}\n\nmodule
  TryYaftee.ST where\n\nimport Control.Monad\nimport Control.Monad.ST\nimport Control.Monad.Yaftee.Eff
  qualified as Eff\nimport Control.Monad.Yaftee.Reader qualified as Reader\nimport
  Control.Monad.Yaftee.ST qualified as ST\nimport Control.HigherOpenUnion qualified
  as U\nimport Data.STRef\n\nrun :: Eff.E '[Reader.R a, ST.S s] i o r -> a -> ST s
  r\nrun m d = Eff.runM $ Reader.run m d\n\nincrease :: (U.Member (Reader.R Int) es,
  U.Base (ST.S s) es) =>\n\tSTRef s Int -> Eff.E es i o ()\nincrease r = do\n\td <-
  Reader.ask\n\tST.modifyRef' r (+ d)\n\nincreaseNTimes :: forall s ->\n\t(U.Member
  (Reader.R Int) es, U.Base (ST.S s) es) =>\n\tInt -> Int -> Eff.E es i o Int\nincreaseNTimes
  s n x0 = do\n\tr <- ST.newRef @s x0\n\treplicateM_ n (increase r)\n\tST.readRef
  r\n\nsample :: forall s . ST s Int\nsample = run @Int (increaseNTimes s 3 5) 2\n```\n\n##
  Trace\n\n```Haskell:TryYaftee/Trace.hs\n{-# LANGUAGE ImportQualifiedPost #-}\n{-#
  LANGUAGE ScopedTypeVariables, TypeApplications, RankNTypes #-}\n{-# LANGUAGE RequiredTypeArguments
  #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# OPTIONS_GHC
  -Wall -fno-warn-tabs #-}\n\nmodule TryYaftee.ST where\n\nimport Control.Monad\nimport
  Control.Monad.ST\nimport Control.Monad.Yaftee.Eff qualified as Eff\nimport Control.Monad.Yaftee.Reader
  qualified as Reader\nimport Control.Monad.Yaftee.ST qualified as ST\nimport Control.HigherOpenUnion
  qualified as U\nimport Data.STRef\n\nrun :: Eff.E '[Reader.R a, ST.S s] i o r ->
  a -> ST s r\nrun m d = Eff.runM $ Reader.run m d\n\nincrease :: (U.Member (Reader.R
  Int) es, U.Base (ST.S s) es) =>\n\tSTRef s Int -> Eff.E es i o ()\nincrease r =
  do\n\td <- Reader.ask\n\tST.modifyRef' r (+ d)\n\nincreaseNTimes :: forall s ->\n\t(U.Member
  (Reader.R Int) es, U.Base (ST.S s) es) =>\n\tInt -> Int -> Eff.E es i o Int\nincreaseNTimes
  s n x0 = do\n\tr <- ST.newRef @s x0\n\treplicateM_ n (increase r)\n\tST.readRef
  r\n\nsample :: forall s . ST s Int\nsample = run @Int (increaseNTimes s 3 5) 2\n```\n"
description-type: markdown
hash: 6ac2b56a59177bc7896f459d8caa0594e00dc315d5a647daedb2a5a579b98d55
homepage: https://github.com/YoshikuniJujo/yaftee-basic-monads#readme
latest: 0.1.0.0
license-name: BSD-3-Clause
maintainer: yoshikuni.jujo@gmail.com
synopsis: Basic monads implemented on Yaftee
test-bench-deps:
  base: '>=4.7 && <5'
  ftcqueue: '>=0.1 && <0.2'
  higher-order-freer-monad: '>=0.1 && <0.2'
  higher-order-open-union: '>=0.1 && <0.2'
  yaftee: '>=0.1 && <0.2'
  yaftee-basic-monads: '>=0'

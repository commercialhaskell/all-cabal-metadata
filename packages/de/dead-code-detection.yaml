all-versions:
- '0.1'
- 0.1.1
- 0.1.2
- '0.2'
- '0.3'
- '0.4'
- 0.4.0.1
- '0.5'
- 0.5.1
- '0.6'
- '0.7'
- '0.8'
- 0.8.1
author: ''
basic-deps:
  Glob: '>=0'
  base: '>=4 && <5'
  containers: '>=0'
  directory: '>=0'
  getopt-generics: '>=0.12 && <0.13 || >=0.13 && <0.14'
  ghc: '>=0'
  ghc-paths: '>=0'
  gitrev: '>=0'
  graph-wrapper: '>=0'
  silently: '>=0'
  string-conversions: '>=0'
  uniplate: '>=0'
changelog: ''
changelog-type: ''
description: |
  ## *status: experimental*

  `dead-code-detection` detects dead code in haskell projects.

  This project is still in an early stage. Currently only those language
  constructs have been implemented that I have stumbled across in projects I used
  it on. If the tool encounters a language construct that it doesn't understand
  yet, it will crash. (I *think* this is the best behavior since ignoring
  unimplemented language constructs would easily result in false positives and
  false negatives.) If you use `dead-code-detection` on any project and it
  doesn't work due to a not implemented language construct, please consider
  opening an issue on github.

  ``` shell
  $ dead-code-detection --root Main -isrc
  src/Example/Module.hs:42:23: unusedName
  ```
description-type: markdown
hash: df86f7157d0ed73e6485eaf03193339df354fefb8d30ed40be27b8f751282ecb
homepage: https://github.com/soenkehahn/dead-code-detection#readme
latest: 0.8.1
license-name: BSD-3-Clause
maintainer: SÃ¶nke Hahn <soenkehahn@gmail.com>
synopsis: detect dead code in haskell projects
test-bench-deps:
  Glob: '>=0'
  base: '>=4 && <5'
  containers: '>=0'
  directory: '>=0'
  filepath: '>=0'
  getopt-generics: '>=0.12 && <0.13 || >=0.13 && <0.14'
  ghc: '>=0'
  ghc-paths: '>=0'
  gitrev: '>=0'
  graph-wrapper: '>=0'
  hspec: '>=0'
  interpolate: '>=0'
  mockery: '>=0'
  silently: '>=0'
  string-conversions: '>=0'
  uniplate: '>=0'

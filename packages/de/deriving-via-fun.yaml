all-versions:
- 0.1.0.0
author: Li-yao Xia
basic-deps:
  base: '>=4.19 && <4.22'
changelog: "# Revision history for deriving-via-fun\r\n\r\n## 0.1.0.0 -- YYYY-mm-dd\r\n\r\n*
  First version. Released on an unsuspecting world.\r\n"
changelog-type: markdown
description: "# Deriving via first-class functions\r\n\r\n1. You want to derive a
  class instance for a type `T`.\r\n2. You want to reuse an existing instance for
  a similar type `U`.\r\n3. Define a function or isomorphism between `T` and `U`.
  Give it a \"type-level name\" `F`.\r\n4. Derive the instance for `T` via `Fun F`.\r\n\r\n[![Hackage](https://img.shields.io/hackage/v/deriving-via-fun.svg)](https://hackage.haskell.org/package/deriving-via-fun)\r\n\r\n##
  Deriving via generic isomorphism\r\n\r\nExample type:\r\n\r\n```haskell\r\ndata
  T0 = T0 Int Bool\r\n```\r\n\r\nTo reuse existing instances for `(Int, Bool)`,\r\nwe
  can do deriving via the \"generic isomorphism\" `T0 ?-> (Int, Bool)`.\r\n\r\n```haskell\r\nderiving
  (Eq, Ord) via Fun (T0 ?-> (Int, Bool))\r\n```\r\n\r\nComplete example with extensions
  and imports:\r\n\r\n```haskell\r\n{-# LANGUAGE DeriveGeneric, DerivingVia, TypeOperators
  #-}\r\nimport DerivingViaFun\r\nimport GHC.Generics (Generic)\r\nimport Data.Monoid
  (Sum(..), Any(..))\r\n\r\ndata T0 = T0 Int Bool\r\n  deriving Generic\r\n  deriving
  (Eq, Ord)           via Fun (T0 ?-> (Int, Bool))\r\n  deriving (Semigroup, Monoid)
  via Fun (T0 ?-> (Sum Int, Any))\r\n```\r\n\r\n## Function composition\r\n\r\nExample:
  derive the `All` monoid (aka. `(&&)`) from `Any` (aka. `(||)`) by duality.\r\n\r\n```haskell\r\nnewtype
  All = All Bool\r\n  deriving (Semigroup, Monoid)\r\n    via Fun (Coerce All Bool
  >>> Not >>> Coerce Bool Any)\r\n```\r\n\r\nThe function `Coerce All Bool >>> Not
  >>> Coerce Bool Any`\r\ndenotes a function composition of [`coerce`](https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Coerce.html)\r\nand
  the boolean function `not`,\r\nas well as its inverse.\r\n\r\n## How it works: classes
  are functors\r\n\r\nThe type `Fun (f :: a ~> b)` is a newtype containing `a`.\r\nDeriving-via-fun
  is enabled for a class `C`\r\nby providing an instance of the form\r\n`C b => C
  (Fun (f :: a ~> b))`,\r\nwhich can be read as a function from `C b` to `C a`,\r\nusing
  the mapping `f :: a ~> b`.\r\nIn that way, we can think of many classes `C` as functors.\r\nWhether
  the mapping `f` represents a function from `a` to `b`,\r\nor a function from `b`
  to `a`, or a bijection between them,\r\ndepends on the specific class `C`.\r\n\r\nFor
  example, `Eq` has this instance, where `Apply f`\r\nprovides a function `a -> b`:\r\n\r\n```haskell\r\ninstance
  (Apply f, Eq b) => Eq (Fun (f :: a ~> b)) where\r\n```\r\n\r\nFor a different example,
  `Bounded` has this instance,\r\nwhere `Apply (Inv f)` provides a function `b ->
  a`:\r\n\r\n```haskell\r\ninstance (Apply (Inv f), Bounded b) => Bounded (Fun (f
  :: a ~> b)) where\r\n```\r\n\r\nAnd of course, there are classes that require going
  both ways,\r\nlike `Semigroup`:\r\n\r\n```haskell\r\ninstance (Iso f, Semigroup
  b) => Semigroup (Fun (f :: a ~> b)) where\r\n```\r\n\r\nFor more details, check
  out [the documentation](https://hackage.haskell.org/package/deriving-via-fun/docs/DerivingViaFun.html)\r\nor
  read the source code.\r\n\r\n## Comparison with *iso-deriving*\r\n\r\nThis library
  is quite similar to [*iso-deriving*](https://hackage.haskell.org/package/iso-deriving),\r\npresented
  in the blog post [Deriving isomorphically](https://www.tweag.io/blog/2020-04-23-deriving-isomorphically/)
  by Hans Hoeglund.\r\n\r\nIn *iso-deriving*, the newtype `As` is indexed by a source
  and target type,\r\nand the user must declare a suitable instance of `Project` and/or
  `Inject`\r\nbetween these types.\r\n\r\nIn *deriving-via-fun* (this library), the
  newtype `Fun` is indexed by a \"function name\". Certain function names, notably
  `(?->)` and `Coerce`, can be reused for many pairs of types without further ceremony.
  Functions can also be composed easily with `(.)` or `(>>>)`, hence \"first-class
  functions\" in the description.\r\n\r\n*deriving-via-fun* can also replicate the
  usage of *iso-deriving*\r\nusing the `Adhoc` function name.\r\n\r\n## Comparison
  with `Generically`\r\n\r\nThere is some overlap in use cases between this library
  and `Generically`.\r\nBut they still represent rather different approaches.\r\n\r\nThe
  provider of a class instance for `Generically` must commit to a\r\nspecific behavior
  for products and sums once for all.\r\n\r\nUsing this library, a class instance
  for `Fun` only needs to apply\r\nan arbitrary mapping. In other words, the class
  is seen as some kind of functor in a general sense.\r\nThe only part of this library
  that knows anything about generics\r\nis `(?->)`, which delimits a restricted and
  localized usage of `Generic`.\r\nIt's still up to the user to select a concrete
  product or sum type from which to\r\ncopy the class instance.\r\n"
description-type: markdown
hash: f5608ba7f7208d3cb7230805cb1469ca09dd8bb19f9b93f0448347563fe9b80a
homepage: ''
latest: 0.1.0.0
license-name: BSD-3-Clause
maintainer: lysxia@gmail.com
synopsis: Deriving via first-class functions
test-bench-deps:
  base: '>=0'
  deriving-via-fun: '>=0'

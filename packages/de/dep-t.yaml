homepage: ''
changelog-type: markdown
hash: a37423d6271a9a4884888077734cf67ff17d0cde1bb658586719bbcde3295818
test-bench-deps:
  rank2classes: '>=1.4.1 && <1.5'
  sop-core: ^>=0.5.0.0
  base: '>=4.10.0.0 && <5'
  doctest: ^>=0.17
  unliftio-core: '>=0.2.0.0 && <0.3'
  mtl: ==2.2.*
  tasty-hunit: '>=0.10.0.2'
  dep-t: -any
  transformers: '>=0.5.0.0 && <0.6'
  tasty: '>=1.3.1'
  template-haskell: -any
maintainer: diaz_carrete@yahoo.com
synopsis: Reader-like monad transformer for dependency injection.
changelog: "# Revision history for dep-t\r\n\r\n## 0.4.0.0\r\n\r\nActually no breaking
  changes here, but a change in the recommended structure of\r\nthe HasX helper classes,
  and in how to write general code against those\r\ntypeclasses.\r\n\r\n* added Control.Monad.Dep.Class\r\n\r\n##
  0.1.3.0\r\n\r\n* re-exported Control.Monad.Trans\r\n\r\n## 0.1.2.0\r\n\r\n* re-exported
  Control.Monad.Reader.Class\r\n\r\n## 0.1.1.0\r\n\r\n* Added NilEnv.\r\n\r\n## 0.1.0.2
  \r\n\r\n* Minor documentation changes.\r\n\r\n## 0.1.0.1 \r\n\r\n* Minor documentation
  changes.\r\n\r\n## 0.1.0.0 -- YYYY-mm-dd\r\n\r\n* First version. Released on an
  unsuspecting world.\r\n"
basic-deps:
  base: '>=4.10.0.0 && <5'
  unliftio-core: ^>=0.2.0.0
  mtl: ^>=2.2
  transformers: ^>=0.5.0.0
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.1.0
- 0.1.2.0
- 0.1.3.0
- 0.4.0.0
author: Daniel Diaz
latest: 0.4.0.0
description-type: markdown
description: "# dep-t\r\n\r\n`DepT` is a\r\n[ReaderT](http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html)-like\r\nmonad
  transformer for dependency injection.\r\n\r\nThe difference with `ReaderT` is that
  `DepT` takes an enviroment whose type is\r\nparameterized by `DepT` itself.\r\n\r\n##
  Rationale\r\n\r\nTo achieve dependency injection in Haskell, a common solution is
  to build a\r\nrecord of functions and pass it to the program logic using some variant
  of\r\n[`ReaderT`](http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html).\r\n\r\nLet's
  start by defining some auxiliary typeclasses to extract functions from an\r\nenvironment
  record:\r\n\r\n    type HasLogger :: (Type -> Type) -> Type -> Constraint\r\n    class
  HasLogger d e | e -> d where\r\n      logger :: e -> String -> d ()\r\n\r\n    type
  HasRepository :: (Type -> Type) -> Type -> Constraint\r\n    class HasRepository
  d e | e -> d where\r\n      repository :: e -> Int -> d ()\r\n\r\nWe see that the
  type of the environment `e` determines the monad `d` on which\r\nthe effects take
  place.\r\n\r\nLet's define a monomorphic record with effects in `IO`:\r\n\r\n    type
  EnvIO :: Type\r\n    data EnvIO = EnvIO\r\n      { _loggerIO :: String -> IO (),\r\n
  \       _repositoryIO :: Int -> IO ()\r\n      }\r\n\r\n    instance HasLogger IO
  EnvIO where\r\n      logger = _loggerIO\r\n\r\n    instance HasRepository IO EnvIO
  where\r\n      repository = _repositoryIO\r\n\r\nRecord-of-functions-in-IO is a
  simple technique which works well in many\r\nsituations. There are even [specialized\r\nlibraries](http://hackage.haskell.org/package/rio)
  that support it.\r\n\r\nHere's a function which obtains its dependencies from the
  monomorphic\r\nenvironment:\r\n\r\n    mkControllerIO :: (HasLogger IO e, HasRepository
  IO e) => Int -> ReaderT e IO String\r\n    mkControllerIO x = do\r\n      e <- ask\r\n
  \     liftIO $ logger e \"I'm going to insert in the db!\"\r\n      liftIO $ repository
  e x\r\n      return \"view\"\r\n\r\nThat's all and well, but there are two issues
  that bug me:\r\n\r\n- We might want to write code that is innocent of `IO` and polymorphic
  over the\r\n  monad, to ensure that the program logic can't do some unexpected missile\r\n
  \ launch, or to allow testing our app in a \"pure\" way. \r\n\r\n- What if the repository
  function needs access to the logger, too? The\r\n  repository lives in the environment
  record, but isn't aware of it. That means\r\n  it can't use the `HasLogger` typeclass
  for easy and convenient dependency\r\n  injection. Why privilege the controller
  in such a way?\r\n\r\n  In a sufficiently complex app, the diverse functions that
  comprise it will be\r\n  organized in a big\r\n  [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph)
  of dependencies.\r\n  And it would be nice if all the functions taking part in dependency
  injection\r\n  were treated uniformly; if all of them had access to (some view of)
  the\r\n  environment record.\r\n\r\nTo tackle these issues, let's begin by writing
  the controller in a more generic\r\nway:\r\n\r\n    mkController :: MonadDep [HasLogger,
  HasRepository] d e m => Int -> m String\r\n    mkController x = do\r\n      e <-
  ask\r\n      liftD $ logger e \"I'm going to insert in the db!\"\r\n      liftD
  $ repository e x\r\n      return \"view\"\r\n\r\nThe signature has changed, and
  we now use `liftD` instead of `liftIO`. But\r\n`mkController` does the same things
  as `mkControllerIO`, and can be used as a\r\nsubstitute for it:\r\n\r\n    mkControllerIO'
  :: (HasLogger IO e, HasRepository IO e) => Int -> ReaderT e IO String\r\n    mkControllerIO'
  = mkController\r\n\r\nHere we have intantiated `m` to `ReaderT e IO`, and `d` (the
  effect monad used\r\nby dependencies in the environment) to `IO`. So in this example
  `liftD` (the\r\nfunction that lifts `d` effects to `m`) is simply `liftIO`.\r\n\r\nHowever
  the `MonadDep` constraint of `mkController` has valid instances for other\r\nmonads,
  as we shall see.\r\n\r\nNow let's turn our attention to the environment record.
  Let's parameterize its\r\ntype by a monad: \r\n\r\n    type Env :: (Type -> Type)
  -> Type\r\n    data Env m = Env\r\n      { _logger :: String -> m (),\r\n        _repository
  :: Int -> m (),\r\n        _controller :: Int -> m String\r\n      }\r\n\r\n    instance
  HasLogger m (Env m) where\r\n      logger = _logger\r\n\r\n    instance HasRepository
  m (Env m) where\r\n      repository = _repository\r\n\r\nNotice that the controller
  function is now part of the environment. No\r\nfavorites here!\r\n\r\nThe following
  implementation of the logger function has no dependencies besides\r\n`MonadIO`:\r\n\r\n
  \   mkStdoutLogger :: MonadIO m => String -> m ()\r\n    mkStdoutLogger msg = liftIO
  (putStrLn msg)\r\n\r\nBut look at this implementation of the repository function.
  It gets hold of the\r\nlogger through `HasLogger`, just as the controller did:\r\n\r\n
  \   mkStdoutRepository :: (MonadDep '[HasLogger] d e m, MonadIO m) => Int -> m ()\r\n
  \   mkStdoutRepository entity = do\r\n      e <- ask\r\n      liftD $ logger e \"I'm
  going to write the entity!\"\r\n      liftIO $ print entity\r\n\r\nIt's about time
  we chose a concrete monad and assemble an environment record:\r\n\r\n    envIO ::
  Env (DepT Env IO)\r\n    envIO =\r\n      let _logger = mkStdoutLogger\r\n          _repository
  = mkStdoutRepository\r\n          _controller = mkController\r\n       in Env {_logger,
  \ _repository, _controller}\r\n\r\nNot very complicated, except... what is that
  weird `DepT Env IO` doing there in\r\nthe signature? \r\n\r\nWell, that's the whole
  reason this library exists. For dependency injection to\r\nwork for all functions,
  `Env` needs to be parameterized with a monad that\r\nprovides that same `Env` environment.
  And trying to use a `ReaderT (Env\r\nsomething) IO` to parameterize `Env` won't
  fly; you'll get weird \"infinite\r\ntype\" kind of errors. So I created the `DepT`
  newtype over `ReaderT` to mollify\r\nthe compiler.\r\n\r\n`DepT` satisfies the `MonadDep`
  constraint, so the effects of `mkController`\r\ncan take place on it.\r\n\r\n##
  So how do we invoke the controller now?\r\n\r\nI suggest something like\r\n\r\n
  \   runDepT (do e <- ask; _controller e 7) envIO \r\n\r\nor \r\n\r\n    (do e <-
  ask; _controller e 7) `runDepT` envIO \r\n\r\nThe companion package\r\n[dep-t-advice](http://hackage.haskell.org/package/dep-t-advice)
  has some more\r\nfunctions for running `DepT` computations.\r\n\r\n## How to avoid
  using \"ask\" and \"liftD\" before invoking a dependency?\r\n\r\nOne possible workaround
  (at the cost of more boilerplate) is to define helper\r\nfunctions like:  \r\n\r\n
  \   loggerD :: MonadDep '[HasLogger] d e m => String -> m ()\r\n    loggerD msg
  = asks logger >>= \\f -> liftD $ f msg\r\n\r\nWhich you can invoke like this:\r\n\r\n
  \   usesLoggerD :: MonadDep [HasLogger, HasRepository] d e m => Int -> m String\r\n
  \   usesLoggerD i = do\r\n      loggerD \"I'm calling the logger!\"\r\n      return
  \"foo\"\r\n\r\nThough perhaps this isn't worth the hassle.\r\n\r\n## How to use
  \"pure fakes\" during testing?\r\n\r\nThe [test suite](./test/tests.hs) has an example
  of using a `Writer` monad for\r\ncollecting the outputs of functions working as
  [\"test\r\ndoubles\"](https://martinfowler.com/bliki/TestDouble.html).\r\n\r\n##
  How to make a function \"see\" a different evironment from the one seen by its dependencies?\r\n\r\nSometimes
  we want a function in the environment to see a slightly different\r\nrecord from
  the record seen by the other functions, and in particular from the\r\nrecord seen
  by its own dependencies. \r\n\r\nFor example, the function might have a `HasLogger`
  constraint but we don't want\r\nit to use the default `HasLogger` instance of the
  environment.\r\n\r\nThe companion package\r\n[dep-t-advice](http://hackage.haskell.org/package/dep-t-advice)
  provides a\r\n`deceive` function that allows for this.\r\n\r\n## How to add AOP-ish
  \"aspects\" to functions in an environment?\r\n\r\nThe companion package\r\n[dep-t-advice](http://hackage.haskell.org/package/dep-t-advice)
  provides a\r\ngeneral method of extending the behaviour of `DepT`-effectful functions,
  in a\r\nway reminiscent of aspect-oriented programming.\r\n\r\n## Caveats\r\n\r\nThe
  structure of the `DepT` type might be prone to trigger a [known infelicity\r\nof
  the GHC\r\nsimplifier](https://twitter.com/DiazCarrete/status/1350116413445439493).\r\n\r\n##
  Links\r\n\r\n- This library was extracted from my answer to [this Stack Overflow\r\n
  \ question](https://stackoverflow.com/a/61782258/1364288).\r\n\r\n- The implementation
  of `mapDepT` was teased out in [this other SO question](https://stackoverflow.com/questions/65710657/writing-a-zooming-function-for-a-readert-like-monad-transformer).\r\n\r\n-
  An [SO\r\n  answer](https://stackoverflow.com/questions/57703898/how-to-call-impure-functions-from-pure-ones/57714058#57714058)\r\n
  \ about records-of-functions and the \"veil of polymorphism\".\r\n\r\n- The answers
  to [this SO\r\n  question](https://stackoverflow.com/questions/61642492/simplifying-the-invocation-of-functions-stored-inside-an-readert-environment)\r\n
  \ gave me the idea for how to \"instrument\" monadic functions (although the\r\n
  \ original motive of the question was different).\r\n\r\n- I'm unsure of the relationship
  between `DepT` and the technique described in\r\n  [Adventures assembling records
  of\r\n  capabilities](https://discourse.haskell.org/t/adventures-assembling-records-of-capabilities/623)\r\n
  \ which relies on having \"open\" and \"closed\" versions of the environment\r\n
  \ record. \r\n\r\n  It seems that, with `DepT`, functions in the environment obtain
  their\r\n  dependencies anew every time they are invoked. If we change a function
  in the\r\n  environment record, all other functions which depend on it will be affected\r\n
  \ in subsequent invocations. I don't think this happens with \"Adventures...\" at\r\n
  \ least when changing a \"closed\", already assembled record.\r\n\r\n  With `DepT`
  a function might use `local` if it knows enough about the\r\n  environment. That
  doesn't seem very useful for program logic; if fact it\r\n  sounds like a recipe
  for confusion. It could perhaps be useful for [AOP-ish\r\n  things](http://hackage.haskell.org/package/dep-t-advice),
  to keep a synthetic\r\n  \"call stack\", or to implement something like Logback's
  [Mapped Diagnostic\r\n  Context](http://logback.qos.ch/manual/mdc.html).\r\n\r\n-
  [RIO](http://hackage.haskell.org/package/rio) is a featureful ReaderT-like /\r\n
  \ prelude replacement library which favors monomorphic environments.\r\n\r\n- Another
  exploration of dependency injection with `ReaderT`:\r\n  [ReaderT-OpenProduct-Environment](https://github.com/keksnicoh/ReaderT-OpenProduct-Environment).\r\n\r\n-
  The [van Laarhoven Free Monad](http://r6.ca/blog/20140210T181244Z.html).\r\n\r\n>
  Swierstra notes that by summing together functors representing primitive I/O\r\n>
  actions and taking the free monad of that sum, we can produce values use\r\n> multiple
  I/O feature sets. Values defined on a subset of features can be\r\n> lifted into
  the free monad generated by the sum. The equivalent process can\r\n> be performed
  with the van Laarhoven free monad by taking the product of\r\n> records of the primitive
  operations. Values defined on a subset of features\r\n> can be lifted by composing
  the van Laarhoven free monad with suitable\r\n> projection functions that pick out
  the requisite primitive operations. \r\n\r\n- [registry](http://hackage.haskell.org/package/registry)
  is a package that\r\n  implements an alternative approach to dependency injection,
  one different\r\n  from the `ReaderT`-based one. \r\n\r\n"
license-name: BSD-3-Clause

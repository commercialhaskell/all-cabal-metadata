homepage: ''
changelog-type: markdown
hash: 4d32d8527c7bf33014d180746733fdd2913660dd76f937bc539ff8efe7ae09f9
test-bench-deps:
  rank2classes: '>=1.4.1 && <1.5'
  barbies: ^>=2.0
  bytestring: -any
  sop-core: '>=0.5.0.0 && <0.6'
  base: '>=4.10.0.0 && <5'
  text: -any
  doctest: ^>=0.20
  containers: -any
  unliftio-core: '>=0.2.0.0'
  mtl: '>=2.2'
  tasty-hunit: '>=0.10.0.2'
  dep-t: -any
  transformers: '>=0.5.0.0'
  tasty: '>=1.3.1'
  aeson: '>=2.0'
  template-haskell: -any
maintainer: diaz_carrete@yahoo.com
synopsis: Dependency injection for records-of-functions.
changelog: "# Revision history for dep-t\n\n## 0.6.4\n\n* Added AccumConstructor,
  a generalization of Constructor that threads a\n  monoidal summary along with the
  environment record.\n\n* Now Dep.Env.Phased.traverseH and related functions provide
  a 'Typeable'\n  constraint on the polymorphic field variable in the function argument.\n\n
  \ This *should* be backwards compatible because, with the 'Typeable' constraint,\n
  \ the HOF is providing *more* info to the caller of 'traverseH' to work with.\n\n
  \ However it *does* cause a little breakage, because now you can't use FunctorT,\n
  \ TraversableT and ApplicativeT from the \"barbies\" library to implement Phased.\n
  \ But most of the time you would use Phased's own generic deriving anyway.\n\n##
  0.6.3\n\n* Now the Bare typeclass doesn't recurse inside Identity or Const.\n\n
  \ Strictly speaking, this is a breaking change, but the cases in which it breaks\n
  \ are very unlikely in practice: when using Identity or Const in the *middle* of\n
  \ a sequence of phases. Typically, these two applicatives will be used as the\n
  \ colophon of the sequence of phases.\n  \n  The motivation for the change is that
  letting Bare \"peek\" inside Identity and\n  Const made it difficult to write fromBare-using
  functions polymorphic on the\n  returned component. Bare got stuck on the component
  type variable and the\n  functions did not compile. This led to unnecessary code
  duplication. Stopping\n  at Identity means Bare never touches the type variable
  and doesn't get stuck.\n\n## 0.6.2\n\n* Moved `fromBare` and `toBare` from dep-t-dynamic.\n\n*
  Doc fix by @eyeinsky (PR #20)\n\n## 0.6.1.0\n\n* Re-export `Data.Functor.Constant`
  from `Control.Monad.Dep`. https://github.com/danidiaz/dep-t/issues/18\n\n## 0.6.0.0\n\n*
  Added module `Dep.Tagged`.\n\n* Changed the `Constructor` type synonym. \n\n  Now
  it takes a fully constructed environment type. \n\n  This is a backwards-incompatible
  change. Type signatures might need to be modified, not so much term level code.\n\n
  \ https://github.com/danidiaz/dep-t/issues/17\n\n* Removed deprecated modules.\n\n##
  0.5.1.0\n\n* `Control.Monad.Dep.Has` and `Control.Monad.Dep.Env` renamed as `Dep.Has`
  and `Dep.Env`.\n\n  The old modules still remain, but deprecated.\n\n## 0.5.0.0\n\n*
  `Phased` now has `Typeable` constraints. Should be a mostly backwards compatible\n
  \ change, as `Typeable` instances are automagically generated for most types.\n\n
  \ Motivated by https://github.com/danidiaz/dep-t-dynamic/issues/1\n\n## 0.4.6.0\n\n*
  added new module Control.Monad.Dep.Env with helpers for defining environments of
  records.\n\n## 0.4.5.0\n\n* added \"asCall\" to Control.Monad.Dep.Has\n\n## 0.4.4.0\n\n*
  added Control.Monad.Dep.Has, a generic \"Has\" typeclass which favors a style in
  which\n  the components come wrapped in records or newtypes.\n\n* added \"useEnv\"
  to Control.Monad.Dep.Class.\n\n## 0.4.0.0\n\nActually no breaking changes here,
  but a change in the recommended structure of\nthe HasX helper classes, and in how
  to write general code against those\ntypeclasses.\n\n* added Control.Monad.Dep.Class\n\n##
  0.1.3.0\n\n* re-exported Control.Monad.Trans\n\n## 0.1.2.0\n\n* re-exported Control.Monad.Reader.Class\n\n##
  0.1.1.0\n\n* Added NilEnv.\n\n## 0.1.0.2 \n\n* Minor documentation changes.\n\n##
  0.1.0.1 \n\n* Minor documentation changes.\n\n## 0.1.0.0 -- YYYY-mm-dd\n\n* First
  version. Released on an unsuspecting world.\n"
basic-deps:
  base: '>=4.10.0.0 && <5'
  unliftio-core: '>=0.2.0.0'
  mtl: '>=2.2'
  transformers: '>=0.5.0.0'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.1.0
- 0.1.2.0
- 0.1.3.0
- 0.4.0.0
- 0.4.0.1
- 0.4.0.2
- 0.4.4.0
- 0.4.5.0
- 0.4.6.0
- 0.5.0.0
- 0.5.1.0
- 0.6.0.0
- 0.6.1.0
- 0.6.2.0
- 0.6.3.0
- 0.6.4.0
author: Daniel Diaz
latest: 0.6.4.0
description-type: markdown
description: "# dep-t\n\nThis package provides various helpers for the \"record-of-functions\"
  style of structuring Haskell applications. The guiding idea is that record-of-functions
  is a form of dependency injection, and the that the environment which contains the
  functions is akin to an [`ApplicationContext`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html)
  in object-oriented frameworks like [Java Spring](https://docs.spring.io/spring-framework/docs/current/reference/html/).\n\nIf
  every dependency knew about the concrete environment, that would increase coupling.
  The solution is to use `Has`-style classes so that each dependency knows only about
  those parts of the environment which it needs to function, and nothing more. Those
  `Has`-style classes can be tailor-made, but the package also provides a generic
  one. \n\n*Very* loosely speaking, `Has`-style constraints correspond to injected
  member variables in object-oriented frameworks.\n\n[![dep-t.png](https://i.postimg.cc/2j0qqkmJ/dep-t.png)](https://postimg.cc/V5bspcJB)\n\n-
  __Dep.Has__ contains a generic `Has` typeclass for locating dependencies in an environment.
  It can be useful independently of `ReaderT`, `DepT` or any monad transformer.\n-
  __Dep.Env__ complements __Dep.Has__, adding helpers for building environments of
  records.\n- __Dep.Tagged__ is a helper for disambiguating dependencies in __Dep.Env__
  environments.\n- __Control.Monad.Dep__ contains the `DepT` monad transformer, a
  variant of `ReaderT`.\n- __Control.Monad.Dep.Class__ is an extension of `MonadReader`,
  useful to program against both `ReaderT` and `DepT`.\n\n## The DepT transformer\n\n`DepT`
  is a\n[ReaderT](http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html)-like\nmonad
  transformer for dependency injection.\n\nThe difference with `ReaderT` is that `DepT`
  takes an enviroment whose type is\nparameterized by `DepT` itself.\n\n### Rationale\n\nTo
  perform dependency injection in Haskell, a common solution is to build a\nrecord
  of functions and pass it to the program logic using some variant of\n[`ReaderT`](http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html).\n\nTo
  avoid becoming tied to a concrete reader environment, let's define some\nauxiliary
  typeclasses that extract functions from a generic environment:\n\n    type HasLogger
  :: (Type -> Type) -> Type -> Constraint\n    class HasLogger d e | e -> d where\n
  \     logger :: e -> String -> d ()\n\n    type HasRepository :: (Type -> Type)
  -> Type -> Constraint\n    class HasRepository d e | e -> d where\n      repository
  :: e -> Int -> d ()\n\nWe see that the type `e` of the environment determines the
  monad `d` on which\nthe effects take place.\n\nHere's a monomorphic environment
  record with functions that have effects in `IO`:\n\n    type EnvIO :: Type\n    data
  EnvIO = EnvIO\n      { _loggerIO :: String -> IO (),\n        _repositoryIO :: Int
  -> IO ()\n      }\n\n    instance HasLogger IO EnvIO where\n      logger = _loggerIO\n\n
  \   instance HasRepository IO EnvIO where\n      repository = _repositoryIO\n\n[Record-of-functions-in-IO](https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/)
  is a simple technique which works well in many\nsituations. There are even [specialized\nlibraries](http://hackage.haskell.org/package/rio)
  that support it.\n\nHere's a function which can get its dependencies from the monomorphic\nenvironment:\n\n
  \   mkControllerIO :: (HasLogger IO e, HasRepository IO e) => Int -> ReaderT e IO
  String\n    mkControllerIO x = do\n      e <- ask\n      liftIO $ logger e \"I'm
  going to insert in the db!\"\n      liftIO $ repository e x\n      return \"view\"\n\nThat's
  all and well, but there are two issues that bug me:\n\n- We might want to write
  code that is innocent of `IO` and polymorphic over the\n  monad, to ensure that
  the program logic can't do some unexpected missile\n  launch, or to allow testing
  our app in a \"pure\" way. \n\n- What if the repository function needs access to
  the logger, too? The\n  repository lives in the environment record, but isn't aware
  of it. That means\n  it can't use the `HasLogger` typeclass for easy and convenient
  dependency\n  injection. Why privilege the controller in such a way?\n\n  In a sufficiently
  complex app, the diverse functions that comprise it will be\n  organized in a big\n
  \ [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph) of dependencies.\n
  \ And it would be nice if all the functions taking part in dependency injection\n
  \ were treated uniformly; if all of them had access to (some view of) the\n  environment
  record.\n\nTo tackle these issues, we begin by giving the controller a more general
  signature:\n\n    mkControllerIO :: (HasLogger IO e, HasRepository IO e, MonadIO
  m, MonadReader e m) => Int -> m String\n\nNow the function can work in other reader-like
  monads besides `ReaderT`.\n\nLet's go one step further, and abstract away the `IO`,
  so that functions in the\nrecord can have effects in other monads:\n\n    mkController
  :: (HasLogger d e, HasRepository d e, LiftDep d m, MonadReader e m) => Int -> m
  String\n    mkController x = do\n      e <- ask\n      liftD $ logger e \"I'm going
  to insert in the db!\"\n      liftD $ repository e x\n      return \"view\"\n\nNow
  both the signature and the implementation have changed:\n\n- There's a new type
  variable `d`, the monad in which functions taken from the\n  environment `e` have
  their effects.\n\n- `MonadIO` has been replaced by `LiftDep` from `Control.Monad.Dep.Class`,
  a\n  constraint that says we can lift `d` effects into `m` (though it could still\n
  \ make sense to require `MonadIO m` for effects not originating in the\n  environment).\n\n-
  Uses of `liftIO` have been replaced by `liftD`.\n\nIf all those constraints prove
  annoying to write, there's a convenient shorthand using the `MonadDep` type family:\n\n
  \   mkController :: MonadDep [HasLogger, HasRepository] d e m => Int -> m String\n\nThe
  new, more polymorphic `mkController` function can replace the original `mkControllerIO`:\n\n
  \   mkControllerIO' :: (HasLogger IO e, HasRepository IO e) => Int -> ReaderT e
  IO String\n    mkControllerIO' = mkController\n\nNow let's focus on the environment
  record. We'll parameterize its type by a\nmonad: \n\n    type Env :: (Type -> Type)
  -> Type\n    data Env m = Env\n      { _logger :: String -> m (),\n        _repository
  :: Int -> m (),\n        _controller :: Int -> m String\n      }\n\n    instance
  HasLogger m (Env m) where\n      logger = _logger\n\n    instance HasRepository
  m (Env m) where\n      repository = _repository\n\nNotice that the controller function
  is now part of the environment. No\nfavorites here!\n\nThe following implementation
  of the logger function has no dependencies besides\n`MonadIO`:\n\n    mkStdoutLogger
  :: MonadIO m => String -> m ()\n    mkStdoutLogger msg = liftIO (putStrLn msg)\n\nBut
  look at this implementation of the repository function. It gets hold of the\nlogger
  through `HasLogger`, just as the controller did:\n\n    mkStdoutRepository :: (MonadDep
  '[HasLogger] d e m, MonadIO m) => Int -> m ()\n    mkStdoutRepository entity = do\n
  \     e <- ask\n      liftD $ logger e \"I'm going to write the entity!\"\n      liftIO
  $ print entity\n\nIt's about time we choose a concrete monad and assemble an environment
  record:\n\n    envIO :: Env (DepT Env IO)\n    envIO =\n      let _logger = mkStdoutLogger\n
  \         _repository = mkStdoutRepository\n          _controller = mkController\n
  \      in Env {_logger,  _repository, _controller}\n\nNot very complicated, except...
  what is that weird `DepT Env IO` doing there in\nthe signature? \n\nWell, that's
  the whole reason this library exists. For dependency injection to\nwork for *all*
  functions, `Env` needs to be parameterized with a monad that\nprovides that same
  `Env` environment. And trying to use a `ReaderT (Env\nsomething) IO` to parameterize
  `Env` won't fly; you'll get weird \"infinite\ntype\" kind of errors. So I created
  the `DepT` newtype over `ReaderT` to mollify\nthe compiler.\n\n`DepT` has `MonadReader`
  and `LiftDep` instances, so the effects of\n`mkController` can take place on it.\n\n###
  So how do we invoke the controller now?\n\nI suggest something like\n\n    runDepT
  (do e <- ask; _controller e 7) envIO \n\nor \n\n    (do e <- ask; _controller e
  7) `runDepT` envIO \n\nThe companion package\n[dep-t-advice](http://hackage.haskell.org/package/dep-t-advice)
  has some more\nfunctions for running `DepT` computations.\n\n### How to avoid using
  \"ask\" and \"liftD\" before invoking a dependency?\n\nOne possible workaround (at
  the cost of more boilerplate) is to define helper\nfunctions like:  \n\n    loggerD
  :: MonadDep '[HasLogger] d e m => String -> m ()\n    loggerD msg = asks logger
  >>= \\f -> liftD $ f msg\n\nWhich you can invoke like this:\n\n    usesLoggerD ::
  MonadDep [HasLogger, HasRepository] d e m => Int -> m String\n    usesLoggerD i
  = do\n      loggerD \"I'm calling the logger!\"\n      return \"foo\"\n\nThough
  perhaps this isn't worth the hassle.\n\n### How to use \"pure fakes\" during testing?\n\nThe
  [test suite](./test/tests.hs) has an example of using a `Writer` monad for\ncollecting
  the outputs of functions working as [\"test\ndoubles\"](https://martinfowler.com/bliki/TestDouble.html).\n\n###
  How to make a function \"see\" a different evironment from the one seen by its dependencies?\n\nSometimes
  we want a function in the environment to see a slightly different\nrecord from the
  record seen by the other functions, and in particular from the\nrecord seen by its
  own dependencies. \n\nFor example, the function might have a `HasLogger` constraint
  but we don't want\nit to use the default `HasLogger` instance of the environment.\n\nThe
  companion package\n[dep-t-advice](http://hackage.haskell.org/package/dep-t-advice)
  provides a\n`deceive` function that allows for this.\n\n### How to add AOP-ish \"aspects\"
  to functions in an environment?\n\nThe companion package\n[dep-t-advice](http://hackage.haskell.org/package/dep-t-advice)
  provides a\ngeneral method of extending the behaviour of `DepT`-effectful functions,
  in a\nway reminiscent of aspect-oriented programming.\n\n### What if I don't want
  to use DepT, or any other monad transformer for that matter?\n\nCheck out the function
  `fixEnv` in module `Dep.Env`, which\nprovides a transformer-less way to perform
  dependency injection, based on\nknot-tying.\n\nThat method requires an environment
  parameterized by _two_ type constructors:\none that wraps each field, and another
  that works as the effect monad for the\ncomponents.\n\n### DepT caveats\n\nThe structure
  of the `DepT` type might be prone to trigger a [known infelicity\nof the GHC\nsimplifier](https://twitter.com/DiazCarrete/status/1350116413445439493).\n\n##
  Links\n\n- This library was extracted from my answer to [this Stack Overflow\n  question](https://stackoverflow.com/a/61782258/1364288).\n\n-
  The implementation of `mapDepT` was teased out in [this other SO question](https://stackoverflow.com/questions/65710657/writing-a-zooming-function-for-a-readert-like-monad-transformer).\n\n-
  An [SO\n  answer](https://stackoverflow.com/questions/57703898/how-to-call-impure-functions-from-pure-ones/57714058#57714058)\n
  \ about records-of-functions and the \"veil of polymorphism\".\n\n- The answers
  to [this SO\n  question](https://stackoverflow.com/questions/61642492/simplifying-the-invocation-of-functions-stored-inside-an-readert-environment)\n
  \ gave me the idea for how to \"instrument\" monadic functions (although the\n  original
  motive of the question was different).\n\n- I'm unsure of the relationship between
  `DepT` and the technique described in\n  [Adventures assembling records of\n  capabilities](https://discourse.haskell.org/t/adventures-assembling-records-of-capabilities/623)\n
  \ which relies on having \"open\" and \"closed\" versions of the environment\n  record,
  and getting the latter from the former by means of knot-tying. \n\n  It seems that,
  with `DepT`, functions in the environment obtain their\n  dependencies anew every
  time they are invoked. If we change a function in the\n  environment record, all
  other functions which depend on it will be affected\n  in subsequent invocations.
  I don't think this happens with \"Adventures...\" at\n  least when changing a \"closed\",
  already assembled record.\n\n  With `DepT` a function might use `local` if it knows
  enough about the\n  environment. That doesn't seem very useful for program logic;
  if fact it\n  sounds like a recipe for confusion. But it enables [complex\n  scenarios](https://www.baeldung.com/spring-abstract-routing-data-source)
  for\n  which the dependency graph needs to change in the middle of a request.\n\n
  \ All in all, perhaps `DepT` will be overkill in a lot of cases, offering\n  unneeded
  flexibility. Perhaps using `fixEnv` from `Dep.Env` will end up being\n  simpler.\n\n
  \ Unlike in \"Adventures...\" the `fixEnv` method doesn't use an extensible\n  record
  for the environment but, to keep things simple, a suitably\n  parameterized conventional
  one.\n\n- Another exploration of dependency injection with `ReaderT`:\n  [ReaderT-OpenProduct-Environment](https://github.com/keksnicoh/ReaderT-OpenProduct-Environment).\n\n-
  [The ReaderT design pattern](https://www.fpcomplete.com/blog/2017/06/readert-design-pattern/).\n\n
  \ > Your application code will, in general, live in ReaderT Env IO. Define it as
  type App = ReaderT Env IO if you wish, or use a newtype wrapper instead of ReaderT
  directly.\n\n  > Optional: instead of directly using the App datatype, write your
  functions in terms of mtl-style typeclasses like MonadReader and MonadIO\n\n- [RIO](http://hackage.haskell.org/package/rio)
  is a featureful ReaderT-like /\n  prelude replacement library which favors monomorphic
  environments.\n\n- The [van Laarhoven Free Monad](http://r6.ca/blog/20140210T181244Z.html).\n\n
  \ > Swierstra notes that by summing together functors representing primitive I/O\n
  \ > actions and taking the free monad of that sum, we can produce values use\n  >
  multiple I/O feature sets. Values defined on a subset of features can be\n  > lifted
  into the free monad generated by the sum. The equivalent process can\n  > be performed
  with the van Laarhoven free monad by taking the product of\n  > records of the primitive
  operations. Values defined on a subset of features\n  > can be lifted by composing
  the van Laarhoven free monad with suitable\n  > projection functions that pick out
  the requisite primitive operations. \n\n  [Another post](https://www.tweag.io/blog/2019-03-20-capability-free-monad/van)
  about the van Laarhoven Free Monad. Is it related to the final encoding of Free
  monads described [here](https://blog.poisson.chat/posts/2021-10-20-initial-final-free-monad.html)?\n\n-
  [Interesting SO response](https://stackoverflow.com/a/634754/1364288) (from\n  2009)
  about the benefits of autowiring in Spring. The record-of-functions\n  approach
  in Haskell can't be said to provide true autowiring. You still need\n  to assemble
  the record manually, and field names in the record play the part\n  of Spring bean
  names. \n\n  > Right now I think the most important reason for using autowiring
  is that\n  > there's one less abstraction in your system to keep track of. The \"bean
  name\"\n  > is effectively gone. It turns out the bean name only exists because
  of xml. So\n  > a full layer of abstract indirections (where you would wire bean-name
  \"foo\"\n  > into bean \"bar\") is gone\n\n- [registry](http://hackage.haskell.org/package/registry)
  is a package that\n  implements an alternative approach to dependency injection,
  one different\n  from the `ReaderT`-based one. \n\n- [Printf(\"%s %s\", dependency,
  injection)](https://www.fredrikholmqvist.com/posts/print-dependency-injection/).
  Commented on [HN](https://news.ycombinator.com/item?id=28915630), [Lobsters](https://lobste.rs/s/4axrt6/printf_s_s_dependency_injection).\n\n-
  [Dependency Injection Principles, Practices, and\n  Patterns](https://www.goodreads.com/book/show/44416307-dependency-injection-principles-practices-and-patterns)\n
  \ This is a good book on the general princples of DI. \n\n- A [series of posts](https://twitter.com/ploeh/status/1485514524962738179)—by
  one of the authors of the DI book—about building a DI container.\n\n- [Lessons learned
  while writing a Haskell\n  application](https://gvolpe.com/blog/lessons-learned-while-writing-a-haskell-app/).\n
  \ This post recommends a \"polymorphic record of functions\" style, which fits\n
  \ the philosophy of this library.\n\n- One [big disadvantage](https://www.reddit.com/r/haskell/comments/r6foxv/opinions_on_reader_continuationbased_io/hmthsoy/)
  of the records-of-functions approach:\n\n  > representing effects as records of
  functions rather than typeclasses/fused effect invocations destroys inlining, so
  you’ll generate significantly worse Core if you use this on a hot path.\n\n- [ReaderT
  pattern is just extensible effects](https://www.reddit.com/r/haskell/comments/sjhatp/readert_pattern_is_just_extensible_effects/)\n\n"
license-name: BSD-3-Clause

homepage: ''
changelog-type: markdown
hash: ccd6ab51dd8178c09c4976fd3f991623a641b00fe139a9fd74105cb7c836bab1
test-bench-deps:
  rank2classes: '>=1.4.1 && <1.5'
  barbies: '>=2.0.2.0 && <2.1'
  sop-core: '>=0.5.0.0 && <0.6'
  base: '>=4.10.0.0 && <5'
  text: -any
  criterion: ^>=1.5
  doctest: ^>=0.18
  containers: -any
  unliftio-core: '>=0.2.0.0 && <0.3'
  mtl: ==2.2.*
  tasty-hunit: '>=0.10.0.2'
  dep-t: '>=0.5.1.0 && <0.6'
  transformers: '>=0.5.0.0 && <0.6'
  tasty: '>=1.3.1'
  microlens: ^>=0.4.12.0
  aeson: -any
  template-haskell: -any
  dep-t-advice: -any
maintainer: diaz_carrete@yahoo.com
synopsis: Giving good advice to functions in records-of-functions.
changelog: "# Revision history for dep-t-advice\r\n\r\n## 0.5.1.0 \r\n\r\n* `Control.Monad.whatever`
  renamed to `whatever`. \r\n\r\n  The old modules still remain, but deprecated.\r\n\r\n*
  Added `fromSimple_`.\r\n\r\n* Added `injectFailures` and `keepCallStack`.\r\n\r\n##
  0.5.0.0 \r\n\r\n* The Advice type has changed to get rid of the existential type.\r\n
  \ This breaks the 'makeAdvice' function.   \r\n* Added 'Control.Monad.Dep.SimpleAdvice'
  and 'Control.Monad.Dep.SimpleAdvice.Basic'.\r\n* Moved some \"basic\" advices.\r\n*
  Removed distributeDepT.\r\n* 'adviseRecord' now receives a 'NonEmpty' path-in-record,
  ordered innermost-first.\r\n* More flexible type for doLocally.\r\n\r\n## 0.4.7.0
  \r\n\r\n* Added 'distributeDepT' and 'component'.\r\n\r\n## 0.4.6.1 \r\n\r\n* Modified
  a signature to make it compile with GHC 9.0.1.\r\n\r\n## 0.4.6.0 \r\n\r\n* `adviseRecord`
  and `deceiveRecord` now work with records having fields wrapped in `Identity`.\r\n\r\n
  \ This is for better compatibility with the [barbies](http://hackage.haskell.org/package/barbies)
  package.\r\n\r\n## 0.4.5.0 \r\n\r\n* Added runFromDep.\r\n\r\n  This required bumping
  the minimum version of dep-t to 0.4.4.0.\r\n\r\n## 0.4.4.0 \r\n\r\n* Added 'adviseRecord'
  and 'deceiveRecord' that manipulate entire\r\n  records-of-functions (also work
  on newtypes) instead of a single bare\r\n  function. \r\n\r\n  Useful when the components
  to put on the environment come in their own record\r\n  types.\r\n\r\n## 0.4.0.0
  \r\n\r\n* Added 'deceive' function.\r\n\r\n* BREAKING CHANGE. The form of the 'HasX'
  constraints expected by 'Ensure' has\r\n  changed. Now they expect the effect monad
  as their first parameter. This is\r\n  in order to help with deriving.\r\n\r\n##
  0.3.0.0 \r\n\r\n* BREAKING CHANGE. Removed the dependency on \"constraints\" to
  reduce the\r\n  dependency footprint. This changes the signature of restrictArgs.\r\n\r\n##
  0.2.0.0 \r\n\r\n* BREAKING CHANGE. The Advice type is no longer parameterized by
  the `cem` and\r\n  `cr` constraints. Instead, it's directly parameterized by the
  types `e` of\r\n  the environment, `m` of the base monad and `r` of the result,
  which are left\r\n  polymorphic when needed. This simplifies a bunch of things.
  The `ca`\r\n  constraint paramter remains however.\r\n\r\n## 0.1.0.0 -- YYYY-mm-dd\r\n\r\n*
  First version. Released on an unsuspecting world.\r\n"
basic-deps:
  sop-core: ^>=0.5.0.0
  base: '>=4.10.0.0 && <5'
  unliftio-core: ^>=0.2.0.0
  mtl: ^>=2.2
  dep-t: '>=0.5.1.0 && <0.6'
  transformers: ^>=0.5.0.0
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.0.1
- 0.3.0.0
- 0.4.0.0
- 0.4.0.1
- 0.4.4.0
- 0.4.5.0
- 0.4.6.0
- 0.4.6.1
- 0.4.7.0
- 0.5.0.0
- 0.5.1.0
author: Daniel Diaz
latest: 0.5.1.0
description-type: markdown
description: "# dep-t-advice\r\n\r\nThis package is a companion to\r\n[dep-t](http://hackage.haskell.org/package/dep-t).
  It provides a mechanism for\r\nhandling cross-cutting concerns in your application
  by adding \"advices\" to the\r\nfunctions in your record-of-functions, in a way
  that is composable and\r\nindependent of each function's particular number of arguments.\r\n\r\n[![dep-t-advice.png](https://i.postimg.cc/L8Cm279S/dep-t-advice.png)](https://postimg.cc/tsxKzBnv)\r\n\r\n##
  Rationale\r\n\r\nSo, you have decided to structure your program in a record-of-functions
  style,\r\nusing [dep-t](http://hackage.haskell.org/package/dep-t). Good choice!\r\n\r\nYou
  have already selected your functions, decided which base monad use for\r\n`DepT`,
  and now you are ready to construct the environment record, which serves\r\nas your
  [composition\r\nroot](https://stackoverflow.com/questions/6277771/what-is-a-composition-root-in-the-context-of-dependency-injection).\r\n\r\nNow
  seems like a good moment to handle some of those pesky [\"croscutting\r\nconcerns\"](https://en.wikipedia.org/wiki/Cross-cutting_concern),
  don't you\r\nthink?\r\n\r\nStuff like:\r\n\r\n- Logging\r\n- Caching\r\n- Monitoring\r\n-
  Validation\r\n- Setting up transaction boundaries.\r\n- Setting up exception handlers
  for uncaught exceptions.\r\n\r\nBut how will you go about it?\r\n\r\n### A perfectly
  simple and reasonable solution\r\n\r\nImagine that you want to make this function
  print its argument to stdout:\r\n\r\n    foo :: Int -> DepT e_ IO () \r\n\r\nEasy
  enough:\r\n\r\n    foo' :: Int -> DepT e_ IO ()\r\n    foo' arg1 = do\r\n        liftIO
  $ putStrLn (show arg1)\r\n        foo arg1\r\n\r\nYou can even write your own general
  \"printArgs\" combinator:\r\n\r\n    printArgs :: Show a => (a -> DepT e_ IO ())
  -> (a -> DepT e_ IO ())\r\n    printArgs f arg1 = do\r\n        liftIO $ putStrLn
  (show arg1)\r\n        f arg1\r\n\r\nYou could wrap `foo` in `printArgs` when constructing
  the record-of-functions,\r\nor perhaps you could modify the corresponding field
  after the record had been\r\nconstructed.\r\n\r\nThis solution works, and is easy
  to understand. There's an annoyance though:\r\nyou need a different version of `printArgs`
  for each number of arguments a\r\nfunction might have.\r\n\r\nAnd if you want to
  compose different combinators (say, `printArgs` and\r\n`printResult`) before applying
  them to functions, you need a composition\r\ncombinator specific for each number
  of arguments.\r\n\r\n### The solution using \"advices\"\r\n\r\nThe `Advice` datatype
  provided by this package encapsulates a transformation on\r\n`DepT`-effectful functions,
  *in a way that is polymorphic over the number of\r\narguments*. The same advice
  will work for functions with `0`, `1` or `N`\r\narguments.\r\n\r\nAdvices can't
  change the type of a function, but they might:\r\n\r\n- Analyze and change the values
  of the function's arguments.\r\n\r\n- Add additional effects to the function, either
  effects from the base monad, or effects from handlers found in the environment.\r\n\r\n-
  Change the result value of the function.\r\n\r\n- Sidestep the execution of the
  function altogether, providing al alternative result.\r\n\r\nHere's how a `printArgs`
  advice might be defined:\r\n\r\n    printArgs :: forall e_ m r. MonadIO m => Handle
  -> String -> Advice Show e_ m r\r\n    printArgs h prefix =\r\n      makeArgsAdvice\r\n
  \       ( \\args -> do\r\n            liftIO $ hPutStr h $ prefix ++ \":\"\r\n            hctraverse_
  (Proxy @Show) (\\(I a) -> liftIO (hPutStr h (\" \" ++ show a))) args\r\n            liftIO
  $ hPutStrLn h \"\\n\"\r\n            liftIO $ hFlush h\r\n            pure args\r\n
  \       )\r\n\r\nThe advice receives the arguments of the function in the form of
  an [n-ary\r\nproduct](http://hackage.haskell.org/package/sop-core-0.5.0.1/docs/Data-SOP-NP.html#t:NP)\r\nfrom
  [sop-core](http://hackage.haskell.org/package/sop-core-0.5.0.1). But it\r\nmust
  be polymorphic on the shape of the type-level list which indexes the\r\nproduct.
  This makes the advice work for any number of parameters.\r\n\r\nThe advice would
  be applied like this:\r\n\r\n    advise (printArgs stdout \"foo args: \") foo\r\n\r\n##
  Advices should be applied at the composition root\r\n\r\nIt's worth emphasizing
  that advices should be applied at the [\"composition\r\nroot\"](https://stackoverflow.com/questions/6277771/what-is-a-composition-root-in-the-context-of-dependency-injection),\r\nthe
  place in our application in which all the disparate functions are assembled\r\nand
  we commit to a concrete monad, namely `DepT`.\r\n\r\nBefore being brought into the
  composition root, the functions need not be aware\r\nthat `DepT` exists. They might
  be working in some generic `MonadReader`\r\nenvironment, plus some constraints on
  that environment.\r\n\r\nOnce we decide to use `DepT`, we can apply the advice,
  because advice only\r\nworks on functions that end on a `DepT` action. Also, advice
  might depend on\r\nthe full gamut of functionality stored in the environment.\r\n\r\n##
  What about `Dep.SimpleAdvice`?\r\n\r\n`Advice`s form `Dep.Advice` work with the
  `DepT` monad, but\r\nthat's a bit too specialized. What if I want to use plain `IO`
  as the monad\r\nwhich parameterizes my record-of-functions?\r\n\r\n`Dep.SimpleAdvice`
  provides a version of the `Advice` type that\r\nworks with records-of-functions
  parameterized with `IO` or other concrete\r\nmonads. \r\n\r\nThis simpler `Advice`
  can be useful when performing dependency injection\r\nthrough [`fixEnv`](https://hackage.haskell.org/package/dep-t-0.5.0.0/docs/Control-Monad-Dep-Env.html#v:fixEnv).\r\n\r\nThere
  are conversion functions between the two versions of `Advice`.\r\n\r\nSee [this
  thread](https://discourse.haskell.org/t/decorate-your-records-of-functions-with-this-weird-trick/3675)
  in the Haskell Discourse for more info.\r\n\r\n## Historical aside\r\n\r\nAccording
  to Wikipedia, the term \"advice\" in the sense of aspect-oriented\r\nprogramming
  goes back to 1966. Quoting from [PILOT: A Step Toward Man-Computer\r\nSymbiosis](http://publications.csail.mit.edu/ai/browse/0200browse.shtml):\r\n\r\n>
  There are two ways a user can modify programs in this subjective model of\r\n> programming:
  he can modify the interface between procedures, or he can modify\r\n> the procedure
  itself. (Since procedures are themselves made up of procedures,\r\n> modifying a
  procedure at one level may correspond to modifying the interface\r\n> between procedures
  at a lower level.) Modifying the interface between\r\n> procedures is called advising.
  Modifying a procedure itself is editing.\r\n\r\n> Advising is the basic innovation
  in the model, and in the PILOT system.\r\n> Advising consists of inserting new procedures
  at any or all of the entry or\r\n> exit points to a particular procedure (or class
  of procedures). The\r\n> procedures inserted are called \"advice procedures\" or
  simply \"advice\".\r\n\r\n> Since each piece of advice is itself a procedure, it
  has its own entries and\r\n> exits. In particular, this means that the execution
  of advice can cause the\r\n> procedure that it modifies to be bypassed completely,
  e.g., by specifying as\r\n> an exit from the advice one of the exits from the original
  procedure; or the\r\n> advice may change essential variables and continue with the
  computation so\r\n> that the original procedure is executed, but with modified variables.\r\n>
  Finally, the advice may not alter the execution or affect the original\r\n> procedure
  at all, e.g., it may merely perform some additional computation\r\n> such as printing
  a message or recording history. Since advice can be\r\n> conditional, the decision
  as to what is to be done can depend on the results\r\n> of the computation up to
  that point.\r\n\r\n> The principal advantage of advising is that the user need not
  be concerned\r\n> about the details of the actual changes in his program, nor the
  internal\r\n> representation of advice. He can treat the procedure to be advised
  *as a\r\n> unit*, a single block, and make changes to it without concern for the\r\n>
  particulars of this block. This may be contrasted with editing in which the\r\n>
  programmer must be cognizant of the internal structure of the procedure.\r\n\r\n[tweet](https://twitter.com/DiazCarrete/status/1446783366678949891).\r\n\r\n##
  Links\r\n\r\n- [Aspect Oriented Programming with\r\n  Spring](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop)\r\n
  \ and [Spring AOP\r\n  APIs](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-api).\r\n\r\n-
  [Using the “constraints” package to make a wrapped function less\r\n  polymorphic](https://stackoverflow.com/questions/65800809/using-the-constraints-package-to-make-a-wrapped-function-less-polymorphic)\r\n\r\n-
  [variadic-function](https://hackage.haskell.org/package/variadic-function) a\r\n
  \ Hackage library which also deals with functions of any number of elements.\r\n
  \ [Reddit\r\n  thread](https://www.reddit.com/r/haskell/comments/oeyaz2/ann_typeablemock_mocks_that_can_fit_into_any/).\r\n\r\n-
  [Inferring the arity of zipWith, with lots of type-level hackery](https://www.youtube.com/watch?v=iGSKqcebhfs&t=957s).
  YouTube video.\r\n\r\n- [Functional Pearl: The Decorator Pattern in Haskell](https://twitter.com/DiazCarrete/status/1403985337513394178)\r\n\r\n
  \ > An arity-generic decorator needs to solve two problems: intercept recursive
  calls and handle functions of any arity uniformly\r\n\r\n"
license-name: BSD-3-Clause

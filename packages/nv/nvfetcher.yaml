homepage: https://github.com/berberman/nvfetcher
changelog-type: markdown
hash: 7c670237102b34f4ce8b96d336ceb1142d1d1cc9d661f44dffe4a22a1619dd42
test-bench-deps: {}
maintainer: berberman <berberman.yandex.com>
synopsis: Generate nix sources expr for the latest version of packages
changelog: |
  # Revision history for nvfetcher

  ## 0.1.0.0

  * First version. Released on an unsuspecting world.
basic-deps:
  shake: '>=0.19.4 && <0.20'
  free: '>=5.1.5 && <5.2'
  bytestring: -any
  extra: '>=1.7.9 && <1.8'
  base: '>=4.8 && <5'
  unordered-containers: -any
  text: -any
  nvfetcher: -any
  validation-selective: -any
  binary: -any
  transformers: -any
  aeson: '>=1.5.6 && <1.6'
  neat-interpolation: '>=0.5.1 && <0.6'
  tomland: ^>=1.3.2
all-versions:
- 0.1.0.0
author: berberman
latest: 0.1.0.0
description-type: markdown
description: "# nvfetcher\n\n[![Hackage](https://img.shields.io/hackage/v/nvfetcher.svg?logo=haskell)](https://hackage.haskell.org/package/nvfetcher)\n[![MIT
  license](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![nix](https://github.com/berberman/nvfetcher/actions/workflows/nix.yml/badge.svg)](https://github.com/berberman/nvfetcher/actions/workflows/nix.yml)\n\nnvfetcher
  is a tool to automate packages updates in flakes repos. It's built on top of [shake](https://www.shakebuild.com/),\nintegrating
  [nvchecker](https://github.com/lilydjwg/nvchecker).\nIt's very simple -- most complicated
  works are done by nvchecker, nvfetcher just wires it with prefetch tools,\nproducing
  only one artifact as the result of build.\nnvfetcher cli program accepts a TOML
  file as config, which defines a set of package sources to run.\n\n## Overview\n\nFor
  example, given the following configuration file:\n\n```toml\n# nvfetcher.toml\n[feeluown-core]\nsrc.pypi
  = \"feeluown\"\nfetch.pypi = \"feeluown\"\n\n[qliveplayer]\nsrc.github = \"IsoaSFlus/QLivePlayer\"\nfetch.github
  = \"IsoaSFlus/QLivePlayer\"\n```\n\nrunning `nvfetcher build` will create `sources.nix`
  like:\n\n```nix\n# sources.nix\n{ fetchgit, fetchurl }:\n{\n  feeluown-core = {\n
  \   pname = \"feeluown-core\";\n    version = \"3.7.6\";\n    src = fetchurl {\n
  \     sha256 = \"1bsz149dv3j5sfbynjrqsqbkkxdxkdlq4sdx2vi8whvfwfg0j2f0\";\n      url
  = \"https://pypi.io/packages/source/f/feeluown/feeluown-3.7.6.tar.gz\";\n    };\n
  \ };\n  qliveplayer = {\n    pname = \"qliveplayer\";\n    version = \"3.22.0\";\n
  \   src = fetchgit {\n      url = \"https://github.com/IsoaSFlus/QLivePlayer\";\n
  \     rev = \"3.22.0\";\n      fetchSubmodules = false;\n      deepClone = false;\n
  \     leaveDotGit = false;\n      sha256 = \"192g42pvibms2rsjh68fck4bj59b10ay9zqcf2hqhcka0xmnyb09\";\n
  \   };\n  };\n}\n```\n\nWe tell nvfetcher how to get the latest version number of
  packages and how to fetch their sources given version numbers,\nand nvfetcher will
  help us keep their version and prefetched SHA256 sums up-to-date, stored in `sources.nix`.\nShake
  will help us handle necessary rebuilds -- we check versions of packages during each
  run, but only prefetch them when needed.\n\n## Live examples\n\nHow to use the generated
  sources file? Here are some examples:\n\n* My [flakes repo](https://github.com/berberman/flakes)\n\n*
  Nick Cao's [flakes repo](https://gitlab.com/NickCao/flakes/-/tree/master/pkgs)\n\n##
  Usage\n\nBasically, there are two ways to use nvfetcher, where the difference is
  how we provide package sources definitions to it. \nNo matter which way you use
  it in, CLI options are inherited from shake with two targets, typically used as:\n\n*
  `nvfetcher build` - our main purpose, creating `sources.nix`\n* `nvfetcher clean`
  - clean up cache and remove `sources.nix`\n\n> nvfetcher uses `build` as the target
  if no specified\n\n> You can specify `-j` to enable parallelism\n\n### CLI\n\nTo
  run nvfetcher as a CLI program, you'll need to provide package sources defined in
  TOML.\n\nAavailable CLI options:\n* `-c` (`--config`) - path to the TOML configuration
  file\n* `-o` (`--output`) - path to the output nix file\n* `-v` (`--version`) -
  print nvfetcher version\n* `-l` (`--log`) - path to log file, where nvfetcher dumps
  the version changes \n\nEach *package* corresponds to a TOML table, whose name is
  encoded as table key;\nthere are two pairs in each table:\n* a nvchecker configuration,
  how to track version updates\n  * `src.github = owner/repo` - the latest gituhb
  release\n  * `src.pypi = pypi_name` - the latest pypi release\n  * `src.git = git_url`
  - the latest commit of a repo\n  * `src.archpkg = archlinux_pkg_name` -- the latest
  version of an archlinux package\n  * `src.aur = aur_pkg_name` -- the latest version
  of an aur package\n  * `src.manual = v` -- a fixed version, which never updates\n
  \ * `src.repology = project:repo` -- the latest version from repology\n* a nix fetcher
  function, how to fetch the package given the version number. `$ver` is available,
  which will be set to the result of nvchecker.\n  * `fetch.github = owner/repo` or
  `owner/repo:rev` (default to `$ver` if no `rev` specified)\n  * `fetch.pypi = pypi_name`
  or `pypi_name:ver` (default to `$ver` if no `ver` specified)\n  * `fetch.git = git_url`
  or `git_url:rev` (default to `$ver` if no `rev` specified)\n  * `fetch.url = url`\n\nYou
  can find an example of the configuration file, see [`nvfetcher_example.toml`](nvfetcher_example.toml).\n\n###
  Haskell library\n\nnvfetcher itsetlf is a Haskell library as well, whereas the CLI
  program is just a trivial wrapper of the library. You can create a Haskell program
  depending on it directly, creating an entry point. In this case, we can define packages
  in Haskell language, getting rid of TOML constraints.\n\nYou can find an example
  of using nvfetcher in the library way, see [`Main_example.hs`](Main_example.hs).\n\n##
  Documentation\n\nFor details of the library, documentation of released versions
  is available on [Hackage](https://hackage.haskell.org/package/nvfetcher),\nand of
  master is on our [github pages](https://nvfetcher.berberman.space).\n\n## Limitations\n\nThere
  is no way to check the equality over version sources and fetchers, so If you change
  either of them in a package,\nyou will need to rebuild everything, i.e. run `nvfetcher
  clean` to remove shake databsae, to make sure that\nour build system works correctly.
  We could automate this process, for example,\ncalculate the hash of the configuration
  file and bump `shakeVersion` to trigger the rebuild.\nHowever, this shouldn't happen
  frequently and we want to minimize the changes, so it's left for you to do manually.\n\n>
  Adding or removing a package doesn't require such rebuild\n\n## Contributing\n\nIssues
  and PRs are always welcome. **\\_(:з」∠)\\_**\n"
license-name: MIT

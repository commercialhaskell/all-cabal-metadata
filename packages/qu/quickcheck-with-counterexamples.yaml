homepage: http://www.github.com/nick8325/quickcheck-with-counterexamples
changelog-type: ''
hash: 14173d181172e6df51b617404945121fcf8c94ead238056efd9322648c4cff21
test-bench-deps: {}
maintainer: nick@smallbone.se
synopsis: Get counterexamples from QuickCheck as Haskell values
changelog: ''
basic-deps:
  base: ! '>=4 && <5'
  QuickCheck: ! '>=2.12'
  template-haskell: -any
all-versions:
- '1.0'
- '1.1'
author: Nick Smallbone
latest: '1.1'
description-type: text
description: ! "When QuickCheck finds a counterexample, it prints it out but\ndoesn't
  save it so that the programmer can access it. This can be\nannoying when debugging.\n\nThis
  library provides a small extension to QuickCheck that returns\ncounterexamples as
  normal Haskell values. To use it, just import\nTest.QuickCheck.Counterexamples instead
  of Test.QuickCheck.\nThe library is largely compatible with normal QuickCheck, but
  the\nreturn types of quickCheck and related functions are changed to\ninclude a
  counterexample.\n\nHere is an example of getting counterexamples.\nSuppose we have
  the following property:\n\nprop_reverse_append :: [Int] -> [Int] -> Property\nprop_reverse_append
  xs ys =\n  reverse (xs++ys) === reverse xs ++ reverse ys\n\nIf we look at the type
  of quickCheck, we see that it will return a\ncounterexample:\n\n> :t quickCheck
  prop_reverse_append\nquickCheck prop_reverse_append :: IO (Maybe ([Int] :&: [Int]
  :&: ()))\n\nThe Maybe is there because we get Nothing if the property succeeds;\n\":&:\"
  is a datatype of pairs.\n\nIf we run QuickCheck, we can get the counterexample as
  a normal\nHaskell value:\n\n> Just (xs :&: ys :&: ()) <- quickCheck prop_reverse_append\n***
  Failed! Falsifiable (after 5 tests and 4 shrinks):    \n[0]\n[1]\n[1,0] /= [0,1]\n\n>
  :t xs\nxs :: [Int]\n\n> xs\n[0]\n\n> ys\n[1]\n"
license-name: BSD3

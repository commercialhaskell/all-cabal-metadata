all-versions:
- 2.3.1
author: Andy Gill
basic-deps:
  base: '>=4.12 && <5'
  transformers: '>=0.5.6 && <0.7'
changelog: |
  2.3.1 -- 2022-09-10
  -----
  * Add `modifyError` to `Control.Monad.Error.Class`, and re-export from
    `Control.Monad.Except`.
  * Make the `MonadCont` instance for `ContT` more polykinded; now, `r` is allowed
    to be of an arbitrary kind `k`, rather than only `Type`.
  * Add a generic `liftCallCC` for use with any `MonadTrans`.
  * Add `modifyError` to `Control.Monad.Error.Class`
  * Return re-export of `ExceptT` and related functions to `Control.Monad.Except`.
  * Add `label` function to `MonadCont`

  2.3 -- 2022-05-07
  ---
  * Add instances for `Control.Monad.Trans.Writer.CPS` and
    `Control.Monad.Trans.RWS.CPS` from `transformers` 0.5.6 and add
    `Control.Monad.Writer.CPS` and `Control.Monad.RWS.CPS`.
  * `Control.Monad.Cont` now re-exports `evalCont` and `evalContT`.
  * Add `tryError`, `withError`, `handleError`, and `mapError` to
    `Control.Monad.Error.Class`, and re-export from `Control.Monad.Except`.
  * Remove `Control.Monad.List` and `Control.Monad.Error`.
  * Remove instances of deprecated `ListT` and `ErrorT`.
  * Remove re-exports of `Error`.
  * Add instances for `Control.Monad.Trans.Accum` and
    `Control.Monad.Trans.Select`.
  * Require GHC 8.6 or higher, and `cabal-install` 3.0 or higher.
  * Require `transformers-0.5.6` or higher.
  * Add `Control.Monad.Accum` for the `MonadAccum` type class, as well as the
    `LiftingAccum` deriving helper.
  * Add `Control.Monad.Select` for the `MonadSelect` type class, as well as the
    `LiftingSelect` deriving helper.
  * Remove re-exports of `Control.Monad`, `Control.Monad.Fix` and `Data.Monoid` modules

  2.2.2 -- 2018-02-24
  -----
  * `Control.Monad.Identity` now re-exports `Control.Monad.Trans.Identity`
  * Fix a bug in which `Control.Monad.State.Class.modify'` was not as strict in
    the new state as its counterparts in `transformers`
  * Add a `MonadError () Maybe` instance
  * Add `liftEither :: MonadError e m => Either e a -> m a` to
    `Control.Monad.Except{.Class}`
  * Add a `MonadWriter w ((,) w)` instance (when built against `base-4.9` or later)

  2.2.1 -- 2014-06-02
  -------
  * Provide MINIMAL pragmas for `MonadState`, `MonadWriter`, `MonadReader`
  * Added a cyclic definition of `ask` in terms of `reader` for consistency with `get`/`put` vs. `state` and `tell` vs. `writer`
  * Fix deprecation warnings caused by `transformers` 0.4 deprecating `ErrorT`.
  * Added `Control.Monad.Except` in the style of the other `mtl` re-export modules

  2.2.0.1 -- 2014-05-05
  -------
  * Fixed a bug caused by the change in how `transformers` 0.4 exports its data types. We will now export `runFooT` for each transformer again!

  2.2 -- 2014-05-05
  ---
  * `transformers` 0.4 support
  * Added instances for `ExceptT`
  * Added `modify'` to `Control.Monad.State.*`

  2.1.3.1 -- 2014-03-24
  -------
  * Avoid importing `Control.Monad.Instances` on GHC 7.8 to build without deprecation warnings.

  2.1.3
  -----
  * Removed the now-irrelevant `Error` constraint from the `MonadError` instance for `Either e`.
changelog-type: markdown
description: "# `mtl` [![Hackage](https://img.shields.io/hackage/v/mtl.svg)](https://hackage.haskell.org/package/mtl)
  [![Build Status](https://travis-ci.org/haskell/mtl.svg)](https://travis-ci.org/haskell/mtl)\n\nThis
  package is a fork of 'mtl' with changes to make it compile with MicroHs.  \n\nMTL
  is a collection of monad classes, extending the `transformers`\npackage, using functional
  dependencies for generic lifting of monadic\nactions.\n\n## Structure\n\nTransformers
  in MTL are divided into classes and data types. Classes\ndefine the monadic operations
  of transformers. Data types, generally\nfrom the `transformers` package, implement
  transformers, and MTL\nprovides instances for all the transformer type classes.\n\nMTL
  and `transformers` use a common module, data type, and function\nnaming scheme.
  As an example, let's imagine we have a transformer\n`Foo`.\n\nIn the `Control.Monad.Foo`
  module, we'd find:\n\n* A type class `MonadFoo` with the transformer operations.\n*
  A data type `FooT` with instances for all monad transformer classes.\n* Functions
  to run the transformed computation, e.g. `runFooT`. For\n  the actual transformers,
  there are usually a number of useful runner\n  functions.\n\n### Lifting\n\nWhen
  using monad transformers, you often need to \"lift\" a monadic\naction into your
  transformed monadic action. This is done using the\n`lift` function from `MonadTrans`
  in the `Control.Monad.Trans.Class`\nmodule:\n\n``` haskell\nlift :: (Monad m, MonadTrans
  t) => m a -> t m a\n```\n\nThe action `m a` is lifted into the transformer action
  `t m a`.\n\nAs an example, here we lift an action of type `IO a` into an action
  of\ntype `ExceptT MyError IO a`:\n\n``` haskell\ndata MyError = EmptyLine\n\nmightFail
  :: ExceptT MyError IO ()\nmightFail = do\n  l <- lift getLine\n  when (null l) (throwError
  EmptyLine)\n```\n\n### Transformers\n\nThe following outlines the available monad
  classes and transformers in\nMTL and `transformers`. For more details, and the corresponding\ndocumentation
  of the `mtl` version you are using, see [the\ndocumentation on Hackage](https://hackage.haskell.org/package/mtl).\n\n*
  `Control.Monad.Cont`\n\n    The Continuation monad transformer adds the ability
  to use\n    [continuation-passing style\n    (CPS)](https://en.wikipedia.org/wiki/Continuation-passing_style)\n
  \   in a monadic computation. Continuations can be used to manipulate\n    the control
  flow of a program, e.g. early exit, error handling, or\n    suspending a computation.\n\n
  \   - Class: `Control.Monad.Cont.Class.MonadCont`\n    - Transformer: `Control.Monad.Cont.ContT`\n\n*
  `Control.Monad.Error` (deprecated!)\n\n    The Error monad transformer has been
  deprecated in favor of\n    `Control.Monad.Except`.\n\n* `Control.Monad.Except`\n\n
  \   The Except monad transformer adds the ability to fail with an\n    error in
  a monadic computation.\n\n    - Class: `Control.Monad.Except.Class.MonadError`\n
  \   - Transformer: `Control.Monad.Except.ExceptT`\n\n* `Control.Monad.Identity`\n\n
  \   The Identity monad transformer does not add any abilities to a\n    monad. It
  simply applies the bound function to its inner monad\n    without any modification.\n\n
  \   - Transformer: `Control.Monad.Trans.Identity.IdentityT` (in the `transformers`
  package)\n    - Identity functor and monad: `Data.Functor.Identity.Identity` (in
  the `base` package)\n\n* `Control.Monad.RWS`\n\n    A convenient transformer that
  combines the Reader, Writer, and\n    State monad transformers.\n\n    - Lazy transformer:
  `Control.Monad.RWS.Lazy.RWST` (which is the default, exported by `Control.Monad.RWS`)\n
  \   - Strict transformer: `Control.Monad.RWS.Strict.RWST`\n\n* `Control.Monad.Reader`\n\n
  \   The Reader monad transformer represents a computation which can\n    read values
  from an environment.\n\n    - Class: `Control.Monad.Reader.Class.MonadReader`\n
  \   - Transformer: `Control.Monad.Reader.ReaderT`\n\n* `Control.Monad.State`\n\n
  \   The State monad transformer represents a computation which can\n    read and
  write internal state values. If you only need to _read_\n    values, you might want
  to use\n    [Reader](http://hackage.haskell.org/package/mtl/docs/Control-Monad-Reader.html)\n
  \   instead.\n\n    - Class: `Control.Monad.State.Class.MonadState`\n    - Lazy
  transformer: `Control.Monad.State.Lazy.StateT` (the default, exported by `Control.Monad.State`)\n
  \   - Strict transformer: `Control.Monad.State.Strict.StateT`\n\n* `Control.Monad.Writer`\n\n
  \   The Writer monad transformer represents a computation that can\n    produce
  a stream of data in addition to the computed values. This\n    can be used to collect
  values in some data structure with a\n    `Monoid` instance. This can be used for
  things like logging and\n    accumulating values throughout a computation.\n\n    -
  Class: `Control.Monad.Writer.Class.MonadWriter`\n    - Lazy transformers: `Control.Monad.Writer.Lazy.WriterT`\n
  \   - Strict transformers: `Control.Monad.Writer.Strict.WriterT`\n\n* `Control.Monad.Accum`\n\n
  \   The `Accum` monad transformer represents a computation which\n    manages append-only
  state, or a writer that can read all\n    previous inputs. It binds a function to
  a monadic value by\n    lazily accumulating subcomputations via `(<>)`. For more
  general\n    access, use [State](https://hackage.haskell.org/package/transformers-0.6.0.4/docs/Control-Monad-Trans-State.html)
  instead.\n\n    - Class: `Control.Monad.Accum`\n    - Transformer: `Control.Monad.Trans.Accum.AccumT`\n\n*
  `Control.Monad.Select`\n\n    The `Select` monad transformer represents a computation
  which\n    can do backtracking search using a 'ranked' evaluation strategy.\n    Binding
  a function to a monad value chains together evaluation\n    strategies in the sense
  that the results of previous strategies\n    may influence subsequent rank and evaluation
  strategies in\n    subcomputations.\n\n    - Class: `Control.Monad.Select`\n    -
  Transformer: `Control.Monad.Trans.Select.SelectT`\n\n## Resources\n\n* [`mtl` on
  Hackage](http://hackage.haskell.org/package/mtl)\n* The [Monad Transformers](http://dev.stephendiehl.com/hask/#monad-transformers)\n
  \ chapter in \"What I Wish I Knew When Learning Haskell\".\n* References:\n    -
  This package is inspired by the paper _Functional Programming\n      with Overloading
  and Higher-Order Polymorphism_, by Mark P\n      Jones, in _Advanced School of Functional
  Programming_, 1995\n      (<http://web.cecs.pdx.edu/~mpj/pubs/springschool.html>).\n"
description-type: markdown
hash: 859898e87e22bc6a98dade0e832c3ad21a7b66a58daeea06314213d8850d8f4e
homepage: http://github.com/augustss/mtl-mhs
latest: 2.3.1
license-name: BSD-3-Clause
maintainer: lennart@augustsson.net
synopsis: Monad classes for transformers, using functional dependencies
test-bench-deps: {}

homepage: http://github.com/haskell/mtl
changelog-type: markdown
hash: 9850384335d39f4307bdd8010c61b61cc2adb88adcb6820f8372f4d2f4905a3d
test-bench-deps: {}
maintainer: "chessai <chessai1996@gmail.com>, \nEmily Pillmore <emilypi@cohomolo.gy>,
  \nKoz Ross <koz.ross@retro-freedom.nz>"
synopsis: Monad classes for transformers, using functional dependencies
changelog: "2.3 -- 2022-05-07\n---\n* Add instances for `Control.Monad.Trans.Writer.CPS`
  and \n  `Control.Monad.Trans.RWS.CPS` from `transformers` 0.5.6 and add \n  `Control.Monad.Writer.CPS`
  and `Control.Monad.RWS.CPS`.\n* `Control.Monad.Cont` now re-exports `evalCont` and
  `evalContT`.\n* Add `tryError`, `withError`, `handleError`, and `mapError` to\n
  \ `Control.Monad.Error.Class`, and re-export from `Control.Monad.Except`.\n* Remove
  `Control.Monad.List` and `Control.Monad.Error`.\n* Remove instances of deprecated
  `ListT` and `ErrorT`.\n* Remove re-exports of `Error`.\n* Add instances for `Control.Monad.Trans.Accum`
  and \n  `Control.Monad.Trans.Select`.\n* Require GHC 8.6 or higher, and `cabal-install`
  3.0 or higher.\n* Require `transformers-0.5.6` or higher.\n* Add `Control.Monad.Accum`
  for the `MonadAccum` type class, as well as the\n  `LiftingAccum` deriving helper.\n*
  Add `Control.Monad.Select` for the `MonadSelect` type class, as well as the\n  `LiftingSelect`
  deriving helper.\n\n2.2.2\n-----\n* `Control.Monad.Identity` now re-exports `Control.Monad.Trans.Identity`\n*
  Fix a bug in which `Control.Monad.State.Class.modify'` was not as strict in\n  the
  new state as its counterparts in `transformers`\n* Add a `MonadError () Maybe` instance\n*
  Add `liftEither :: MonadError e m => Either e a -> m a` to\n  `Control.Monad.Except{.Class}`\n*
  Add a `MonadWriter w ((,) w)` instance (when built against `base-4.9` or later)\n\n2.2.1\n-------\n*
  Provide MINIMAL pragmas for `MonadState`, `MonadWriter`, `MonadReader`\n* Added
  a cyclic definition of `ask` in terms of `reader` for consistency with `get`/`put`
  vs. `state` and `tell` vs. `writer`\n* Fix deprecation warnings caused by `transformers`
  0.4 deprecating `ErrorT`.\n* Added `Control.Monad.Except` in the style of the other
  `mtl` re-export modules\n\n2.2.0.1\n-------\n* Fixed a bug caused by the change
  in how `transformers` 0.4 exports its data types. We will now export `runFooT` for
  each transformer again!\n\n2.2\n---\n* `transformers` 0.4 support\n* Added instances
  for `ExceptT`\n* Added `modify'` to `Control.Monad.State.*`\n\n2.1.3.1\n-------\n*
  Avoid importing `Control.Monad.Instances` on GHC 7.8 to build without deprecation
  warnings.\n\n2.1.3\n-----\n* Removed the now-irrelevant `Error` constraint from
  the `MonadError` instance for `Either e`.\n"
basic-deps:
  base: '>=4.12 && <5'
  transformers: '>=0.5.6 && <0.7'
all-versions:
- '1.0'
- 1.1.0.0
- 1.1.0.1
- 1.1.0.2
- 1.1.1.0
- 1.1.1.1
- 2.0.0.0
- 2.0.1.0
- 2.0.1.1
- 2.1.1
- 2.1.2
- 2.1.3.1
- '2.2'
- 2.2.0.1
- 2.2.1
- 2.2.2
- '2.3'
author: Andy Gill
latest: '2.3'
description-type: markdown
description: |
  # `mtl` [![Hackage](https://img.shields.io/hackage/v/mtl.svg)](https://hackage.haskell.org/package/mtl) [![Build Status](https://travis-ci.org/haskell/mtl.svg)](https://travis-ci.org/haskell/mtl)

  MTL is a collection of monad classes, extending the `transformers`
  package, using functional dependencies for generic lifting of monadic
  actions.

  ## Structure

  Transformers in MTL are divided into classes and data types. Classes
  define the monadic operations of transformers. Data types, generally
  from the `transformers` package, implement transformers, and MTL
  provides instances for all the transformer type classes.

  MTL and `transformers` use a common module, data type, and function
  naming scheme. As an example, let's imagine we have a transformer
  `Foo`.

  In the `Control.Monad.Foo` module, we'd find:

  * A type class `MonadFoo` with the transformer operations.
  * A data type `FooT` with instances for all monad transformer classes.
  * Functions to run the transformed computation, e.g. `runFooT`. For
    the actual transformers, there are usually a number of useful runner
    functions.

  ### Lifting

  When using monad transformers, you often need to "lift" a monadic
  action into your transformed monadic action. This is done using the
  `lift` function from `MonadTrans` in the `Control.Monad.Trans.Class`
  module:

  ``` haskell
  lift :: (Monad m, MonadTrans t) => m a -> t m a
  ```

  The action `m a` is lifted into the transformer action `t m a`.

  As an example, here we lift an action of type `IO a` into an action of
  type `ExceptT MyError IO a`:

  ``` haskell
  data MyError = EmptyLine

  mightFail :: ExceptT MyError IO ()
  mightFail = do
    l <- lift getLine
    when (null l) (throwError EmptyLine)
  ```

  ### Transformers

  The following outlines the available monad classes and transformers in
  MTL and `transformers`. For more details, and the corresponding
  documentation of the `mtl` version you are using, see [the
  documentation on Hackage](https://hackage.haskell.org/package/mtl).

  * `Control.Monad.Cont`

      The Continuation monad transformer adds the ability to use
      [continuation-passing style
      (CPS)](https://en.wikipedia.org/wiki/Continuation-passing_style)
      in a monadic computation. Continuations can be used to manipulate
      the control flow of a program, e.g. early exit, error handling, or
      suspending a computation.

      - Class: `Control.Monad.Cont.Class.MonadCont`
      - Transformer: `Control.Monad.Cont.ContT`

  * `Control.Monad.Error` (deprecated!)

      The Error monad transformer has been deprecated in favor of
      `Control.Monad.Except`.

  * `Control.Monad.Except`

      The Except monad transformer adds the ability to fail with an
      error in a monadic computation.

      - Class: `Control.Monad.Except.Class.MonadError`
      - Transformer: `Control.Monad.Except.ExceptT`

  * `Control.Monad.Identity`

      The Identity monad transformer does not add any abilities to a
      monad. It simply applies the bound function to its inner monad
      without any modification.

      - Transformer: `Control.Monad.Trans.Identity.IdentityT` (in the `transformers` package)
      - Identity functor and monad: `Data.Functor.Identity.Identity` (in the `base` package)

  * `Control.Monad.List`

      This transformer combines the list monad with another monad. _Note
      that this does not yield a monad unless the inner monad is
      [commutative](https://en.wikipedia.org/wiki/Commutative_property)._

      - Transformer: `Control.Monad.List.ListT`

  * `Control.Monad.RWS`

      A convenient transformer that combines the Reader, Writer, and
      State monad transformers.

      - Lazy transformer: `Control.Monad.RWS.Lazy.RWST` (which is the default, exported by `Control.Monad.RWS`)
      - Strict transformer: `Control.Monad.RWS.Strict.RWST`

  * `Control.Monad.Reader`

      The Reader monad transformer represents a computation which can
      read values from an environment.

      - Class: `Control.Monad.Reader.Class.MonadReader`
      - Transformer: `Control.Monad.Reader.ReaderT`

  * `Control.Monad.State`

      The State monad transformer represents a computation which can
      read and write internal state values. If you only need to _read_
      values, you might want to use
      [Reader](http://hackage.haskell.org/package/mtl/docs/Control-Monad-Reader.html)
      instead.

      - Class: `Control.Monad.State.Class.MonadState`
      - Lazy transformer: `Control.Monad.State.Lazy.StateT` (the default, exported by `Control.Monad.State`)
      - Strict transformer: `Control.Monad.State.Strict.StateT`

  * `Control.Monad.Writer`

      The Writer monad transformer represents a computation that can
      produce a stream of data in addition to the computed values. This
      can be used to collect values in some data structure with a
      `Monoid` instance. This can be used for things like logging and
      accumulating values throughout a computation.

      - Class: `Control.Monad.Writer.Class.MonadWriter`
      - Lazy transformers: `Control.Monad.Writer.Lazy.WriterT`
      - Strict transformers: `Control.Monad.Writer.Strict.WriterT`

  ## Resources

  * [`mtl` on Hackage](http://hackage.haskell.org/package/mtl)
  * The [Monad Transformers](http://dev.stephendiehl.com/hask/#monad-transformers)
    chapter in "What I Wish I Knew When Learning Haskell".
  * References:
      - This package is inspired by the paper _Functional Programming
        with Overloading and Higher-Order Polymorphism_, by Mark P
        Jones, in _Advanced School of Functional Programming_, 1995
        (<http://web.cecs.pdx.edu/~mpj/pubs/springschool.html>).
license-name: BSD-3-Clause

all-versions:
- 0.0.1.0
- 0.0.1.1
author: phoityne.hs@gmail.com
basic-deps:
  base: ^>=4.21.0.0
  optparse-applicative: '>=0'
  pms-application-service: '>=0'
  pms-domain-model: '>=0'
  pms-domain-service: '>=0'
  pms-infrastructure: '>=0'
  pms-ui-request: '>=0'
  pms-ui-response: '>=0'
  safe-exceptions: '>=0'
changelog: |
  # Revision history for pty-mcp-server

  ## 0.0.1.0 -- 2025-05-31

  * First version.
changelog-type: markdown
description: "# pty-mcp-server\n\n----\n## ⚠️ Caution\n\n**Do not grant unrestricted
  control to AI.**  \nUnsupervised use or misuse may lead to unintended consequences.
  \ \nAll AI systems must remain strictly under human oversight and control.  \nUse
  responsibly, with full awareness and at your own risk.  \n\n----\n\n`pty-mcp-server`
  is a Haskell implementation of the MCP (Model Context Protocol),\ndesigned to enable
  AI agents to acquire and control PTY (pseudo-terminal) connections dynamically.\n\nThrough
  MCP, AI can interact with external CLI-based tools in a structured, automated, and
  scriptable way,  \nleveraging PTY interfaces to execute tasks in real environments.\n\nAs
  an MCP server, `pty-mcp-server` operates strictly in **stdio** mode, communicating
  with MCP clients exclusively via standard input and output (stdio).\n\n---\n\n##
  User Guide (Usage and Setup)\n\n### Features\n\n`pty-mcp-server` provides the following
  built-in tools for powerful and flexible automation:\n\n#### Available Tools\n-
  **`pty-connect`**  \n  Launches any command through a PTY interface with optional
  arguments.  \n  Great for general-purpose terminal automation.\n\n- **`pty-message`**
  \ \n  Sends input to an existing PTY session (e.g., `df -k`) without needing full
  context of the current terminal state.  \n  Abstracts interaction in a programmable
  way.\n\n- **`pty-bash`**  \n  Starts an interactive Bash shell (`/bin/bash -i -l`)
  in a pseudo-terminal.  \n  Empowers AI to execute shell commands like a real user.\n\n-
  **`pty-ssh`**  \n  Opens a remote SSH session via PTY, enabling access to remote
  systems.  \n  Accepts user/host and SSH flags as arguments.\n\n- **`pty-cabal`**
  \ \n  Launches a cabal repl session within a specified project directory, loading
  a target Haskell file.  \n  Supports argument passing and live code interaction.\n\n-
  **`pty-stack`**  \n  Launches a stack repl session within a specified project directory,
  loading a target Haskell file.  \n  Supports argument passing and live code interaction.\n\n-
  **`pty-ghci`**  \n  Launches a GHCi session within a specified project directory,
  loading a target Haskell file.  \n  Supports argument passing and live code interaction.\n\n-
  **`Scriptable CLI Integration`**  \n  The `pty-mcp-server` supports execution of
  shell scripts associated with registered tools defined in `tools-list.json`. Each
  tool must be registered by name, and a corresponding shell script (`.sh`) should
  exist in the configured `scripts/` directory.\n\n  This design supports AI-driven
  workflows by exposing tool interfaces through a predictable scripting mechanism.
  The AI can issue tool invocations by name, and the server transparently manages
  execution and interaction.  \n  To add a new tool:\n    1. Create a shell script
  named `your-tool.sh` in the `scripts/` directory.\n    2. Add an entry in `tools-list.json`
  with the name `\"your-tool\"` and appropriate metadata.\n    3. No need to recompile
  or modify the server — tools are dynamically resolved by name.\n\n  This separation
  of tool definitions (`tools-list.json`) and implementation (`scripts/your-tool.sh`)
  ensures clean decoupling and simplifies extensibility.\n\n\n### Example Use Cases\n\n-
  Performing interactive REPL operations (e.g., using GHCi or other CLI-based REPLs)\n-
  Interactive debugging of Haskell applications\n- System diagnostics through bash
  scripting\n- Remote server management via SSH\n- Dynamic execution of CLI tools
  in PTY environments\n\n### Requirements\n\n- GHC >= 9.12\n- Linux environment (PTY
  support required)\n- On Windows, use within a WSL (Windows Subsystem for Linux)
  environment\n\n### Dependencies\n\nThis package depends on the following packages:
  \ \n- [`pms-ui-request`](https://github.com/phoityne/pms-ui-request)\n- [`pms-ui-response`](https://github.com/phoityne/pms-ui-response)\n-
  [`pms-infrastructure`](https://github.com/phoityne/pms-infrastructure)\n- [`pms-application-service`](https://github.com/phoityne/pms-application-service)\n-
  [`pms-domain-service`](https://github.com/phoityne/pms-domain-service)\n- [`pms-domain-model`](https://github.com/phoityne/pms-domain-model)\n\n###
  How to Run\n\nThe `pty-mcp-server` application is executed from the command line.\n\n####
  Usage\n\n```sh\n$ pty-mcp-server -y config.yaml\n```\nWhile the server can be launched
  directly from the command line, it is typically started and managed by development
  tools that integrate an MCP client—such as Visual Studio Code. These tools utilize
  the server to enable interactive and automated command execution via PTY sessions.\n\n####
  VSCode Integration: `.vscode/mcp.json`\n\nTo streamline development and server invocation
  from within Visual Studio Code, the project supports a `.vscode/mcp.json` configuration
  file.\n\nThis file defines how the `pty-mcp-server` should be launched in a development
  environment. Example configuration:\n\n```json\n{\n  \"servers\": {\n    \"pty-mcp-server\":
  {\n      \"type\": \"stdio\",\n      \"command\": \"pty-mcp-server\",\n      \"args\":
  [\"-y\", \"/path/to/your/config.yaml\"]\n    }\n  }\n}\n```\n\n### config.yaml Configuration
  ([ref](https://github.com/phoityne/pty-mcp-server/blob/main/configs/pty-mcp-server.yaml))\n-
  `logDir`:  \n  The directory path where log files will be saved. This includes standard
  output/error logs and logs from script executions.\n\n- `logLevel`:  \n  Sets the
  logging level. Examples include `\"Debug\"`, `\"Info\"`, and `\"Error\"`.\n\n- `scriptsDir`:
  \ \n  Directory containing script files (shell scripts named after tool names, e.g.,
  `ping.sh`). If a script matching the tool name exists here, it will be executed
  when the tool is called.  \n  This directory must also contain the `tools-list.json`
  file, which defines the available public tools and their metadata.\n\n- `prompts`:
  \ \n  A list of prompt strings used to detect interactive command prompts. This
  allows the AI to identify when a command is awaiting input. Examples include `\"ghci>\"`,
  `\"]$\"`, `\"password:\"`, etc.\n\n### Installation\n\nYou can install `pty-mcp-server`
  using `cabal`:\n\n```bash\ncabal install pty-mcp-server\n```\n\n### Running with
  Podman or Docker\n\nYou can build and run `pty-mcp-server` using either **Podman**
  or **Docker**.\n\n**Note:** When running pty-mcp-server inside a Docker container,
  after establishing a pty connection, you will be operating within the container
  environment. This should be taken into account when interacting with the server.\n\n####
  1. Build the image\n\nClone the repository and navigate to the `docker` directory:\n\n```bash\n$
  git clone https://github.com/phoityne/pty-mcp-server.git\n$ cd pty-mcp-server/docker\n$
  podman build . -t pty-mcp-server-image\n$\n```\nRef : [build.sh](https://github.com/phoityne/pty-mcp-server/blob/main/docker/build.sh)\n\n####
  2. Run the container\nRun the server inside a container:\n\n```bash\n$ podman run
  --rm -i \\\n--name pty-mcp-server-container \\\n-v /path/to/dir:/path/to/dir \\\n--hostname
  pms-docker-container \\\npty-mcp-server-image \\\n-y /path/to/dir/config.yaml\n$\n```\nRef
  : [run.sh](https://github.com/phoityne/pty-mcp-server/blob/main/docker/run.sh)\n\nBelow
  is an example of how to configure `mcp.json` to run the MCP server within VSCode:\n```json\n{\n
  \ \"servers\": {\n    \"pty-mcp-server\": {\n      \"type\": \"stdio\",\n      \"command\":
  \"/path/to/run.sh\",\n      \"args\": []\n      /*\n      \"command\": \"podman\",\n
  \     \"args\": [\n        \"run\", \"--rm\", \"-i\",\n        \"--name\", \"pty-mcp-server-container\",\n
  \       \"-v\", \"/path/to/dir:/path/to/dir\",\n        \"--hostname\", \"pms-docker-container\",\n
  \       \"pty-mcp-server-image\",\n        \"-y\", \"/path/to/dir/config.yaml\"\n
  \     ]\n      */\n    }\n  }\n}\n```\n\n---\n\n## Architecture Guide (Software
  Architecture and Technical Details)\n\n### Architectural Strategy\n\nThe architecture
  of the `pty-mcp-server` project is designed with medium-to-large scale systems in
  mind. Emphasis is placed on **modularity**, **maintainability**, and **scalability**,
  especially in environments involving multiple teams or organizations.\n\nTo achieve
  these goals, the system is structured as a collection of well-separated packages,
  each responsible for a specific concern or domain. This package-oriented design
  provides several strategic benefits.\n\nThe overall package structure adheres to
  the principles of **Onion Architecture**, reflecting a layered design that places
  the domain model at the core. Furthermore, the **internal module structure within
  each package** is also guided by a layered approach, maintaining clear separation
  between pure data definitions, domain services, and infrastructure concerns.\n\n---\n\n###
  Role of `pty-mcp-server` as a Dependency Injector\n\nIn addition to managing REPL
  communication, `pty-mcp-server` is **not merely an executable module**, but also
  acts as a **dependency injector** for the entire system.\n\n- It is capable of **referencing
  all relevant PMS packages**, including those that it depends on.\n- This allows
  it to **construct and wire together application components** across multiple packages
  and modules in a unified manner.\n- By centralizing this dependency resolution,
  `pty-mcp-server` provides a single point of control over **cross-cutting dependencies**,
  improving visibility and control over the system architecture.\n\nAs a result, inter-package
  and inter-module dependencies can be **centrally coordinated and managed**, which
  promotes better encapsulation, reusability, and testability throughout the system.\n\n---\n\n###
  Rationale for Package Separation\n\n- **Clear Interface Definition**  \n  Each package
  exposes only its minimal, well-defined public API. This enforces clean module boundaries
  and reduces unintended dependencies between components.\n\n- **Team and Vendor Ownership**
  \ \n  In larger projects, different teams or external vendors can own specific packages.
  Clear separation ensures well-defined responsibilities and supports collaborative
  development across organizational boundaries.\n\n- **Repository and Release Independence**
  \ \n  Packages can be split into separate repositories and versioned independently.
  This allows for modular development and flexible release workflows, reducing build
  times and simplifying integration.\n\n- **Improved Maintainability and Extensibility**
  \ \n  By isolating concerns, the impact of code changes is limited to relevant modules.
  This minimizes regressions and facilitates safe, incremental improvements over time.\n\n---\n\n###
  Intended Use Cases\n\n- Medium-to-large scale enterprise systems involving multiple
  developers or teams  \n- Modular systems with independent development and release
  cycles for components  \n- Projects that require long-term maintainability, extensibility,
  and isolation of concerns\n\n---\n\nThis architecture follows a layered and modular
  approach. Domain models, domain services, application logic, and infrastructure
  concerns are each encapsulated in their own package, enabling clean composition
  while preserving separation of responsibilities.\n\n\n### Deployment Diagram\n![Deployment
  Diagram](https://raw.githubusercontent.com/phoityne/pty-mcp-server/main/docs/01-1.png)\n\n###
  Package Structure\n![Package Structure](https://raw.githubusercontent.com/phoityne/pty-mcp-server/main/docs/01-2.png)\n\n###
  Demo haskell cabal repl\n![Demo haskell cabal repl](https://raw.githubusercontent.com/phoityne/pty-mcp-server/main/docs/demo_cabal.gif)\nref
  : [prompt](https://github.com/phoityne/pty-mcp-server/blob/main/assets/prompts/haskell-cabal-debug-prompt.md)\n\n###
  Demo bash\n![Demo bash](https://raw.githubusercontent.com/phoityne/pty-mcp-server/main/docs/demo_bash.gif)\n\n###
  Demo shellscript\n![Demo shellscript](https://raw.githubusercontent.com/phoityne/pty-mcp-server/main/docs/demo_script.gif)\n\n###
  Demo Docker\n![Demo Docker](https://raw.githubusercontent.com/phoityne/pty-mcp-server/main/docs/demo_docker.gif)\n\n"
description-type: markdown
hash: 41f67cf91d9a76915e8f2b943670fedf8e85fcc5dd5cd933073bf30b9c780442
homepage: https://github.com/phoityne/pty-mcp-server
latest: 0.0.1.1
license-name: Apache-2.0
maintainer: phoityne.hs@gmail.com
synopsis: pty-mcp-server
test-bench-deps: {}

homepage: https://github.com/mizunashi-mana/ptera
changelog-type: markdown
hash: 04285e3a03d42d11b2cad0f99933a7666307139b1f99ca64b448444328185a59
test-bench-deps:
  ptera-core: '>=0.1.0 && <0.2'
  membership: '>=0.0.1 && <0.1'
  base: '>=4.14.0 && <5'
  unordered-containers: '>=0.2.0 && <0.3'
  hspec: -any
  doctest: -any
  array: '>=0.5.4 && <0.6'
  containers: '>=0.6.0 && <0.7'
  enummapset-th: '>=0.6.0 && <0.7'
  ghc-prim: '>=0.6.1 && <0.7'
  ptera: '>=0.1.0 && <0.2'
  ptera-th: -any
  QuickCheck: -any
  template-haskell: '>=2.16.0 && <2.17'
maintainer: mizunashi-mana@noreply.git
synopsis: A parser generator
changelog: ''
basic-deps:
  ptera-core: '>=0.1.0 && <0.2'
  membership: '>=0.0.1 && <0.1'
  base: '>=4.14.0 && <5'
  unordered-containers: '>=0.2.0 && <0.3'
  array: '>=0.5.4 && <0.6'
  containers: '>=0.6.0 && <0.7'
  enummapset-th: '>=0.6.0 && <0.7'
  ghc-prim: '>=0.6.1 && <0.7'
  ptera: '>=0.1.0 && <0.2'
  template-haskell: '>=2.16.0 && <2.17'
all-versions:
- 0.1.0.0
author: Mizunashi Mana
latest: 0.1.0.0
description-type: markdown
description: |
  # Ptera: A Generator for Parsers

  [![Hackage](https://img.shields.io/hackage/v/ptera.svg)](https://hackage.haskell.org/package/ptera)

  ## Installation

  Add dependencies on `package.cabal`:

  ```
  build-depends:
      base,
      bytestring,
      ptera,          -- main
      ptera-th,       -- for outputing parser with Template Haskell
      charset,
      template-haskell,
  ```

  ## Usage

  Write parser rules:

  ```haskell
  data Terminal
      = Digit
      | SymPlus
      | SymMulti
      deriving (Eq, Show, Enum)

  data NonTerminal
      | Expr
      | Sum
      | Product
      | Value
      deriving (Eq, Show, Enum)

  type ParseRule = Rule Terminal NonTerminal


  data Ast
      = GenValue
      | GenSum (NonEmpty Ast)
      | GenProduct Ast Ast

  rExpr :: ParseRule Ast
  rExpr = rule Expr rSum

  rSum :: ParseRule Ast
  rSum = rule Sum do
      (rProduct <,> manyP do token SymPlus *> rProduct) <&> \(e, es) -> GenSum do e :| es

  rProduct :: ParseRule Ast
  rProduct = rule Product do
      orP
          [
              (rValue <* token SymMulti <,> rProduct) <&> \(e1, e2) -> GenProduct e1 e2,
              rValue
          ]

  rValue :: ParseRule Ast
  rValue = rule Value do token Digit *> pure GenValue
  ```

  ## Examples

  * Small language: https://github.com/mizunashi-mana/ptera/tree/master/example/small-lang
  * Haskell2010: https://github.com/mizunashi-mana/ptera/tree/master/example/haskell2010
license-name: (Apache-2.0 OR MPL-2.0)

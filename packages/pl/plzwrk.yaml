homepage: https://github.com/meeshkan/plzwrk#readme
changelog-type: markdown
hash: 3857ffe5ddf56a56a3c12551132310e8a02f46f9ea406a7d4ae44ffbd7d0bc9d
test-bench-deps:
  base: '>=4.7 && <5'
  unordered-containers: '>=0.2.10 && <0.3'
  hspec: '>=2.7.0 && <2.7.2'
  text: '>=1.2.3 && <1.3'
  mtl: '>=2.2.2 && <2.3'
  plzwrk: -any
maintainer: mike@meeshkan.com
synopsis: A front-end framework
changelog: |
  # Changelog for plzwrk

  ## 0.0.0.8

  - Fixes a bug in the HSX parser that rejected certain valid text nodes

  ## 0.0.0.7

  - Removes spurious dependencies for faster build.

  ## 0.0.0.6

  - Adds `#el` mixin for element lists.

  ## 0.0.0.5

  - Adds bounds for cabal packages
  - Explicity declares `Control.Monad.Fail` in `HSX.hs` to allow automated haddock builds.

  ## 0.0.0.4

  - Adds `hsx` and `hsx'` for `jsx`-like manipulation.

  ## 0.0.0.3

  - Adds bindings for `fetch`
  - Simplifies `Browserful` API to only contain primitives and uses utility functions to build on top of the primitives.

  ## 0.0.0.2

  - Adds server side rendering via `toHTML` and `plzwrkSSR`.
  - Adds more documentation.

  ## 0.0.0.1

  - Adds util functions for attribute creation like `wClass`, `wId` etc.

  ## 0.0.0.0

  - Initial release.
basic-deps:
  bytestring: '>=0.10.10 && <0.11'
  split: '>=0.2.3 && <0.3'
  base: '>=4.7 && <5'
  unordered-containers: '>=0.2.10 && <0.3'
  text: '>=1.2.3 && <1.3'
  parsec: '>=3.1.14 && <3.2'
  containers: '>=0.6.2 && <0.7'
  mtl: '>=2.2.2 && <2.3'
  hashable: '>=1.3.0 && <1.4'
  plzwrk: -any
  transformers: '>=0.5.6 && <0.6'
  haskell-src-meta: '>=0.8.5 && <0.9'
  aeson: '>=1.4.7 && <1.5'
  template-haskell: '>=2.14.0 && <2.16'
  neat-interpolation: '>=0.5.1 && <0.6'
all-versions:
- 0.0.0.0
- 0.0.0.1
- 0.0.0.2
- 0.0.0.3
- 0.0.0.4
- 0.0.0.5
- 0.0.0.6
- 0.0.0.7
- 0.0.0.8
author: Mike Solomon
latest: 0.0.0.8
description-type: markdown
description: "# plzwrk\r\n\r\nA Haskell front-end framework.\r\n\r\n## Hello world\r\n\r\n```haskell\r\n{-#
  LANGUAGE QuasiQuotes #-}\r\n\r\nimport Web.Framework.Plzwrk\r\nimport Web.Framework.Plzwrk.Asterius\r\n\r\nmain
  :: IO ()\r\nmain = do\r\n  browser <- asteriusBrowser\r\n  plzwrk'_ [hsx|<p>Hello
  world!</p>|] browser\r\n```\r\n\r\nSee it [live](https://plzwrk-hello-world.surge.sh).\r\n\r\n##
  Kitchen sink\r\n\r\nCheck out the code [here](./kitchen-sink/Main.hs).\r\n\r\nSee
  it [live](https://plzwrk-kitchen-sink.surge.sh).\r\n\r\n## Installation\r\n\r\nAdd
  `plzwrk` to the `build-depends` stanza of your `.cabal` file.\r\n\r\nAlso, add `plzwrk-X.Y.Z.?`
  to the `extra-deps` list of your `stack.yaml` file if you're using stack.\r\n\r\n##
  Making a webpage\r\n\r\n`plzwrk` uses [Asterius](https://github.com/tweag/asterius)
  as its backend for web development. Compiling an application using `plzwrk` is no
  different than compiling an application using `ahc-cabal` and `ahc-dist` as described
  in the [Asterius documentation](https://asterius.netlify.app) with **one caveat**.
  You **must** use `--constraint \"plzwrk +plzwrk-enable-asterius\"` when running
  `ahc-cabal`.\r\n\r\nA minimal flow is shown below, mostly copied from the asterius
  documentation. It assumes that you have a cabal-buildable project in the `pwd`.
  Note the use of the `--constraint \"plzwrk +plzwrk-enable-asterius\"` flag in the
  `ahc-cabal` step.\r\n\r\n```bash\r\nusername@hostname:~/my-dir$ docker run --rm
  -it -v $(pwd):/project -w /project terrorjack/asterius\r\nasterius@hostname:/project$
  ahc-cabal v2-update\r\nasterius@hostname:/project$ ahc-cabal new-install --constraint
  \"plzwrk +plzwrk-enable-asterius\" --installdir <inst-dir> <exec-name>\r\nasterius@hostname:/project$
  cd <inst-dir> && ahc-dist --input-exe <exec-name> --browser --bundle\r\n```\r\n\r\n##
  Documentation\r\n\r\nThe main documentation for `plzwrk` is on [hackage](https://hackage.haskell.org/package/plzwrk).
  The four importable modules are:\r\n\r\n- `Web.Frameworks.Plzwrk` for the basic
  functions\r\n- `Web.Frameworks.Plzwrk.Tag` for helper functions to make takes like
  `input` or `br` if you are not using `hsx`.\r\n- `Web.Frameworks.Plzwrk.MockJSVal`
  to use a mock browser.\r\n- `Web.Frameworks.Plzwrk.Asterius` to use a bindings for
  a real browser courtesy of [Asterius](https://github.com/tweag/asterius).\r\n\r\n##
  Design\r\n\r\n`plzwrk` is inspired by [redux](https://redux.js.org/) for its state
  management. The main idea is that you have a HTML-creation function that is composed,
  via `<*>`, with getters from a state.\r\n\r\n```haskell\r\n\r\n-- State\r\ndata
  MyState = MkMyState { _name :: Text, age :: Int, _tags :: [Text] }\r\n\r\n-- Function
  hydrating a DOM with elementse from the state\r\nmakeP = (\\name age ->\r\n  [hsx'|<p>#t{concat
  [name, \" is the name and \", show age, \" is my age.\"]}#</p>|])\r\n    <$> _name\r\n
  \   <*> _age\r\n\r\n-- The same function using functional tags instead of hsx\r\nmakeP
  = (\\name age ->\r\n    p'__ concat [name, \" is the name and \", show age, \" is
  my age.\"])\r\n      <$> _name\r\n      <*> _age\r\n```\r\n\r\nHTML-creation functions
  can be nested, allowing for powerful abstractions.\r\n\r\n```haskell\r\nnested =
  div_ (take 10 $ repeat makeP)\r\n```\r\n\r\n### HSX\r\n\r\n`hsx` is not unlike `jsx`.
  The main difference is that instead of using just `{}`, `hsx` uses three different
  varieties of `#{}#`\r\n\r\n- `#e{}#` for an element\r\n- `#el{}#` for a list of
  elements\r\n- `#t{}#` for a text node or text attribute\r\n- `#c{}#` for a callback
  attribute\r\n\r\n### Hydrating with a state\r\n\r\nHTML-creation functions use an
  apostrophe after the tag name (ie `div'`) if they accept arguments from a state
  and no apostrophe (ie `div`) if they don't. The same is true of `hsx`, ie `[hsx|<br
  />|]` versus `(s -> [hsx'|<br />|])`. Additionally, HTML-creation functions for
  tags that do not have any attributes (class, style etc) are marked with a trailing
  underscore (`div_ [p__ \"hello\"]`), and tags that only accept text are marked with
  two trailing underscores (`p__ \"hello\"`).\r\n\r\n### Event handlers\r\n\r\nEvent
  handlers take two arguments - an opaque pointer to the event and the current state
  - and return a new state (which could just be the original state) in the `IO` monad.
  For example, if the state is an integer, a valid event handler could be:\r\n\r\n```\r\neh
  :: opq -> Int -> IO Int\r\neh _ i = pure $ i + 1\r\ndom = [hsx|<button click=#c{eh}#>Click
  here</button>|]\r\n```\r\n\r\nTo handle events (ie extract values from input events,
  etc) you can use one of the functions exported by `Web.Framework.Plzwrk`. Please
  see the [hackage documentation](https://hackage.haskell.org/package/plzwrk) for
  more information.\r\n\r\n> If you are using the Asterius backend, callback functions
  are still quite fragile and subject to breakage. The less third-party libraries
  you use in them, the better. For example, avoid using `Data.Text` and `aeson` if
  possible.\r\n\r\n## Server side rendering\r\n\r\nPlzwrk supports server side rendering.
  To do this, you have to compile your site twice:\r\n- once using `ahc-cabal` using
  the procedure above to create any JavaScript you need (ie event handlers), and\r\n-
  once using plain old `cabal` to create the inital HTML.\r\n\r\nWhen compiling using
  `ahc-cabal`, make sure to use the `plzwrkSSR` family of functions. These functions
  will look for pre-existing elements in the DOM and attach event listeners to them
  instead of creating elements from scratch. Additionally, if the static website needs
  to be initialized with data (ie using the result of an HTTP response made on the
  server), you'll need to pass these values dynamically to the function that calls
  `plzwrkSSR`. You can do this using the `foreign export` syntax as described in the
  [Asterius documentation](https://asterius.netlify.app/jsffi.html#jsffi-static-exports).\r\n\r\nWhen
  compiling with `cabal`, you'll likely be using it to output an HTML document or
  build a server that serves your website as `text/html`. Regardless of the approach,
  you should use `toHTML` to create the part of the initial DOM controlled by plzwrk.
  \ Also, in your HTML, make sure to include a link to the script(s) produced by `ahc-dist`
  and, if needed, make sure to call your exported functions.\r\n\r\n## Testing your
  code\r\n\r\nPlzwrk comes with a mock browser that can act as a drop-in replacement
  for your browser. Use this in your tests.\r\n\r\n```haskell\r\nimport Web.Framework.Plzwrk.MockJSVal\r\n\r\nmain
  :: IO ()\r\n    browser <- makeMockBrowser\r\n    print \"Now I'm using the mock
  browser.\"\r\n```\r\n\r\n## When to use\r\n\r\nPlzwrk may be a good fit if you enjoy
  the benefits of programming in Haskell and would like to create a web app.\r\n\r\nPlzwrk
  is experimental. It is unfit for production and the syntax will change frequently,
  often in non-backward-compatible ways. We will try to document all of these changes
  in the [changelog](ChangeLog.md).\r\n\r\nSome alternatives to `plzwrk`:\r\n\r\n-
  [Elm](https://elm-lang.org/), a delightful language for reliable web apps.\r\n-
  [Purescript react basic](https://github.com/lumihq/purescript-react-basic), an opinionated
  set of bindings to the React library, optimizing for the most basic use cases.\r\n\r\n##
  Contributing\r\n\r\nThanks for your interest in contributing! If you have a bug
  or feature request, please file an [issue](https://github.com/meeshkan/plzwrk/issues),
  or if you'd like to hack at the code base, please propose a [pull request](https://github.com/meeshkan/plzwrk/issues).\r\n"
license-name: BSD-3-Clause

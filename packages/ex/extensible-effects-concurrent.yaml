homepage: https://github.com/sheyll/extensible-effects-concurrent#readme
changelog-type: markdown
hash: f18b2029496befde5bd4170ff0d76ea3bea2cf1d5ee664257324fd4702b8390c
test-bench-deps:
  extensible-effects-concurrent: -any
  hostname: -any
  extensible-effects: -any
  stm: -any
  base: -any
  time: -any
  tasty-discover: -any
  text: -any
  monad-control: -any
  filepath: -any
  async: -any
  data-default: -any
  HUnit: -any
  containers: -any
  lens: -any
  tasty-hunit: -any
  pretty-types: ! '>=0.2.3.1 && <0.4'
  tasty: -any
  deepseq: -any
  QuickCheck: -any
maintainer: sven.heyll@gmail.com
synopsis: Message passing concurrency as extensible-effect
changelog: "# Changelog for extensible-effects-concurrent\n\n## 0.32.0\n\n- **Protocol-Server**\n
  \   - Remove effect parameter from `StartArgument` and `Init`\n    \n- **ForkIO
  Scheduler**\n    - Fix monitor reference leak\n    - Shorten the process detail
  output,\n      and return it from `getProcessState`\n\n- **Async Logging**\n    -
  Fix the Asynchronous LogWriter so it does not stop logging after a flood of log
  messages\n    \n\n## 0.31.0\n\n- **Logging**\n   - Fix runtime crash caused by logging\n
  \    See: [#2](https://github.com/sheyll/extensible-effects-concurrent/issues/2)
  \           \n    - Replace polymorphic `LogWriter` with\n      a monomorphic one
  based on `IO`\n    - Rename type aliases:\n       - `LogsTo` -> `FilteredLogging`\n
  \      - `LogIo` -> `IoLogging`\n    - Remove `Capturing` log writer\n    - Remove
  `Capturing` log writer\n    - Fix ghci log buffering issue \n       [#1](https://github.com/sheyll/extensible-effects-concurrent/issues/1)
  \n    \n## 0.30.0\n- Improve inline code documentation\n- **Supervisor:** \n    -
  Rename to **[Broker](./src/Control/Eff/Concurrent/Protocol/Broker.hs)**  \n    -
  Add the `ChildEvent` needed by the new **watchdog**  \n    - Add `callById` and
  `castById`\n- [Process](./src/Control/Eff/Concurrent/Process.hs)\n    - Introduce
  a new `Interrupt NoRecovery` clause: `ExitOtherProcessNotRunning`\n    - Change
  the second parameter of `ProcessDown` from `SomeExitReason` to `Interrupt NoRecovery`\n
  \   - Introduce new `Interrupt` reasons\n      for all categories with an existential\n
  \     parameter, that must have `NFData`, `Show`\n      and `Typeable` constraints.\n
  \   - Introduce a new timing primitive: `Delay`   \n- [StatefulServer](./src/Control/Eff/Concurrent/Protocol/StatefulServer.hs)\n
  \   - _Upgrade_ the associated **type alias** `Model`  to an associated **type**.\n
  \   - Add `mapEffects` \n    - Add `coerceEffects`        \n- Export the `TimeoutMicros`
  constructor\n- Add **[Watchdog](./src/Control/Eff/Concurrent/Protocol/Watchdog.hs)**
  a server that watches \n  a **[Broker](./src/Control/Eff/Concurrent/Protocol/Broker.hs)**
  and restarts crashed\n  processes registered at the broker.\n        \n- **[Logging](./src/Control/Eff/Log.hs)**\n
  \   - Add `logCallStack`\n    - Add `logMultiLine`      \n\n-  **[Timer](./src/Control/Eff/Concurrent/Process/Timer.hs)**\n
  \   - Allow timers to have custom titles via:\n        - `sendAfterWithTitle`\n
  \       - `startTimerWithTitle`\n    - Switch to use the new `Delay` primitive    \n
  \           \n## 0.29.2\n- Improve `Supervisor` API: Use `Init` from the effectful
  server as start\n  argument type.\n\n## 0.29.1\n- Add more constraints to `Embeds`\n-
  Improve the `CallbackServer`\n- Add `LogWriterEffects`\n- Rewrite `HandleLogWriter`
  so that the instance types have to be effects.\n  TL,DR; This allows shorter type
  signatures than before.  \n\n## 0.29.0\n- Remove the reply type parameter from `HasPdu`
  \n- Make a new constraint `Embeds` that replaces `EmbedProtocol`\n- Rename `EmbedProtocol`
  to `HasPduPrism`\n- Add `EmbeddedPduList` to `HasPdu`\n- Add embedded protocols
  example\n- Rename and change `ServesProtocol` to `HasEndpointReader`\n\n## 0.28.0\n-
  Simplify `Protocol.Observer` registration API\n- Rewrite `Protocol.Observer.Queue`
  API\n- Add the `ProcessId` to the `ProcessDown` message\n\n## 0.27.1\n- Introduce
  `HasProcesses` and `HasSafeProcesses` everywhere\n\n## 0.27.0\n- Improve/fix `EmbedProtocol`
  type class\n- Add a _this_ like parameter to the methods of `EffectfulServer`\n-
  Rename `IsPdu` to `HasPdu`\n- Remove `GenServer` from `EffectfulServer` and put
  it into a \n  new module: `Control.Eff.Concurrent.Protocol.CallbackServer`\n- Rename
  `Control.Eff.Concurrent.Protocol.Request` to `(...).Wrapper`\n\n## 0.26.1\n- Documentation
  fixes\n- `Supervisor`: Don't start a new process when a process for a child-id exists
  \n\n## 0.26.0\n- Introduce `ReplyTarget` \n- Change the `sendReply` signature to
  accept a `ReplyTarget`\n\n## 0.25.1\n- Add `castSingleton` and `callSingleton`,
  which use the `EndpointReader` and `EmbedProtocol` type class.\n- Change `toObserver`
  to accept an Endpoint of a protocol that embeds `Observer x`\n- Add `sendEmbeddedReply`\n-
  Add `toEmbeddedEndpoint` and `fromEmbeddedEndpoint`\n- Change `StatefulServer` class
  definition to not add `Processes` to the effects by default\n- Add forgotten re-exports
  to `Concurrent`\n- Fix the `NFData` instance for `Pdu (Observer o)`\n- Put the `Pdu`
  data family inside of a new type class `IsPdu`\n\n## 0.25.0\n- Improve effect type
  aliases and module structure, [read the details here](./ChangeLog-Details-0.25.0.md).\n\n##
  0.24.3\n- Add `EmbedProtocol` related function `toEmbeddedOrigin`\n\n## 0.24.2\n-
  Add more `EmbedProtocol` related functions:\n    - `embedReplySerializer`\n    -
  `embedRequestOrigin`\n- Improve documentation for `EffectfulServer`\n- Improve documentation
  for `StatefulServer`\n\n## 0.24.1\n\n- Add more `EmbedProtocol` tuple instances
  (4-tuple, 5-tuple)\n- Make `Effectful.Server` instances composable (See the `GenServerTests`
  for an example)\n  [more details in a seperate file](./ChangeLog-Details-0.24.1.md)\n-
  Add `ProcessTitle` - every process now must have a short title text for logging\n-
  Add `ProcessDetails` - every process can call `UpdateProcessDetails` to update\n
  \ its infos about the current state of it for debugging and error tracing purposes.\n-
  Add `GetProcessState` to retreive the `ProcessDetails` for some other process.\n\n##
  0.24.0\n\n- Get rid of the `PrettyTypeShow` constraint in `Tangible`\n- Get rid
  of `LogWriterEffects` and the necessity for some `UndecidableInstances` that came
  with it\n- Add `Server` module for `Api` handling via type classes\n    - Add `Stateless`\n
  \   - Add `GenServer`\n- Reimplement `Supervisor`\n\n## 0.23.0\n\n- Include the
  process id in the console and trace log renderer\n- Add a **process supervisor**
  similar to Erlang/OTPs simple_one_for_one supervisor.\n- Fix `SingleThreadedScheduler`
  process linking bug: A process shall not be interrupted\n  when a linked process
  exits normally.\n- Rename **ExitReason** to **Interrupt** and make the interrupt
  and exit handling\n  API more robust.\n\n## 0.22.1\n\n- Fix duplicated content in
  RFC-5424 log message renderer\n\n## 0.22.0\n\n- Remove `SchedulerProxy` ruins\n\n-
  Make message sending strict:\n\n  Ensure that every message sent from one process
  to another\n  is reduced to normal form by the sender.\n\n    - Remove *all* lazy
  message selectors\n    - Introduce a newtype wrapper `StrictDynamic` around `Dynamic`\n
  \     and export only a constructor that deeply evaluates the\n      value to *rnf*
  before converting it to a `Dynamic`\n\n- Change the `Server` API for better system
  *vitality*:\n\n- Add `callWithTimeout`: A `call` over `IO` with a `Timeout` parameter\n\n-
  Add more efficient log renderer:\n    - `renderLogMessageBodyNoLocation`\n    -
  `renderRFC5424NoLocation`\n\n## 0.21.2\n\n- Fix copy-paste error: Remove the `LogsTo`
  constraint from `withAsyncLogWriter`\n\n## 0.21.1\n\n- Remove dependency to the
  `socket` and `socket-unix` packages\n  - they are marked as *broken* by in NixOS\n
  \ - the code based on `network` is much shorter\n\n- Rewrite the UDP log writer
  to use `network`\n\n- Rewrite the UnixSocket log writer to use `network`\n\n## 0.21.0\n\n-
  Add more log message renderers\n\n    - Multiple extra time stamp formats\n    -
  RFC3164\n\n- Add IO log writer for unix domain sockets, e.g. `/dev/log`\n\n- Add
  IO log writer for UDP\n\n- Extract and simplify the async logger\n\n- Extract and
  simplify the file log writers\n\n## 0.20.0\n\n- Rewrite Logging API so that usage
  is not as bloated\n\n## 0.19.1\n\n- Fix Travis build\n- Fix typos\n- Fix README\n\n##
  0.19.0\n\n- Adapt to extensible-effects-concurrent 5.0.0.1\n- Update to Stackage
  LTS-13.13\n- Improve NIX expressions\n- Rewrite the logging API\n- Improve Documentation\n-
  Add Examples\n\n## 0.18.1\n\n- Fix inappropriate `LinkedProcessCrashed` interrupt
  when a process exits with `NotRecovered ProcessFinished`\n\n## 0.18.0\n\n- Split-up
  and replace `spawnLinkObservationQueue` with a simpler (but more verbose) alternative\n\n##
  0.17.0\n\n- Rename misspelled `spawnLinkObserverationQueue` to `spawnLinkObservationQueue`\n\n##
  0.16.1\n\n- Export `ObserverRegistry` constructors for custom event registration
  handling\n\n## 0.16.0\n\nAPI Stabilization and cleanup release with major API changes.\n\n-
  Replace `Control.Eff.Concurrent.Api.Server` with\n   `Control.Eff.Concurrent.Api.Server2`
  and rename\n   `Control.Eff.Concurrent.Api.Server2` to\n   `Control.Eff.Concurrent.Api.Server`\n\n-
  Rewrite `Observer` and related modules like `Observer.Queue`\n  - Remove all type
  classes\n  - Rely on `Server2`\n  - Remove `CallBackObserver`\n  - Remove the observer
  support code in `Server2`\n\n- Remove the `SchedulerProxy` parameter and tell library
  users to enable `AllowAmbiguousTypes` and `TypeApplications`\n  - Remove dependent
  support code like `HasScheduler`\n\n## 0.15.0\n\n- Add `Api` `Request` and `Reply`
  types\n- Add `RequestOrigin` which can be used in `Server2` based Api servers to
  queue and defer replies to `Call`s\n\n## 0.14.3\n\n- Export the functions introduced
  in 0.14.2 in `Control.Eff.Concurrent`.\n\n## 0.14.2\n\n- Add `Server2` functions
  to spawn and _link_\n- Add a `Server2` function to defer the reply to a `Call`s
  called:\n  `handleCallsDeferred`\n\n## 0.14.1\n\n- Add Server2 based observation
  handling with `handleObservations`\n\n## 0.14.0\n\n- Fix/Improve Server2\n\n## 0.13.2\n\n-
  Add `ProcessFinished`\n- Add `tryUninterrupted`\n- Add simpler `Server2`\n\n## 0.13.1\n\n-
  Remove misguided `MonadCatch` constraints in the `ObservationQueueReader`\n  functions,
  and use `Interrupts` instead\n\n## 0.13.0\n\n- Fix bad constraints in `Queue` observer\n\n##
  0.12.2\n\n- Fix some compiler warnings\n\n## 0.12.1\n\n- Fix build errors with GHC-8.6\n\n##
  0.12.0\n\n- Add implicit SchedulerProxy\n- Add flushMessages\n- Add receiving with
  timeout\n- Add process `Link`ing and `Monitoring`.\n- Make the distinction between
  recoverable and non-recoverable exit explicit in\n  the type parameter of `ExitReason`,
  and introduce `interruptXXXX`\n  functions in addition to `shutdownXXXX` functions,
  to throw recoverable exits.\n- Merge `ShutdownRequest` and `ExitReason`\n- Rename
  `receiveLoopSuchThat` to `receiveSelectedLoop`\n- Pass the exit reason to the callback
  passed to `receiveSelectedLoop`\n- Rename `receiveMessage` to `receiveAnyMessage`\n-
  Rename `receiveAnyLoop` to `receiveAnyLoop`\n- Pass the exit reason to the callback
  passed to `receiveAnyLoop`\n- Rename `receiveMessage` to `receiveAnyMessage`\n-
  Rename `receiveMessageAs` to `receiveMessage`\n- Rename `receiveLoop` to `receiveLoop`\n-
  Pass the exit reason to the callback passed to `receiveAnyLoop`\n- Remove `SchedulerShuttingDown`\n-
  Improve logging for exceptions in `ForkIOScheduler`\n- Fix a bug in the logging
  system that caused all log filters to be forgotten\n  when using unliftings such
  as `MonadBaseControl`, `MonadThrow`, `MonadCatch`\n  and `MonadMask`\n- Fix the
  scheduler shutdown to not always run into the cancellation timeout\n\n## 0.11.1\n\n-
  Fix a compilation error\n\n## 0.11.0\n\n- Change the return type of `spawnCallbackObserver`
  from\n  `Bool` to `ApiServerCmd`\n\n## 0.10.0\n\n- Re-introduce a Logs Effect but
  keep the LogWriter Reader\n- Get rid of the LogWriterProxy and the implicit argument\n-
  Make logging stricter: require log message to be NFData instances\n\n## 0.9.2\n\n-
  Try to adapt the dependency versions to make hackage happy again\n\n## 0.9.1\n\n-
  Add smart constructors for `MessageSelector`\n- Remove `ReceiveMessage` `Process`
  action\n- Rename `ReceiveMessageSuchThat` to `ReceiveSelectedMessage`\n- Improve
  some Show instances, e.g. ProcessId\n- Rewrite Logging API:\n  - Vastly simplified
  API\n\n## 0.9.0\n\n- Make `ForkIOScheduler` faster and more robust\n- Add `ExitReason`\n-
  Add `ProcessState`\n- Add `ShutdownRequest` type\n- Rewrite logging to be a `Reader`
  of a `LogWriter`\n- Remove pure logging, the `Logs...` constraint must be\n  accompanied
  by `Lifted IO` (or `MonadIO`) in many log functions\n  most prominently `logMsg`\n-
  Add a `lmDistance` field in `LogMessage`\n- Add `increaseLogMessageDistance` and
  `dropDistantLogMessages`\n  using the new `lmDistance` field\n- Add a newtype for
  the argument to selective receives: `MessageSelector`\n- Add a `makeReference` function
  to `Process` which will return process local\n  unique `Int`s\n- Rename `spawnServer`
  to `spawnServerWithEffects` and add a simpler version of\n  `spawnServerWithEffects`
  called `spawnServer`\n- Make all `ApiHandler` handler callbacks optional (by changing
  the type to `Maybe ...`)\n- `ApiHandler` must now return an `ApiServerCmd`.\n- Add
  `ApiServerCmd` which allows handler functions to leave to server loop without\n
  \ exiting the process\n- Fix `Observer.Queue`\n- Rename fields in `ApiHandler`\n-
  Add smart constructors for `ApiHandler`\n\n## 0.8.0\n\n- Add selective receive\n-
  Complete `Api.Server` rewrite (simplification)\n- Move examples to `./examples/`
  and add executables to the\n  cabal file\n\n## 0.7.3\n\n- Add `withFrozenCallStack`
  to exposed functions\n- Add `ObserverState` type alias\n\n## 0.7.2\n\n- Add `ObservationQueue`
  utility\n- Fix missing re-exports from\n  `Control.Eff.Concurrent.Api.Client`\n
  \ in `Control.Eff.Concurrent` introduced in recent versions\n\n## 0.7.1\n\n- Improve
  call-stack support in log messages\n- Expose `setLogMessageTimestamp` and `setLogMessageThreadId`\n\n##
  0.7.0\n\n- Remove the parameter from `closeLogChannelAfter` that had the optional:\n
  \ last-log-message-before-channel-closes\n\n## 0.6.4\n\n- Add `whereIsServer`\n\n##
  0.6.3\n\n- Add `ServerReader` type alias\n\n## 0.6.2\n\n- Fix bad `containers` version
  boundary\n\n## 0.6.1\n\n- Improve Experimental Nix Expressions\n\n## 0.6.0\n\n-
  Rewrite Logging\n- Improve Experimental Nix Expressions\n\n## 0.5.0.0\n\n- Switch
  to `extensible-effects` version `3.1.0.0`\n- Bump to stackage LTS-12.9\n- Add `Control.Eff.Log.MessageFactory`\n-
  Add `Control.Eff.Log.Message`\n\n## 0.4.0.0\n\n- Switch to `extensible-effects`
  version `3.0.0.0`\n- Improve single threaded scheduler to be more space efficient\n-
  Add some strictness annotations\n- Add `Control.Eff.Loop` with (hopefully) constant
  space `forever` and\n  `replicateM_`\n- Add `Control.Eff.Concurrent`, a module that
  conveniently re-exports most\n  library functions.\n\n## 0.3.0.2\n\n- Improve single
  threaded scheduler such that the main process can return a value\n\n## 0.3.0.1\n\n-
  Fix a race condition in the SchedulerSession shutdown\n- Improve the interactive
  scheduler session API\n- Rename `SchedulerVar` -> `SchedulerSession`\n- Remove `submitPrint`\n\n##
  0.3.0.0\n\n- Add support for running and interacting with a scheduler\n  and it's
  processes from IO, for example from ghci\n- Rename `yieldProcess` to `executeAndResumeOrExit`\n-
  Add an actual `yieldProcess`, that behaves like `yield`\n- Change the return type
  of function to `()` where applicable\n  to avoid all these `_ <- sendMessage...`
  or `void $ sendMessage`\n  dances.\n- Add a simple logging observer: `spawnLoggingObserver`\n-
  Removed `Control.Eff.Interactive`\n- Removed most functions in `Control.Eff.ExceptionExtra`\n-
  Make `sendMessage` and the reply in `call` strict with respect to the message\n
  \ payload\n\n## 0.2.0.3\n\n- Improve 'Api' documentation\n- Improve `LogChannel`
  API\n- Reorganize unit tests\n- Hopefully tune travis ci test parameter enough to
  get a stable build result\n\n## 0.2.0.2\n\n- Fix minor `stack upload` complaints
  about the cabal file\n\n## 0.2.0.1\n\n- Simplify IO Exception handling in `ForkIoScheduler`,\n-
  Add many unit tests for exception, exit and shutdown\n\n## 0.2.0.0\n\n- Add `Spawn`
  to `Process`\n- Merge `MessagePassing` and `Process`\n- Add initial test suite\n-
  Fix shutdown error in `ForkIoScheduler`\n- Rename `Dispatcher` to `Scheduler`\n-
  Add `receiveAnyLoop` function to `Process`\n- Change `Api.Server` `serve` to loop
  instead of handling just one request\n- Allow combining multiple `ApiHandler` such
  that one process can handle\n  multiple APIs\n\n## 0.1.3.0\n\n- Rename and split
  `GenServer` to `Api`, `Api.Client`, `Api.Server`\n- Add `registerServer`, `callRegistered`
  and `castRegistered`\n- Remove the variant of `cast` that returns a boolean\n\n##
  0.1.2.2\n\n- Try to fix version bounds for hackage\n\n## 0.1.2.1\n\n- Add more documentation\n-
  Simplify Scheduler API\n- Make more exception safe\n\n## 0.1.2.0\n\n- Add Observer
  module\n- Implement Exception handling\n- Improve Scheduler shutdown\n- Add logging
  support via the logging-effect library\n\n## 0.1.1.0\n\n- Substantial API reorganization\n-
  Rename/Move modules\n\n## 0.1.0.1\n\n- Stack/Cabal/Github Cosmetics\n- Travis build
  job\n\n## 0.1.0.0\n\n- Initial Version\n"
basic-deps:
  extensible-effects-concurrent: -any
  exceptions: ! '>=0.10 && <0.11'
  hostname: -any
  extensible-effects: ==5.*
  stm: ! '>=2.4.5 && <2.6'
  base: ! '>=4.12 && <5'
  time: ! '>=1.8 && <1.9'
  text: ==1.2.*
  safe-exceptions: ! '>=0.1 && <0.2'
  monad-control: ! '>=1.0 && <1.1'
  filepath: ! '>=1.4 && <1.5'
  network: ! '>=2 && <4'
  async: ! '>=2.2 && <3'
  data-default: ==0.7.*
  containers: ! '>=0.5.8 && <0.7'
  lens: ! '>=4.14 && <4.18'
  mtl: ! '>=2.2 && <2.3'
  hashable: ! '>=1.2'
  transformers-base: ! '>=0.4 && <0.5'
  pretty-types: ! '>=0.2.3.1 && <0.4'
  deepseq: ==1.4.*
  directory: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.1.2.0
- 0.1.2.1
- 0.1.2.2
- 0.1.3.0
- 0.2.0.2
- 0.2.0.3
- 0.3.0.0
- 0.3.0.1
- 0.3.0.2
- 0.4.0.0
- 0.5.0.0
- 0.5.0.1
- 0.6.0
- 0.6.1
- 0.6.2
- 0.6.3
- 0.7.0
- 0.7.1
- 0.7.2
- 0.7.3
- '0.8'
- 0.9.0
- 0.9.2
- 0.9.2.1
- 0.9.2.2
- 0.10.0
- 0.11.1
- 0.12.0
- 0.12.1
- 0.13.0
- 0.13.2
- 0.14.0
- 0.14.1
- 0.14.2
- 0.14.3
- 0.15.0
- 0.16.0
- 0.16.1
- 0.17.0
- 0.18.0
- 0.18.1
- 0.19.0
- 0.19.1
- 0.20.0
- 0.21.0
- 0.21.1
- 0.22.0
- 0.22.1
- 0.23.0
- 0.24.0
- 0.24.1
- 0.24.2
- 0.24.3
- 0.25.0
- 0.25.1
- 0.26.0
- 0.26.1
- 0.27.0
- 0.28.0
- 0.29.0
- 0.29.1
- 0.29.2
- 0.30.0
- 0.31.0
- 0.32.0
author: Sven Heyll
latest: 0.32.0
description-type: markdown
description: "# extensible-effects-concurrent\n\n[![Build Status](https://travis-ci.org/sheyll/extensible-effects-concurrent.svg?branch=master)](https://travis-ci.org/sheyll/extensible-effects-concurrent)\n\n[![Hackage](https://img.shields.io/hackage/v/extensible-effects-concurrent.svg?style=flat)](http://hackage.haskell.org/package/extensible-effects-concurrent)\n\n##
  From Erlang to Haskell\n\nThis project is an attempt to implement core ideas learned
  from the **Erlang/OTP**  \nframework in Haskell using **[extensible-effects](http://hackage.haskell.org/package/extensible-effects)**.\n\nThis
  library sketches my personal history of working on a large, real world Erlang\napplication,
  trying to bring some of the ideas over to Haskell.\n\nI know about cloud-haskell
  and transient, but I wanted something based on \n'extensible-effects', and I also
  wanted to deepen my understanding of it.\n\n### Modeling an Application with Processes\n\nThe
  fundamental approach to modelling applications in Erlang is\nbased on the concept
  of concurrent, communicating processes.\n\n\n### Example Code\n\n```haskell\nmodule
  Main where\n\nimport           Control.Eff\nimport           Control.Eff.Concurrent\n\nmain
  :: IO ()\nmain = defaultMain example\n\nexample :: Eff Effects ()\nexample = do\n
  \ person <- spawn \"alice\" alice\n  replyToMe <- self\n  sendMessage person replyToMe\n
  \ personName <- receiveMessage\n  logInfo' (\"I just met \" ++ personName)\n\nalice
  :: Eff Effects ()\nalice = do\n  logInfo \"I am waiting for someone to ask me...\"\n
  \ sender <- receiveMessage\n  sendMessage sender (\"Alice\" :: String)\n  logInfo'
  (show sender ++ \" message received.\")\n\n```\nThis is taken from [example-4](./examples/example-4/Main.hs).\n\n\n**Running**
  this example causes this output:\n\n```text\nDEBUG      no proc  scheduler loop
  entered                                       at ForkIOScheduler.hs:209\nDEBUG        init!1
  enter process                                                at ForkIOScheduler.hs:691\nNOTICE
  \      init!1 ++++++++ main process started ++++++++                       at ForkIOScheduler.hs:579\nDEBUG
  \      alice!2 enter process                                                at ForkIOScheduler.hs:691\nINFO
  \       alice!2 I am waiting for someone to ask me...                        at
  Main.hs:19\nINFO        alice!2 !1 message received.                                         at
  Main.hs:22\nDEBUG       alice!2 exit: Process finished successfully                          at
  ForkIOScheduler.hs:729\nINFO         init!1 I just met Alice                                             at
  Main.hs:15\nNOTICE       init!1 ++++++++ main process returned ++++++++                      at
  ForkIOScheduler.hs:581\nDEBUG        init!1 exit: Process finished successfully
  \                         at ForkIOScheduler.hs:729\nDEBUG      no proc  scheduler
  loop returned                                      at ForkIOScheduler.hs:211\nDEBUG
  \     no proc  scheduler cleanup begin                                      at ForkIOScheduler.hs:205\nNOTICE
  \    no proc  cancelling processes: []                                     at ForkIOScheduler.hs:222\nNOTICE
  \    no proc  all processes cancelled                                      at ForkIOScheduler.hs:239\n```\n\nThe
  mental model of the programming framework regards objects as **processes**\nwith
  an isolated internal state. \n\n**[Processes](http://hackage.haskell.org/package/extensible-effects-concurrent-0.25.0/docs/Control-Eff-Concurrent-Process.html)**
  are at the center of that contraption. All *actions*\nhappen in processes, and all
  *interactions* happen via messages sent\nbetween processes. \n\nThis is called **Message
  Passing Concurrency**;\nin this library it is provided via the **`Process`** effect.
  \n\nThe **`Process`** effect itself is just an *abstract interface*.\n\nThere are
  two schedulers, that *interpret* the `Process` effect:\n\n- A *multi-threaded* scheduler,
  based on the `async`\n- A *pure* single-threaded scheduler, based on coroutines\n\n###
  Using the library\n\nFor convenience, it is enough to import one of three modules:\n\n-
  [Control.Eff.Concurrent](http://hackage.haskell.org/package/extensible-effects-concurrent/docs/Control-Eff-Concurrent.html)
  for a multi threaded scheduler and `LoggingAndIo`\n- [Control.Eff.Concurrent.Pure](http://hackage.haskell.org/package/extensible-effects-concurrent/docs/Control-Eff-Concurrent-Pure.html),
  for a single threaded scheduler and pure log capturing and otherwise no IO\n- [Control.Eff.Concurrent.SingleThreaded](http://hackage.haskell.org/package/extensible-effects-concurrent/docs/Control-Eff-Concurrent-SingleThreaded.html),
  for a single threaded scheduler and totally impure logging via IO\n\n### Process
  Life-Cycles and Interprocess Links\n\nAll processes except the first process are
  **`spawned`** by existing \nprocesses.\n\nWhen a process **`spawns`** a new process
  they are independent apart from the fact that\nthe parent knows the process-id of
  the spawend child process.\n \nProcesses can **monitor** each other to be notified
  when a communication partner exits, \npotentially in unforseen ways.\n\nSimilarily
  processes may choose to mutually **link** each other.\n\nThat allows to model **trees**
  in which processes watch and start or\nrestart each other.\n\nBecause processes
  never share memory, the internal - possibly broken - state of \na process is gone,
  when a process exits; hence restarting a process will not\nbe bothered by left-over,
  possibly inconsistent, state. \n\n### Timers \n\n[The Timer module](src/Control/Eff/Concurrent/Process/Timer.hs)
  contains functions to send messages after a time\nhas passed, and reiceive messages
  with timeouts.\n\n### More Type-Safety: [The Protocol Metaphor](./src/Control/Eff/Concurrent/Protocol.hs)\n\nAs
  the library carefully leaves the realm of untyped messages, it uses the \nconcept
  of a **protocol** that governs the communication\nbetween concurrent processes,
  which are either **protocol servers** or\n**clients** as a metaphor.\n\nThe communication
  is initiated by the client.\n\nThe idea is to indicate such a _protocol_ using a
  **custom data type**,\ne.g. `data TemperatureSensorReader` or `data SqlServer`.\n
  \nThe library consists some tricks to restrict the kinds of messages that\nare acceptable
  when communicating with processes _adhering to the protocol_.\n\nThis _protocol_
  is not encoded in the users code, but rather something that\nthe programmer keeps
  in his head. \n\nIn order to be appreciated by authors of real world applications,
  the \nprotocol can be defined by giving an abstract message sum-type and \ncode
  for spawning server processes.\n\nIt focusses on these questions:\n\n1. What messages
  does a process accept?\n2. When sending a certain message, should the sender wait
  for an answer?\n\n#### Protocol Phantom Type\n\nIn this library, the key to a _protocol_
  is a single type,\nthat could even be a so called __phantom type__, i.e. a\ntype
  without any runtime values:\n\n```haskell \n\ndata UserRegistry -- look mom, no
  constructors!! \n\n``` \n\nSuch a type exists only for the type system.\n\nIt can
  only be used as a parameter to certain type constructors,\nand for defining type
  class and type family instances, e.g.\n\n\n```haskell \n\nnewtype Endpoint protocol
  = MkServer { _processId :: ProcessId }\n\ndata UserRegistry\n\nstartUserRegistry
  :: Eff e (Endpoint UserRegistry)\nstartUserRegistry = \n  error \"just an example\"\n\n```\n\nHere
  the `Endpoint` has a type parameter `protocol` but the type is not\nused by the
  constructor to hold any values, hence we can use `UserRegistry`,\nas a parameter,
  since `UserRegistry` has no value constructors.\n\n#### Protocol Data Units\n\nMessages
  that belong to a protocol are called __protocol data units (PDU)__.\n\n#### Protocol
  Servers Endpoints\n\nThe `ProcessId` of a process identifies the messages box that\n`receiveMessage`
  will use, when waiting for an incoming message.\n\nWhile it defines _where_ the
  messages are collected, it does \nnot restrict or inform about _what_ data is handled
  by a process.\n\nAn [Endpoint](https://hackage.haskell.org/package/extensible-effects-concurrent/docs/Control-Eff-Concurrent-Protocol.html#t:Endpoint)
  is a wrapper \naround the `ProcessId` that takes a _type parameter_.\n\nThe type
  does not have to have any values, it can be a phantom type.\n\nThis type serves
  only the tag the process as a server accepting messages identified by the [HasPdu](https://hackage.haskell.org/package/extensible-effects-concurrent/docs/Control-Eff-Concurrent-Protocol.html#t:HasPdu)
  \  type class.\n\n#### Server/Protocol Composability\n\nUsually a protocol consists
  of some really custom PDUs and\nsome PDUs that more or less are found in many protocols,\nlike
  event listener registration and event notification.\n\nIt is therefore helpful to
  be able to compose protocols.\n\nThe machinery in this library allows to list several
  \nPDU instances understood by endpoints of a given protocol\nphantom type.\n\n####
  Protocol Clients   \n\n_Clients_ use a protocol by sending `Pdu`s indexed by \nsome
  protocol phantom type to a server process.\n\nClients use `Endpoint`s to address
  these servers, and the\nfunctions defined in [the corresponding module](https://hackage.haskell.org/package/extensible-effects-concurrent/docs/Control-Eff-Concurrent-Protocol-Client.html).\n\nMost
  important are these two functions:  \n\n* [cast](https://hackage.haskell.org/package/extensible-effects-concurrent/docs/Control-Eff-Concurrent-Protocol-Client.html#v:cast)\n
  \ to send fire-and-forget messages\n   \n* [call](https://hackage.haskell.org/package/extensible-effects-concurrent/docs/Control-Eff-Concurrent-Protocol-Client.html#v:cast)\n
  \ to send RPC-style requests and wait (block) for the responses.\n  Also, when the
  server is not running, or crashes in \n  while waiting, the calling process is interrupted\n\n####
  Protocol Servers   \n\nThis library offers an API for defining practically safe
  to\n use __protocol servers__:\n\n* [EffectfulServer](./src/Control/Eff/Concurrent/Protocol/EffectfulServer.hs)
  This modules defines the framework\n  of a process, that has a callback function
  that is repeatedly\n  called when ever a message was received.\n  \n  The callback
  may rely on any extra effects (extensible effects).    \n\n* [StatefulServer](./src/Control/Eff/Concurrent/Protocol/StatefulServer.hs)
  A server based on the `EffectfulServer` that includes the definition of\n  in internal
  state called __Model__, and some nice \n  helper functions to access the model.
  These functions\n  allow the use of lenses. \n  Unlike the effectful server, the
  effects that the \n  callback functions can use are defined in this module.\n\n*
  [CallbackServer](./src/Control/Eff/Concurrent/Protocol/CallbackServer.hs) A server
  based on the `EffectfulServer` that does not require a type class\n   instance like
  the stateful and effectful servers do.\n   It can be used to define _inline_ servers.\n
  \ \n#### Events and Observers\n\nA parameterized protocol for event handling is
  provided in \nthe module:\n\n* [Observer](./src/Control/Eff/Concurrent/Protocol/Observer.hs)
  \n \n\n#### Brokers and Watchdogs\n\nA key part of a robust system is monitoring
  and possibly restarting \nstuff that crashes, this is done in conjunction by two
  modules:\n\n* [Broker](./src/Control/Eff/Concurrent/Protocol/Broker.hs)\n* [Watchdog](./src/Control/Eff/Concurrent/Protocol/Watchdog.hs)\n\nA
  client of a process that might be restarted cannot use the `ProcessId` \ndirectly,
  but has to use an abstract ID and lookup the `ProcessId` from a \nprocess **[broker](./src/Control/Eff/Concurrent/Protocol/Broker.hs)**,
  that manages the current `ProcessId` of protocol server\nprocesses.\n\nThat way,
  when ever the server process registered at a broker crashes,\n**a [watchdog](./src/Control/Eff/Concurrent/Protocol/Watchdog.hs)
  process** can (re-)start the crashed server.  \n\n### Additional services\n\nCurrently
  a **logging effect** is also part of the code base.\n\n## Usage and Implementation\n\nShould
  work with `stack`, `cabal` and `nix`. \n\n### Required GHC Extensions\n\nIn order
  to use the library you might need to activate some extension\nin order to fight
  some ambiguous types, stemming from the flexibility to\nchoose different Scheduler
  implementations.\n\n- AllowAmbiguousTypes\n- TypeApplications\n\n\n## Planned Features\n\n-
  Stackage [![extensible-effects-concurrent LTS](http://stackage.org/package/extensible-effects-concurrent/badge/lts)](http://stackage.org/lts/package/extensible-effects-concurrent)\n\n-
  Scheduler `ekg` Monitoring\n"
license-name: BSD-3-Clause

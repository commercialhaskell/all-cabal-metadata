homepage: https://github.com/tek/exon#readme
changelog-type: markdown
hash: f9f5b599fb4de68963c0a3b57d5e48df8941b77265d65cb7e15c2fb0392594c1
test-bench-deps:
  exon: -any
  flatparse: ==0.2.*
  base: ==4.*
  tasty-hedgehog: -any
  text: -any
  hedgehog: -any
  haskell-src-exts: <1.24
  relude: '>=0.7 && <1.2'
  tasty: -any
  haskell-src-meta: <0.9
  template-haskell: -any
maintainer: haskell@tryp.io
synopsis: Monoidal Quasiquote Interpolation
changelog: |
  # 0.2.1.0
  * add naive stderr interpreters for `DataLog` and `Log`.

  # 0.2.0.0

  * `DataLog` got a second constructor, `Local`. It takes a higher-order `Sem` and a transformation function, the latter
    of which is applied to all messages logged within the former.
    This allows context manipulation for blocks of code.
  * `interceptDataLogConc` adds support for concurrent processing of log messages to any interpretation of `DataLog`.
basic-deps:
  flatparse: ==0.2.*
  base: ==4.*
  text: -any
  haskell-src-exts: <1.24
  relude: '>=0.7 && <1.2'
  haskell-src-meta: <0.9
  template-haskell: -any
all-versions:
- 0.1.0.0
author: Torsten Schmits
latest: 0.1.0.0
description-type: markdown
description: |
  This Haskell library provides quasiquote string interpolation with customizable concatenation for arbitrary types.

  The default case uses `Monoid` and `IsString`:

  ```haskell
  import Exon (exon)
  import Data.Text (toUpper)

  newtype Name =
    Name Text
    deriving newtype (Show, Monoid, IsString)

  instance Semigroup Name where
    Name l <> Name r = Name (l <> " | " <> r)

  lastName :: Name
  lastName = "Fry"

  up :: Name -> Name
  up (Name name) = Name (toUpper name)

  >>> [exon|Philip J. #{up lastName}|]
  Name "Philip | J. | FRY"
  ```

  Individual segments are tokenized at whitespace boundaries, expressions between `#{` and `}` are inserted verbatim.

  The default implementation ignores whitespace when concatenating, while it is preserved for `String`, `Text` etc.

  # Customization

  Concatenation is performed by the class `Exon.Exon`:

  ```haskell
  class Exon (tag :: Type) (a :: Type) where
    convertSegment :: Segment a -> Result a

    appendSegment :: Result a -> Segment a -> Result a

    insertWhitespace :: Result a -> String -> Segment a -> Result a

    concatSegments :: NonEmpty (Segment a) -> a
  ```

  All methods have default implementations.
  The `tag` parameter is an arbitrary type that allows the creation of different quoters, with `exon` using the tag
  `ExonDefault.`

  In order to get the default quoter to support custom rules for a type, one simply has to write an instance:

  ```haskell
  import Exon (Exon, ExonDefault, Result)
  import qualified Exon as Segment (Segment(..))

  instance Exon ExonDefault Name where
    convertSegment = \case
      Segment.String s -> Result (Name s)
      Segment.Expression name -> Result name
      Segment.Whitespace ws -> Result (Name " >>> ")
  ```

  # Acknowledgments

  Inspired by the magnificent [string-interpolate].

  [string-interpolate]: https://hackage.haskell.org/package/string-interpolate
license-name: BSD-2-Clause-Patent

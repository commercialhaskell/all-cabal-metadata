homepage: https://github.com/jonascarpay/apecs#readme
changelog-type: markdown
hash: de957e05030bd4430ac0f08c2a648b4e315a34f5492154331acac089d365b957
test-bench-deps:
  apecs: -any
  base: ! '>=4.7 && <5'
  criterion: -any
  containers: -any
  linear: -any
  QuickCheck: -any
  vector: -any
maintainer: jonascarpay@gmail.com
synopsis: Fast ECS framework for game programming
changelog: ! "## [0.6.1]\n### Added\n- The `Reactive` store and module is a redesign
  of the `Register` store, and provides a more general solution for 'stores that perform
  additional actions when written to'.\n- The `Apecs.Stores.Extra` submodule, which
  contains the `Pushdown` and `ReadOnly` stores. `Pushdown` adds pushdown semantics
  to stores, and `ReadOnly` hides the `ExplSet` instances of whatever it wraps.\n-
  The `EntityCounter` and associated functions have all been specified to `IO`, since
  `Global EntityCounter` only works in IO. Furthermore, `EntityCounter` now uses a
  `ReadOnly` store, to prevent users from accidentally changing its value.\n- `Redirect`
  component that writes to another entity in `cmap`.\n### Changed\n- Default stores
  have `MonadIO m => m` instances, rather than `IO`. This makes it easier to nest
  `SystemT`.\n- All apecs packages have been consolidated into a single git repo.\n-
  `Apecs.Components` contains the components (and corresponding stores) from `Apecs.Core`.\n\n##
  [0.6.0.0]\n### Changed\n- Nothing, but since 0.5.1 was API-breaking I've decided
  to bump to 0.6\n## [0.5.1.1]\n### Changed\n- `Register` needs UndecidableInstances
  in GHC 8.6.2, I'm looking for a way around this. I've removed it for now.\n\n##
  [0.5.1.0]\n### Added\n- The `Register` store, which allows reverse lookups for bounded
  enums.\n  For example, if `Bool` has storage `Register (Map Bool)`, `regLookup True`
  will yield a list of all entities with a `True` component.\n  Can also be used to
  emulate a hash table, where `fromEnum` is the hashing function.\n  This allows us
  to make simple spatial hashes.\n  I'm open to suggestions for better names than
  Register.\n- `cmapIf`, cmap with a conditional test\n### Changed\n- `ExplInit` now
  too takes a monad argument.\n- Started rewrite of the test suite\n- Caches now internally
  use -2 to denote absence, to avoid possible conflict with -1 as a global entity\n###
  Removed\n- The STM instances have been removed, to be moved to their own package\n\n##
  [0.5.0.0]\n### Changed\n- `System w a` is now a synonym for `SystemT w IO a`.\n
  \ A variable monad argument allows apecs to be run in monads like ST or STM.\n  Most
  of the library has been rewritten to be as permissive as possible in its monad argument.\n###
  Added\n- STM stores. These will be moved to a separate package soon.\n\n## [0.4.1.2]\n###
  Changed\n- Either can now be deleted, deleting `Either a b` is the same as deleting
  `(a,b)`.\n- Some were missing their inline pragma's, now they don't\n\n## [0.4.1.1]\n###
  Changed\n- Export `Get`, `Set`, `Destroy`, `Members` by default\n- Export `cfold`,
  `cfoldM`, `cfoldM_` by default\n- Fix () instance\n\n## [0.4.1.0]\n### Added\n-
  `cfold`, `cfoldM`, `cfoldM_`\n- `Either` instances and `EitherStore`\n\n### Changed\n-
  Changed MaybeStore implementation to no longer use -1 for missing entities.\n- Fixed
  some outdated documentation.\n- Change the `global` void entity to -2, just to be
  sure it won't conflict if accidentally used in a cache.\n\n## [0.4.0.0]\n### Added\n-
  A changelog\n\n### Changed\n- `Store` is now split into 5 separate type classes;
  `ExplInit`, `ExplGet`, `ExplSet`, `ExplDestroy`, and `ExplMembers`.\n    This makes
  it illegal to e.g. iterate over a `Not`.\n- phantom arguments are now given as `Proxy`
  values, re-exported from `Data.Proxy`. This makes phantom arguments explicit and
  avoids undefined values.\n"
basic-deps:
  base: ! '>=4.7 && <5'
  containers: -any
  mtl: -any
  template-haskell: -any
  vector: -any
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.2.0.0'
- '0.2.0.1'
- '0.2.0.2'
- '0.2.0.3'
- '0.2.1.0'
- '0.2.1.1'
- '0.2.2.0'
- '0.2.3.0'
- '0.2.4.0'
- '0.2.4.1'
- '0.2.4.2'
- '0.2.4.3'
- '0.2.4.4'
- '0.2.4.5'
- '0.2.4.6'
- '0.2.4.7'
- '0.3.0.0'
- '0.3.0.1'
- '0.3.0.2'
- '0.4.0.0'
- '0.4.0.1'
- '0.4.1.0'
- '0.4.1.1'
- '0.5.0.0'
- '0.5.1.0'
- '0.5.1.1'
- '0.6.0.0'
- '0.7.0'
author: Jonas Carpay
latest: '0.7.0'
description-type: markdown
description: ! "# apecs\n\napecs is an _Entity Component System_ (ECS) framework inspired
  by [specs](https://github.com/slide-rs/specs) and [Entitas](https://github.com/sschmid/Entitas-CSharp).\nECS
  presents a data-driven approach to game development, that elegantly tackles many
  of the unique issues of game programming.\napecs aims to be\n* **Fast** - apecs
  is designed for high-performance applications. Its performance is competitive with
  Rust ECS libraries.\n* **Simple** - Game logic is expressed using a small number
  of combinators, and minimal boilerplate.\n* **Safe** - The `cmap`/`cfold`-DSL hides
  all the dangers of the low-level API.\n* **Extensible** - apecs can be used with
  anything that implements the low-level API. See [apecs-physics](apecs-physics/)
  or [apecs-stm](apecs-stm/) for examples.\n\n#### Links\n- [manual](https://github.com/jonascarpay/apecs/blob/master/prepub.pdf)
  (see [#19](https://github.com/jonascarpay/apecs/issues/19))\n- [tutorial](https://github.com/jonascarpay/apecs/blob/master/examples/Shmup.md)\n-
  [documentation](https://hackage.haskell.org/package/apecs/docs/Apecs.html)\n- [apecs-physics](https://github.com/jonascarpay/apecs-physics)\n\n####
  Performance\n[ecs-bench](https://github.com/lschmierer/ecs_bench) shows that apecs
  is competitive with the fastest Rust ECS frameworks.\n\n![Benchmarks](bench/chart.png)\n\n####
  Example\n```haskell\n{-# LANGUAGE DataKinds, FlexibleInstances, ScopedTypeVariables,
  TypeFamilies, MultiParamTypeClasses, TemplateHaskell #-}\n\nimport Apecs\nimport
  Control.Monad\nimport Apecs.Util\nimport Linear (V2 (..))\n\nnewtype Position =
  Position (V2 Double) deriving Show\nnewtype Velocity = Velocity (V2 Double) deriving
  Show\ndata Flying = Flying\n\nmakeWorldAndComponents \"World\" [''Position, ''Velocity,
  ''Flying]\n\ngame :: System World ()\ngame = do\n  newEntity (Position 0, Velocity
  1)\n  newEntity (Position 2, Velocity 1)\n  newEntity (Position 1, Velocity 2, Flying)\n\n
  \ -- 1. Add velocity to position\n  -- 2. Apply gravity to non-flying entities\n
  \ -- 3. Print a list of entities and their positions\n  cmap $ \\(Position p, Velocity
  v) -> Position (v+p)\n  cmap $ \\(Velocity v, _ :: Not Flying) -> Velocity (v -
  V2 0 1)\n  cmapM_ $ \\(Position p, Entity e) -> liftIO . print $ (e, p)\n\nmain
  :: IO ()\nmain = initWorld >>= runSystem game\n```\n"
license-name: BSD3

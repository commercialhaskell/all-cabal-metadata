homepage: https://github.com/pwrobinson/concurrent-hashtable#readme
changelog-type: markdown
hash: 8f4ea406489c64f609382ee03ddfb8786acee3961d95bd4a2e3fb697264c9736
test-bench-deps:
  stm: ! '>=2.4.5.1 && <3'
  dictionary-type: -any
  base: ! '>=4.7 && <5'
  unordered-containers: ! '>=0.2.10.0 && <1'
  criterion: ! '>=1.5.6.0 && <2'
  async: ! '>=2.2.2 && <3'
  containers: ! '>=0.6.0.1 && <1'
  concurrent-hashtable: -any
  atomic-primops: ! '>=0.8.3 && <2'
  hashable: ! '>=1.2.7.0 && <2'
  random: ! '>=1.1 && <2'
  QuickCheck: ! '>=2.13.2 && <3'
  vector: ! '>=0.12.0.3 && <1'
maintainer: pwr@lowerbound.io
synopsis: Thread-safe hash tables for multi-cores!
changelog: |
  # Changelog for concurrent-hashtable

  ## Unreleased changes
basic-deps:
  stm: ! '>=2.4.5.1 && <3'
  base: ! '>=4.7 && <5'
  async: ! '>=2.2.2 && <3'
  atomic-primops: ! '>=0.8.3 && <2'
  hashable: ! '>=1.2.7.0 && <2'
  random: ! '>=1.1 && <2'
  vector: ! '>=0.12.0.3 && <1'
all-versions:
- 0.1.0
- 0.1.1
- 0.1.2
- 0.1.3
- 0.1.4
- 0.1.5
author: Peter Robinson
latest: 0.1.5
description-type: markdown
description: |
  # A thread-safe hash table for multi-cores

  You can find benchmarks and more information about the internals of this package [here](https://lowerbound.io/blog/2019-10-24_concurrent_hash_table_performance.html).

  ## Installation

  > stack install

  ## Usage Example

  ```{haskell}
  > ht <- newWithDefaults 4     -- creates hash table of initial size 4
  > insert ht 1 "hello"         -- adds key-value pair (1,"hello")
  > insert ht 2 "world"         -- adds key-value pair (2,"world")
  > atomically $ readAssocs ht  -- convert to a key-value list
   [(1,"hello"),(2,"world")]
  > readSizeIO ht               -- returns 4
  > insert ht 3 "!"             -- adds key-value pair (3,"!") and triggers a resize as the load fraction is â‰¥ 0.75
  > readSizeIO ht               -- returns 8
  > atomically $ readAssocs ht  -- convert to a key-value list
   [(1,"hello"),(3,"!"),(2,"world")]
  ```
license-name: BSD-3-Clause

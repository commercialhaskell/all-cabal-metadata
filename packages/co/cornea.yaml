homepage: https://github.com/tek/cornea#readme
changelog-type: ''
hash: 54143e32f8dea78b249544f4527af98604c5a53ae2a69261bfa87ddaa102177f
test-bench-deps:
  either: '>=5.0.1'
  base: ==4.*
  tasty-hedgehog: -any
  monad-control: '>=1.0'
  hedgehog: -any
  lifted-base: <0.3
  th-abstraction: '>=0.3'
  cornea: -any
  lens: '>=4'
  relude: '>=0.7'
  mtl: -any
  transformers: -any
  tasty: -any
  template-haskell: -any
maintainer: tek@tryp.io
synopsis: classy optical monadic state
changelog: ''
basic-deps:
  either: '>=5.0.1'
  base: ==4.*
  monad-control: '>=1.0'
  lifted-base: <0.3
  th-abstraction: '>=0.3'
  lens: '>=4'
  relude: '>=0.7'
  mtl: -any
  transformers: -any
  template-haskell: -any
all-versions:
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
- 0.3.0.0
- 0.3.0.1
- 0.3.1.2
- 0.4.0.0
- 0.4.0.1
author: Torsten Schmits
latest: 0.4.0.1
description-type: markdown
description: |
  # Intro

  Classes for accessing and mutating nested data types with corresponding adapter
  classes for `MonadState`, `MonadReader` and `MonadError`. Inspired by the
  [next level mtl with classy optics] talk.

  [Hackage]

  # Internals

  Lenses and Prisms from [lens] are autogenerated with [TH] by splicing with
  `deepPrisms` and `deepLenses`.
  The generator recurses into single-field constructors and record fields if
  there are instances of `DeepPrisms` or `DeepLenses` for their parameter types.

  # Example

  For `MonadError`:

  ```haskell
  {-# LANGUAGE TemplateHaskell #-}

  import Cornea (MonadDeepError(throwHoist))
  import Control.Monad.Trans.Except (runExceptT)
  import Data.DeepPrisms (deepPrisms)

  newtype Error = Error String

  newtype Inner = Inner Error
  deepPrisms ''Inner

  data Mid = Mid Inner
  deepPrisms ''Mid

  newtype Outer = Outer Mid
  deepPrisms ''Outer

  throwDeep :: MonadDeepError e Inner m => m ()
  throwDeep = throwHoist (Inner (Error "boom"))

  main :: IO (Either Outer ())
  main = runExceptT throwDeep
  ```

  In `main`, `MonadError Outer IO` and `DeepPrisms Outer Inner` are summoned.

  Analogously for `MonadState`:

  ```haskell
  {-# LANGUAGE TemplateHaskell #-}

  import Cornea (MonadDeepState(get, gets, put))
  import Control.Monad.Trans.State (execStateT)
  import Data.DeepLenses (deepLenses)

  newtype S = S Int

  newtype Inner = Inner { _innerS :: S }
  deepLenses ''Inner

  data Mid = Mid { _midInner :: Inner }
  deepLenses ''Mid

  newtype Outer = Outer { _outerMid :: Mid }
  deepLenses ''Outer

  stateDeep :: MonadDeepState s Inner m => m ()
  stateDeep = do
    (Inner (S a)) <- get
    b <- gets $ \(Inner (S b)) -> b
    put (Inner (S (a + b + 3)))

  main :: IO Outer
  main = do
    execStateT stateDeep (Outer (Mid (Inner (S 5))))
  ```

  `MonadReader` works basically the same as `MonadState`.

  [lens]: https://hackage.haskell.org/package/lens
  [TH]: https://hackage.haskell.org/package/template-haskell
  [next level mtl with classy optics]: https://github.com/gwils/next-level-mtl-with-classy-optics
  [Hackage]: https://hackage.haskell.org/package/cornea
license-name: BSD-2-Clause-Patent

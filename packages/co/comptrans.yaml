all-versions:
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
- 0.1.0.4
- 0.1.0.5
author: James Koppel
basic-deps:
  base: '>=4.7 && <5'
  compdata: <1
  containers: <=0.6
  deepseq: <1.5
  deepseq-generics: <0.1.2
  ghc-prim: '>=0.2'
  lens: <5
  template-haskell: '>=0'
  th-expand-syns: <=0.4
changelog: ''
changelog-type: ''
description: |-
  Template Haskell for converting an AST for a language written using normal
  algebraic data types into ones written using multi-sorted compositional data types
  (`Data.Comp.Multi` from the `compdata` library) so that you can use generic and modular operators
  on it. You might need to add additional constructors that can e.g.: convert a (Term e Foo) into a
  (Term e [Foo]).

  The sCource files have comments showing example output for a simple language. See the examples directory
  for an extended example of generating a compositional data type for the entire Java language, with labelled variants
  as well as variants where an entire project of source files can be treated as a single AST -- and you can use the same operations
  on all of them!
description-type: haddock
hash: 6189d92a8069d4ed7c676b6b56f910bbf78621089c285e7ad0f85cc40316277b
homepage: https://github.com/jkoppel/comptrans
latest: 0.1.0.5
license-name: BSD-3-Clause
maintainer: James Koppel
synopsis: Automatically converting ASTs into compositional data types
test-bench-deps: {}

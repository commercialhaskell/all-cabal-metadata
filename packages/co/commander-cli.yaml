homepage: https://github.com/SamuelSchlesinger/commander-cli
changelog-type: markdown
hash: c7294940830153c066a124d9e3eb628ba421a3e87c5025d9dc6b4a466f90ac84
test-bench-deps:
  base: '>=4.12 && <5'
  unordered-containers: '>=0.2 && <0.3'
  text: '>=1.2.4 && <1.3'
  commander-cli: -any
maintainer: sgschlesinger@gmail.com
synopsis: A command line argument/option parser library built around a monadic metaphor
changelog: |
  # Revision history for commander-cli

  ## 0.1.0.0 -- 2020-01-12

  * Ported this to a cabal project after having built it in a larger repository
  accompanied by scripts written with it. (Samuel Schlesinger)
basic-deps:
  base: '>=4.12 && <5'
  unordered-containers: '>=0.2 && <0.3'
  text: '>=1.2.4 && <1.3'
  commander-cli: -any
  process: '>=1.6 && <1.7'
  mtl: ==2.2.*
  directory: '>=1.3 && <1.4'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.0.1
author: Samuel Schlesinger
latest: 0.2.0.1
description-type: markdown
description: "# commander-cli\n\n[![Build Status](https://travis-ci.org/SamuelSchlesinger/commander-cli.svg?branch=master)](https://travis-ci.org/SamuelSchlesinger/commander-cli)\n\nThe
  commander-cli package contains two DSLs for describing command line programs, \none
  at the type level and one at the term level. The one at the type level looks \nlike
  this:\n\n```haskell\ntype File = \"writer\" & Arg \"file\" FilePath & Arg \"contents\"
  FilePath & Raw\n          + \"reader\" & Arg \"file\" FilePath & Raw\n```\n\nThis
  is a type which encodes information about an command line program we want to write.
  We can\ninstantiate a term of this type by writing\n\n```haskell\nfile :: ProgramT
  File IO\nfile = sub (arg \\file -> arg \\contents -> raw $ writeFile file contents)
  \n   :+: sub (arg \\file -> raw $ readFile file >>= putStrLn)\n```\n\nI can write
  a term of this type without specifying the File type by using the\nTypeApplications
  extension.\n\n```haskell\nfile = sub @\"writer\" (arg @\"file\" \\file -> arg @\"contents\"
  \\contents -> raw $ writeFile file contents)\n   :+: sub @\"reader\" (arg @\"file\"
  \\file -> raw $ readFile file >>= putStrLn)\n```\n\nThe library consists of a few
  basic types which are important for understanding\nhow to use it. The first thing
  is the class\n\n```haskell\nclass Unrender r where\n  unrender :: Text -> Maybe
  r\n```\n\nThis class is what you will use to define the parsing of a type from text
  and\ncan use any parsing library or whatever you want. Next, we have the class\n\n```haskell\nclass
  HasProgram p where\n  data ProgramT p m a\n  run :: ProgramT p IO a -> CommanderT
  State IO a\n  hoist :: (forall x. m x -> n x) -> ProgramT p m a -> ProgramT p n
  a\n  invocations :: [Text]\n```\n\nInstances of this class will define a syntactic
  element, a new instance of the\ndata family ProgramT, as well as its semantics in
  terms of the CommanderT monad,\nwhich is a backtracking monad based on a metaphor
  to military commanders which\nretreats upon defeat.\n"
license-name: MIT

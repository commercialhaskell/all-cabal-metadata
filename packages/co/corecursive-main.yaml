homepage: https://github.com/githubuser/corecursive-main#readme
changelog-type: markdown
hash: 9f3e2dd48cbf8e5f250054cca6ac0f9ac2f05e55feb6f81f52937960aa0e1ad3
test-bench-deps:
  base: ! '>=4.7 && <5'
  corecursive-main: -any
  process: -any
maintainer: example@example.com
synopsis: Write your main like it can call itself back.
changelog: ! '# Changelog for corecursive-main


  ## Unreleased changes

'
basic-deps:
  unix: -any
  base: ! '>=4.7 && <5'
  corecursive-main: -any
  process: -any
all-versions:
- '0.1.0.0'
author: Author name here
latest: '0.1.0.0'
description-type: markdown
description: ! '# corecursive-main


  Functional programmers are used to program with (co-)recursive functions.  What

  if the main program was itself recursive? One could benefit the underlying

  operating system scheduler to orchestrate resources. For instance, limiting

  memory, file-descriptor on a per-recursive-call basis. Another instance is

  supporting distributed computations across multiple machines.


  ## This package


  This package demonstrates the idea of replacing the main entry-point of the

  program (i.e., `main :: IO ()`) with a recursion-aware main. The program first

  pattern matches on an "argument". This argument defines which action to take

  for the rest of the program. The rest of the program runs with a

  "Self-reference", which allows the program to call itself back. Explicitly

  passing a Self-reference is very similar to how the `fix` function allows to

  factor recursion out of the body of a self-referential function.


  Unlike `fix`, which executes recursive-call in the same memory-space as the

  call-site, developper using this package need to teach the program to transfer

  arguments and return values back-and-forth the call-site and the execution

  site. This package minimizes the developper effort to perform this translation.


  Currently, one mode is supported: spawning a child process on the same OS while

  serializing arguments over the command-line parameters.


  Future versions of this package or sibling packages will likely provide:

  - support for ''JSON'' or ''Dhall'' serialization format

  - support for ''stdin'' or networked serialization mechanisms

  - remote calls using `ssh`


  ## Envisionned usages


  Distributed computating:

  - run a same copy of the program on many places, each on a subset of the data (much
  like Map/Reduce)


  Dev/Ops:

  - use a single binary to reconfigure the whole datacenter and services after a cataclysmic
  outage (see #History) as well


  - orchestrate processes locally


  ## History


  This package is factored out of code and findings made while writing

  [DepTrack](https://github.com/lucasdicioccio/deptrack-project). If you like

  this package you may find other interesting ideas in DepTrack.

'
license-name: BSD3

homepage: https://github.com/michalkonecny/collect-errors#readme
changelog-type: markdown
hash: 63aac5b27853cf3308586bc097fec3518e20b880b956b4a5520b337e8fb8aeb0
test-bench-deps: {}
maintainer: mikkonecny@gmail.com
synopsis: Error monad with a Float instance
changelog: |
  # Changelog for collect-errors

  ## v0.1.2.0

  * Add CanTakeErrors type class and liftTakeErrors function

  * Add instance of deepseq's NFData

  ## v0.1.1.0

  * Add removeValue functions

  ## v0.1.0.0

  * Initial port of CollectErrors and CN from mixed-types-num-0.4.1

  * Simplify the code by abandoning EnsureCE and related type functions and utilities

  * NumErrors within CN are now a set to prevent multiple occurrences of the same error

  * Add CollectError or CN instances for various Prelude type classes, including Num and Floating, checking for domain violations
basic-deps:
  base: '>=4.7 && <5'
  containers: -any
  deepseq: -any
  QuickCheck: '>=2.7'
all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
author: Michal Konecny
latest: 0.1.2.0
description-type: markdown
description: |
  # collect-errors

  `CollectErrors es t` is a monad wrapper around values of type `t` which can accommodate (a list of)
  (potential) errors of type `es` that have (maybe) occurred during the computation
  of a value.  A value may be missing, leaving only the error(s).

  The wrapper `CN t` is a special case of `CollectErrors es t` with `es` = `NumErrors`.

  The `CN` wrapper also propagates instances of `Floating`,
  allowing us to write expressions with partial
  functions (ie functions that fail for some inputs) instead of
  branching after each application of such function:

      *Numeric.CollectErrors> a = 1 :: CN Double
      *Numeric.CollectErrors> (1/(a-1))+(sqrt (a-2))
      {{ERROR: division by 0; ERROR: out of domain: sqrt for negative arg -1.0}}

  as opposed to:

      *Prelude> a = 1 :: Double
      *Prelude> (1/(a-1))+(sqrt (a-2))
      NaN

  Dealing with the errors can be moved outside the expression:

      *Numeric.CollectErrors> a = 1 :: CN Double
      *Numeric.CollectErrors> toEither $ 1/(a-1)
      Left {ERROR: division by 0}

      *Numeric.CollectErrors> toEither $ 1/a+(sqrt a)
      Right 2.0

  The `CN` wrapper has support for **potential errors** so that it can be applied to a set arithmetic such as **interval arithmetic**.

  The `Floating` instance cannot be used with a set arithmetic since the instance relies on true/false comparisons but a set arithmetic has only **three-valued (true/false/undecided) comparisons**. Package [mixed-types-num](https://hackage.haskell.org/package/mixed-types-num) provides alternative numerical type classes in which three-valued (ie Kleenean) comparisons are available.
license-name: BSD-3-Clause

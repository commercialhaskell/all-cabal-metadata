homepage: https://github.com/michalkonecny/collect-errors#readme
changelog-type: markdown
hash: 98a2e05b7e66ff16489fc92e2f93bd9187cbc60ab8f35e383b8f6aa297d07837
test-bench-deps: {}
maintainer: mikkonecny@gmail.com
synopsis: Error monad with a Float instance
changelog: |
  # Changelog for collect-errors

  ## v0.1.4.0

  * Add clearPotentialErrors

  ## v0.1.3.0

  * Add CanTakeCNErrors type shortcut

  ## v0.1.2.0

  * Add CanTakeErrors type class and liftTakeErrors function

  * Add instance of deepseq's NFData

  ## v0.1.1.0

  * Add removeValue functions

  ## v0.1.0.0

  * Initial port of CollectErrors and CN from mixed-types-num-0.4.1

  * Simplify the code by abandoning EnsureCE and related type functions and utilities

  * NumErrors within CN are now a set to prevent multiple occurrences of the same error

  * Add CollectError or CN instances for various Prelude type classes, including Num and Floating, checking for domain violations
basic-deps:
  base: '>=4.7 && <5'
  containers: -any
  deepseq: -any
  QuickCheck: '>=2.7'
all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
- 0.1.3.0
- 0.1.4.0
author: Michal Konecny
latest: 0.1.4.0
description-type: markdown
description: "# collect-errors\n\n`CollectErrors es t` is a monad wrapper around values
  of type `t` which can accommodate (a list of)\n(potential) errors of type `es` that
  have (maybe) occurred during the computation\nof a value.  A value may be missing,
  leaving only the error(s).\n\nThe wrapper `CN t` is a special case of `CollectErrors
  es t` with `es` = `NumErrors`.\n\n## Generated API documentation\n\nSee the [Hackage
  page](https://hackage.haskell.org/package/collect-errors).\n\n## Feature highlights\n\n###
  Error collecting\n\nThe `CN` wrapper propagates instances of `Floating`,\nallowing
  us to write expressions with partial\nfunctions (ie functions that fail for some
  inputs) instead of\nbranching after each application of such function:\n\n    $
  stack ghci collect-errors:lib --no-load --ghci-options Numeric.CollectErrors\n    *Numeric.CollectErrors>
  a = 1 :: CN Double\n    *Numeric.CollectErrors> (1/(a-1))+(sqrt (a-2))\n    {{ERROR:
  division by 0; ERROR: out of domain: sqrt for negative arg -1.0}}\n\nas opposed
  to:\n\n    *Prelude> a = 1 :: Double\n    *Prelude> (1/(a-1))+(sqrt (a-2))\n    NaN\n\n###
  Error investigation\n\nDealing with the errors can be moved outside the expression:\n\n
  \   *Numeric.CollectErrors> a = 1 :: CN Double\n    *Numeric.CollectErrors> toEither
  $ 1/(a-1)\n    Left {ERROR: division by 0}\n\n    *Numeric.CollectErrors> toEither
  $ 1/a+(sqrt a)\n    Right 2.0\n\nAn alternative way to branch based on errors is
  provided by the function `withErrorOrValue`:\n\n    ...> a = 2 :: CN Double\n    ...>
  withErrorOrValue (const 0) id (1/a)\n    0.5\n\nThe `CN` wrapper can be forcibly
  removed as follows:\n\n    ...> :t unCN (1/a)\n    ... :: Double\n\n    ...> unCN
  (1/a)\n    0.5\n\n    ...> unCN (1/(a-2))\n    *** Exception: CollectErrors: {ERROR:
  division by 0}\n\n### Undecided comparisons\n\nThe following examples require the
  interval arithmetic package [aern2-mp](https://github.com/michalkonecny/aern2) and
  its dependency [mixed-types-num](https://hackage.haskell.org/package/mixed-types-num):\n\n
  \   $ stack ghci aern2-mp:lib --no-load --ghci-options AERN2.MP\n    *AERN2.MP>
  import MixedTypesNumPrelude\n    *AERN2.MP MixedTypesNumPrelude>\n\nComparisons
  involving sets (such as intervals) are undecided when the intervals overlap:\n\n
  \   ...> pi100 = piBallP (prec 100)\n    ...> :t pi100\n    pi100 :: MPBall\n    ...>
  pi100\n    [3.1415926535897932384626433832793333156439620213... ± ~7.8886e-31 ~2^(-100)]\n\n
  \   ...> 0 < pi100\n    CertainTrue\n\n    ...> pi100 == pi100\n    TrueOrFalse\n\nThe
  values `CertainTrue` and `TrueOrFalse` are part of the three-valued type `Kleenean`
  provided by  \n[mixed-types-num](https://hackage.haskell.org/package/mixed-types-num).\n\nThe
  above equality cannot be decided since `pi100` is not a single number but a set
  of numbers spanning the interval and the comparison operator cannot tell if the
  two operands sets represent the same number or a different number.\n\nThe Prelude
  `Floating` instance for `CN` cannot be used reliably with interval arithmetic because
  the instance relies on true/false comparisons:\n\n    ...> import qualified Prelude
  as P\n    ... P> (cn pi100) P./ (cn pi100 - cn pi100)\n    *** Exception: Failed
  to decide equality of MPBalls.  If you switch to MixedTypesNumPrelude instead of
  Prelude, comparison of MPBalls returns Kleenean instead of Bool.\n\nUsing its Kleenean
  comparisons, package [mixed-types-num](https://hackage.haskell.org/package/mixed-types-num)
  provides alternative numerical type classes in which errors are detected and collected
  correctly when using the `CN` wrapper:\n\n    ...> (cn pi100) / (cn pi100 - cn pi100)\n
  \   {{POTENTIAL ERROR: division by 0}}\n\n### Potential errors\n\nAs we see in the
  above example, the `CN` wrapper supports potential errors that sometimes arise as
  a consequence of undecided comparisons.\n\nWhen an error is present (which can be
  checked using `hasError`), the function `hasCertainError` can be used to further
  distinguish cases where the error is certain or potential:\n\n    ...> import qualified
  Numeric.CollectErrors as CN\n    ...> CN.hasCertainError $ (cn pi100) / (cn 0)\n
  \   True\n\n    ...> CN.hasCertainError $ (cn pi100) / (cn pi100 - cn pi100)\n    False\n\nSometimes
  the potential errors are *harmless*:\n\n    ...> sqrt (cn pi100 - cn pi100)\n    [0.0000000000000006280369834735100420368561502297...
  ± ~6.2804e-16 ~2^(-50)]{{POTENTIAL ERROR: out of domain: negative sqrt argument}}\n\nSuch
  harmless potential errors can be ignored using `clearPotentialErrors`:\n\n    ...>
  clearPotentialErrors $ sqrt (cn pi100 - cn pi100)\n    [0.0000000000000006280369834735100420368561502297...
  ± ~6.2804e-16 ~2^(-50)]\n\n"
license-name: BSD-3-Clause

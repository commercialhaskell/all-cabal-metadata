homepage: https://github.com/rudymatela/conjure#readme
changelog-type: ''
hash: 1e6017a0ccda8334ce316c554131b570ebccae11c3ca3cd54da71421f1d96afa
test-bench-deps:
  base: ==4.*
  leancheck: -any
  speculate: -any
  code-conjure: -any
  express: -any
maintainer: Rudy Matela <rudy@matela.com.br>
synopsis: conjure Haskell functions out of partial definitions
changelog: ''
basic-deps:
  base: '>=4 && <5'
  leancheck: '>=0.9.4'
  speculate: '>=0.4.6'
  express: '>=0.1.8'
  template-haskell: -any
all-versions:
- 0.0.2
- 0.0.4
- 0.1.0
- 0.1.2
- 0.2.0
- 0.2.2
author: Rudy Matela
latest: 0.2.2
description-type: markdown
description: "Conjure\n=======\n\n[![Conjure's Build Status][build-status]][build-log]\n[![Conjure
  on Hackage][hackage-version]][code-conjure-on-hackage]\n[![Conjure on Stackage LTS][stackage-lts-badge]][code-conjure-on-stackage-lts]\n[![Conjure
  on Stackage Nightly][stackage-nightly-badge]][code-conjure-on-stackage-nightly]\n\n![Conjure
  logo][conjure-logo]\n\nConjure is a tool that produces Haskell functions out of
  partial definitions.\n\nThis is currently an experimental tool in its early stages,\ndon't
  expect much from its current version.\nIt is just a piece of curiosity in its current
  state.\n\n\nInstalling\n----------\n\nTo install the [latest Conjure version from
  Hackage], just run:\n\n\t$ cabal update\n\t$ cabal v1-install code-conjure\n\nIf
  you are using Cabal v3.0 or later,\n[avoid using `cabal install`] for the time being\nand
  use `v1-install` instead.\n\nPrerequisites are [express], [leancheck] and [speculate].\nThey
  should be automatically resolved and installed by [Cabal].\n\nNOTE: the name of
  the Hackage package is __[`code-conjure`]__\n-- not to be confused with [Conjure
  the BitTorrent client].\n\n\nConjuring functions\n-------------------\n\nGiven\n\n\tsquare
  :: Int -> Int\n\tsquare 0  =  0\n\tsquare 1  =  1\n\tsquare 2  =  4\n\nand\n\n\tprimitives
  :: [Expr]\n\tprimitives  =  [ val (0::Int)\n\t               , val (1::Int)\n\t
  \              , value \"+\" ((+) :: Int -> Int -> Int)\n\t               , value
  \"*\" ((*) :: Int -> Int -> Int)\n\t               ]\n\nrunning\n\n\t> conjure \"square\"
  square primitives\n\nyields\n\n\tsquare :: Int -> Int\n\t-- testing 3 combinations
  of argument values\n\t-- looking through 3 candidates of size 1\n\t-- looking through
  3 candidates of size 2\n\t-- looking through 5 candidates of size 3\n\tsquare x
  \ =  x * x\n\nin less than a second.\n\nSee the `eg/arith.hs` example.\n\n\nConjuring
  recursive functions\n-----------------------------\n\nGiven\n\n\tfactorial :: Int
  -> Int\n\tfactorial 0  =  1\n\tfactorial 1  =  1\n\tfactorial 2  =  2\n\tfactorial
  3  =  6\n\tfactorial 4  =  24\n\tfactorial 5  =  120\n\nand\n\n\tprimitives :: [Expr]\n\tprimitives
  \ =  [ val (0::Int)\n\t               , val (1::Int)\n\t               , value \"+\"
  ((+) :: Int -> Int -> Int)\n\t               , value \"*\" ((*) :: Int -> Int ->
  Int)\n\t               , value \"dec\" (subtract 1 :: Int -> Int)\n\t               ,
  value \"==\" ((==) :: Int -> Int -> Bool)\n\t               ]\n\nrunning\n\n\t>
  conjure \"factorial\" factorial primitives\n\nyields\n\n\tfactorial :: Int -> Int\n\t--
  testing 6 combinations of argument values\n\t-- looking through 3 candidates of
  size 1\n\t-- looking through 5 candidates of size 2\n\t-- looking through 8 candidates
  of size 3\n\t-- looking through 26 candidates of size 4\n\t-- looking through 59
  candidates of size 5\n\t-- looking through 167 candidates of size 6\n\t-- looking
  through 581 candidates of size 7\n\t-- looking through 1654 candidates of size 8\n\t--
  looking through 5754 candidates of size 9\n\t-- looking through 17797 candidates
  of size 10\n\tfactorial n  =  if n == 0 then 1 else n * factorial (dec n)\n\nin
  about 3 seconds.\n\nSee the `eg/factorial.hs` example.\n\nIt is also possible to
  generate:\n\n    factorial n  =  if n == 0 then 1 else n * factorial (n - 1)\n\nin
  about 90s by including `(-) :: Int -> Int -> Int` in the primitives.\n\n\nRelated
  work\n------------\n\n[MagicHaskeller] (2007) is another tool\nthat is able to generate
  Haskell code automatically.\nIt supports recursion through\ncatamorphisms, paramorphisms
  and the [fix] function.\nIt is more mature than Conjure and is several orders of
  magnitude faster.\n\n[Barliman] for Lisp is another tool that does program synthesis.\n\nThere
  are hundreds of others,\nI'll add the most closely related here when I have the
  time.\n\n\nFurther reading\n---------------\n\nFor a detailed documentation of each
  function, see\n[Conjure's Haddock documentation].\n\n\nConjure, Copyright 2021  Rudy
  Matela,\ndistribued under the 3-clause BSD license.\n\n\n[Conjure's Haddock documentation]:
  https://hackage.haskell.org/package/code-conjure/docs/Conjure.html\n[fix]: https://hackage.haskell.org/package/base/docs/Data-Function.html#v:fix\n\n[symbol
  `>`]: https://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810780208\n[Template
  Haskell]: https://wiki.haskell.org/Template_Haskell\n\n[conjure-logo]: https://github.com/rudymatela/conjure/raw/master/doc/conjure.svg?sanitize=true\n\n[`code-conjure`]:
  \                  https://hackage.haskell.org/package/code-conjure\n[Conjure the
  BitTorrent client]:    https://hackage.haskell.org/package/conjure\n\n[Cabal]:   https://www.haskell.org/cabal\n[Haskell]:
  https://www.haskell.org/\n[leancheck]:      https://hackage.haskell.org/package/leancheck\n[express]:
  \       https://hackage.haskell.org/package/express\n[speculate]:      https://hackage.haskell.org/package/speculate\n[MagicHaskeller]:
  https://hackage.haskell.org/package/MagicHaskeller\n[Barliman]:       https://github.com/webyrd/Barliman\n\n[avoid
  using `cabal install`]:         https://github.com/haskell/cabal/issues/7373\n[latest
  Conjure version from Hackage]: https://hackage.haskell.org/package/code-conjure\n\n[build-log]:
  \   https://github.com/rudymatela/conjure/actions/workflows/build.yml\n[build-status]:
  https://github.com/rudymatela/conjure/actions/workflows/build.yml/badge.svg\n[hackage-version]:
  \                 https://img.shields.io/hackage/v/code-conjure.svg\n[code-conjure-on-hackage]:
  \         https://hackage.haskell.org/package/code-conjure\n[stackage-lts-badge]:
  \              https://stackage.org/package/code-conjure/badge/lts\n[stackage-nightly-badge]:
  \          https://stackage.org/package/code-conjure/badge/nightly\n[code-conjure-on-stackage]:
  \        https://stackage.org/package/code-conjure\n[code-conjure-on-stackage-lts]:
  \    https://stackage.org/lts/package/code-conjure\n[code-conjure-on-stackage-nightly]:
  https://stackage.org/nightly/package/code-conjure\n"
license-name: BSD-3-Clause

homepage: https://github.com/rudymatela/conjure#readme
changelog-type: markdown
hash: 434e4786a2427285711e93ee5a55decae95cefd57792dc25aea3aac4953cdf4c
test-bench-deps:
  base: ==4.*
  leancheck: -any
  speculate: -any
  code-conjure: -any
  express: -any
maintainer: Rudy Matela <rudy@matela.com.br>
synopsis: conjure Haskell functions out of partial definitions
changelog: "Changelog for (Code) Conjure\n============================\n\n\nv0.3.6\n------\n\n*
  add switch for descending recursions\n  to allow generation of `gcd`\n* refactor
  recursion generation (replace a hole later)\n* change `conjpureWith` to take `Args`\n*
  rename two args fields to `maxBodyRecursions` and `maxEvalRecursions`\n  at this
  point, the old names were misnomers.\n\n\nv0.3.4\n------\n\n* reallow recursions
  under `&&` and `||`\n  (simplifies the generated `or`, `and`, `set` and `elem` functions)\n*
  only require deconstructions on a non-empty subset of arguments\n  (allows `fib01`
  to be produced)\n* limit number of terminal evaluations in `recursiveToDynamic`\n*
  fix bug in `recursiveToDynamic` (not counting some recursions)\n* add 4 new benchmarks:
  `count`, `gcd`, `tree` and `setelem`\n\n\nv0.3.2\n------\n\n* significant runtime
  reduction in several benchmarks, e.g.:\n\t- take is now reachable in about 5 seconds\n*
  improved candidate generation:\n\t- faster runtime\n\t- fewer redundant/invalid
  candidates\n* limit recursive calls to use deconstructors\n\t- test to find deconstructors
  automatically\n* improve recursion evaluation method (`revaluate` replaces `recursexpr`)\n*
  add fibonacci benchmark\n* minor:\n\t- record runtimes with one decimal place instead
  of two\n\t- add longshot benchmark\n\t- add intercalate to the list benchmark\n\t-
  add stub `Conjure.Constructors` module\n\n\nv0.3.0\n------\n\n* only automatically
  include an `if` for the return type of the given function\n* add the `take-drop`
  benchmark\n* make bottom-up enumeration more type directed\n\n\nv0.2.8\n------\n\n*
  export the `A`, `B`, `C`, `D`, `E` and `F` helper types\n\n\nv0.2.6\n------\n\n*
  require Express v0.1.10 due to `hasHole` being now exported there\n* require Eq
  result on `conjure1`, `conjure2` and `conjure3`\n* code cleanup and more tests\n\n\nv0.2.4\n------\n\n*
  allow conjuring from specifications in addition to partial definitions\n  (`conjure1`,
  `conjure2`, `conjure3` and related functions)\n* improve examples\n* improve criteria
  for automatic primitive inclusion:\n\t- only include `if :: ... -> Bool` if there
  are `Bool` primitives\n\t- include `False` and `True` automatically only on Speculate's
  background\n* add code-optional candidate nubbing and debug functions\n\n\nv0.2.2\n------\n\n*
  by default, search for 60 argument combinations\n  among 100000 enumerated combinations\n\n\nv0.2.0\n------\n\n*
  search until 100% match is found and exit\n* other misc changes\n\n\nv0.1.2\n------\n\nFor
  the changelog of earlier versions, check the git commit history.\n"
basic-deps:
  base: '>=4 && <5'
  leancheck: '>=0.9.10'
  speculate: '>=0.4.8'
  express: '>=0.1.14'
  template-haskell: -any
all-versions:
- 0.0.2
- 0.0.4
- 0.1.0
- 0.1.2
- 0.2.0
- 0.2.2
- 0.2.4
- 0.2.6
- 0.2.8
- 0.3.0
- 0.3.2
- 0.3.4
- 0.3.6
author: Rudy Matela
latest: 0.3.6
description-type: markdown
description: "Conjure\n=======\n\n[![Conjure's Build Status][build-status]][build-log]\n[![Conjure
  on Hackage][hackage-version]][code-conjure-on-hackage]\n[![Conjure on Stackage LTS][stackage-lts-badge]][code-conjure-on-stackage-lts]\n[![Conjure
  on Stackage Nightly][stackage-nightly-badge]][code-conjure-on-stackage-nightly]\n\n![Conjure
  logo][conjure-logo]\n\nConjure is a tool that produces Haskell functions out of
  partial definitions.\n\nThis is currently an experimental tool in its early stages,\ndon't
  expect much from its current version.\nIt is just a piece of curiosity in its current
  state.\n\n\nInstalling\n----------\n\nTo install the [latest Conjure version from
  Hackage], just run:\n\n\t$ cabal update\n\t$ cabal v1-install code-conjure\n\nIf
  you are using Cabal v3.0 or later,\n[avoid using `cabal install`] for the time being\nand
  use `v1-install` instead.\n\nPrerequisites are [express], [leancheck] and [speculate].\nThey
  should be automatically resolved and installed by [Cabal].\n\nNOTE: the name of
  the Hackage package is __[`code-conjure`]__\n-- not to be confused with [Conjure
  the BitTorrent client].\n\n\nConjuring functions\n-------------------\n\nGiven\n\n\tsquare
  :: Int -> Int\n\tsquare 0  =  0\n\tsquare 1  =  1\n\tsquare 2  =  4\n\nand\n\n\tprimitives
  :: [Expr]\n\tprimitives  =  [ val (0::Int)\n\t               , val (1::Int)\n\t
  \              , value \"+\" ((+) :: Int -> Int -> Int)\n\t               , value
  \"*\" ((*) :: Int -> Int -> Int)\n\t               ]\n\nrunning\n\n\t> conjure \"square\"
  square primitives\n\nyields\n\n\tsquare :: Int -> Int\n\t-- testing 3 combinations
  of argument values\n\t-- looking through 3 candidates of size 1\n\t-- looking through
  3 candidates of size 2\n\t-- looking through 5 candidates of size 3\n\tsquare x
  \ =  x * x\n\nin less than a second.\n\nSee the `eg/arith.hs` example.\n\n\nConjuring
  recursive functions\n-----------------------------\n\nGiven\n\n\tfactorial :: Int
  -> Int\n\tfactorial 0  =  1\n\tfactorial 1  =  1\n\tfactorial 2  =  2\n\tfactorial
  3  =  6\n\tfactorial 4  =  24\n\tfactorial 5  =  120\n\nand\n\n\tprimitives :: [Expr]\n\tprimitives
  \ =  [ val (0::Int)\n\t               , val (1::Int)\n\t               , value \"+\"
  ((+) :: Int -> Int -> Int)\n\t               , value \"*\" ((*) :: Int -> Int ->
  Int)\n\t               , value \"dec\" (subtract 1 :: Int -> Int)\n\t               ,
  value \"==\" ((==) :: Int -> Int -> Bool)\n\t               ]\n\nrunning\n\n\t>
  conjure \"factorial\" factorial primitives\n\nyields\n\n\tfactorial :: Int -> Int\n\t--
  testing 6 combinations of argument values\n\t-- looking through 3 candidates of
  size 1\n\t-- looking through 5 candidates of size 2\n\t-- looking through 8 candidates
  of size 3\n\t-- looking through 26 candidates of size 4\n\t-- looking through 59
  candidates of size 5\n\t-- looking through 167 candidates of size 6\n\t-- looking
  through 581 candidates of size 7\n\t-- looking through 1654 candidates of size 8\n\t--
  looking through 5754 candidates of size 9\n\t-- looking through 17797 candidates
  of size 10\n\tfactorial n  =  if n == 0 then 1 else n * factorial (dec n)\n\nin
  about 3 seconds.\n\nSee the `eg/factorial.hs` example.\n\nIt is also possible to
  generate:\n\n    factorial n  =  if n == 0 then 1 else n * factorial (n - 1)\n\nin
  about 90s by including `(-) :: Int -> Int -> Int` in the primitives.\n\n\nRelated
  work\n------------\n\n[MagicHaskeller] (2007) is another tool\nthat is able to generate
  Haskell code automatically.\nIt supports recursion through\ncatamorphisms, paramorphisms
  and the [fix] function.\nIt is more mature than Conjure and is several orders of
  magnitude faster.\n\n[Barliman] for Lisp is another tool that does program synthesis.\n\nThere
  are hundreds of others,\nI'll add the most closely related here when I have the
  time.\n\n\nFurther reading\n---------------\n\nFor a detailed documentation of each
  function, see\n[Conjure's Haddock documentation].\n\n\nConjure, Copyright 2021  Rudy
  Matela,\ndistribued under the 3-clause BSD license.\n\n\n[Conjure's Haddock documentation]:
  https://hackage.haskell.org/package/code-conjure/docs/Conjure.html\n[fix]: https://hackage.haskell.org/package/base/docs/Data-Function.html#v:fix\n\n[symbol
  `>`]: https://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810780208\n[Template
  Haskell]: https://wiki.haskell.org/Template_Haskell\n\n[conjure-logo]: https://github.com/rudymatela/conjure/raw/master/doc/conjure.svg?sanitize=true\n\n[`code-conjure`]:
  \                  https://hackage.haskell.org/package/code-conjure\n[Conjure the
  BitTorrent client]:    https://hackage.haskell.org/package/conjure\n\n[Cabal]:   https://www.haskell.org/cabal\n[Haskell]:
  https://www.haskell.org/\n[leancheck]:      https://hackage.haskell.org/package/leancheck\n[express]:
  \       https://hackage.haskell.org/package/express\n[speculate]:      https://hackage.haskell.org/package/speculate\n[MagicHaskeller]:
  https://hackage.haskell.org/package/MagicHaskeller\n[Barliman]:       https://github.com/webyrd/Barliman\n\n[avoid
  using `cabal install`]:         https://github.com/haskell/cabal/issues/7373\n[latest
  Conjure version from Hackage]: https://hackage.haskell.org/package/code-conjure\n\n[build-log]:
  \   https://github.com/rudymatela/conjure/actions/workflows/build.yml\n[build-status]:
  https://github.com/rudymatela/conjure/actions/workflows/build.yml/badge.svg\n[hackage-version]:
  \                 https://img.shields.io/hackage/v/code-conjure.svg\n[code-conjure-on-hackage]:
  \         https://hackage.haskell.org/package/code-conjure\n[stackage-lts-badge]:
  \              https://stackage.org/package/code-conjure/badge/lts\n[stackage-nightly-badge]:
  \          https://stackage.org/package/code-conjure/badge/nightly\n[code-conjure-on-stackage]:
  \        https://stackage.org/package/code-conjure\n[code-conjure-on-stackage-lts]:
  \    https://stackage.org/lts/package/code-conjure\n[code-conjure-on-stackage-nightly]:
  https://stackage.org/nightly/package/code-conjure\n"
license-name: BSD-3-Clause

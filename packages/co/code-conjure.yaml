homepage: https://github.com/rudymatela/conjure#readme
changelog-type: ''
hash: 616b9675c0b7ddd203ace620aaaa34f49d18dde6dfbda23d1766957907715d37
test-bench-deps:
  base: '>=4 && <5'
  leancheck: -any
  speculate: -any
  code-conjure: -any
  express: -any
maintainer: Rudy Matela <rudy@matela.com.br>
synopsis: conjure Haskell functions out of partial definitions
changelog: ''
basic-deps:
  base: '>=4 && <5'
  leancheck: '>=0.9.4'
  speculate: '>=0.4.6'
  express: '>=0.1.6'
  template-haskell: -any
all-versions:
- 0.0.2
author: Rudy Matela
latest: 0.0.2
description-type: markdown
description: "Conjure\n=======\n\n[![Conjure's Build Status][build-status]][build-log]\n[![Conjure
  on Hackage][hackage-version]][code-conjure-on-hackage]\n[![Conjure on Stackage LTS][stackage-lts-badge]][code-conjure-on-stackage-lts]\n[![Conjure
  on Stackage Nightly][stackage-nightly-badge]][code-conjure-on-stackage-nightly]\n\n![Conjure
  logo][conjure-logo]\n\nConjure is a tool that produces Haskell functions out of
  partial definitions.\n\nThis is currently an experimental tool in its early stages,\ndon't
  expect much from its current version.\nIt is just a piece of curiosity in its current
  state.\n\n\nInstalling\n----------\n\nTo install the [latest Conjure version from
  Hackage], just run:\n\n\t$ cabal update\n\t$ cabal install code-conjure\n\nStarting
  from Cabal v3.0, you need to pass `--lib` as an argument to cabal\ninstall:\n\n\t$
  cabal install code-conjure --lib\n\nPrerequisites are [express], [leancheck] and
  [speculate].\nThey should be automatically resolved and installed by [Cabal].\n\nNOTE:
  the name of the Hackage package is __[`code-conjure`]__\n-- not to be confused with
  [Conjure the BitTorrent client].\n\n\nConjuring functions\n-------------------\n\nGiven\n\n\tsquare
  :: Int -> Int\n\tsquare 0  =  0\n\tsquare 1  =  1\n\tsquare 2  =  4\n\nand\n\n\tbackground
  :: [Expr]\n\tbackground =\n\t  [ val (0::Int)\n\t  , val (1::Int)\n\t  , value \"+\"
  ((+) :: Int -> Int -> Int)\n\t  , value \"*\" ((*) :: Int -> Int -> Int)\n\t  ,
  value \"==\" ((==) :: Int -> Int -> Bool)\n\t  ]\n\nrunning\n\n\t> conjure \"square\"
  square background\n\nyields\n\n\tsquare :: Int -> Int\n\t-- looking through 815
  candidates, 100% match, 3/3 assignments\n\tsquare x  =  x * x\n\nin less than a
  second.\n\nSee the `eg/arith.hs` example.\n\n\nConjuring recursive functions\n-----------------------------\n\nGiven\n\n\tfactorial
  :: Int -> Int\n\tfactorial 0  =  1\n\tfactorial 1  =  1\n\tfactorial 2  =  2\n\tfactorial
  3  =  6\n\tfactorial 4  =  24\n\tfactorial 5  =  120\n\nand\n\n\tbackground :: [Expr]\n\tbackground
  \ =\n\t  [ val (0::Int)\n\t  , val (1::Int)\n\t  , value \"+\" ((+) :: Int -> Int
  -> Int)\n\t  , value \"*\" ((*) :: Int -> Int -> Int)\n\t  , value \"dec\" (subtract
  1 :: Int -> Int)\n\t  , value \"isZero\" ((==0) :: Int -> Bool)\n\t  , val False\n\t
  \ , val True\n\t  , ifFor (undefined :: Int)\n\t  , value \"==\" ((==) :: Int ->
  Int -> Bool)\n\t  ]\n\nrunning\n\n\t> conjure \"factorial\" factorial background\n\nyields\n\n\tfactorial
  :: Int -> Int\n\t-- looking through 9266 candidates, 100% match, 6/6 assignments\n\tfactorial
  x  =  if isZero x then 1 else x * factorial (dec x)\n\nin about 3 seconds.\n\nSee
  the `eg/factorial.hs` example.\n\nIt is also possible to generate:\n\n    factorial
  x  =  if x == 0 then 1 else x * factorial x - 1\n\nin about 30s by changing the
  background and increasing the size limit.\n\n\nRelated work\n------------\n\n[MagicHaskeller]
  (2007) is another tool\nthat is able to generate Haskell code automatically.\nIt
  supports recursion through\ncatamorphisms, paramorphisms and the [fix] function.\nIt
  is more mature than Conjure and is several orders of magnitude faster.\n\n[Barliman]
  for Lisp is another tool that does program synthesis.\n\nThere are hundreds of others,\nI'll
  add the most closely related here when I have the time.\n\n\nFurther reading\n---------------\n\nFor
  a detailed documentation of each function, see\n[Conjure's Haddock documentation].\n\n\nConjure,
  Copyright 2020  Rudy Matela,\ndistribued under the 3-clause BSD license.\n\n\n[Conjure's
  Haddock documentation]: https://hackage.haskell.org/package/code-conjure/docs/Conjure.html\n[fix]:
  https://hackage.haskell.org/package/base/docs/Data-Function.html#v:fix\n\n[symbol
  `>`]: https://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810780208\n[Template
  Haskell]: https://wiki.haskell.org/Template_Haskell\n\n[conjure-logo]: https://github.com/rudymatela/conjure/raw/master/doc/conjure.svg?sanitize=true\n\n[`code-conjure`]:
  \                  https://hackage.haskell.org/package/code-conjure\n[Conjure the
  BitTorrent client]:    https://hackage.haskell.org/package/conjure\n\n[Cabal]:   https://www.haskell.org/cabal\n[Haskell]:
  https://www.haskell.org/\n[leancheck]:      https://hackage.haskell.org/package/leancheck\n[express]:
  \       https://hackage.haskell.org/package/express\n[speculate]:      https://hackage.haskell.org/package/speculate\n[MagicHaskeller]:
  https://hackage.haskell.org/package/MagicHaskeller\n[Barliman]:       https://github.com/webyrd/Barliman\n\n[build-status]:
  \                    https://travis-ci.org/rudymatela/conjure.svg?branch=master\n[build-log]:
  \                       https://travis-ci.org/rudymatela/conjure\n[hackage-version]:
  \                 https://img.shields.io/hackage/v/code-conjure.svg\n[code-conjure-on-hackage]:
  \         https://hackage.haskell.org/package/code-conjure\n[stackage-lts-badge]:
  \              https://stackage.org/package/code-conjure/badge/lts\n[stackage-nightly-badge]:
  \          https://stackage.org/package/code-conjure/badge/nightly\n[code-conjure-on-stackage]:
  \        https://stackage.org/package/code-conjure\n[code-conjure-on-stackage-lts]:
  \    https://stackage.org/lts/package/code-conjure\n[code-conjure-on-stackage-nightly]:
  https://stackage.org/nightly/package/code-conjure\n"
license-name: BSD-3-Clause

homepage: ''
changelog-type: markdown
hash: 1c9e8fc4c95b4c25ef71b221f1d69015fce4fc6ebdd4afeec3d83991cb86664a
test-bench-deps:
  test-framework-hunit: -any
  test-framework: -any
  base: '>=4.16 && <5'
  test-framework-quickcheck2: '>=0.3'
  criterion: -any
  uniplate: -any
  HUnit: -any
  containers: -any
  th-expand-syns: -any
  mtl: '>=2.2.1'
  transformers: -any
  random: -any
  deepseq: -any
  QuickCheck: '>=2'
  template-haskell: -any
maintainer: paba@itu.dk
synopsis: Compositional Data Types
changelog: |
  0.13
  ---

  - Compatibility with GHC 9.2, 9.4, 9.6
  - GHC version 9.0 and older no longer supported
basic-deps:
  base: '>=4.16 && <4.19'
  containers: -any
  th-expand-syns: -any
  mtl: '>=2.2.1'
  transformers: -any
  deepseq: -any
  QuickCheck: '>=2'
  tree-view: '>=0.5'
  template-haskell: -any
all-versions:
- '0.1'
- '0.2'
- '0.3'
- '0.4'
- 0.4.1
- '0.5'
- 0.5.1
- 0.5.2
- 0.5.3
- '0.6'
- 0.6.1
- 0.6.1.1
- 0.6.1.2
- 0.6.1.3
- 0.6.1.4
- '0.7'
- 0.7.0.1
- 0.7.0.2
- '0.8'
- 0.8.0.1
- 0.8.1.0
- 0.8.1.1
- 0.8.1.2
- 0.8.1.3
- '0.9'
- '0.10'
- 0.10.1
- '0.11'
- '0.12'
- 0.12.1
- 0.13.0
author: Patrick Bahr, Tom Hvitved
latest: 0.13.0
description-type: haddock
description: |-
  This library implements the ideas of /Data types a la carte/
  (Journal of Functional Programming, 18(4):423-436, 2008,
  <http://dx.doi.org/10.1017/S0956796808006758>) as outlined in the
  paper /Compositional data types/ (Workshop on Generic Programming,
  83-94, 2011, <http://dx.doi.org/10.1145/2036918.2036930>). The
  purpose of this library is to allow the programmer to construct data
  types -- as well as the functions defined on them -- in a modular
  fashion. The underlying idea is to separate the signature of a data
  type from the fixed point construction that produces its recursive
  structure. Signatures can then be composed and decomposed freely.

  Building on that foundation, this library provides additional
  extensions and (run-time) optimisations which make compositional data types
  usable for practical implementations. In particular, it
  provides an excellent framework for manipulating and analysing
  abstract syntax trees in a type-safe manner. Thus, it is perfectly
  suited for programming language implementations, especially, in an environment
  consisting of a family of tightly interwoven /domain-specific languages/.

  In concrete terms, this library provides the following features:

  *  Compositional data types in the style of Wouter Swierstra's
  Functional Pearl /Data types a la carte/. The implementation of
  signature subsumption is based on the paper
  /Composing and Decomposing Data Types/ (Workshop on Generic
  Programming, 2014, to appear), which makes signature composition more
  flexible.

  *  Modular definition of functions on compositional data types through
  catamorphisms and anamorphisms as well as more structured
  recursion schemes such as primitive recursion  and co-recursion,
  and course-of-value iteration and co-iteration.

  *  Support for monadic computations via monadic variants of all
  recursion schemes.

  *  Support of a succinct programming style over compositional data types
  via generic programming combinators that allow various forms of
  generic transformations and generic queries.

  *  Generalisation of compositional data types (terms) to
  compositional data types \"with holes\" (contexts). This allows
  flexible reuse of a wide variety of catamorphisms (called
  /term homomorphisms/) as well as an efficient composition of them.

  *  Operations on signatures, for example, to add and remove
  annotations of abstract syntax trees. This includes combinators to
  propagate annotations fully automatically through certain
  term homomorphisms.

  *  Optimisation of the implementation of recursion schemes. This
  includes /short-cut fusion/ style optimisation rules which yield a
  performance boost of up to factor six.

  *  Automatic derivation of instances of all relevant type classes for
  using compositional data types via /Template Haskell/. This includes
  instances of 'Prelude.Eq', 'Prelude.Ord' and 'Prelude.Show' that are
  derived via instances for functorial variants of them. Additionally,
  also /smart constructors/, which allow to easily construct inhabitants
  of compositional data types, are automatically generated.

  *  /Mutually recursive data types/ and
  /generalised algebraic data types (GADTs)/. All of the above is also lifted
  to families of mutually recursive data types and (more generally) GADTs.
  This extension resides in the module "Data.Comp.Multi".

  Examples of using (generalised) compositional data types are bundled
  with the package in the folder @examples@.

  There are some supplementary packages, some of which were included
  in previous versions of this package:

  * @compdata-param@
  <https://hackage.haskell.org/package/compdata-param>: a parametric
  variant of compositional data types to deal with variable binders
  in a systematic way.

  * @compdata-automata@
  <https://hackage.haskell.org/package/compdata-automata>: advanced
  recursion schemes derived from tree automata that allow for a
  higher degree of modularity and make it possible to apply fusion.

  * @compdata-dags@
  <https://hackage.haskell.org/package/compdata-dags>: recursion
  schemes on directed acyclic graphs.
license-name: BSD-3-Clause

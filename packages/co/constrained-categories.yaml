all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.2.5.1
- 0.3.0.0
- 0.3.0.1
- 0.3.1.0
- 0.3.1.1
- 0.4.0.0
- 0.4.1.0
- 0.4.2.0
author: Justus Sagemüller
basic-deps:
  base: '>=4.8 && <5'
  contravariant: '>=0'
  fail: '>=0'
  semigroups: '>=0'
  tagged: '>=0'
  trivial-constraint: '>=0.4 && <0.8'
  void: '>=0'
changelog: ''
changelog-type: ''
description: |-
  Haskell has, and makes great use of, powerful facilities from category
  theory – basically various variants of functors.

  However, all those are just endofunctors in Hask, the category of
  all Haskell types with functions as morphisms. Which is sufficient
  for container / control structures that you want to be able to handle
  any type of data, but otherwise it's a bit limiting, seeing as
  there are (in maths, science etc.) many categories that cannot properly
  be represented this way. Commonly used libraries such as
  <http://hackage.haskell.org/package/vector-space> thus make
  little notion of the fact that the objects they deal with actually
  form a category, instead defining just specialised versions of
  the operations.

  This library generalises functors etc. to a much wider class of
  categories, by allowing for constraints on objects (so these can have
  extra properties required). At the same time, we try to keep as close
  as possible to the well-known Haskell type class hierarchies rather
  than exactly adopting the mathematicians' notions.

  Consider the README file, the examples, and/or the documentation to
  "Control.Category.Constrained" for how to make use of this.
description-type: haddock
hash: b25f8a7d23e847dcaff2cba5c03bbe868f17485ef17acc82796a90bd5cadf406
homepage: https://github.com/leftaroundabout/constrained-categories
latest: 0.4.2.0
license-name: GPL-3.0-only
maintainer: (@) jsag $ hvl.no
synopsis: Constrained clones of the category-theory type classes, using ConstraintKinds.
test-bench-deps: {}

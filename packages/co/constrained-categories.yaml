homepage: https://github.com/leftaroundabout/constrained-categories
changelog-type: ''
hash: 478e481b2ae62f3ff21c900ab9f26a5f01cc0b5b8f4a96f44c6e005970ed2639
test-bench-deps: {}
maintainer: (@) jsag $ hvl.no
synopsis: Constrained clones of the category-theory type classes, using ConstraintKinds.
changelog: ''
basic-deps:
  void: -any
  base: ! '>=4.7 && <5'
  semigroups: -any
  tagged: -any
  contravariant: -any
  trivial-constraint: ! '>=0.4 && <0.5'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.2.5.1
- 0.3.0.0
- 0.3.0.1
- 0.3.1.0
- 0.3.1.1
- 0.4.0.0
author: Justus Sagemüller
latest: 0.4.0.0
description-type: haddock
description: |-
  Haskell has, and makes great use of, powerful facilities from category
  theory – basically various variants of functors.

  However, all those are just endofunctors in Hask, the category of
  all Haskell types with functions as morphisms. Which is sufficient
  for container / control structures that you want to be able to handle
  any type of data, but otherwise it's a bit limiting, seeing as
  there are (in maths, science etc.) many categories that cannot properly
  be represented this way. Commonly used libraries such as
  <http://hackage.haskell.org/package/vector-space> thus make
  little notion of the fact that the objects they deal with actually
  form a category, instead defining just specialised versions of
  the operations.

  This library generalises functors etc. to a much wider class of
  categories, by allowing for constraints on objects (so these can have
  extra properties required). At the same time, we try to keep as close
  as possible to the well-known Haskell type class hierarchies rather
  than exactly adopting the mathematicians' notions.

  Consider the README file, the examples, and/or the documentation to
  "Control.Category.Constrained" for how to make use of this.
license-name: GPL-3.0-only

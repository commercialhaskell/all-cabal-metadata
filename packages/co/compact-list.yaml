all-versions:
- 0.1.0
author: Harendra Kumar
basic-deps:
  base: '>=4.8 && <5'
  ghc-prim: '>=0.2 && <0.6'
changelog: |
  ## 0.1.0

  * Initial release
changelog-type: markdown
description: |
  # compact-list

  [![Hackage](https://img.shields.io/hackage/v/compact-list.svg?style=flat)](https://hackage.haskell.org/package/compact-list)
  [![Build Status](https://travis-ci.org/composewell/compact-list.svg?branch=master)](https://travis-ci.org/composewell/compact-list)
  [![Windows Build status](https://ci.appveyor.com/api/projects/status/sndov45axamjt6bu?svg=true)](https://ci.appveyor.com/project/harendra-kumar/compact-list)

  If you hold on to a large data structure in garbage collected (GC) memory
  for relatively longer times it puts undue pressure on GC, unnecessarily
  increasing the work done by GC and also increasing the duration of GC
  pauses. A `CompactList` allows you to keep a large list in a Compact Region
  not touched by GC, thus avoiding any GC overhead.  This is essentially like
  a convenient in-memory append only file where you can write a list of
  Haskell values without having to marshall or serialize them.
description-type: markdown
hash: 47b500afaf39207ed9ec491fe2ec833d3f44e8bc18e867a86df8a398019f2af9
homepage: https://github.com/composewell/compact-list
latest: 0.1.0
license-name: BSD-3-Clause
maintainer: harendra.kumar@gmail.com
synopsis: An append only list in a compact region
test-bench-deps:
  base: '>=4.8 && <5'
  compact-list: '>=0'

homepage: https://github.com/freckle/graphula#readme
changelog-type: markdown
hash: 6a7db2a11131d50e562b2ad8aca02b6513ae1905eda4bc865f1448892a1175f3
test-bench-deps:
  bytestring: '>=0.10.12.0'
  base: '>=4.14.1.0 && <5'
  persistent: '>=2.11.0.4'
  hspec: '>=2.7.8'
  text: '>=1.2.4.1'
  generic-arbitrary: '>=0.1.0'
  markdown-unlit: '>=0.5.1'
  persistent-template: '>=2.9.1.0'
  http-api-data: '>=0.4.1.1'
  path-pieces: '>=0.2.1'
  containers: '>=0.6.2.1'
  graphula: -any
  unliftio-core: '>=0.2.0.1'
  monad-logger: '>=0.3.36'
  transformers: '>=0.5.6.2'
  QuickCheck: '>=2.14.2'
  resourcet: '>=1.2.4.2'
  persistent-sqlite: '>=2.11.1.0'
  aeson: '>=1.5.6.0'
maintainer: Freckle Education
synopsis: A simple interface for generating persistent data and linking its dependencies
changelog: |
  ## [*Unreleased*](https://github.com/freckle/graphula/compare/v2.0.1.0...main)

  None

  ## [v2.0.1.0](https://github.com/freckle/graphula/compare/v2.0.0.5...v2.0.1.0)

  - Add/improve documentation
  - Re-organize previously-internal module

  ## [v2.0.0.5](https://github.com/freckle/graphula/compare/v2.0.0.4...v2.0.0.5)

  - Release without dependencies upper bounds

  ## [v2.0.0.4](https://github.com/freckle/graphula/compare/v2.0.0.3...v2.0.0.4)

  - Relax persistent packages' upper bounds

  ## [v2.0.0.3](https://github.com/freckle/graphula/compare/v2.0.0.2...v2.0.0.3)

  - Relax dependencies upper bounds

  ## [v2.0.0.2](https://github.com/freckle/graphula/compare/v2.0.0.1...v2.0.0.2)

  - Support GHC-8.10 and unliftio-core 2.0.0

  ## [v2.0.0.1](https://github.com/faktory/graphula/tree/v2.0.0.1)

  First tagged release.
basic-deps:
  unliftio: '>=0.2.14'
  base: '>=4.14.1.0 && <5'
  persistent: '>=2.11.0.4'
  text: '>=1.2.4.1'
  semigroups: '>=0.19.1'
  HUnit: '>=1.6.1.0'
  generics-eot: '>=0.4.0.1'
  containers: '>=0.6.2.1'
  unliftio-core: '>=0.2.0.1'
  mtl: '>=2.2.2'
  transformers: '>=0.5.6.2'
  temporary: '>=1.3'
  random: '>=1.1'
  QuickCheck: '>=2.14.2'
  directory: '>=1.3.6.0'
all-versions:
- 2.0.0.1
- 2.0.0.2
- 2.0.0.3
- 2.0.0.4
- 2.0.0.5
- 2.0.1.0
author: ''
latest: 2.0.1.0
description-type: markdown
description: |
  # Graphula

  Graphula is a simple interface for generating persistent data and linking its
  dependencies. We use this interface to generate fixtures for automated testing.


  <!--
  ```haskell
  {-# LANGUAGE DeriveGeneric #-}
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE TypeApplications #-}
  {-# LANGUAGE TypeFamilies #-}
  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE GeneralizedNewtypeDeriving #-}
  {-# LANGUAGE TemplateHaskell #-}
  {-# LANGUAGE QuasiQuotes #-}
  {-# LANGUAGE DerivingStrategies #-}
  {-# LANGUAGE MultiParamTypeClasses #-}
  {-# LANGUAGE ExistentialQuantification #-}
  {-# LANGUAGE StandaloneDeriving #-}
  {-# LANGUAGE FlexibleInstances #-}
  {-# LANGUAGE UndecidableInstances #-}
  {-# OPTIONS_GHC -fno-warn-missing-deriving-strategies #-}
  {-# OPTIONS_GHC -fno-warn-orphans #-}

  module Main (module Main) where

  import Control.Monad.IO.Class
  import Control.Monad.IO.Unlift
  import Control.Monad.Logger (NoLoggingT)
  import Control.Monad.Trans.Reader (ReaderT)
  import Control.Monad.Trans.Resource (ResourceT)
  import Database.Persist.Sqlite
  import Database.Persist.TH
  import GHC.Generics (Generic)
  import Graphula
  import Test.Hspec
  import Test.QuickCheck
  import Test.QuickCheck.Arbitrary.Generic
  import Text.Markdown.Unlit ()

  instance (ToBackendKey SqlBackend a) => Arbitrary (Key a) where
    arbitrary = toSqlKey <$> arbitrary
  ```
  -->

  ## Arbitrary Data

  Graphula utilizes `QuickCheck` to generate random data. We need to declare
  `Arbitrary` instances for our models.

  ```haskell
  share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
  School
    name String
    deriving Show Eq Generic

  Teacher
    schoolId SchoolId
    name String
    deriving Show Eq Generic

  Course
    schoolId SchoolId
    teacherId TeacherId
    name String
    deriving Show Eq Generic

  Student
    name String
    deriving Show Eq Generic

  Question
    content String
    deriving Show Eq Generic

  Answer
    questionId QuestionId
    studentId StudentId
    yes Bool
    UniqueAnswer questionId studentId
    deriving Show Eq Generic
  |]

  instance Arbitrary School where
    arbitrary = genericArbitrary

  instance Arbitrary Teacher where
    arbitrary = genericArbitrary

  instance Arbitrary Course where
    arbitrary = genericArbitrary

  instance Arbitrary Student where
    arbitrary = genericArbitrary

  instance Arbitrary Question where
    arbitrary = genericArbitrary

  instance Arbitrary Answer where
    arbitrary = genericArbitrary
  ```

  ## Dependencies

  We declare dependencies via the `HasDependencies` typeclass and its associated
  type `Dependencies`. If a model does not have any dependencies, we only need to
  declare an empty instance.

  ```haskell
  instance HasDependencies School

  instance HasDependencies Student

  instance HasDependencies Question
  ```

  For single-dependency models, we use the `Only` type.

  ```haskell
  instance HasDependencies Teacher where
    type Dependencies Teacher = Only SchoolId
  ```

  Multi-dependency models use tuples. Declare these dependencies in the order they
  appear in the model's type definition. `HasDependencies` leverages generic
  programming to inject dependencies for you.

  ```haskell
  instance HasDependencies Course where
    type Dependencies Course = (SchoolId, TeacherId)

  instance HasDependencies Answer where
    type Dependencies Answer = (QuestionId, StudentId)
  ```

  ## Logging failures

  `runGraphulaLogged` will dump generated data to a temporary file. Or
  `runGraphulaLoggedWithFileT` can be used to pass an explicit path.

  ```haskell
  loggingSpec :: IO ()
  loggingSpec = do
    let
      logFile :: FilePath
      logFile = "test.graphula"

      failingGraph :: IO ()
      failingGraph = runGraphulaT Nothing runDB . runGraphulaLoggedWithFileT logFile $ do
        student <- node @Student () mempty
        question <- node @Question () mempty
        answer <- node @Answer
          (entityKey question, entityKey student)
          $ edit $ \a -> a { answerYes = True }

        -- Test failures will cause the graph to be logged (not any exception)
        liftIO $ answerYes (entityVal answer) `shouldBe` False

    failingGraph `shouldThrow` anyException

    n <- lines <$> readFile logFile
    n `shouldSatisfy` (not . null)
  ```

  ## Running It

  ```haskell
  simpleSpec :: IO ()
  simpleSpec =
    runGraphulaT Nothing runDB $ do
      school <- node @School () mempty
      teacher <- node @Teacher (Only $ entityKey school) mempty
      course <- node @Course (entityKey school, entityKey teacher) mempty
      student <- node @Student () $ edit $ \s -> s { studentName = "Pat" }
      question <- node @Question () mempty
      answer <- node @Answer
        (entityKey question, entityKey student)
        $ edit $ \a -> a { answerYes = True }

      liftIO $ do
        -- Typically, you would run some other function like "fetch correct
        -- answers at school" and assert you found the correct answers you
        -- generated. In this example we just assert some things about the data
        -- directly:
        teacherSchoolId (entityVal teacher) `shouldBe` entityKey school
        courseTeacherId (entityVal course) `shouldBe` entityKey teacher
        answerYes (entityVal answer) `shouldBe` True
  ```

  <!--
  ```haskell
  main :: IO ()
  main = hspec $
    describe "graphula" . parallel $ do
      it "generates and links arbitrary graphs of data" simpleSpec
      it "allows logging graphs" loggingSpec

  runDB :: MonadUnliftIO m => ReaderT SqlBackend (NoLoggingT (ResourceT m)) a -> m a
  runDB f = runSqlite "test.db" $ do
    runMigration migrateAll
    f
  ```
  -->
license-name: MIT

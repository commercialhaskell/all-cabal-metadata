homepage: https://github.com/lsrcz/grisette-haskell#readme
changelog-type: markdown
hash: 2526b89d25e38003b9f3370c9595d653f38123d656c812ccdc78ffdbf9360e53
test-bench-deps:
  once: '>=0.2 && <0.5'
  grisette: -any
  sbv: '>=8.11 && <9.1'
  bytestring: '>=0.10.12 && <0.12'
  base: '>4.14 && <5'
  th-compat: '>=0.1.2 && <0.2'
  unordered-containers: '>=0.2.11 && <0.3'
  generic-deriving: '>=1.14.1 && <1.15'
  doctest: '>=0.18.2 && <0.21'
  array: '>=0.5.4 && <0.6'
  loch-th: '>=0.2.2 && <0.3'
  tasty-test-reporter: '>=0.1.1.2 && <0.2'
  hashtables: '>=1.2.3.4 && <1.4'
  intern: '>=0.9.2 && <0.10'
  tasty-quickcheck: '>=0.10.1 && <0.11'
  mtl: '>=2.2.2 && <2.3'
  hashable: '>=1.2.3 && <1.5'
  tasty-hunit: ==0.10.*
  transformers: '>=0.5.6 && <0.6'
  tasty: '>=1.1.0.3 && <1.5'
  parallel: -any
  deepseq: '>=1.4.4 && <1.5'
  Glob: -any
  template-haskell: '>=2.16 && <2.20'
  call-stack: '>=0.1 && <0.5'
  vector: '>=0.12.1 && <0.14'
maintainer: Sirui Lu (siruilu@cs.washington.edu)
synopsis: Symbolic evaluation as a library
changelog: |-
  # Changes

  ## Version 0.2.0.0

  ### Feature
  - Redesigned symbolic value interface.
    - `Sym Bool`/`Sym Integer`, etc., are no longer available and are replaced with `SymBool` and `SymInteger`. ([#41](https://github.com/lsrcz/grisette/pull/41))
    - New symbolic bit vector interface. Added unsized bit vector. ([#41](https://github.com/lsrcz/grisette/pull/41))
  - Add term size count API. ([#48](https://github.com/lsrcz/grisette/pull/48), [#53](https://github.com/lsrcz/grisette/pull/53))
  - Add timeout to solver interface. ([#49](https://github.com/lsrcz/grisette/pull/49), [#50](https://github.com/lsrcz/grisette/pull/50))
  - Add parallel do-notation for parallel symbolic compilation. ([#51](https://github.com/lsrcz/grisette/pull/51))
  - New safe operator interfaces. ([#56](https://github.com/lsrcz/grisette/pull/56))


  ### Bugfix
  - Dropped merging cache for `UnionM`. This fixed some segmentation fault errors. ([#43](https://github.com/lsrcz/grisette/pull/43))
  - Added some missing instances for symbolic values and bit vectors. ([#46](https://github.com/lsrcz/grisette/pull/46), [#61](https://github.com/lsrcz/grisette/pull/61))
  - Fix CEGIS when no symbolic input is present. ([#52](https://github.com/lsrcz/grisette/pull/52))
  - Fix overlapping `ToSym` and `ToCon` instances. ([#54](https://github.com/lsrcz/grisette/pull/54))
  - Fix uninterpreted function lowering. ([#57](https://github.com/lsrcz/grisette/pull/57), [#58](https://github.com/lsrcz/grisette/pull/58))
  - Add missing instances for `MonadFresh` and `FreshT`. ([#59](https://github.com/lsrcz/grisette/pull/59))
  - Fix CEGIS crash when subsequent solver calls introduces new symbolic constant. ([#60](https://github.com/lsrcz/grisette/pull/60))



  ## Version 0.1.0.0
  Initial release.
basic-deps:
  once: '>=0.2 && <0.5'
  sbv: '>=8.11 && <9.1'
  bytestring: '>=0.10.12 && <0.12'
  base: '>4.14 && <5'
  th-compat: '>=0.1.2 && <0.2'
  unordered-containers: '>=0.2.11 && <0.3'
  generic-deriving: '>=1.14.1 && <1.15'
  array: '>=0.5.4 && <0.6'
  loch-th: '>=0.2.2 && <0.3'
  hashtables: '>=1.2.3.4 && <1.4'
  intern: '>=0.9.2 && <0.10'
  mtl: '>=2.2.2 && <2.3'
  hashable: '>=1.2.3 && <1.5'
  transformers: '>=0.5.6 && <0.6'
  parallel: -any
  deepseq: '>=1.4.4 && <1.5'
  template-haskell: '>=2.16 && <2.20'
  call-stack: '>=0.1 && <0.5'
  vector: '>=0.12.1 && <0.14'
all-versions:
- 0.1.0.0
- 0.2.0.0
author: Sirui Lu, Rastislav BodÃ­k
latest: 0.2.0.0
description-type: markdown
description: "# Grisette\n\n[![Haskell Tests](https://github.com/lsrcz/grisette/actions/workflows/test.yml/badge.svg)](https://github.com/lsrcz/grisette/actions/workflows/test.yml)\n\nGrisette
  is a symbolic evaluation library for Haskell. By translating\nprograms into constraints,
  Grisette can help the development of program\nreasoning tools, including verification
  and synthesis.\n\nFor a detailed description of the system, please refer to our
  POPL'23 paper\n[Grisette: Symbolic Compilation as a Functional Programming Library](https://lsrcz.github.io/files/POPL23.pdf).\n\n##
  Features\n\n- **Multi-path** symbolic evaluation with efficient (customizable) state
  merging.\n- Symbolic evaluation is **purely functional**. The propagated symbolic
  value includes the assertion / error state of the execution, yet it is just a data
  structure. As a result, Grisette is a library that does not modify the Haskell compiler.
  \ \n- The separation of symbolic and concrete values is enforced with **static types**.
  These types help discover opportunities for partial evaluation as well as safe use
  of Haskell libraries. \n\n## Design and Benefits \n\n- Modular purely functional
  design, with a focus on composability.\n  - Allows for symbolic evaluation of user-defined
  data structures / data\n    structures from third-party libraries.\n  - Allows for
  symbolic evaluation of error-handling code with user-defined\n    error types.\n
  \ - Allows for memoization (tested and benchmarked) / parallelization (not\n    tested
  and benchmarked yet) of symbolic evaluation.\n- Core multi-path symbolic evaluation
  semantics modeled as a monad, allowing for\n  easy integration with other monadic
  effects, for example:\n  - error handling via `ExceptT`,\n  - stateful computation
  via `StateT`,\n  - unstructured control flow via `ContT`, etc.\n\n## Installation\n\n###
  Install Grisette\n\nGrisette is available via\n[Hackage](https://hackage.haskell.org/package/grisette).
  You can install it with\n`cabal`:\n\n```bash\n$ cabal install grisette\n```\n\nHowever,
  Grisette is a library and is usually used as a dependency of other\npackages. You
  can add it to your project's `.cabal` file:\n\n```cabal\nlibrary\n  ...\n  build-depends:
  grisette >= 0.1 < 0.2\n```\n\n### Install SMT Solvers\n\nTo run the examples, you
  also need to install an SMT solver and make it \navailable through `PATH`. We recommend
  that you start with\n[Z3](https://github.com/Z3Prover/z3), as it supports all our
  examples and is\nusually easier to install.\n[Boolector](https://github.com/Boolector/boolector)
  is significantly more\nefficient on some examples, but it does not support all of
  the examples.\n\n#### Install Z3\n\nOn Ubuntu, you can install Z3 with:\n\n```bash\n$
  apt update && apt install z3\n```\n\nOn macOS, with [Homebrew](https://brew.sh/),
  you can install Z3 with:\n\n```bash\nbrew install z3\n```\n\nYou may also build
  Z3 from source, which may be more efficient on your system.\nPlease refer to the
  [Z3 homepage](https://github.com/Z3Prover/z3) for the build\ninstructions.\n\n####
  Install Boolector\n\nBoolector from major package managers are usually outdated
  or inexist. We\nrecommend that you build Boolector from source with the CaDiCaL
  SAT solver,\nwhich is usually more efficient on our examples.\nPlease refer to the
  [Boolector homepage](https://github.com/Boolector/boolector)\nfor the build instructions.\n\n##
  Example\n\nThe following example uses Grisette to build a synthesizer of arithmetic
  programs. Given the input-output pair (2,5), the synthesizer may output the program
  (\\x -> x+3).  The example is adapted from [this blog\npost](https://www.cs.utexas.edu/~bornholt/post/building-synthesizer.html)
  by\nJames Bornholt.\n\n\nThe example has three parts:\n- We define the arithmetic
  language. The language is _symbolic_:\n  - its syntax tree represents a set of concrete
  syntax trees, and\n  - its interpreter accepts such symbolic syntax trees, and interprete
  at once all represented concrete syntax trees. \n- We define the candidate program
  space of the synthesizer by creating a particular symbolic syntax tree. The synthesizer
  will search the space of concrete trees for a solution. \n- We interpret the symbolic
  syntax tree and pass the resulting constraints to the solver. If a solution exists,
  the solver returns a concrete tree that agrees with the input-out example. \n\n###
  Defining the Arithmetic Language\n\nWe will synthesize single-input programs in
  this example.\nA single input program will be `\\x -> E`, where `E` is an expression
  defined by\nthe following grammar:\n\n```\nE -> c      -- constant\n   | x      --
  value for input variable\n   | E + E  -- addition\n   | E * E  -- multiplication\n```\n\nThe
  syntax defines how a concrete expression is represented. To synthesis a\nprogram,
  we need to define symbolic program spaces. This relies on the `UnionM`\ncontainer
  provided by the library to represent multiple ASTs compactly in a\nsingle value.\n\nTo
  make this expression space type work with Grisette, a set of type classes\nshould
  be derived. This includes `Mergeable`, `EvaluateSym`, etc.\nThe `Mergeable` type
  classes allows to represent multiple ASTs compactly in a\n`UnionM`, while the `EvaluateSym`
  type class allows to evaluate it given a model\nreturned by a solver to replace
  the symbolic holes inside to concrete values.\n\n```haskell\ndata SExpr\n  -- `SConst`
  represents a constant in the syntax tree.\n  --\n  -- `SConst 1` is the constant
  1, while `SConst \"c1\"` is a symbolic constant,\n  -- and the solver can be used
  to find out what the concrete value should be.\n  = SConst SymInteger\n  -- `SInput`
  is very similar to the `SConst`, but is for inputs. We separate\n  -- these two
  mainly for clarity.\n  | SInput SymInteger\n  -- `SPlus` and `SMul` represent the
  addition and multiplication operators.\n  --\n  -- The children are **sets** of
  symbolic programs. Here `UnionM`s are such\n  -- sets.\n  --\n  -- The solver will
  try to pick one concrete program from the set of programs.\n  | SPlus (UnionM SExpr)
  (UnionM SExpr)\n  | SMul (UnionM SExpr) (UnionM SExpr)\n  -- `Generic` helps us
  derive other type class instances for `SExpr`.\n  deriving stock (Generic, Show)\n
  \ -- Some type classes provided by Grisette for building symbolic evaluation\n  --
  tools. See the documentation for more details.\n  deriving (Mergeable, EvaluateSym)\n
  \   via (Default SExpr)\n\n-- A template haskell procedure to help the construction
  of `SExpr` sets.\n--\n-- >>> SConst 1 :: SExpr\n-- SConst 1\n-- >>> mrgSConst 1
  :: UnionM SExpr\n-- UMrg (Single (SConst 1))\n$(makeUnionWrapper \"mrg\" ''SExpr)\n```\nThen
  we can define the program space.\nThe following code defines a program space `\\x
  -> x + {x, c}`. Some example\nprograms in this space are `\\x -> x + x`, `\\x ->
  x + 1`, and `\\x -> x + 2`.\nThe solver will be used to choose the right hand side
  of the addition. It may\nchoose to use the input variable `x`, or synthesize a constant
  `c`.\n\n```haskell\nspace :: SymInteger -> SExpr\nspace x = SPlus\n  (mrgSInput
  x)\n  (mrgIf \"choice\" (mrgSInput x) (mrgSConst \"c\"))\n```\n\nWe then need to
  convert this program space to its logical encoding, and we do this by writing an
  interpreter to interpret all the\nexpressions represented by an `SExpr` all at once.
  The interpreter looks very\nsimilar to a normal interpreter, except that the `onUnion`
  combinator is used\nto lift the interpreter to work on `UnionM` values.\n\n```haskell\ninterpret
  :: SExpr -> SymInteger\ninterpret (SInt x) = x\ninterpret (SPlus x y) = interpretU
  x + interpretU y\ninterpret (SMul x y) = interpretU x * interpretU y\n\n-- interpet
  a set of programs\ninterpretU :: UnionM SExpr -> SymInteger\ninterpretU = onUnion
  interpret\n```\n\nAnd we can compose the interpreter with the program space to get
  it executable.\n\n```haskell\nexecutableSpace :: Integer -> SymInteger\nexecutableSpace
  = interpret . space . toSym\n```\n\nThen we can do synthesis. We call the program
  space on the input 2, and construct the constraint that the result is equal to 5.
  We then call the solver with the `solve` function. The solver is able to find a
  solution, and it will return the assignments to the symbolic constants as a model.\n\nWe
  can then use the model to evaluate the program space, and get the synthesized program.\n\n```haskell\nexample
  :: IO ()\nexample = do\n  Right model <- solve (UnboundedReasoning z3) $ executableSpace
  2 ==~ 5\n  print $ evaluateSym False model (space \"x\")\n  -- result: SPlus {SInput
  x} {SConst 3}\n  let synthesizedProgram :: Integer -> Integer =\n        evaluateSymToCon
  model . executableSpace\n  print $ synthesizedProgram 10\n  -- result: 13\n```\n\nFor
  more details, please refer to [the Grisette examples](https://github.com/lsrcz/grisette-examples)
  (WIP).\n\n## Documentation\n\n- Haddock documentation at  [grisette](https://hackage.haskell.org/package/grisette).\n-
  Grisette essentials (WIP).\n- Grisette tutorials (WIP).\n\n## License\nThe Grisette
  library is distributed under the terms of the BSD3 license. The\n[LICENSE](LICENSE)
  file contains the full license text.\n\n## Citing Grisette\nIf you use Grisette
  in your research, please use the following bibtex entry:\n\n```bibtex\n@article{10.1145/3571209,\nauthor
  = {Lu, Sirui and Bod\\'{\\i}k, Rastislav},\ntitle = {Grisette: Symbolic Compilation
  as a Functional Programming Library},\nyear = {2023},\nissue_date = {January 2023},\npublisher
  = {Association for Computing Machinery},\naddress = {New York, NY, USA},\nvolume
  = {7},\nnumber = {POPL},\nurl = {https://doi.org/10.1145/3571209},\ndoi = {10.1145/3571209},\nabstract
  = {The development of constraint solvers simplified automated reasoning about programs
  and shifted the engineering burden to implementing symbolic compilation tools that
  translate programs into efficiently solvable constraints. We describe Grisette,
  a reusable symbolic evaluation framework for implementing domain-specific symbolic
  compilers. Grisette evaluates all execution paths and merges their states into a
  normal form that avoids making guards mutually exclusive. This ordered-guards representation
  reduces the constraint size 5-fold and the solving time more than 2-fold. Grisette
  is designed entirely as a library, which sidesteps the complications of lifting
  the host language into the symbolic domain. Grisette is purely functional, enabling
  memoization of symbolic compilation as well as monadic integration with host libraries.
  Grisette is statically typed, which allows catching programming errors at compile
  time rather than delaying their detection to the constraint solver. We implemented
  Grisette in Haskell and evaluated it on benchmarks that stress both the symbolic
  evaluation and constraint solving.},\njournal = {Proc. ACM Program. Lang.},\nmonth
  = {jan},\narticleno = {16},\nnumpages = {33},\nkeywords = {State Merging, Symbolic
  Compilation}\n}\n```\n"
license-name: BSD-3-Clause

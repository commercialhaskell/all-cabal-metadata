homepage: https://github.com/caraus-ecms/graphql#readme
changelog-type: markdown
hash: cde8774292393417b6ad834f0b6e91871940b154abbf306db1fca6eba1c6a4f9
test-bench-deps:
  exceptions: '>=0.10.4 && <0.11'
  base: '>=4.7 && <5'
  parser-combinators: '>=1.2.1 && <1.3'
  unordered-containers: '>=0.2.10.0 && <0.3'
  hspec: '>=2.7.2 && <2.8'
  text: '>=1.2.4.0 && <1.3'
  megaparsec: '>=8.0.0 && <8.1'
  conduit: '>=1.3.2 && <1.4'
  containers: '>=0.6.2.1 && <0.7'
  raw-strings-qq: ==1.1.*
  hspec-megaparsec: '>=2.1.0 && <2.2'
  transformers: '>=0.5.6.2 && <0.6'
  scientific: '>=0.3.6.2 && <0.4'
  QuickCheck: '>=2.13.2 && <2.14'
  aeson: '>=1.4.7.1 && <1.5'
  graphql: -any
  hspec-expectations: '>=0.8.2 && <0.9'
maintainer: belka@caraus.de
synopsis: Haskell GraphQL implementation
changelog: "# Changelog\nAll notable changes to this project will be documented in
  this file.\n\nThe format is based on\n[Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand
  this project adheres to\n[Haskell Package Versioning Policy](https://pvp.haskell.org/).\n\n##
  [0.10.0.0] - 2020-08-29\n## Changed\n- `Test.Hspec.GraphQL.*`: replace `IO` in the
  resolver with any `MonadCatch`.\n- The `Location` argument of `AST.Document.Definition.ExecutableDefinition`
  was\n  moved to `OperationDefinition` and `FragmentDefinition` since these are the\n
  \ actual elements that have a location in the document.\n- `Validate.Rules` get
  the whole validation context (AST and schema).\n\n## Added\n- `Validate.Validation`
  contains data structures and functions used by the\n  validator and concretet rules.\n-
  `Validate.Rules`: operation validation rules.\n\n## [0.9.0.0] - 2020-07-24\n## Fixed\n-
  Location of a parse error is returned in a singleton array with key\n  `locations`.\n-
  Parsing comments in the front of definitions.\n- Some missing labels were added
  to the parsers, some labels were fixed to\n  refer to the AST nodes being parsed.
  \n\n## Added\n- `AST` reexports `AST.Parser`.\n- `AST.Document.Location` is a token
  location as a line and column pair.\n- `Execute` reexports `Execute.Coerce`.\n-
  `Error.Error` is an error representation with a message and source location.\n-
  `Error.Response` represents a result of running a GraphQL query.\n- `Type.Schema`
  exports `Type` which lists all types possible in the schema.\n- Parsing subscriptions.\n-
  `Error.ResponseEventStream`, `Type.Out.Resolve`, `Type.Out.Subscribe` and\n  `Type.Out.SourceEventStream`
  define subscription resolvers.\n- `Error.ResolverException` is an exception that
  can be thrown by (field value\n  and event stream) resolvers to signalize an error.
  Other exceptions will\n  escape.\n- `Test.Hspec.GraphQL` contains some test helpers.\n-
  `Validate` contains the validator and standard rules.\n\n## Changed\n- `Type.Out.Resolver`:
  Interface fields don't have resolvers, object fields\n  have value resolvers, root
  subscription type resolvers need an additional\n  resolver that creates an event
  stream. `Resolver` represents these differences\n  now and pairs a field with the
  function(s). Resolvers don't have `ExceptT`,\n  errors are handled with `MonadThrow`/`MonadCatch`.\n-
  All code from `Trans` is moved to `Type.Out` and exported by `Type` and\n  `Type.Out`.\n-
  `AST.Core` contained only `Arguments` which was moved to `Type.Definition`.\n  `AST`
  provides now only functionality related to parsing and encoding, as it\n  should
  be.\n- `Execute.execute` takes an additional argument, a possible operation name\n
  \ and returns either a stream or the response.\n- `Error` module was changed to
  work with dedicated types for errors and the\n  response instead of JSON.\n- `graphqlSubs`
  takes an additional argument, the operation name. The type of\n  variable names
  is changed back to JSON since it is a common format and it\n  saves additional conversions.
  Custom format still can be used with the\n  underlying functions (in the `Execute`
  module). The function returns either a\n  a stream or the resolved value.\n- `graphql`
  returns either a stream or the resolved value.\n- The constraint of the base monad
  was changed to `MonadCatch` (and it implies\n  `MonadThrow`).\n\n## Removed\n- `Trans.ActionT`
  is an unneeded layer of complexity. `Type.Out.Resolver`\n  represents possible resolver
  configurations.\n- `Execute.executeWithName`. `Execute.execute` takes the operation
  name and\n   completely replaces `executeWithName`.\n\n## [0.8.0.0] - 2020-06-20\n###
  Fixed\n- The parser rejects variables when parsing defaultValue (DefaultValue).
  The\n  specification defines default values as `Value` with `const` parameter and\n
  \ constants cannot be variables. `AST.Document.ConstValue` was added,\n  `AST.Document.ObjectField`
  was modified.\n- AST transformation should never fail.\n    * Arguments and fields
  with a missing variable as value should be left out.\n    * Invalid (recusrive or
  non-existing) fragments should be skipped.\n- Argument value coercion.\n- Variable
  value coercion.\n- Result coercion.\n- The executor should skip the fields missing
  in the object type and not fail.\n- Merging subselections.\n\n### Changed\n- `Schema.Resolver`
  was moved to `Type.Out`, it is a field and resolver function\n  pair.\n- `AST.Core.Value`
  was moved into `Type.Definition`. These values are used only\n  in the execution
  and type system, it is not a part of the parsing tree.\n- `Type` module is superseded
  by `Type.Out`. This module contains now only\n  exports from other module that complete
  `Type.In` and `Type.Out` exports.\n- `Error.CollectErrsT` contains the new `Resolution`
  data structure.\n  `Resolution` represents the state used by the executor. It contains
  all types\n  defined in the schema and collects the thrown errors.\n\n### Added\n-
  `Type.Definition` contains base type system definition, e.g. Enums and\n  Scalars.\n-
  `Type.Schema` describes a schema. Both public functions that execute queries\n  accept
  a `Schema` now instead of a `HashMap`. The execution fails if the root\n  operation
  doesn't match the root Query type in the schema.\n- `Type.In` and `Type.Out` contain
  definitions for input and output types.\n- `Execute.Coerce` defines a typeclass
  responsible for input, variable value\n  coercion. It decouples us a bit from JSON
  since any format can be used to pass\n  query variables. Execution functions accept
  (`HashMap Name a`) instead of\n  `Subs`, where a is an instance of `VariableValue`.\n\n###
  Removed\n- `Schema.scalar`, `Schema.wrappedScalar`. They accepted everything can
  be\n  converted to JSON and JSON is not suitable as an internal representation for\n
  \ GraphQL. E.g. GraphQL distinguishes between Floats and Integers.\n- `Schema.wrappedObject`,
  `Schema.object`, `Schema.resolversToMap`. There is no\n  need in special functions
  to construct field resolvers anymore, resolvers are\n  normal functions attached
  to the fields in the schema representation.\n- `Schema.resolve` is superseded by
  `Execute.Execution`.\n- `Error.runAppendErrs` isn't used anywhere.\n- `AST.Core`:
  `Document`, `Directive`, `Field`, `Fragment`, `Selection`, `Alias`\n  `TypeCondition`
  were modified, moved into `Execute.Transform.Document` and\n  made private. These
  types describe intermediate representation used by the\n  executor internally. Moving
  was required to avoid cyclic dependencies between\n  the executor and type system.\n-
  `AST.Core` doesn't reexports anything.\n\n## [0.7.0.0] - 2020-05-11\n### Fixed\n-
  Result of null encoding\n- Block strings encoding\n- Result of tab and newline encoding\n\n###
  Added\n- AST for the GraphQL schema.\n- Type system definition parser.\n- `Trans.argument`.\n-
  Schema extension parser.\n- Contributing guidelines.\n- `Schema.resolversToMap`
  (intended to be used internally).\n\n### Changed\n- Rename `AST.Definition` into
  `AST.Document.ExecutableDefinition`.\n  `AST.Document.TypeSystemDefinition` and
  `AST.Document.TypeSystemExtension`\n  can also be definitions.\n- Move all AST data
  to `AST.Document` and reexport them.\n- Rename `AST.OperationSelectionSet` to `AST.Document.SelectionSet`.\n-
  Make `Schema.Subs` a `Data.HashMap.Strict` (was a function\n  `key -> Maybe value`
  before).\n- Make `AST.Lexer.at` a text (symbol) parser. It was a char before and
  is\n  `symbol \"@\"` now.\n- Replace `MonadIO` with a plain `Monad`. Since the tests
  don't use IO,\n  set the inner monad to `Identity`.\n- `NonEmpty (Resolver m)` is
  now `HashMap Text (NonEmpty (Resolver m))`. Root\n  operation type can be any type,
  therefore a hashmap is needed. Since types\n  cannot be empty, we save the list
  of resolvers in the type as a non-empty\n  list. Currently only \"Query\" and \"Mutation\"
  are supported as types. For more\n  schema support is required. The executor checks
  now if the type in the query\n  matches the type of the provided root resolvers.\n\n###
  Removed\n- `AST.Field`, `AST.InlineFragment` and `AST.FragmentSpread`.\n  These
  types are only used in `AST.Selection` and `AST.Selection` contains now\n  3 corresponding
  data constructors, `Field`, `InlineFragment` and\n  `FragmentSpread`, instead of
  separate types. It simplifies pattern matching\n  and doesn't make the code less
  typesafe.\n- `Schema.scalarA`.\n- `Schema.wrappedScalarA`.\n- `Schema.wrappedObjectA`.\n-
  `Schema.objectA`.\n- `AST.Argument`. Replaced with `AST.Arguments` which holds all
  arguments as a\n  key/value map.\n\n## [0.6.1.0] - 2019-12-23\n### Fixed\n- Parsing
  multiple string arguments, such as\n  `login(username: \"username\", password: \"password\")`
  would fail on the comma\n  due to strings not having a space consumer.\n- Fragment
  spread is evaluated based on the `__typename` resolver. If the\n  resolver is missing,
  it is assumed that the type condition is satisfied (all\n  fragments are included).\n-
  Escaping characters during encoding.\n\n### Added\n- Directive support (@skip and
  @include).\n- Pretifying multi-line string arguments as block strings.\n\n## [0.6.0.0]
  - 2019-11-27\n### Changed\n- `Language.GraphQL.Encoder` moved to `Language.GraphQL.AST.Encoder`.\n-
  `Language.GraphQL.Parser` moved to `Language.GraphQL.AST.Parser`.\n- `Language.GraphQL.Lexer`
  moved to `Language.GraphQL.AST.Lexer`.\n- All `Language.GraphQL.AST.Value` data
  constructor prefixes were removed. The\n  module should be imported qualified.\n-
  All `Language.GraphQL.AST.Core.Value` data constructor prefixes were removed.\n
  \ The module should be imported qualified.\n- `Language.GraphQL.AST.Core.Object`
  is now just a HashMap.\n- `Language.GraphQL.AST.Transform` is isn't exposed publically
  anymore.\n- `Language.GraphQL.Schema.resolve` accepts a selection `Seq` (`Data.Sequence`)\n
  \ instead of a list. Selections are stored as sequences internally as well.\n- Add
  a reader instance to the resolver's monad stack. The Reader contains\n  a Name/Value
  hashmap, which will contain resolver arguments.\n\n### Added\n- Nested fragment
  support.\n\n### Fixed\n- Consume ignored tokens after `$` and `!`. I mistakenly
  assumed that\n  `$variable` is a single token, same as `Type!` is a single token.
  This is not\n  the case, for example `Variable` is defined as `$ Name`, so these
  are two\n  tokens, therefore whitespaces and commas after `$` and `!` should be\n
  \ consumed.\n\n### Improved\n- `Language.GraphQL.AST.Parser.type_`: Try type parsers
  in a variable\n  definition in a different order to avoid using `but`.\n\n### Removed\n-
  `Language.GraphQL.AST.Arguments`. Use `[Language.GraphQL.AST.Argument]`\n  instead.\n-
  `Language.GraphQL.AST.Directives`. Use `[Language.GraphQL.AST.Directives]`\n  instead.\n-
  `Language.GraphQL.AST.VariableDefinitions`. Use\n  `[Language.GraphQL.AST.VariableDefinition]`
  instead.\n- `Language.GraphQL.AST.FragmentName`. Use `Language.GraphQL.AST.Name`
  instead.\n- `Language.GraphQL.Execute.Schema` - It was a resolver list, not a schema.\n-
  `Language.GraphQL.Schema`: `enum`, `enumA`, `wrappedEnum` and `wrappedEnumA`.\n
  \ Use `scalar`, `scalarA`, `wrappedScalar` and `wrappedScalarA` instead.\n\n\n##
  [0.5.1.0] - 2019-10-22\n### Deprecated\n- `Language.GraphQL.AST.Arguments`. Use
  `[Language.GraphQL.AST.Argument]`\n  instead.\n- `Language.GraphQL.AST.Directives`.
  Use `[Language.GraphQL.AST.Directives]`\n  instead.\n- `Language.GraphQL.AST.VariableDefinitions`.
  Use\n  `[Language.GraphQL.AST.VariableDefinition]` instead.\n\n### Added\n- Module
  documentation.\n- Inline fragment support.\n\n### Fixed\n- Top-level fragments.\n-
  Fragment for execution is chosen based on the type.\n\n## [0.5.0.1] - 2019-09-10\n###
  Added\n- Minimal documentation for all public symbols.\n\n### Deprecated\n- `Language.GraphQL.AST.FragmentName`.
  Replaced with Language.GraphQL.AST.Name.\n- `Language.GraphQL.Execute.Schema` -
  It is not a schema (at least not a\n  complete one), but a resolver list, and the
  resolvers should be provided by\n  the user separately, because the schema can originate
  from a GraphQL\n  document. `Schema` name should be free to provide a data type
  for the real\n  schema later.\n- `Language.GraphQL.Schema`: `enum`, `enumA`, `wrappedEnum`
  and `wrappedEnumA`.\n  There are actually only two generic types in GraphQL: Scalars
  and objects.\n  Enum is a scalar value.\n\n### Fixed\n- Parsing block string values.\n\n##
  [0.5.0.0] - 2019-08-14\n### Added\n- `executeWithName` executes an operation with
  the given name.\n- Export `Language.GraphQL.Encoder.definition`,\n  `Language.GraphQL.Encoder.type'`
  and `Language.GraphQL.Encoder.directive`.\n- Export `Language.GraphQL.Encoder.value`.
  Escapes \\ and \" in strings now.\n\n### Changed\n- `Operation` includes now possible
  operation name which allows to support\n  documents with multiple operations.\n-
  `Language.GraphQL.Encoder.document` and other encoding functions take a\n  `Formatter`
  as argument to distinguish between minified and pretty printing.\n- All encoder
  functions return `Data.Text.Lazy`.\n\n### Removed\n- Unused `Language.GraphQL.Encoder.spaced`.\n\n##
  [0.4.0.0] - 2019-07-23\n### Added\n- Support for mutations.\n- Error handling (with
  monad transformers).\n- Nullable types.\n- Arbitrary nested lists support.\n- Potential
  BOM header parsing.\n\n### Changed\n- attoparsec is replaced with megaparsec.\n-
  The library is now under `Language.GraphQL` (instead of `Data.GraphQL`).\n- HUnit
  and tasty are replaced with Hspec.\n- `Alternative`/`MonadPlus` resolver constraints
  are replaced with `MonadIO`.\n\n### Removed\n- Duplicates from `Language.GraphQL.AST`
  already available in\n  `Language.GraphQL.AST.Core`.\n- All module exports are now
  explicit, so private and help functions aren't\n  exported anymore.\n\n## [0.3]
  - 2015-09-22\n### Changed\n- Exact match numeric types to spec.\n- Names follow
  now the spec.\n- AST slightly different for better readability or easier parsing.\n-
  Replace golden test for test to validate parsing/encoding.\n\n### Added\n- Parsing
  errors in all cases where `Alternative` is used.\n- GraphQL encoder.\n\n### Fixed\n-
  Expect braces `inputValueDefinitions` instead of parens when parsing.\n\n## [0.2.1]
  - 2015-09-16\n### Fixed\n- Include data files for golden tests in Cabal package.\n-
  Support for ghc-7.8.\n\n## [0.2] - 2015-09-14\n### Added\n- Rudimentary parser for
  `GraphQL` which successfully parses the sample file\n  `kitchen-sink.graphql` from
  `graphql-js` tests.\n- Golden test for `kitchen-sink.grahql` parsing.\n### Changed\n-
  Many optional data types in `GraphQl` didn't need to be wrapped in a `Maybe`.\n-
  Some `newtype`s became type synonyms for easier parsing.\n\n## 0.1 - 2015-09-12\n###
  Added\n- Data types for the GraphQL language.\n\n[0.10.0.0]: https://github.com/caraus-ecms/graphql/compare/v0.9.0.0...v0.10.0.0\n[0.9.0.0]:
  https://github.com/caraus-ecms/graphql/compare/v0.8.0.0...v0.9.0.0\n[0.8.0.0]: https://github.com/caraus-ecms/graphql/compare/v0.7.0.0...v0.8.0.0\n[0.7.0.0]:
  https://github.com/caraus-ecms/graphql/compare/v0.6.1.0...v0.7.0.0\n[0.6.1.0]: https://github.com/caraus-ecms/graphql/compare/v0.6.0.0...v0.6.1.0\n[0.6.0.0]:
  https://github.com/caraus-ecms/graphql/compare/v0.5.1.0...v0.6.0.0\n[0.5.1.0]: https://github.com/caraus-ecms/graphql/compare/v0.5.0.1...v0.5.1.0\n[0.5.0.1]:
  https://github.com/caraus-ecms/graphql/compare/v0.5.0.0...v0.5.0.1\n[0.5.0.0]: https://github.com/caraus-ecms/graphql/compare/v0.4.0.0...v0.5.0.0\n[0.4.0.0]:
  https://github.com/caraus-ecms/graphql/compare/v0.3...v0.4.0.0\n[0.3]: https://github.com/caraus-ecms/graphql/compare/v0.2.1...v0.3\n[0.2.1]:
  https://github.com/caraus-ecms/graphql/compare/v0.2...v0.2.1\n[0.2]: https://github.com/caraus-ecms/graphql/compare/v0.1...v0.2\n"
basic-deps:
  exceptions: '>=0.10.4 && <0.11'
  base: '>=4.7 && <5'
  parser-combinators: '>=1.2.1 && <1.3'
  unordered-containers: '>=0.2.10.0 && <0.3'
  text: '>=1.2.4.0 && <1.3'
  megaparsec: '>=8.0.0 && <8.1'
  conduit: '>=1.3.2 && <1.4'
  containers: '>=0.6.2.1 && <0.7'
  transformers: '>=0.5.6.2 && <0.6'
  scientific: '>=0.3.6.2 && <0.4'
  aeson: '>=1.4.7.1 && <1.5'
  hspec-expectations: '>=0.8.2 && <0.9'
all-versions:
- '0.1'
- '0.2'
- 0.2.1
- '0.3'
- 0.4.0.0
- 0.5.0.0
- 0.5.0.1
- 0.5.1.0
- 0.6.0.0
- 0.6.1.0
- 0.7.0.0
- 0.8.0.0
- 0.9.0.0
- 0.10.0.0
author: |-
  Danny Navarro <j@dannynavarro.net>,
  Matthías Páll Gissurarson <mpg@mpg.is>,
  Sólrún Halla Einarsdóttir <she@mpg.is>
latest: 0.10.0.0
description-type: markdown
description: "# GraphQL implementation in Haskell\n\n[![Hackage Version](https://img.shields.io/hackage/v/graphql.svg)](https://hackage.haskell.org/package/graphql)\n[![Build
  Status](https://github.com/caraus-ecms/graphql/workflows/Haskell%20CI/badge.svg)](https://github.com/caraus-ecms/graphql/actions?query=workflow%3A%22Haskell+CI%22)\n[![License](https://img.shields.io/badge/license-BSD--3--Clause-blue.svg)](https://raw.githubusercontent.com/caraus-ecms/graphql/master/LICENSE)\n[![Simple
  Haskell](https://www.simplehaskell.org/badges/badge.svg)](https://www.simplehaskell.org)\n\nThis
  implementation is relatively low-level by design, it doesn't provide any\nmappings
  between the GraphQL types and Haskell's type system and avoids\ncompile-time magic.
  It focuses on flexibility instead, so other solutions can\nbe built on top of it.\n\n##
  State of the work\n\nFor now this library provides:\n\n- Parser for the query and
  schema languages, as well as a printer for the query\n  language (minimizer and
  pretty-printer).\n- Data structures to define a type system.\n- Executor (queries,
  mutations and subscriptions are supported).\n- Validation is work in progress.\n-
  Introspection isn't available yet.\n\nBut the idea is to be a Haskell port of\n[`graphql-js`](https://github.com/graphql/graphql-js).\n\nFor
  a more precise list of currently missing features see issues marked as\n\"[not implemented](https://github.com/caraus-ecms/graphql/labels/not%20implemented)\".\n\n##
  Documentation\n\nAPI documentation is available through\n[Hackage](https://hackage.haskell.org/package/graphql).\n\nYou'll
  also find a small tutorial with some examples under\n[docs/tutorial](https://github.com/caraus-ecms/graphql/tree/master/docs/tutorial).\n\n###
  Getting started\n\nWe start with a simple GraphQL API that provides us with some
  famous and less\nfamous cites.\n\n```graphql\n\"\"\"\nRoot Query type.\n\"\"\"\ntype
  Query {\n  \"\"\"\n  Provides a cite.\n  \"\"\"\n  cite: String!\n}\n```\n\nThis
  is called a GraphQL schema, it defines all queries supported by the API.\n`Query`
  is the root query type. Every GraphQL API should define a query type.\n\n`Query`
  has a single field `cite` that returns a `String`. The `!` after the\ntype denotes
  that the returned value cannot be `Null`. GraphQL fields are\nnullable by default.\n\nTo
  be able to work with this schema, we are going to implement it in Haskell.\n\n```haskell\n{-#
  LANGUAGE OverloadedStrings #-}\n\nimport Control.Exception (SomeException)\nimport
  qualified Data.Aeson as Aeson\nimport qualified Data.ByteString.Lazy.Char8 as ByteString.Lazy.Char8\nimport
  qualified Data.HashMap.Strict as HashMap\nimport Language.GraphQL\nimport Language.GraphQL.Type\nimport
  qualified Language.GraphQL.Type.Out as Out\n\n-- GraphQL supports 3 kinds of operations:
  queries, mutations and subscriptions.\n-- Our first schema supports only queries.\nschema
  :: Schema IO\nschema = Schema\n    { query = queryType, mutation = Nothing, subscription
  = Nothing }\n\n-- GraphQL distinguishes between input and output types. Input types
  are field\n-- argument types and they are defined in Language.GraphQL.Type.In. Output
  types\n-- are result types, they are defined in Language.GraphQL.Type.Out. Root
  types\n-- are always object types.\n--\n-- Here we define a type \"Query\". The
  second argument is an optional\n-- description, the third one is the list of interfaces
  implemented by the\n-- object type. The last argument is a field map. Keys are field
  names, values\n-- are field definitions and resolvers. Resolvers are the functions,
  where the\n-- actual logic lives, they return values for the respective fields.\nqueryType
  :: Out.ObjectType IO\nqueryType = Out.ObjectType \"Query\" (Just \"Root Query type.\")
  []\n    $ HashMap.singleton \"cite\" citeResolver\n  where\n    -- 'ValueResolver'
  is a 'Resolver' data constructor, it combines a field\n    -- definition with its
  resolver function. This function resolves a value for\n    -- a field (as opposed
  to the 'EventStreamResolver' used by subscriptions).\n    -- Our resolver just returns
  a constant value.\n    citeResolver = ValueResolver citeField\n        $ pure \"Piscis
  primum a capite foetat\"\n    -- The first argument is an optional field description.
  The second one is\n    -- the field type and the third one is for arguments (we
  have none in this\n    -- example).\n    --\n    -- GraphQL has named and wrapping
  types. String is a scalar, named type.\n    -- Named types are nullable by default.
  To make our \"cite\" field\n    -- non-nullable, we wrap it in the wrapping type,
  Non-Null.\n    citeField = Out.Field\n        (Just \"Provides a cite.\") (Out.NonNullScalarType
  string) HashMap.empty\n\n-- Now we can execute a query. Since our schema defines
  only one field,\n-- everything we can do is to ask to resolve it and give back the
  result.\n-- Since subscriptions don't return plain values, the 'graphql' function
  returns\n-- an 'Either'. 'Left' is for subscriptions, 'Right' is for queries and\n--
  mutations.\nmain :: IO ()\nmain = do\n    Right result <- graphql schema \"{ cite
  }\"\n    ByteString.Lazy.Char8.putStrLn $ Aeson.encode result\n```\n\nExecuting
  this query produces the following JSON:\n\n```json\n{\n  \"data\": {\n    \"cite\":
  \"Piscis primum a capite foetat\"\n  }\n}\n```\n\n## Further information\n\n- [Contributing
  guidelines](CONTRIBUTING.md).\n- [Changelog](CHANGELOG.md) – this one contains the
  most recent changes; \n  individual changelogs for specific versions can be found
  on\n  [Hackage](https://hackage.haskell.org/package/graphql).\n\n## Contact\n\nSuggestions,
  contributions and bug reports are welcome.\n\nShould you have questions on usage,
  please open an issue and ask – this helps\nto write useful documentation.\n\nFeel
  free to contact on Slack in [#haskell on\nGraphQL](https://graphql.slack.com/messages/haskell/).
  You can obtain an\ninvitation [here](https://graphql-slack.herokuapp.com/).\n"
license-name: BSD-3-Clause

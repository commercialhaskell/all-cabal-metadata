homepage: https://github.com/mgajda/json-autotype
changelog-type: markdown
hash: 409f73cf510f5300d2119387ceb6e944aed0161271214339b0acaddaeaf723cf
test-bench-deps:
  bytestring: ! '>=0.9 && <0.11'
  base: ! '>=4.3 && <4.12'
  unordered-containers: ==0.2.*
  text: ! '>=1.1 && <1.4'
  filepath: ! '>=1.3 && <1.5'
  process: ! '>=1.1 && <1.7'
  uniplate: ==1.6.*
  smallcheck: ! '>=1.0 && <1.2'
  containers: ! '>=0.3 && <0.7'
  lens: ! '>=4.1 && <4.17'
  GenericPretty: ==1.2.*
  mtl: ! '>=2.1 && <2.3'
  hashable: ==1.2.*
  optparse-applicative: ! '>=0.12 && <1.0'
  scientific: ! '>=0.3 && <0.5'
  QuickCheck: ! '>=2.4 && <3.0'
  pretty: ! '>=1.1 && <1.3'
  aeson: ! '>=0.11.2 && <1.5'
  vector: ! '>=0.9 && <0.13'
  directory: ! '>=1.1 && <1.4'
maintainer: ! 'simons@cryp.to

  mjgajda@gmail.com'
synopsis: Automatic type declaration for JSON input data
changelog: ! "Changelog\n=========\n    2.0.0  Jun 2018\n        * Elm support completed
  with untagged unions\n        * Add HaskellStrict option for running tests with
  -Werror, -Wall by default.\n        * Make random tests run with -Werror, -Wall
  by default\n        * Update dependencies to Aeson ranged between 1.2.1-1.4\n\n
  \   1.1.2  Mar 2018\n        * Fixed maintainer list.\n\n    1.1.1  Mar 2018\n        *
  Fixed test builds (for Haskell).\n\n    1.1.0  Mar 2018\n        * Partial support
  Elm code generation.\n\n    1.0.19  Nov 2017\n        * Allow to have a custom name
  for toplevel data type.\n\n    1.0.18  Nov 2017\n        * Fixed unit tests.\n        *
  Fixed import for inclusion in Stackage.\n\n    1.0.17  Nov 2017\n        * Fixed
  build and test issues.\n\n    1.0.16  Nov 2017\n        * Dependencies updated to
  resolve #12, #15.\n        * Fixed orphan Generic for Aeson >= 1.2.1 (#14).\n        *
  Cleaned option parsing code.\n        * Qualify GHC.Generics import.\n        *
  Switch to optparse-applicative\n        * Option to explicitly unify selected entries\n\n
  \   1.0.15  Dec 2016\n        * Support YAML input.\n\n    1.0.14  May 2016\n        *
  Update to latest lens.\n\n    1.0.13  Mar 2016\n        * Bumped up hint upper bound
  for v0.5.\n\n    1.0.12  Mar 2016\n\n        * Fixed issue #8 - misrepresenting
  Double as Int.\n        * Fixed issue #9 - efficient formatting with new Aeson-0.10
  builder (toEncoding.)\n\n    1.0.11  Mar 2016\n\n        * Updated to GHC 8.0\n\n
  \   1.0.10  Sep 2015\n\n        *Â Fixed bug appeared with aeson 0.10 breaking change:\n\thttps://github.com/bos/aeson/issues/287\n\n
  \   1.0.8  Sep 2015\n\n        * Dependency bump for lens 4.13 and aeson 0.10.\n\n
  \   1.0.7  Jul 2015\n\n        * Dependency bump for lens and vector.\n\n    1.0.6
  \ Jun 2015\n\n        * Make lens and aeson versions consistent in the *.cabal file.\n\n
  \   1.0.3-1.0.5  Jun 2015\n\n        * Bumped Aeson dependency up.\n        * Tiny
  docs corrections.\n\n    1.0.2  Jun 2015\n\n        * Relaxed dependency for lens-4.11.\n\n
  \   1.0.1  Apr 2015\n\n        * Relaxed dependency to lens-4.10.\n\n    1.0  Apr
  2015\n\n        * First stable release.\n\n    0.5  Apr 2015\n\n        * Reduced
  name space pollution when generating code.\n          Now all valid JSON test examples
  do work.\n        * Corrected build failure on GHC 7.8.4\n\n    0.4  Apr 2015\n\n
  \       * Release candidate for current functionality.\n\n    0.3  Apr 2015\n\n
  \       * Passed all smallcheck/quickcheck tests.\n        * Approaching release
  candidate.\n\n    0.2.5.13  Apr 2015\n\n        * Correctly handling lone option,
  not yet union with optionality.\n          Fixed: #3.\n\n    0.2.5.12  Apr 2015\n\n
  \       * Added typechecking before and after type unification.\n        * Added
  shrink for more informative QuickCheck testing.\n        * Tested mostly using GHC
  7.10.\n\n    0.2.5.11  Mar 2015\n\n        * Add short versions of command line
  flags: -o, -d, and -t.\n\n    0.2.5.10  Mar 2015\n\n        * Bump up lens dependency.\n\n
  \   0.2.5.8  Mar 2015\n\n        * Updated tests and build config.\n\n    0.2.5.7
  \ Mar 2015\n\n        * Fixed documentation anchors, and unit test classification
  for failures.\n\n    0.2.5.6  Mar 2015\n\n        * Relaxed upper bounds for lens
  4.8.\n\n    0.2.5.5  Mar 2015\n\n        * (Skipped this version number by mistake.)\n\n
  \   0.2.5.4  Dec 2014\n\n        * Relaxed upper bounds for new lens.\n\n    0.2.5.3
  \ Dec 2014\n\n        * Relaxed upper bounds again.\n\n    0.2.5.2  Dec 2014\n\n
  \       * Updated metainfo, relaxed upper bounds for GHC 7.10.\n\n    0.2.5.0  Nov
  2014\n\n        * Nicer union type syntax in Data.Aeson.AutoType.Alternative.\n\n
  \   0.2.4.0  Nov 2014\n\n        * To assure proper treatment of unions,\n          I
  make them with Data.Aeson.AutoType.Alternative type instead of Either.\n\n    0.2.3.0
  \ Nov 2014\n\n        * Explicit JSON parser generation to avoid conflicts between
  Haskell keywords and field names.\n        * Renaming of Haskell field names with
  a prefix of object name (data type.)\n\n    0.2.2.0  Nov 2014\n\n        * GenerateJSONParser
  may now take multiple input samples to produce single parser.\n        * Fixed automated
  testing for all example files.\n\n    0.2.1.4  Oct 2014\n\n        * Added examples
  to the package distribution.\n\n    0.2.1.3  Oct 2014\n\n        * Cleaned up package.\n
  \       * Changelog in markdown format.\n\n    0.2.1  Oct 2014\n\n        * Added
  option to use it as a filter ('-' is accepted input name.)\n\n    0.2.0  Oct 2014\n\n
  \       * First release to Hackage.\n        * Handling of proper unions, and most
  examples.\n        * Automatically tested on a wide range of example documents (see\n
  \       tests/)\n        * Initial documentation in README.md.\n\n    0.1.0  July
  2014\n\n\t* First experiments uploaded to GitHub, and discussed to\n\tHackerSpace.SG.\n"
basic-deps:
  bytestring: ! '>=0.9 && <0.11'
  base: ! '>=4.3 && <4.12'
  unordered-containers: ==0.2.*
  text: ! '>=1.1 && <1.4'
  filepath: ! '>=1.3 && <1.5'
  process: ! '>=1.1 && <1.7'
  uniplate: ==1.6.*
  containers: ! '>=0.3 && <0.7'
  lens: ! '>=4.1 && <4.17'
  GenericPretty: ==1.2.*
  mtl: ! '>=2.1 && <2.3'
  hashable: ==1.2.*
  optparse-applicative: ! '>=0.12 && <1.0'
  scientific: ! '>=0.3 && <0.5'
  pretty: ! '>=1.1 && <1.3'
  aeson: ! '>=0.11.2 && <1.5'
  yaml: ! '>=0.8 && <0.9'
  vector: ! '>=0.9 && <0.13'
all-versions:
- '0.2.0.0'
- '0.2.1.0'
- '0.2.1.1'
- '0.2.1.2'
- '0.2.1.3'
- '0.2.1.4'
- '0.2.2.0'
- '0.2.3.0'
- '0.2.4.0'
- '0.2.5.0'
- '0.2.5.1'
- '0.2.5.2'
- '0.2.5.3'
- '0.2.5.4'
- '0.2.5.6'
- '0.2.5.7'
- '0.2.5.8'
- '0.2.5.9'
- '0.2.5.10'
- '0.2.5.11'
- '0.2.5.12'
- '0.2.5.13'
- '0.3'
- '0.4'
- '0.5'
- '1.0'
- '1.0.1'
- '1.0.2'
- '1.0.3'
- '1.0.4'
- '1.0.5'
- '1.0.6'
- '1.0.7'
- '1.0.10'
- '1.0.13'
- '1.0.14'
- '1.0.15'
- '1.0.18'
- '1.1.2'
- '2.0.0'
author: Michal J. Gajda
latest: '2.0.0'
description-type: markdown
description: ! "json-autotype\n=============\nTakes a JSON format input, and generates
  automatic Haskell type declarations.\n\nParser and printer instances are derived
  using [Aeson](http://hackage.haskell.org/package/aeson).\n\nThe program uses union
  type unification to trim output declarations. The types of same attribute tag and
  similar attribute set, are automatically unified using recognition by attribute
  set matching. (This option can be optionally turned off, or a set of unified types
  may be given explicitly.) `:|:` alternatives (similar to `Either`) are used to assure
  that all `JSON` inputs seen in example input file are handled correctly.\n\nI should
  probably write a short paper to explain the methodology.\n\n[![Build Status](https://circleci.com/gh/mgajda/json-autotype.svg?style=shield)](https://circleci.com/gh/mgajda/json-autotype)\n[![Hackage](https://img.shields.io/hackage/v/lens.svg)](https://hackage.haskell.org/package/json-autotype)\n[![Hackage
  Dependencies](https://img.shields.io/hackage-deps/v/json-autotype.svg?style=flat)](http://packdeps.haskellers.com/feed?needle=json-autotype)\n\nDetails
  on official releases are on [Hackage](https://hackage.haskell.org/package/json-autotype)\nWe
  currently support code generation to [Haskell](https://www.haskell.org), and [Elm](https://elm-lang.org).\n\n_Please
  [volunteer help](https://gitter.im/dataHaskell/json-autotype) or [financial support](https://paypal.me/MichalJan),
  if you want your favourite language supported too!_\nExpression of interest may
  be filed as [GitHub issue](https://github.com/mgajda/json-autotype/issues/new).\n\n\nUSAGE:\n======\nAfter
  installing with `cabal install json-autotype`, you might generate stub code for
  the parser:\n\n```\n    json-autotype input1.json ... inputN.json -o MyFormat.hs\n```\n\nThen
  you might test the parser by running it on an input file:\n\n```\n    runghc MyFormat.hs
  input.json\n```\n\nAt this point you may see data structure generated automatically
  for you.\nThe more input files you give to the inference engine `json-autotype`,\nthe
  more precise type description will be.\n\nAlgorithm will also suggest which types
  look similar, based on a set of attribute names,\nand unify them unless specifically
  instructed otherwise.\n\nThe goal of this program is to make it easy for users of
  big JSON APIs to generate entries from\nexample data.\n\nOccasionally you might
  find a valid JSON for which `json-autotype` doesn't generate a correct parser.\nYou
  may either edit the resulting file _and_ send it to the author as a test case for
  future release.\n\nPatches and suggestions are welcome.\n\nEXAMPLES:\n=========\n\nThe
  most simple example:\n```\n    {\n        \"colorsArray\":[{\n                \"colorName\":\"red\",\n
  \               \"hexValue\":\"#f00\"\n            },\n            {\n                \"colorName\":\"green\",\n
  \               \"hexValue\":\"#0f0\"\n            },\n            {\n                \"colorName\":\"blue\",\n
  \               \"hexValue\":\"#00f\"\n            }\n        ]\n    }\n```\n\nIt
  will produce the module with the following datatypes and TH calls for JSON parser
  derivations:\n```\n    data ColorsArray = ColorsArray {\n        colorsArrayHexValue
  \   :: Text,\n        colorsArrayColorName :: Text\n      } deriving (Show,Eq)\n\n
  \   data TopLevel = TopLevel {\n        topLevelColorsArray :: ColorsArray\n      }
  deriving (Show,Eq)\n```\nNote that attribute names match the names of JSON dictionary
  keys.\n\nAnother example with ambiguous types:\n```\n    {\n        \"parameter\":[{\n
  \               \"parameterName\":\"apiVersion\",\n                \"parameterValue\":1\n
  \           },\n            {\n                \"parameterName\":\"failOnWarnings\",\n
  \               \"parameterValue\":false\n            },\n            {\n                \"parameterName\":\"caller\",\n
  \               \"parameterValue\":\"site API\"\n            }]\n    }\n```\nIt
  will produce quite intuitive result (plus extra parentheses, and class derivations):\n\n```\n
  \   data Parameter = Parameter {\n        parameterParameterValue :: Bool :|: Int
  :|: Text,\n        parameterParameterName :: Text\n      }\n\n    data TopLevel
  = TopLevel {\n        topLevelParameter :: Parameter\n      }\n```\n\nReal-world
  use case examples are provided in the package [source repository](https://github.com/mgajda/json-autotype/tree/master/test).\n\nMethodology:\n============\n1.
  JSON-Autotype uses its own [union type system](https://github.com/mgajda/json-autotype/blob/master/Data/Aeson/AutoType/Type.hs)
  to derive types from JSON documents as the first step.\n2. Then it finds all those
  records that have 90% of the same key names, and suggest them as similar enough
  to merit treating as instances of the same type. (Note that this is optional, and
  can be tuned manually.)\n3. Last step is to derive unique-ish type names - we currently
  do it by concatenating the name of the container and name of the key. (Please open
  PR, if you want something fancy about that - initial version used just key name,
  when it was unique.)\n4. Finally it generates [Haskell](https://www.haskell.org/)
  or [Elm](http://elm-lang.org/) code for the type.\n\nCombination of robust [*union
  type system*](https://github.com/mgajda/json-autotype/blob/master/Data/Aeson/AutoType/Type.hs),
  and heuristic makes this system extremely reliable.\nMain test is QuickCheck-based
  generation of random JSON documents, and checking that they are all correctly parsed
  by resulting parser.\n\nMore details are described in [Haskell.SG meetup presentation](https://engineers.sg/video/json-autotype-1-0-haskell-sg--429).\n\nOther
  approaches:\n=================\n\n* There is a [TypeScript type provider](https://jvilk.com/MakeTypes/),
  and [PLDI 2016 paper](https://dl.acm.org/citation.cfm?id=2908115) on solving this
  problem using <em>preferred type shapes</em> instead of union types.\nOne can think
  about it as a alternative theory that gives very similar results, with more complicated
  exposition. It also does not tackle the problem of tagged records. It also does
  not attempt to <em>guess</em> unification candidates in order to reduce type complexity.\n*
  There *was* a [json-sampler](https://maxs.io/generating-types-from-json-samples/)
  that allows to make simpler data structure from JSON examples, but doesn't seem
  to perform unification, nor is it suitable for big APIs.\n\n* [PADS project](https://www.cs.princeton.edu/~dpw/papers/padsml06.pdf)
  is another attempt to automatically infer types to treat <em>arbitrary</em> data
  formats (not just JSON). It mixes type declarations, with parsing/printing information
  in order to have a consistent view of both. It does not handle automatic type inference
  though.\n* [JSON Schema generator](https://www.newtonsoft.com/jsonschema/help/html/GenerateSchema.htm)
  uses .NET types to generate JSON Schema instead (in opposite direction.) Similar
  schema generation is [used here](https://sixgun.wordpress.com/2012/02/09/using-json-net-to-generate-jsonschema/)\n*
  Microsoft Developer Network advocates use of [Data Contracts](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/using-data-contracts)
  instead to constrain possible input data.\n"
license-name: BSD3

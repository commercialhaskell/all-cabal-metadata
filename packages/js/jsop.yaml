homepage: ''
changelog-type: markdown
hash: 7fa46b9c2644b66e39e19281d2178b63d85a21b2fceb168e7233cdb4883a3e51
test-bench-deps:
  string-interpolate: -any
  lens-aeson: -any
  monoidal-containers: -any
  base: '>=4.7 && <5'
  tasty-discover: -any
  unordered-containers: -any
  text: -any
  tasty-hspec: -any
  jsop: -any
  protolude: -any
  containers: -any
  lens: -any
  tasty: -any
  generics-sop: -any
  aeson: -any
maintainer: paolo.veronelli@gmail.com
synopsis: Cherry picking in JSON objects
changelog: |
  # Changelog for jsop

  ## Unreleased changes
basic-deps:
  string-interpolate: -any
  lens-aeson: -any
  monoidal-containers: -any
  base: '>=4.7 && <5'
  tasty-discover: -any
  unordered-containers: -any
  text: -any
  tasty-hspec: -any
  protolude: -any
  containers: -any
  lens: -any
  tasty: -any
  generics-sop: -any
  aeson: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
author: Paolo Veronelli
latest: 0.2.0.0
description-type: markdown
description: "# jsop, JSON record cherry picker \n\nJSOP is good for picking out a
  product type value  from nested json objects \n\nThe `jread`  memoize the keys path
  structure so `jread f g` should be curried to repeat on multiple values. The `Value`
  will be scanned only one time, despite the paths are always expressed from the root.
  Order is restored by a final lookup.\n\n## Example\n\nPreamble\n\n```haskell\n\n{-#
  LANGUAGE TypeFamilies #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE BlockArguments
  #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE OverloadedStrings
  #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE
  TemplateHaskell #-}\n{-# LANGUAGE TypeApplications #-}\n\nimport Data.Aeson\nimport
  Data.Aeson.Lens\nimport Data.String.Interpolate\nimport qualified Data.Text as T\nimport
  Generics.SOP\nimport Generics.SOP.TH\nimport JSOP.Parse\nimport Protolude hiding
  (All, optional, (:*:))\nimport Data.Maybe (fromJust)\n```\n\nGiven we have a SOP
  encoding of the record (tuples are good). \n\n\n```haskell\ndata ABC = ABC Text
  Int Int deriving (Show, Eq)\n\nderiveGeneric ''ABC\n\n```\n\nThen we need a product
  of pickers with the same shape as our product type.\n\nIn this case I  choose to
  encode paths joining json keys with ` / `\n\n```haskell\ncherryPickABC :: NP (Parser
  Text) '[Text, Int, Int]\ncherryPickABC =\n  required \"object 1 / a string\" _String\n
  \   :* required \"object 2 / a number\" _Integral\n    :* optional \"object 4 /
  a number\" 42 _Integral\n    :* Nil\n``` \n\nGiven the next json structure\n\n```haskell\njsonWithABC
  :: Value\njsonWithABC = fromJust . decode $ [i| \n  {\n    \"object 1\": \n      {
  \"a string\": \"ciao\"\n      , \"ignore me\" : 34\n      }\n  , \"object 2\": \n
  \     { \"a number\": 2\n      , \"object 3\": {}\n      }\n  , \"object 4\": {\n
  \     \"a plumber\" :43\n      } \n  }\n  |]\n``` \n\nWe can cherry pick the scattered
  `ABC` with\n\n```haskell \nabc :: ABC\nRight abc = jread (T.splitOn \" / \") cherryPickABC
  jsonWithAB\n```\n\n\n"
license-name: BSD-3-Clause

all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
author: ''
basic-deps:
  aeson: '>=2.0.3.0'
  aeson-optics: '>=1.2.0.1'
  attoparsec: '>=0.14.4'
  base: '>=4.16.4.0 && <5'
  optics-core: '>=0.4.1'
  text: '>=1.2.5.0'
  vector: '>=0.12.3.1'
changelog: |
  See https://github.com/pbrisbin/jsonpatch/releases
changelog-type: markdown
description: |
  # jsonpatch

  [![Hackage](https://img.shields.io/hackage/v/jsonpatch.svg?style=flat)](https://hackage.haskell.org/package/jsonpatch)
  [![Stackage Nightly](http://stackage.org/package/jsonpatch/badge/nightly)](http://stackage.org/nightly/package/jsonpatch)
  [![Stackage LTS](http://stackage.org/package/jsonpatch/badge/lts)](http://stackage.org/lts/package/jsonpatch)
  [![CI](https://github.com/pbrisbin/jsonpatch/actions/workflows/ci.yml/badge.svg)](https://github.com/pbrisbin/jsonpatch/actions/workflows/ci.yml)

  Haskell package for parsing and applying [JSON Patches][jsonpatch].

  [jsonpatch]: https://jsonpatch.com/

  ## Example

  <!--

  ```haskell
  {-# OPTIONS_GHC -Wno-incomplete-patterns #-}
  {-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}

  module Main (main) where
  import Prelude
  import Text.Markdown.Unlit ()
  ```

  -->

  Typical use cases need only one import:

  ```haskell
  import Data.JSON.Patch
  ```

  Our example will make use of a few more libraries:


  ```haskell
  import Control.Exception (displayException)
  import Data.Aeson (Value, Result(..), fromJSON)
  import Data.Aeson.Encode.Pretty
  import Data.Aeson.QQ (aesonQQ)
  import Data.ByteString.Lazy qualified as BSL
  ```

  The `FromJSON` instance can be used to build a `[Patch]`:

  ```haskell
  patch :: [Patch]
  patch = fromResult $ fromJSON [aesonQQ|
    [
      { "op": "replace", "path": "/baz", "value": "boo" },
      { "op": "add", "path": "/hello", "value": ["world"] },
      { "op": "remove", "path": "/foo" }
    ]
  |]


  -- | Unsafe unwrapping for the sake of example
  fromResult :: Result a -> a
  fromResult (Success a) = a
  ```

  The patches can then be applied to a document:

  ```haskell
  result :: Either PatchError Value
  result = patchValue patch [aesonQQ|
    {
      "baz": "qux",
      "foo": "bar"
    }
  |]
  ```

  The result is in `Either PatchError`, with `displayException` available to get
  a user-friendly message.

  ```haskell
  main :: IO ()
  main = either (fail . displayException) (BSL.putStr . encodePretty) result
  ```

  The above program outputs:

  ```json
  {
    "baz": "boo",
    "hello": ["world"]
  }
  ```


  ## Quality

  The full test suite from [`json-patch/json-patch-tests`][json-patch-tests]
  passes. However, some error cases have poor (or misleading) error messages at
  this time.

  [json-patch-tests]: https://github.com/json-patch/json-patch-tests

  ## License

  This package is licensed AGPLv3. See [COPYING](./COPYING).
description-type: markdown
hash: b7ce5b78c6dc6fadc1b9f9265f667ad0750a54ab20a8db183fce01d7b669c22a
homepage: https://github.com/pbrisbin/jsonpatch#readme
latest: 0.3.0.0
license-name: AGPL-3.0-only
maintainer: Patrick Brisbin
synopsis: JSON Patch parsing and application
test-bench-deps:
  aeson: '>=2.0.3.0'
  aeson-optics: '>=1.2.0.1'
  aeson-pretty: '>=0.8.9'
  aeson-qq: '>=0.8.4'
  base: '>=4.16.4.0 && <5'
  bytestring: '>=0.11.4.0'
  hspec: '>=2.9.7'
  hspec-expectations-json: '>=1.0.0.7'
  jsonpatch: '>=0'
  markdown-unlit: '>=0.5.1'
  optics-core: '>=0.4.1'
  path: '>=0.9.2'
  vector: '>=0.12.3.1'

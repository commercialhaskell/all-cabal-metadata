all-versions:
- 0.1.0.0
author: VegOwOtenks
basic-deps:
  adjunctions: '>=4.4.3 && <4.5'
  base: '>=4.21.0 && <4.22'
  containers: '>=0.7 && <0.8'
  distributive: '>=0.6.2 && <0.7'
  infinite-list: '>=0.1.2 && <0.2'
  random: '>=1.3.1 && <1.4'
changelog: |
  # Changelog for `Infinitree`

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
  and this project adheres to the
  [Haskell Package Versioning Policy](https://pvp.haskell.org/).

  ## Unreleased

  ## 0.1.0.0 - YYYY-MM-DD
changelog-type: markdown
description: |
  # Infinitree

  Memoization using Lazy Infinite trees indexed by natural numbers

  ## Considerations

  Using this data structure comes with trade-offs:
  - It is impossible to evict data from the cache
  - The cache is unbound in size
  - Indexing can be done only using Natural Numbers
  - Lookup is logarithmic in time and space

  ## Usage

  This is a rather constructed example.

  ```haskell
  fibonacci = Infinitree.build $ go
    where
      go 0 = 0
      go 1 = 1
      go n = Infinitree.index fibonacci (n - 1) + Infinitree.index fibonacci (n - 2)
  ```

  It is also possible to use multiple levels of infinitrees, you can see an example of this in a solution to a [puzzle from Advent Of Code 2024](https://adventofcode.com/2024/day/11).
  The code below may be a spoiler if you're trying to do the puzzle linked above. It uses two layers of cache trees and may make a lot more sense after you've read the problem description.
  ```haskell
  {-# LANGUAGE MultiWayIf #-}
  import Control.Arrow ( (>>>), Arrow((&&&)) )

  import Data.Infinitree (Infinitree)
  import Numeric.Natural (Natural)
  import qualified Data.Infinitree as Infinitree

  parse :: String -> [StoneNumber]
  parse = words >>> map read

  type StoneNumber = Natural
  type StoneCount  = Natural
  type BlinkCount  = Natural

  lookupStoneCount :: BlinkCount -> StoneNumber -> StoneCount
  lookupStoneCount i = Infinitree.index (Infinitree.index blinkTree i)

  blinkTree :: Infinitree (Infinitree StoneCount)
  blinkTree = Infinitree.build stoneTree

  stoneTree :: Natural -> Infinitree StoneCount
  stoneTree = Infinitree.build . countSplit

  countSplit :: BlinkCount -> StoneNumber -> StoneCount
  countSplit 0 _ = 1
  countSplit i n = if
    | n == 0 ->
      lookupStoneCount (pred i) (succ n)
    | even nDigits ->
      lookupStoneCount (pred i) firstSplit + lookupStoneCount (pred i) secondSplit
    | otherwise ->
      lookupStoneCount (pred i) (n * 2024)
      where
        nDigits = digitCount n :: Int
        secondSplit    = n `mod` (10 ^ (nDigits `div` 2))
        firstSplit     = (n - secondSplit) `div` (10 ^ (nDigits `div` 2))

  part1 :: [StoneNumber] -> StoneCount
  part1 = map (lookupStoneCount 25)
    >>> sum
  part2 :: [StoneNumber] -> StoneCount
  part2 = map (lookupStoneCount 75)
    >>> sum

  digitCount :: (Integral a, Integral b) => a -> b
  digitCount = succ . floor . logBase 10 . fromIntegral

  main :: IO ()
  main = getContents
          >>= print
          . (part1 &&& part2)
          . parse
  ```
description-type: markdown
hash: 2549e5433331d41f4c28015edca7a241e1166b88a829f91b56717d2497cd43cf
homepage: ''
latest: 0.1.0.0
license-name: AGPL-3.0-or-later
maintainer: hackage@vegowotenks.de
synopsis: Infinitely deep trees for lazy stateless memoization
test-bench-deps:
  Infinitree: '>=0'
  adjunctions: '>=4.4.3 && <4.5'
  base: '>=0'
  containers: '>=0.7 && <0.8'
  criterion: '>=0'
  distributive: '>=0.6.2 && <0.7'
  infinite-list: '>=0.1.2 && <0.2'
  random: '>=1.3.1 && <1.4'

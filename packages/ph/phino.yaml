all-versions:
- 0.0.0.1
- 0.0.0.2
- 0.0.0.3
- 0.0.0.4
- 0.0.0.5
- 0.0.0.6
- 0.0.0.7
- 0.0.0.8
- 0.0.0.9
- 0.0.0.10
- 0.0.0.11
- 0.0.0.12
- 0.0.0.13
- 0.0.0.14
- 0.0.0.15
- 0.0.0.16
- 0.0.0.17
- 0.0.0.18
- 0.0.0.19
- 0.0.0.20
- 0.0.0.21
- 0.0.0.22
- 0.0.0.23
- 0.0.0.24
- 0.0.0.25
- 0.0.0.26
- 0.0.0.27
- 0.0.0.28
- 0.0.0.29
- 0.0.0.30
- 0.0.0.31
- 0.0.0.32
- 0.0.0.33
- 0.0.0.34
- 0.0.0.35
- 0.0.0.36
- 0.0.0.37
- 0.0.0.38
- 0.0.0.39
- 0.0.0.40
- 0.0.0.41
- 0.0.0.42
- 0.0.0.43
- 0.0.0.44
- 0.0.0.45
- 0.0.0.46
- 0.0.0.47
- 0.0.0.48
- 0.0.0.49
- 0.0.0.50
- 0.0.0.51
- 0.0.0.52
- 0.0.0.53
- 0.0.0.54
- 0.0.0.55
- 0.0.0.56
- 0.0.0.57
- 0.0.0.58
- 0.0.0.59
- 0.0.0.60
- 0.0.0.61
author: maxonfjvipon
basic-deps:
  aeson: ^>=2.2.3.0
  array: ^>=0.5.8.0
  base: '>=4.18.3.0 && <5'
  binary-ieee754: ^>=0.1.0.0
  bytestring: ^>=0.11.5.4
  containers: ^>=0.6.7
  directory: ^>=1.3.8.5
  file-embed: ^>=0.0.16.0
  filepath: ^>=1.4.301.0
  megaparsec: ^>=9.7.0
  optparse-applicative: ^>=0.19.0.0
  phino: '>=0'
  random: '>=1.2 && <1.4'
  regex-pcre-builtin: ^>=0.95.2.3.8.44
  scientific: ^>=0.3.8.0
  text: ^>=2.0.2
  time: ^>=1.12
  transformers: ^>=0.6.1.0
  utf8-string: ^>=1.0.2
  vector: ^>=0.13.2.0
  xml-conduit: ^>=1.10
  yaml: ^>=0.11.11.2
changelog: ''
changelog-type: ''
description: "# Command-Line Manipulator of \U0001D711-Calculus Expressions\n\n[![DevOps
  By Rultor.com](https://www.rultor.com/b/objectionary/phino)](https://www.rultor.com/p/objectionary/phino)\n\n[![`phino`
  on Hackage](https://img.shields.io/hackage/v/phino)](http://hackage.haskell.org/package/phino)\n[![cabal-linux](https://github.com/objectionary/phino/actions/workflows/cabal.yml/badge.svg)](https://github.com/objectionary/phino/actions/workflows/cabal.yml)\n[![stack-linux](https://github.com/objectionary/phino/actions/workflows/stack.yml/badge.svg)](https://github.com/objectionary/phino/actions/workflows/stack.yml)\n[![codecov](https://codecov.io/gh/objectionary/phino/branch/master/graph/badge.svg)](https://app.codecov.io/gh/objectionary/phino)\n[![Haddock](https://img.shields.io/badge/docs-Haddock-blue.svg)](https://objectionary.github.io/phino/)\n[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSES/MIT.txt)\n[![Hits-of-Code](https://hitsofcode.com/github/objectionary/phino?branch=master&label=Hits-of-Code)](https://hitsofcode.com/github/objectionary/phino/view?branch=master&label=Hits-of-Code)\n[![PDD
  status](https://www.0pdd.com/svg?name=objectionary/phino)](https://www.0pdd.com/p?name=objectionary/phino)\n\nThis
  is a command-line normalizer, rewriter, and dataizer\nof [\U0001D711-calculus](https://www.eolang.org)
  expressions.\n\nFirst, you write a simple [\U0001D711-calculus](https://www.eolang.org)
  program\nin the `hello.phi` file:\n\n```text\nΦ ↦ ⟦ φ ↦ ⟦ Δ ⤍ 68-65-6C-6C-6F ⟧,
  t ↦ ξ.k, k ↦ ⟦⟧ ⟧\n```\n\n## Installation\n\nThen you can install `phino` in two
  ways:\n\nInstall [Cabal][cabal] first and then:\n\n```bash\ncabal update\ncabal
  install --overwrite-policy=always phino-0.0.0.60\nphino --version\n```\n\nOr download
  binary from the internet using [curl](https://curl.se/) or\n[wget](https://en.wikipedia.org/wiki/Wget):\n\n```bash\nsudo
  curl -o /usr/local/bin/phino http://phino.objectionary.com/releases/macos-15/phino-latest\nsudo
  chmod +x /usr/local/bin/phino\nphino --version\n```\n\nDownload paths are:\n\n*
  Ubuntu: <http://phino.objectionary.com/releases/ubuntu-24.04/phino-latest>\n* MacOS
  (ARM): <http://phino.objectionary.com/releases/macos-15/phino-latest>\n* MacOS (Intel):
  <http://phino.objectionary.com/releases/macos-14-large/phino-latest>\n\n## Build\n\nTo
  build `phino` from source, clone this repository:\n\n```bash\ngit clone git@github.com:objectionary/phino.git\ncd
  phino\n```\n\nThen, run the following command (ensure you have [Cabal][cabal] installed):\n\n```bash\ncabal
  build all\n```\n\nNext, run this command to install `phino` system-wide:\n\n```bash\nsudo
  cp \"$(cabal list-bin phino)\" /usr/local/bin/phino\n```\n\nVerify that `phino`
  is installed correctly:\n\n```bash\nphino --version\n0.0.0.0\n```\n\n## Dataize\n\nThen,
  you dataize the program:\n\n```bash\n$ phino dataize hello.phi\n68-65-6C-6C-6F\n```\n\n##
  Rewrite\n\nYou can rewrite this expression with the help of [rules](#rule-structure)\ndefined
  in the `my-rule.yml` YAML file (here, the `!d` is a capturing group,\nsimilar to
  regular expressions):\n\n```yaml\nname: My custom rule\npattern: Δ ⤍ !d\nresult:
  Δ ⤍ 62-79-65\n```\n\nThen, rewrite:\n\n```bash\n$ phino rewrite --rule=my-rule.yml
  hello.phi\nΦ ↦ ⟦ φ ↦ ⟦ Δ ⤍ 62-79-65 ⟧, t ↦ ξ.k, k ↦ ⟦⟧ ⟧\n```\n\nIf you want to
  use many rules, just use `--rule` as many times as you need:\n\n```bash\nphino rewrite
  --rule=rule1.yaml --rule=rule2.yaml ...\n```\n\nYou can also use [built-in rules](resources),
  which are designed\nto normalize expressions:\n\n```bash\nphino rewrite --normalize
  hello.phi\n```\n\nIf no input file is provided, the \U0001D711-expression is taken
  from `stdin`:\n\n```bash\n$ echo 'Φ ↦ ⟦ φ ↦ ⟦ Δ ⤍ 68-65-6C-6C-6F ⟧ ⟧' | phino rewrite
  --rule=my-rule.yml\nΦ ↦ ⟦ φ ↦ ⟦ Δ ⤍ 62-79-65 ⟧ ⟧\n```\n\nYou're able to pass [`XMIR`][xmir]
  as input. Use `--input=xmir` and `phino`\nwill parse given `XMIR` from file or `stdin`
  and convert it to `phi` AST.\n\n```bash\nphino rewrite --rule=my-rule.yaml --input=xmir
  file.xmir\n```\n\nAlso `phino` supports \U0001D711-expressions in\n[ASCII](https://en.wikipedia.org/wiki/ASCII)
  format and with\nsyntax sugar. The `rewrite` command also allows you to desugar
  the expression\nand print it in canonical syntax:\n\n```bash\n$ echo 'Q -> [[ @
  -> Q.io.stdout(\"hello\") ]]' | phino rewrite\nΦ ↦ ⟦\n  φ ↦ Φ.io.stdout(\n    α0
  ↦ Φ.string(\n      α0 ↦ Φ.bytes(\n        α0 ↦ ⟦ Δ ⤍ 68-65-6C-6C-6F ⟧\n      )\n
  \   )\n  )\n⟧\n```\n\n## Merge\n\nYou can merge several \U0001D711-programs into
  a single one by merging their\ntop level formations:\n\n```bash\n$ cat bytes.phi\n{⟦\n
  \ org ↦ ⟦\n    eolang ↦ ⟦\n      bytes ↦ ⟦\n        data ↦ ∅,\n        φ ↦ data\n
  \     ⟧\n    ⟧\n  ⟧\n⟧}\n$ cat number.phi\n{⟦\n  org ↦ ⟦\n    eolang ↦ ⟦\n      number
  ↦ ⟦\n        as-bytes ↦ ∅,\n        φ ↦ as-bytes,\n        plus(x) ↦ ⟦\n          λ
  ⤍ L_org_eolang_number_plus\n        ⟧\n      ⟧\n    ⟧\n  ⟧\n⟧}\n$ cat foo.phi\n{⟦\n
  \ foo ↦ 5.plus(3)\n⟧}\n$ phino merge bytes.phi number.phi foo.phi --sweet\n{⟦\n
  \ org ↦ ⟦\n    eolang ↦ ⟦\n      bytes ↦ ⟦\n        data ↦ ∅,\n        φ ↦ data\n
  \     ⟧,\n      number ↦ ⟦\n        as-bytes ↦ ∅,\n        φ ↦ as-bytes,\n        plus(x)
  ↦ ⟦\n          λ ⤍ L_org_eolang_number_plus\n        ⟧\n      ⟧\n    ⟧\n  ⟧,\n  foo
  ↦ 5.plus(3)\n⟧}\n```\n\n## Match\n\nYou can test the \U0001D711-program matches
  against the [rule](#rule-structure)\npattern. The result output contains matched
  substitutions:\n\n```bash\n$ phino match --pattern='⟦ Δ ⤍ !d, !B ⟧' hello.phi\nB
  >> ⟦ ρ ↦ ∅ ⟧\nd >> 68-65-6C-6C-6F\n```\n\n## Explain (under development)\n\nYou
  can _explain_ rewriting rule by printing them in [LaTeX][latex] format:\n\n```bash\n$
  phino explain --rule=my-rule.yaml\n\\documentclass{article}\n\\usepackage{amsmath}\n\\begin{document}\n\\rule{My
  custom rule}\n\\...\n\\end{document}\n```\n\nFor more details, use `phino [COMMAND]
  --help` option.\n\n## Rule structure\n\nThis is BNF-like yaml rule structure. Here
  types ended with\napostrophe, like `Attribute'` are built types from \U0001D711-program
  [AST](src/AST.hs)\n\n```bnfc\nRule:\n  name: String?\n  pattern: String\n  result:
  String\n  when: Condition?       # predicate, works with substitutions before extension\n
  \ where: [Extension]?    # substitution extensions\n  having: Condition?     # predicate,
  works with substitutions after extension\n\nCondition:\n  = and: [Condition]     #
  logical AND\n  | or:  [Condition]     # logical OR\n  | not: Condition       # logical
  NOT\n  | alpha: Attribute'    # check if given attribute is alpha\n  | eq:                  #
  compare two comparable objects\n      - Comparable\n      - Comparable\n  | in:
  \                 # check if attributes exist in bindings\n      - Attribute'\n
  \     - Binding'\n  | nf: Expression'      # returns True if given expression in
  normal form\n                         # which means that no more other normalization
  rules\n                         # can be applied\n  | xi: Expression'      # special
  condition for Rcopy normalization rule to\n                         # avoid infinite
  recursion while the condition checking\n                         # returns True
  if there's no ξ outside of the formation\n                         # in given expression.\n
  \ | matches:             # returns True if given expression after dataization\n
  \     - String           # matches to given regex\n      - Expression\n  | part-of:
  \            # returns True if given expression is attached to any\n      - Expression'
  \     # attribute in ginve bindings\n      - BiMeta'\n\nComparable:              #
  comparable object that may be used in 'eq' condition\n  = Attribute'\n  | Number\n
  \ | Expression'\n\nNumber:                  # comparable number\n  = Integer              #
  just regular integer\n  | ordinal: Attribute'  # calculate index of alpha attribute\n
  \ | length: BiMeta'      # calculate length of bindings by given meta binding\n\nExtension:
  \              # substitutions extension used to introduce new meta variables\n
  \ meta: [ExtArgument]    # new introduced meta variable\n  function: String       #
  name of the function\n  args: [ExtArgument]    # arguments of the function\n\nExtArgument\n
  \ = Bytes'               # !d\n  | Binding'             # !B\n  | Expression'          #
  !e\n  | Attribute'           # !a\n```\n\nHere's list of functions that are supported
  for extensions:\n\n* `contextualize` - function of two arguments, that rewrites
  given expression\n  depending on provided context according to the contextualization\n
  \ [rules](assets/contextualize.jpg)\n* `scope` - resolves the scope for given expression.
  Works only with meta\n  expressions denotes as `\U0001D452` or `!e`. The scope is
  nearest outer formation,\n  if it's present. In all other cases the default scope
  is used, which is\n  anonymous formation `⟦ ρ ↦ ∅ ⟧`.\n* `random-tau` - creates
  attribute with random unique name. Accepts bindings,\n  and attributes. Ensures
  that created attribute is not present in list of\n  provided attributes and does
  not exist as attribute in provided bindings.\n* `dataize` - dataizes given expression
  and returns bytes.\n* `concat` - accepts bytes or dataizable expressions as arguments,\n
  \ concatenates them into single sequence and convert it to expression\n  that can
  be pretty printed as human readable string:\n  `Φ.string(Φ.bytes⟦ Δ ⤍ !d ⟧)`.\n*
  `sed` - pattern replacer, works like unix `sed` function.\n  Accepts two arguments:
  target expression and pattern.\n  Pattern must start with `s/`, consists of three
  parts\n  separated by `/`, for example, this pattern `s/\\\\s+//g`\n  replaces all
  the spaces with empty string. To escape braces and slashes\n  in pattern and replacement
  parts - use them with `\\\\`,\n  e.g. `s/\\\\(.+\\\\)//g`.\n* `random-string` -
  accepts dataizable expression or bytes as pattern.\n  Replaces `%x` and `%d` formatters
  with random hex numbers and\n  decimals accordingly. Uniqueness is guaranteed during
  one\n  execution of `phino`.\n* `size` - accepts exactly one meta binding and returns
  size of it and\n  `Φ̇.number`.\n* `tau` - accepts `Φ̇.string`, dataizes it and converts
  it to attribute.\n  If dataized string can't be converted to attribute - an error
  is thrown.\n* `string` - accepts `Φ̇.string` or `Φ̇.number` or attribute and converts
  it\n  to `Φ̇.string`.\n* `number` - accepts `Φ̇.string` and converts it `Φ̇.number`\n*
  `sum` - accepts list of `Φ̇.number` or `Φ̇.bytes` and returns sum of them as `Φ̇.number`\n*
  `join` - accepts list of bindings and returns list of joined bindings. Duplicated\n
  \ `ρ`, `Δ` and `λ` attributes are ignored, all other duplicated attributes are replaced\n
  \ with unique attributes using `random-tau` function.\n\n## Meta variables\n\nThe
  `phino` supports meta variables to write \U0001D711-expression patterns for\ncapturing
  attributes, bindings, etc.\n\nThis is the list of supported meta variables:\n\n*
  `!a` || `\U0001D70F` - attribute\n* `!e` || `\U0001D452` - any expression\n* `!B`
  || `\U0001D435` - list of bindings\n* `!d` || `δ` - bytes in meta delta binding\n*
  `!t` - tail after expression, sequence of applications and/or dispatches,\n         must
  start only with dispatch\n* `!F` - function name in meta lambda binding\n\nEvery
  meta variable may also be used with an integer index, like `!B1` or `\U0001D70F0`.\n\nIncorrect
  usage of meta variables in \U0001D711-expression patterns leads to\nparsing errors.\n\n##
  How to Contribute\n\nFork repository, make changes, then send us a [pull request][guidelines].\nWe
  will review your changes and apply them to the `master` branch shortly,\nprovided
  they don't violate our quality standards. To avoid frustration,\nbefore sending
  us your pull request please make sure all your tests pass:\n\n```bash\nmake all\n```\n\nTo
  generate a local coverage report for development, run:\n\n```bash\nmake coverage\n```\n\nYou
  will need [GHC] and [Cabal ≥3.0][cabal] or [Stack ≥ 3.0][stack] installed.\n\n[cabal]:
  https://www.haskell.org/cabal/\n[stack]: https://docs.haskellstack.org/en/stable/install_and_upgrade/\n[GHC]:
  https://www.haskell.org/ghc/\n[guidelines]: https://www.yegor256.com/2014/04/15/github-guidelines.html\n[xmir]:
  https://news.eolang.org/2022-11-25-xmir-guide.html\n[latex]: https://en.wikipedia.org/wiki/LaTeX\n"
description-type: markdown
hash: 79693acc4108e199a14c8b33165ba4966b62fb7f556209c85400e5d51ab9f9dd
homepage: https://github.com/objectionary/phino#readme
latest: 0.0.0.61
license-name: MIT
maintainer: mtrunnikov@gmail.com
synopsis: "Command-Line Manipulator of \U0001D711-Calculus Expressions"
test-bench-deps:
  aeson: ^>=2.2.3.0
  base: '>=4.18.3.0 && <5'
  bytestring: ^>=0.11.5.4
  containers: ^>=0.6.7
  directory: ^>=1.3.8.5
  filepath: ^>=1.4.301.0
  hspec: ^>=2.11.16
  hspec-core: ^>=2.11.16
  megaparsec: ^>=9.7.0
  optparse-applicative: ^>=0.19.0.0
  phino: '>=0'
  process: ^>=1.6.19.0
  silently: ^>=1.2.5.4
  text: ^>=2.0.2
  time: ^>=1.12
  xml-conduit: ^>=1.10
  yaml: ^>=0.11.11.2

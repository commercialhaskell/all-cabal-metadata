homepage: http://www2.tcs.ifi.lmu.de/~abel/projects.html#helf
changelog-type: markdown
hash: 7dafe67457048a6d8902a18affff2deae08484ce1b3504a0baabb815ff6f2e8e
test-bench-deps: {}
maintainer: Andreas Abel <andreas.abel@ifi.lmu.de>
synopsis: Typechecking terms of the Edinburgh Logical Framework (LF).
changelog: |
  0.2022.5.30
  -----------

  - Fix compilation with GHC 9.4 alpha2 and mtl-2.3 RC3
  - Builds with GHC 7.6 - 9.4

  0.2021.8.12
  -----------

  - Removed uses of `fail`
  - Build with GHC 7.6 - 9.0


  0.2016.12.25
  ------------

  - Build with GHC 7.8 - 8.0
basic-deps:
  base: '>=4.6 && <5'
  array: '>=0.3 && <1'
  containers: '>=0.3 && <1'
  mtl: '>=2.2.1 && <3'
  transformers: '>=0.2 && <1'
  QuickCheck: '>=2.4 && <3'
  pretty: '>=1.0 && <2'
all-versions:
- 0.2016.12.25
- 0.2021.8.12
- 0.2022.5.30
author: Andreas Abel and Nicolai Kraus
latest: 0.2022.5.30
description-type: markdown
description: |
  # helf
  A Haskell implementation of the Edinburgh Logical Framework.

  helf parses and typechecks `.elf` files written for the Twelf implementation
  of the Logical Framework.  helf is mainly a laboratory to experiment with different
  representation of lambda-terms for bidirectional typechecking.

  ## Limitations

  helf only understands a subset of the Twelf language and implements only a small subset of Twelf's features.
  + helf does not parse the backarrow `<-` notation for function space.
  + helf only understands the fixity pragmas for operators.  It ignores all other pragmas.
  + helf only implements bidirectional type checking.  It does not have unification or type reconstruction.
  + helf does not give nice error messages.

  ## Installation

  Requires GHC and cabal, for instance via the Haskell Platform.
  In a shell, type
  ```
    cabal install helf
  ```

  ## Examples

  File `eval.elf`:
  ```elf
  % Untyped lambda calculus.

  tm   : type.
  abs  : (tm -> tm) -> tm.
  app  : tm -> (tm -> tm).

  % cbn weak head evaluation.

  eval : tm -> tm -> type.

  eval/abs : {M : tm -> tm}
    eval (abs M) (abs M).

  eval/app : {M : tm} {M' : tm -> tm} {N : tm} {V : tm}
    eval M (abs M') ->
    eval (M' N) V   ->
    eval (app M N) V.
  ```
  Type check with:
  ```
    helf eval.elf
  ```

  For more examples, see `test/succeed/`.
license-name: MIT

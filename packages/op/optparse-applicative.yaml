homepage: https://github.com/pcapriotti/optparse-applicative
changelog-type: markdown
hash: b8f3ad58ae63ab3cc8173e18abc0d5362feef545b5359ffa3a5dbc0635790a9b
test-bench-deps:
  base: -any
  semigroups: -any
  optparse-applicative: -any
  QuickCheck: ==2.8.*
maintainer: paolo@capriotti.io
synopsis: Utilities and combinators for parsing command line options
changelog: ! "## Version 0.13.0.0 (15 Aug 2016)\n\n- Implement command groups, which
  allow subcommands to have their own\n  usage description.\n\n- Implement showHelpOnEmpty,
  which is similar to showHelpOnError, but only\n  fires when a command or subcommand
  is begun, and suppresses the \"Missing:\"\n  error text.\n\n- Fix ghc 8.0 warnings\n\n-
  Fix ghc 7.10 warnings\n\n- Bump dependency bounds\n\n- Add maybeReader function
  for convenient ReadM creation\n\n- Move eitherReader to Readers section (for better
  discoverability)\n\n- Fix hsubparser metavar override\n\n- Remove ComplError, which
  was dead code.\n\n- Reimplement Missing error generation, which overly complicated
  evalParser.\n\n- Export Semigroup instances for types which are also Monoids. Removes\n
  \ mempty synonym `(<>)` export, as it clashes with Semigroup exports.\n  One may
  need to import Data.Monoid or Data.Semigroup when upgrading.\n\n- Use a Cabal test
  suite for tests, simplify test dependencies.\n\n## Version 0.12.1.0 (18 Jan 2016)\n\n-
  Updated dependency bounds.\n\n- Improve subparser contexts to improve usage error
  texts\n\n- Doc\n\n- Fixed bugs\n    * \\# 164 - Invalid options and invalid arguments
  after parser has succeeded\n               not displaying\n    * \\# 146 - multi-word
  filename completion is broken\n\n\n## Version 0.12.0.0 (17 Sep 2015)\n\n- Add \"missing\"
  error condition descriptions when required flags and arguments\n  are not provided.\n\n-
  Allow multiple short flags to be concatenated together behind a single\n  hyphen,
  e.g. \"-xcf\".\n\n- Updated dependency bounds on `process` and `ansi-wl-pprint`.\n\n-
  Add `Show` and `Eq` instances to some types for easier debugging.\n\n- Add defaultPrefs,
  a default preferences value\n\n- Docs.\n\n## Version 0.11.0.2 (17 Feb 2015)\n\n-
  Updated dependency bounds.\n\n## Version 0.11.0.1 (5 Oct 2014)\n\n- Updated documentation.\n\n##
  Version 0.11.0 (4 Oct 2014)\n\n- Added Alternative instances for `Chunk` and `ReadM`.\n\n-
  The `ReadM` monad is now a `ReaderT` for the argument being parsed.  User\n  defined
  readers do not need to handle their argument explicitly, but can\n  always access
  it using `readerAsk`.\n\n- Argument builders now take a `ReadM` parameter, just
  like options.\n\n- Fixed bugs\n    * \\#106 - argument should perhaps use `ReadM`\n\n##
  Version 0.10.0 (1 Sep 2014)\n\n- Parser execution and help text generation are now
  more modular, and allow for\n  greater customisation.\n\n- More consistent API for
  `option` and `argument` builders: now `option` takes\n  a reader as argument, and
  `nullOption` is deprecated in favour of `option`.\n  The `reader` modifier is gone.
  \ Quick migration guide:\n\n    * `option` (without a `reader` modifier) => `option
  auto`\n    * `nullOption` (without a `reader` modifier) => `option disabled`\n    *
  `option`/`nullOption` (with a `reader r` modifier) => `option r`.\n\n- Added convenience
  builder `strArgument`, equivalent to `argument str`.\n\n- Removed functions deprecated
  from at least version 0.8.0.\n\n- Switched test infrastructure to `tasty`.\n\n-
  Fixed bugs\n    * \\#63 - Inconsistency between 'argument' and 'strOption' types\n\n##
  Version 0.9.1.1 (31 Jul 2014)\n\n- Fixed bugs\n    * \\#97 - Version 0.9.1 fails
  test suite\n\n## Version 0.9.1 (30 Jul 2014)\n\n- Documentation tweaks.\n\n- Added
  low-level function to handle parse results (pull request \\#94).\n\n- `ParserResult`
  now has a `Show` instance (see issue \\#95).\n\n- Fixed bugs\n    * \\#93 - Formatting
  problem for several sub-parsers\n\n## Version 0.9.0 (23 May 2014)\n\n- The option
  returned by `abortOption` is now visible by default.\n\n## Version 0.8.1 (5 May
  2014)\n\n- Fixed bugs\n    * \\#74 - Missing newline\n\n## Version 0.8.0.1 (19 Mar
  2014)\n\n- Fixed bugs\n    * \\#73 - Release 0.8.0 is broken\n\n## Version 0.8.0
  (16 Mar 2014)\n\n- Help page formatting.  Added `columns` preference modifier,\n
  \ which can be used to specify the number of columns in the output\n  terminal.\n\n-
  Deprecated `arguments` and `arguments1` builders. Using `many` and `some` on a\n
  \ parser built using `argument` now returns a multiple argument parsers that\n  behaves
  correctly with respect to `--`.\n\n- Fixed bugs\n    * \\#60 - runParser can't be
  called\n    * \\#64 - --help behaviour\n\n## Version 0.7.0.2 (18 Oct 2013)\n\n-
  Fixed bugs\n    * \\#51 - Build fails with ghc 6.12.3 and ghc 7.0.4\n\n## Version
  0.7.0.1 (18 Oct 2013)\n\n- Minor docs fixes\n\n## Version 0.7.0 (17 Oct 2013)\n\n-
  Added builders for options that always fail. This makes it\n  easier to create options
  that just print an error message or\n  display some brief information and then exit
  (like `--version`).\n\n- Added `execParserMaybe` and `customExecParserMaybe` functions\n
  \ (pull request #49).\n\n- Fixed bugs\n    * \\#47 - Current master prints help
  text instead of error\n    * \\#48 - Can we have an eitherReader convenience function?\n
  \   * \\#50 - In order parsing problems.\n    * \\#22 - Strict (no-intersperse)
  arguments\n\n## Version 0.6.0 (11 Oct 2013)\n\n- Arguments are now always parsed
  in order.\n\n- Fixed bugs\n    * \\#40 - Add context information to error messages\n
  \   * \\#41 - Readme uses old reader API\n    * \\#38 - Internal types leaking into
  public API\n    * \\#44 - Can the build input restriction process == 1.1.* be relaxed?\n
  \   * \\#28 - Help for subcommands\n\n## Version 0.5.2.1 (24 Dic 2012)\n\n- Minor
  docs fixes.\n\n## Version 0.5.2 (23 Dic 2012)\n\n- Fixed compatibility with GHC
  7.2.\n\n## Version 0.5.1 (23 Dic 2012)\n\n- There is a new parser preference `noBacktrack`,
  that controls whether how a\n  failure in a subparser is propagated. By default,
  an unknown option in a\n  subparser causes the option to be looked up in parent
  parsers. When\n  `noBacktrack` is used, this behavior is disabled. This is useful
  to implement\n  subcommands that have no relations with their parent commands.\n\n-
  Fixed bugs\n    * \\#35 - Artifacts of \"hidden\"\n    * \\#31 - Backtracking on
  commands\n    * \\#25 - Allow for using Maybe in options types to specify optional
  arguments\n    * \\#34 - No simple/obvious way to add a --version switch\n    *
  \\#29 - Document Mod\n    * \\#26 - Improve docs for the `Arrow` interface\n\n##
  Version 0.5.0 (22 Dic 2012)\n\n- Fewer GHC extensions required.\n\n- Improved error
  handling: unrecognized options now result in an error message.\n\n- By default,
  the full help text is not displayed on parse errors anymore.\n  This behavior can
  be controlled with the `prefShowHelpOnError` field of\n  `ParserPrefs`.\n\n- The
  `(&)` operator is now deprecated. Modifiers can still be combined using\n  `(<>)`
  or `mappend`.\n\n- Fixed bugs\n    * \\#37 - Use (\\<\\>) instead of (&) in documentation\n\n##
  Version 0.4.3 (09 Dic 2012)\n\n- Updated dependency bounds.\n\n## Version 0.4.2
  (26 Nov 2012)\n\n- Fixed bugs\n    * \\#27 - Please include the test source files
  in the cabal sdist tarball\n\n## Version 0.4.1 (04 Sep 2012)\n\n- Fixed bugs\n    *
  \\#19 - Regression\n\n## Version 0.4.0 (05 Aug 2012)\n\n- Brief help text for nested
  commands now shows the full command line.\n\n- Fixed inefficiency in the `arguments`
  parsers for long argument lists.\n\n- Added automatic [bash\ncompletion](https://github.com/pcapriotti/optparse-applicative/wiki/Bash-Completion).\n\n-
  Added `disambiguate` modifier for `prefs`, which enabled automatic\ndisambiguation
  of option abbreviations. With disambiguation on, a command line\nlike:\n\n        foo
  --out\n\n    will match an option called `--output`, as long as its the only one
  starting\n    with the string `out`.\n\n- Added `briefDesc` modifier.\n\n- Fixed
  bugs\n    * \\#8 - Long options not disambiguated\n    * \\#10 - Shell completions\n
  \   * \\#16 - Possible memory leak?\n\n## Version 0.3.2 (31 Jul 2012)\n\n- Fixed
  bug where both branches of an alternative could be matched.\n\n- Improved brief
  help text for alternatives.\n\n## Version 0.3.1 (30 Jul 2012)\n\n- Added new `showDefault`
  and `showDefaultWith` modifiers, which will result in\nthe default value (if present)
  to be displayed in the help text.\n\n- Fixed bugs\n    * \\#12 - Optionally display
  default values in help\n\n## Version 0.3.0 (30 Jul 2012)\n\n- Option modifiers are
  now instances of `Monoid` instead of `Category`.\n\n- Dropped dependencies on data-default
  and data-lens.\n\n- Fixed bugs\n    * \\#14 - \"arguments\" can no longer take a
  list as a default\n\n## Version 0.2.0 (23 Jul 2012)\n\n- Parser is now an instance
  of Alternative. This makes it possible to build\ncertain complex parsers that were
  not definable before. See\n`tests/Examples/Alternatives.hs` for a simple example.\n\n-
  Removed `multi` modifier. You can now use the `many` or `some` methods from\n`Alternative`,
  instead, to create parsers for options that can appear more than\nonce.\n\n- Added
  new `flag'` builder that returns a flag without a default value.\nAlthough flags
  without default values were not useful before, with the addition\nof `Alternative`
  combinators, they do have valid use cases.\n\n- Added new `internal` modifier for
  options. An internal option is completely\ninvisible in the help text.\n\n- Added
  a new `customExecParser` function, which takes an additional\n`ParserPrefs` parameter.
  At the moment, `ParserPrefs` can only be used to\ncontrol how many-valued option
  metavars are displayed in the help text. Setting\nits `multiSuffix` field to e.g.
  `...` will result in an `arguments` parser\ndescription like `[METAVAR]...`.\n\n-
  Fixed bugs\n    * \\#6 - \"arguments\" swallows options\n    * \\#5 - Help formatting
  for \"arguments\" misleading\n\n## Version 0.1.1 (21 Jul 2012)\n\n- New arrow interface\n\n-
  Fixed bugs\n      * \\#7 - \"arguments\" reads positional arguments in reverse\n\n##
  Version 0.1.0 (07 Jul 2012)\n\n- Improved error reporting internals\n\n- Removed
  template-haskell dependency\n\n- Fixed bugs:\n      * \\#3 - No help for subparsers\n
  \     * \\#4 - Extra empty lines around command list\n\n## Version 0.0.1 (09 Jun
  2012)\n\n- Initial release.\n"
basic-deps:
  ansi-wl-pprint: ! '>=0.6.6 && <0.7'
  base: ==4.*
  process: ! '>=1.0 && <1.5'
  semigroups: ! '>=0.10 && <0.19'
  transformers: ! '>=0.2 && <0.6'
  transformers-compat: ! '>=0.3 && <0.6'
all-versions:
- '0.0.1'
- '0.1.0'
- '0.1.1'
- '0.2.0'
- '0.3.0'
- '0.3.1'
- '0.3.2'
- '0.4.0'
- '0.4.1'
- '0.4.2'
- '0.4.3'
- '0.5.0'
- '0.5.1'
- '0.5.2'
- '0.5.2.1'
- '0.6.0'
- '0.7.0'
- '0.7.0.1'
- '0.7.0.2'
- '0.8.0'
- '0.8.0.1'
- '0.8.1'
- '0.9.0'
- '0.9.1'
- '0.9.1.1'
- '0.10.0'
- '0.11.0'
- '0.11.0.1'
- '0.11.0.2'
- '0.12.0.0'
- '0.12.1.0'
- '0.13.0.0'
author: Paolo Capriotti
latest: '0.13.0.0'
description-type: markdown
description: ! "# Applicative option parser\n\nThis package contains utilities and
  combinators to define command line option\nparsers.\n\n[![Continuous Integration
  status][status-png]][status]\n[![Hackage page (downloads and API reference)][hackage-png]][hackage]\n\n**Table
  of Contents**\n\n- [Getting started](#getting-started)\n- [Supported options](#supported-options)\n
  \   - [Regular options](#regular-options)\n    - [Flags](#flags)\n    - [Arguments](#arguments)\n
  \   - [Commands](#commands)\n- [Option builders](#option-builders)\n- [Advanced
  features](#advanced-features)\n- [How it works](#how-it-works)\n\n## Getting started\n\nInstall
  with\n\n```sh\ncabal install optparse-applicative\n```\n\nHere is a simple example
  of an applicative option parser:\n\n```haskell\nimport Options.Applicative\n\ndata
  Sample = Sample\n  { hello :: String\n  , quiet :: Bool }\n\nsample :: Parser Sample\nsample
  = Sample\n     <$> strOption\n         ( long \"hello\"\n        <> metavar \"TARGET\"\n
  \       <> help \"Target for the greeting\" )\n     <*> switch\n         ( long
  \"quiet\"\n        <> help \"Whether to be quiet\" )\n```\n\nThe parser is built
  using [applicative style][applicative] starting from a set\nof basic combinators.
  In this example, `hello` is defined as an option with a\n`String` argument, while
  `quiet` is a boolean flag (called `switch`).\n\nA parser can be used like this:\n\n```haskell\ngreet
  :: Sample -> IO ()\ngreet (Sample h False) = putStrLn $ \"Hello, \" ++ h\ngreet
  _ = return ()\n\nmain :: IO ()\nmain = execParser opts >>= greet\n  where\n    opts
  = info (helper <*> sample)\n      ( fullDesc\n     <> progDesc \"Print a greeting
  for TARGET\"\n     <> header \"hello - a test for optparse-applicative\" )\n```\n\nThe
  `greet` function is the entry point of the program, while `opts` is a\ncomplete
  description of the program, used when generating a help text. The\n`helper` combinator
  takes any parser, and adds a `help` option to it.\n\nThe `hello` option in this
  example is mandatory (since it doesn't have a\ndefault value), so running the program
  without any argument will display a\nshort option summary:\n\n    Usage: hello --hello
  TARGET [--quiet]\n\nRunning the program with the `--help` option will display the
  full help text:\n\n    hello - a test for optparse-applicative\n\n    Usage: hello
  --hello TARGET [--quiet]\n      Print a greeting for TARGET\n\n    Available options:\n
  \     -h,--help                Show this help text\n      --hello TARGET           Target
  for the greeting\n      --quiet                  Whether to be quiet\n\ncontaining
  a detailed list of options with descriptions.\n\nThe specified metavars are used
  as placeholders for the option arguments, and\ncan be referred to in the program
  description.  This makes it possible to\nexplicitly describe the connection between
  the options and the behaviour of the\nprogram.\n\nParsers are instances of both
  `Applicative` and `Alternative`, and work with\nany generic combinator, like `many`
  and `some`. For example, to make a option\nreturn `Nothing` instead of failing when
  it's not supplied, you can use the\n`optional` combinator in `Control.Applicative`:\n\n```haskell\noptional
  $ strOption\n   ( long \"output\"\n  <> metavar \"DIRECTORY\" )\n```\n\n [applicative]:
  http://www.soi.city.ac.uk/~ross/papers/Applicative.html\n\n## Supported options\n\n`optparse-applicative`
  supports four kinds of options: regular options, flags,\narguments and commands.\n\n###
  Regular options\n\nA **regular option** is an option which takes a single argument,
  parses it, and\nreturns a value.\n\nA regular option can have a default value, which
  is used as the result if the\noption is not found in the command line. An option
  without a default value is\nconsidered mandatory, and produces an error when not
  found.\n\nRegular options can have **long** names, or **short** (one-character)
  names,\nwhich determine when the option matches and how the argument is extracted.\n\nAn
  option with a long name (say \"output\") is specified on the command line as\n\n
  \   --output filename.txt\n\nor\n\n    --output=filename.txt\n\nwhile a short name
  option (say \"o\") can be specified with\n\n    -o filename.txt\n\nor\n\n    -ofilename.txt\n\nOptions
  can have more than one name, usually one long and one short, although\nyou are free
  to create options with an arbitrary combination of long and short\nnames.\n\nRegular
  options returning strings are the most common, and they can be created\nusing the
  `strOption` builder. For example,\n\n```haskell\nstrOption\n   ( long \"output\"\n
  \ <> short 'o'\n  <> metavar \"FILE\"\n  <> help \"Write output to FILE\" )\n```\n\ncreates
  a regular option with a string argument (which can be referred to as\n`FILE` in
  the help text and documentation), a long name \"output\" and a short\nname \"o\".
  See below for more information on the builder syntax and modifiers.\n\nA regular
  option can return an object of any type, and takes a *reader*\nparameter which specifies
  how the argument should be parsed.  A common reader is\n`auto`, which assumes a
  `Read` instance for the return type and uses it to parse\nits argument. For example:\n\n```haskell\nlineCount
  :: Parser Int\nlineCount = option auto\n            ( long \"lines\"\n           <>
  short 'n'\n           <> metavar \"K\"\n           <> help \"Output the last K lines\"
  )\n```\n\nspecifies a regular option with an `Int` argument. We added an explicit
  type\nannotation here, since without it the parser would have been polymorphic in
  the\noutput type. There's usually no need to add type annotations, however, because\nthe
  type will be normally inferred from the context in which the parser is\nused.\n\nOne
  can also create a custom reader that doesn't use the `Read` typeclass, and\nuse
  it to parse option arguments. A custom reader is a value in the `ReadM`\nmonad.
  We provide `eitherReader :: (String -> Either String a) -> ReadM a`\nto help create
  these values, where a `Left` will hold the error message\nfor a failure.\n\n```haskell\ndata
  FluxCapacitor = ...\n\nparseFluxCapacitor :: ReadM FluxCapacitor\nparseFluxCapacitor
  = eitherReader $ \\s -> ...\n\noption parseFluxCapacitor ( long \"flux-capacitor\"
  )\n```\n\nOne can also use `ReadM` directly, using `str` to obtain the command line
  string,\nand `readerAbort` or `readerError` within the `ReadM` monad to exit with
  an\nerror message.\n\n### Flags\n\nA **flag** is just like a regular option, but
  it doesn't take any arguments: it is\neither present in the command line or not.\n\nA
  flag has a default value and an **active value**. If the flag is found on the\ncommand
  line, the active value is returned, otherwise the default value is\nused. For example:\n\n```haskell\ndata
  Verbosity = Normal | Verbose\n\nflag Normal Verbose\n  ( long \"verbose\"\n <> short
  'v'\n <> help \"Enable verbose mode\" )\n```\n\nis a flag parser returning a `Verbosity`
  value.\n\nSimple boolean flags can be specified using the `switch` builder, like
  so:\n\n```haskell\nswitch\n  ( long \"keep-tmp-files\"\n <> help \"Retain all intermediate
  temporary files\" )\n```\n\nThere is also a `flag'` builder, which has no default
  value. For example, to\nadd a `--version` switch to a program, you could write:\n\n```haskell\nflag'
  Nothing (long \"version\" <> hidden) <|> (Just <$> normal_options)\n```\n\n### Arguments\n\nAn
  **argument** parser specifies a positional command line argument.\n\nThe `argument`
  builder takes a reader parameter, and creates a parser which\nwill return the parsed
  value every time it is passed a command line argument\nfor which the reader succeeds.
  For example\n\n```haskell\nargument str (metavar \"FILE\")\n```\n\ncreates an argument
  accepting any string.  To accept an arbitrary number of\narguments, combine the
  `argument` builder with either the `many` or `some`\ncombinator:\n\n```haskell\nsome
  (argument str (metavar \"FILES...\"))\n```\n\nArguments are only displayed in the
  brief help text, so there's no need to\nattach a description to them. They should
  be manually documented in the program\ndescription.\n\nNote that arguments starting
  with `-` are considered options by default, and\nwill not be considered by an `argument`
  parser.\n\nHowever, parsers always accept a special argument: `--`. When a `--`
  is found on\nthe command line, all the following words are considered by `argument`
  parsers,\nregardless of whether they start with `-` or not.\n\n### Commands\n\nA
  **command** can be used to specify a sub-parser to be used when a certain\nstring
  is encountered in the command line.\n\nCommands are useful to implement command
  line programs with multiple functions,\neach with its own set of options, and possibly
  some global options that apply\nto all of them. Typical examples are version control
  systems like `git`, or\nbuild tools like `cabal`.\n\nA command can be created using
  the `subparser` builder, and commands can be\nadded with the `command` modifier.
  For example\n\n```haskell\nsubparser\n  ( command \"add\" (info addOptions\n      (
  progDesc \"Add a file to the repository\" ))\n <> command \"commit\" (info commitOptions\n
  \     ( progDesc \"Record changes to the repository\" ))\n)\n```\n\nEach command
  takes a full `ParserInfo` structure, which will be used to extract\na description
  for this command when generating a help text.\n\nNote that all the parsers appearing
  in a command need to have the same type.\nFor this reason, it is often best to use
  a sum type which has the same\nstructure as the command itself. For example, for
  the parser above, you would\ndefine a type like:\n\n```haskell\ndata Options = Options\n
  \ { optGlobalOpt :: String\n  , optGlobalFlag :: Bool\n  ...\n  , optCommand ::
  Command }\n\ndata Command\n  = Add AddOptions\n  | Commit CommitOptions\n  ...\n```\n\nAlternatively,
  you can directly return an `IO` action from a parser, and\nexecute it using `join`
  from `Control.Monad`.\n\n```haskell\nstart :: String -> IO ()\nstop :: IO ()\n\nopts
  :: Parser (IO ())\nopts = subparser\n  ( command \"start\" (info (start <$> argument
  str idm) idm)\n <> command \"stop\"  (info (pure stop) idm) )\n\nmain :: IO ()\nmain
  = join $ execParser (info opts idm)\n```\n\n## Option builders\n\nBuilders allow
  you to define parsers using a convenient combinator-based\nsyntax. Each builder
  takes a **modifier** as parameter, and returns a parser.\n\nA modifier is a composition
  of functions which act on the option, setting\nvalues for properties or adding features,
  and is used to build the option from\nscratch and finally lift it to a single-option
  parser, which can then be\ncombined with other parsers using normal `Applicative`
  combinators.\n\nModifiers are instances of the `Monoid` typeclass, so they can be
  combined\nusing the composition function `mappend` (or simply `(<>)`).\n\nSee the
  [haddock documentation][builder-documentation] for `Options.Applicative.Builder`\nfor
  a full list of builders and modifiers.\n\n## Advanced features\n\n* [Bash completion]\n*
  [Arrow interface]\n* [Disambiguation]\n\n [Bash completion]: https://github.com/pcapriotti/optparse-applicative/wiki/Bash-Completion\n
  [Arrow interface]: https://github.com/pcapriotti/optparse-applicative/wiki/Arrows\n
  [Disambiguation]: https://github.com/pcapriotti/optparse-applicative/wiki/Disambiguation\n\n##
  How it works\n\nA `Parser a` is essentially a heterogeneous list of `Option`s, implemented
  with\nexistential types.\n\nAll options are therefore known statically (i.e. before
  parsing, not\nnecessarily before runtime), and can, for example, be traversed to
  generate a\nhelp text.\n\nSee [this blog post][blog] for a more detailed explanation
  based on a\nsimplified implementation.\n\n [status-png]: https://api.travis-ci.org/pcapriotti/optparse-applicative.svg\n
  [status]: http://travis-ci.org/pcapriotti/optparse-applicative?branch=master\n [blog]:
  http://paolocapriotti.com/blog/2012/04/27/applicative-option-parser/\n [builder-documentation]:
  http://hackage.haskell.org/package/optparse-applicative/docs/Options-Applicative-Builder.html\n
  [hackage-png]: http://img.shields.io/hackage/v/optparse-applicative.svg\n [hackage]:
  http://hackage.haskell.org/package/optparse-applicative\n"
license-name: BSD3

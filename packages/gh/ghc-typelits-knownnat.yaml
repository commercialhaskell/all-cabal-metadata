homepage: http://clash-lang.org/
changelog-type: markdown
hash: 67937f663a2fcd67fe08b536d0818bf0a6604e534514e20d135c4daf8f72171c
test-bench-deps:
  base: ! '>=4.8 && <5'
  ghc-typelits-knownnat: ! '>=0.1'
  ghc-typelits-natnormalise: ! '>=0.5 && <0.6'
  singletons: ! '>=2.2 && <3.0'
  tasty-hunit: ! '>=0.9'
  tasty: ! '>=0.10'
maintainer: christiaan.baaij@gmail.com
synopsis: Derive KnownNat constraints from other KnownNat constraints
changelog: ! "# Changelog for the [`ghc-typelits-knownnat`](http://hackage.haskell.org/package/ghc-typelits-knownnat)
  package\n\n## 0.2.3 *January 15th 2017*\n* Solve normalised literal constraints,
  i.e.:\n  * `KnownNat (((addrSize + 1) - (addrSize - 1))) ~ KnownNat 2`\n\n## 0.2.2
  *September 29th 2016*\n* New features:\n  * Derive smaller constraints from larger
  constraints when they differ by a single variable, i.e. `KnownNat (a + b), KnownNat
  b` implies `KnownNat a`.\n\n## 0.2.1 *August 19th 2016*\n* Fixes bugs:\n  * Source
  location of derived wanted constraints is, erroneously, always set to line 1, column
  1\n\n## 0.2 *August 17th 2016*\n* New features:\n  * Handle `GHC.TypeLits.-`\n  *
  Handle custom, user-defined, type-level operations\n  * Thanks to Gabor Greif (@ggreif):
  derive smaller from larger constraints, i.e. `KnownNat (n+1)` implies `KnownNat
  n`\n\n## 0.1.2\n* New features: Solve \"complex\" KnownNat constraints involving
  arbitrary type-functions, as long as there is a given KnownNat constraint for this
  type functions.\n\n## 0.1.1 *August 11th 2016*\n* Fixes bug: panic on a non-given
  KnownNat constraint variable\n\n## 0.1 *August 10th 2016*\n* Initial release\n"
basic-deps:
  ghc: ! '>=8.0.1 && <8.2'
  base: ! '>=4.9 && <4.10'
  ghc-tcplugins-extra: ! '>=0.2'
  ghc-typelits-natnormalise: ! '>=0.5.2 && <0.6'
  singletons: ! '>=2.2 && <3.0'
  transformers: ! '>=0.5.2.0 && <0.6'
  template-haskell: ! '>=2.11.0.0 && <2.13'
all-versions:
- '0.1'
- '0.1.1'
- '0.2'
- '0.2.1'
- '0.2.2'
- '0.2.3'
author: Christiaan Baaij
latest: '0.2.3'
description-type: markdown
description: ! "# ghc-typelits-knownnat\n\n[![Build Status](https://secure.travis-ci.org/clash-lang/ghc-typelits-knownnat.svg?branch=master)](http://travis-ci.org/clash-lang/ghc-typelits-knownnat)\n[![Hackage](https://img.shields.io/hackage/v/ghc-typelits-knownnat.svg)](https://hackage.haskell.org/package/ghc-typelits-knownnat)\n[![Hackage
  Dependencies](https://img.shields.io/hackage-deps/v/ghc-typelits-knownnat.svg?style=flat)](http://packdeps.haskellers.com/feed?needle=exact%3Aghc-typelits-knownnat)\n\nA
  type checker plugin for GHC that can derive \"complex\" `KnownNat`\nconstraints
  from other simple/variable `KnownNat` constraints. i.e. without this\nplugin, you
  must have both a `KnownNat n` and a `KnownNat (n+2)` constraint in\nthe type signature
  of the following function:\n\n```haskell\nf :: forall n . (KnownNat n, KnownNat
  (n+2)) => Proxy n -> Integer\nf _ = natVal (Proxy :: Proxy n) + natVal (Proxy ::
  Proxy (n+2))\n```\n\nUsing the plugin you can omit the `KnownNat (n+2)` constraint:\n\n```haskell\nf
  :: forall n . KnownNat n => Proxy n -> Integer\nf _ = natVal (Proxy :: Proxy n)
  + natVal (Proxy :: Proxy (n+2))\n```\n\nThe plugin can derive `KnownNat` constraints
  for types consisting of:\n\n* Type variables, when there is a corresponding `KnownNat`
  constraint\n* Type-level naturals\n* Applications of the arithmetic expression:
  `{+,-,*,^}`\n* Type functions, when there is either:\n  * a matching given `KnownNat`
  constraint; or\n  * a corresponding `KnownNat<N>` instance for the type function\n\nTo
  elaborate the latter points, given the type family `Min`:\n\n```haskell\ntype family
  Min (a :: Nat) (b :: Nat) :: Nat where\n  Min 0 b = 0\n  Min a b = If (a <=? b)
  a b\n```\n\nthe plugin can derive a `KnownNat (Min x y + 1)` constraint given only
  a\n`KnownNat (Min x y)` constraint:\n\n```haskell\ng :: forall x y . (KnownNat (Min
  x y)) => Proxy x -> Proxy y -> Integer\ng _ _ = natVal (Proxy :: Proxy (Min x y
  + 1))\n```\n\nAnd, given the type family `Max`:\n\n```haskell\ntype family Max (a
  :: Nat) (b :: Nat) :: Nat where\n  Max 0 b = b\n  Max a b = If (a <=? b) b a\n\n$(genDefunSymbols
  [''Max]) -- creates the 'MaxSym0' symbol\n```\n\nand corresponding `KnownNat2` instance:\n\n```haskell\ninstance
  (KnownNat a, KnownNat b) => KnownNat2 \"TestFunctions.Max\" a b where\n  type KnownNatF2
  \"TestFunctions.Max\" = MaxSym0\n  natSing2 = let x = natVal (Proxy @ a)\n                 y
  = natVal (Proxy @ b)\n                 z = max x y\n             in  SNatKn z\n
  \ {-# INLINE natSing2 #-}\n```\n\nthe plugin can derive a `KnownNat (Max x y + 1)`
  constraint given only a\n`KnownNat x` and `KnownNat y` constraint:\n\n```haskell\nh
  :: forall x y . (KnownNat x, KnownNat y) => Proxy x -> Proxy y -> Integer\nh _ _
  = natVal (Proxy :: Proxy (Max x y + 1))\n```\n\nTo use the plugin, add the\n\n```\nOPTIONS_GHC
  -fplugin GHC.TypeLits.KnownNat.Solver\n```\n\nPragma to the header of your file.\n"
license-name: BSD2

homepage: ''
changelog-type: markdown
hash: 2f19d2e36a6675c873024a2d152c79846d6bec1fe2c80154692d7367bd593821
test-bench-deps: {}
maintainer: libraries@haskell.org
synopsis: GHC primitives
changelog: "## 0.7.0 (*Jan 2021*)\n\n- Shipped with GHC 9.0.1\n\n- Add known-key `cstringLength#`
  to `GHC.CString`. This is just the\n  C function `strlen`, but a built-in rewrite
  rule allows GHC to\n  compute the result at compile time when the argument is known.\n
  \ \n- In order to support unicode better the following functions in `GHC.CString`\n
  \ gained UTF8 counterparts:\n\n        unpackAppendCStringUtf8# :: Addr# -> [Char]
  -> [Char]\n        unpackFoldrCStringUtf8# :: Addr# -> (Char -> a -> a) -> a ->
  a\n\n- `unpackFoldrCString*` variants can now inline in phase `[0]`.\n\n  If the
  folding function is known this allows for unboxing of the\n  Char argument resulting
  in much faster code.\n\n- Renamed the singleton tuple `GHC.Tuple.Unit` to `GHC.Tuple.Solo`.\n\n-
  Add primops for atomic exchange:\n\n        atomicExchangeAddrAddr# :: Addr# ->
  Addr# -> State# s -> (# State# s, Addr# #)\n        atomicExchangeWordAddr# :: Addr#
  -> Word# -> State# s -> (# State# s, Word# #)\n\n- Add primops for atomic compare
  and swap at a given `Addr#`:\n\n        atomicCasAddrAddr# :: Addr# -> Addr# ->
  Addr# -> State# s -> (# State# s, Addr# #)\n        atomicCasWordAddr# :: Addr#
  -> Word# -> Word# -> State# s -> (# State# s, Word# #)\n\n- Add an explicit fixity
  for `(~)` and `(~~)`: \n\n        infix 4 ~, ~~\n\n- Introduce `keepAlive#` to replace
  `touch#` in controlling object lifetime without\n  the soundness issues of the latter
  (see\n  [#17760](https://gitlab.haskell.org/ghc/ghc/-/issues/17760)).\n\n## 0.6.1
  (*March 2020*)\n\n- Shipped with GHC 8.10.1\n\n- Add primop for shrinking `SmallMutableArray#`\n
  \ to `GHC.Prim`:\n\n        shrinkSmallMutableArray# :: SmallMutableArray# s a ->
  Int# -> State# s -> State# s\n\n  Note that `resizeSmallMutableArray#` is not included
  as\n  as primitive. It has been implemented in library space in\n  `GHC.Exts`. See
  the release notes of `base`.\n\n- Added to `GHC.Prim`:\n\n        closureSize# ::
  a -> Int#\n\n- Added to `GHC.Prim`:\n\n        bitReverse# :: Word# -> Word#\n        bitReverse8#
  :: Word# -> Word#\n        bitReverse16# :: Word# -> Word#\n        bitReverse32#
  :: Word# -> Word#\n        bitReverse64# :: Word# -> Word#\n\n  `bitReverse#` is
  a primop that, for a `Word` of 8, 16, 32 or 64 bits,\n  reverses the order of its
  bits e.g. `0b110001` becomes `0b100011`.\n  These primitives use optimized machine
  instructions when available.\n\n- Add Int# multiplication primop:\n\n      timesInt2#
  :: Int# -> Int# -> (# Int#, Int#, Int# #)\n\n   `timesInt2#` computes the multiplication
  of its two parameters and returns a\n   triple (isHighNeeded,high,low) where high
  and low are respectively the high\n   and low bits of the double-word result. isHighNeeded
  is a cheap way to test\n   if the high word is a sign-extension of the low word
  (isHighNeeded = 0#) or\n   not (isHighNeeded = 1#).\n\n## 0.6.0\n\n- Shipped with
  GHC 8.8.1\n\n- Added to `GHC.Prim`:\n\n        traceBinaryEvent# :: Addr# -> Int#
  -> State# s -> State# s\n\n## 0.5.3\n\n- Shipped with GHC 8.6.1\n\n- Added to `GHC.Prim`:\n\n
  \       addWordC# :: Word# -> Word# -> (# Word#, Int# #)\n\n- `unpackClosure#` can
  now unpack any valid Haskell closure.\n  Previously it returned empty pointer and
  non-pointer arrays\n  for thunks.\n\n- Add unaligned bytearray access primops (#4442)\n\n
  \        readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (#
  State# s, Char# #)\n         readWord8ArrayAsAddr# :: MutableByteArray# s -> Int#
  -> State# s -> (# State# s, Addr# #)\n         readWord8ArrayAsFloat# :: MutableByteArray#
  s -> Int# -> State# s -> (# State# s, Float# #)\n         readWord8ArrayAsDouble#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)\n         readWord8ArrayAsStablePtr#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# #)\n         readWord8ArrayAsInt16#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16# #)\n         readWord8ArrayAsInt32#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32# #)\n         readWord8ArrayAsInt64#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)\n         readWord8ArrayAsInt#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)\n\n         readWord8ArrayAsWord16#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16# #)\n         readWord8ArrayAsWord32#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32# #)\n         readWord8ArrayAsWord64#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)\n         readWord8ArrayAsWord#
  :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)\n\n         writeWord8ArrayAsChar#
  :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s\n         writeWord8ArrayAsAddr#
  :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s\n         writeWord8ArrayAsFloat#
  :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s\n         writeWord8ArrayAsDouble#
  :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s\n         writeWord8ArrayAsStablePtr#
  :: MutableByteArray# s -> Int# -> StablePtr# -> State# s -> State# s\n\n         writeWord8ArrayAsInt16#
  :: MutableByteArray# s -> Int# -> Int16# -> State# s -> State# s\n         writeWord8ArrayAsInt32#
  :: MutableByteArray# s -> Int# -> Int32# -> State# s -> State# s\n         writeWord8ArrayAsInt64#
  :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s\n         writeWord8ArrayAsInt#
  :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\n\n         writeWord8ArrayAsWord16#
  :: MutableByteArray# s -> Int# -> Word16# -> State# s -> State# s\n         writeWord8ArrayAsWord32#
  :: MutableByteArray# s -> Int# -> Word32# -> State# s -> State# s\n         writeWord8ArrayAsWord64#
  :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s\n         writeWord8ArrayAsWord#
  :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s\n\n## 0.5.2.0\n\n-
  Shipped with GHC 8.4.1\n\n- Added to `GHC.Prim`:\n\n        compareByteArrays# ::
  ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#\n\n- Don't allocate a thunk
  for each unpacked UTF-8 character in `unpackCStringUtf8#`\n\n## 0.5.1.1 *November
  2017*\n\n- Shipped with GHC 8.2.2\n\n- Changed strictness properties of `catchRetry#`
  (#14171)\n\n## 0.5.1.0 *July 2017*\n\n- Shipped with GHC 8.2.1\n\n- Added to `GHC.Prim`:\n\n
  \       fabsDouble# :: Double# -> Double#\n        fabsFloat# :: Float# -> Float#\n
  \       isByteArrayPinned# :: ByteArray# -> Int#\n        isMutableByteArrayPinned#
  :: MutableByteArray# s -> Int#\n        anyToAddr# :: a -> State# (RealWorld) ->
  (# State# (RealWorld),Addr# #)\n\n- New primitives for compact regions in `GHC.Prim`:\n\n
  \       Compact#\n        compactNew#\n        compactResize#\n        compactContains#\n
  \       compactContainsAny#\n        compactGetFirstBlock#\n        compactGetNextBlock#\n
  \       compactAllocateBlock#\n        compactFixupPointers#\n        compactAdd#\n
  \       compactAddWithSharing#\n        compactSize#\n\n- Generalised `noDuplicate#`
  from\n\n        noDuplicate# :: State# (RealWorld) -> State# (RealWorld)\n\n    to\n\n
  \       noDuplicate# :: State# s -> State# s\n\n\n## 0.5.0.0\n\n- Shipped with GHC
  8.0.1\n\n- `GHC.Classes`: new `class IP (a :: Symbol) b | a -> b`\n\n- `GHC.Prim`:
  changed type signatures from\n\n        check# :: (State# RealWorld -> (# State#
  RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, () #)\n        finalizeWeak#
  :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld ->
  (# State# RealWorld, () #) #)\n        mkWeak# :: a -> b -> c -> State# RealWorld
  -> (# State# RealWorld, Weak# b #)\n\n    to\n\n        check# :: (State# RealWorld
  -> (# State# RealWorld, a #)) -> State# RealWorld -> State# RealWorld\n        finalizeWeak#
  :: Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld ->
  (# State# RealWorld, b #) #)\n        mkWeak# :: a -> b -> (State# RealWorld ->
  (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)\n\n-
  Removed from `GHC.Prim`:\n\n        parAt# :: b -> a -> Int# -> Int# -> Int# ->
  Int# -> c -> Int#\n        parAtAbs# :: a -> Int# -> Int# -> Int# -> Int# -> Int#
  -> b -> Int#\n        parAtForNow# :: b -> a -> Int# -> Int# -> Int# -> Int# ->
  c -> Int#\n        parAtRel# :: a -> Int# -> Int# -> Int# -> Int# -> Int# -> b ->
  Int#\n        parGlobal# :: a -> Int# -> Int# -> Int# -> Int# -> b -> Int#\n        parLocal#
  :: a -> Int# -> Int# -> Int# -> Int# -> b -> Int#\n\n- Added to `GHC.Prim`:\n\n
  \       getSizeofMutableByteArray# :: MutableByteArray# d -> State# d -> (# State#
  d, Int# #)\n        subWordC# :: Word# -> Word# -> (# Word#, Int# #)\n        runRW#
  :: (State# RealWorld -> (# State# RealWorld, o #)) -> (# State# RealWorld, o #)\n\n-
  Added to `GHC.Types`:\n\n        data Module = Module TrName TrName\n        data
  Nat\n        data Symbol\n        data TrName = TrNameS Addr# | TrNameD [Char]\n
  \       data TyCon = TyCon Word# Word# Module TrName\n"
basic-deps:
  rts: ==1.0.*
all-versions:
- 0.3.1.0
- 0.4.0.0
- 0.5.0.0
- 0.5.1.0
- 0.5.1.1
- 0.5.2.0
- 0.5.3
- 0.6.1
- 0.7.0
author: ''
latest: 0.7.0
description-type: haddock
description: This package contains the primitive types and operations supplied by
  GHC.
license-name: BSD-3-Clause

all-versions:
- 0.1.0.0
author: Aaron Allen
basic-deps:
  async: '>=2.2 && <3'
  base: <4.23
  deferred-folds: '>=0.9 && <1'
  directory: '>=0'
  foldl: '>=1 && <2'
  ghc: '>=9.6 && <9.13'
  stm: '>=0'
  stm-containers: '>=1.2 && <1.3'
  text: '>=0'
changelog: |
  # Revision history for ghci-quickfix

  ## 0.1.0.0 -- 2026-01-09

  * First version. Released on an unsuspecting world.
changelog-type: markdown
description: "# ghci-quickfix \U0001F4DD\n\nThis is a GHC plugin that will write diagnostics
  to a file during compilation,\nwhich can then be used with `vim`/`nvim`'s quickfix
  feature. By default, the file\nis `errors.err` in the project root directory but
  this can be customized (see plugin options).\n\n**NOTE:** If you're using this plugin
  via\n[`repl-alliance`](https://github.com/aaronallen8455/repl-alliance), you need
  to\nexplicitly enable it by passing `--fplugin-opt ReplAlliance:--quickfix` to GHC\nor
  by setting the environment variable `GHCI_QUICKFIX_ENABLED=true`.\n\n## Usage\n\nThis
  plugin is intended to be used with GHCi or adjacent utilities such as\n`ghcid` and
  `ghciwatch` as a development tool, not as a package dependency.\n\n### Stack Projects\n\nTo
  use with a stack project (you may need to add `ghci-quickfix` to your\n`extra-deps`
  first):\n\n```bash\nstack repl my-project --package ghci-quickfix --ghci-options='-fplugin
  GhciQuickfix'\n```\n\n### Cabal Projects\n\nTo use with a cabal project (you may
  need to run `cabal update` first):\n\n```bash\ncabal repl my-project --build-depends
  ghci-quickfix --repl-options='-fplugin GhciQuickfix'\n```\n\n## Vim/Neovim Integration\n\nAfter
  starting your REPL with the plugin enabled, you can load errors in Vim:\n\n```vim\n:cf
  errors.err\n```\n\nThe `errors.err` argument can be omitted since it is the default
  file.\n\nOr to update without jumping to the first error:\n\n```vim\n:cg errors.err\n```\n\nNavigate
  between error locations using `:cn` (next) and `:cp` (previous).\n\nTo get highlighting
  for errors and warnings in the editor, you can turn the\nquickfix entries into diagnostics.
  The following snippet can be added to your\n`init.lua` file to accomplish this.\n\n```lua\n--
  [[ Quickfix to diagnostics ]]\n-- Configure errorformat to distinguish between warning
  and error type.\nvim.o.errorformat = '%f:%l:%c: %tarning: %m,%f:%l:%c: %trror: %m,'
  .. vim.o.errorformat\n\n-- Create namespace for quickfix diagnostics\nlocal qf_ns
  = vim.api.nvim_create_namespace('quickfix_diagnostics')\n\n-- Configure diagnostic
  display for quickfix namespace\nvim.diagnostic.config({\n  underline = true,\n  virtual_text
  = false,\n  signs = true,\n  update_in_insert = false,\n}, qf_ns)\n\n-- Helper function
  to create diagnostic entry from quickfix item\nlocal function create_diagnostic_from_qf_item(item)\n
  \ local severity = vim.diagnostic.severity.ERROR\n\n  -- Determine severity based
  on type field\n  if item.type == 'W' or item.type == 'w' then\n    severity = vim.diagnostic.severity.WARN\n
  \ end\n\n  -- Handle column range - if no end_col, highlight to end of line\n  local
  col_start = (item.col or 1) - 1\n  local col_end = nil\n  local end_lnum = nil\n\n
  \ if item.end_col and item.end_col > 0 and item.end_lnum then\n    col_end = item.end_col\n
  \   end_lnum = item.end_lnum - 1\n  end\n\n  return {\n    lnum = item.lnum - 1,\n
  \   col = col_start,\n    end_lnum = end_lnum,\n    end_col = col_end,\n    severity
  = severity,\n    message = item.text or '',\n    source = 'quickfix',\n  }\nend\n\n--
  Function to convert quickfix entries to diagnostics and apply to all buffers\nlocal
  function quickfix_to_diagnostics()\n  -- Clear all quickfix diagnostics from all
  buffers\n  vim.diagnostic.reset(qf_ns)\n\n  local qf_list = vim.fn.getqflist()\n
  \ local diagnostics_by_buf = {}\n\n  for _, item in ipairs(qf_list) do\n    if item.bufnr
  > 0 and item.lnum > 0 then\n      if not diagnostics_by_buf[item.bufnr] then\n        diagnostics_by_buf[item.bufnr]
  = {}\n      end\n      table.insert(diagnostics_by_buf[item.bufnr], create_diagnostic_from_qf_item(item))\n
  \   end\n  end\n\n  -- Set diagnostics for each buffer\n  for bufnr, diagnostics
  in pairs(diagnostics_by_buf) do\n    vim.diagnostic.set(qf_ns, bufnr, diagnostics,
  {})\n  end\nend\n\n-- Function to apply diagnostics for a specific buffer\nlocal
  function apply_quickfix_diagnostics_for_buffer(bufnr)\n  local qf_list = vim.fn.getqflist()\n
  \ local diagnostics = {}\n\n  for _, item in ipairs(qf_list) do\n    if item.bufnr
  == bufnr and item.lnum > 0 then\n      table.insert(diagnostics, create_diagnostic_from_qf_item(item))\n
  \   end\n  end\n\n  vim.diagnostic.set(qf_ns, bufnr, diagnostics, {})\nend\n\n--
  Auto-convert quickfix entries to diagnostics when loading from file\nvim.api.nvim_create_autocmd('QuickFixCmdPost',
  {\n  pattern = '[cg]file,[cg]getfile',\n  callback = function()\n    quickfix_to_diagnostics()\n
  \ end,\n})\n\n-- Reapply diagnostics when a buffer is read (handles newly opened
  buffers)\nvim.api.nvim_create_autocmd('BufReadPost', {\n  pattern = '*',\n  callback
  = function(args)\n    local qf_list = vim.fn.getqflist()\n    if #qf_list == 0 then\n
  \     return\n    end\n\n    -- Only apply diagnostics for this specific buffer
  if it has quickfix entries\n    local bufnr = args.buf\n    for _, item in ipairs(qf_list)
  do\n      if item.bufnr == bufnr then\n        apply_quickfix_diagnostics_for_buffer(bufnr)\n
  \       return\n      end\n    end\n  end,\n})\n```\n\n## Plugin Options\n\nPlugin
  options are passed using the `--fplugin-opt` flag. For example:\n\n```bash\n-fplugin
  GhciQuickfix -fplugin-opt GhciQuickfix:--quickfix-file=my-errors.err\n```\n\n###
  Available Options\n\n- **`--quickfix-file=<path>`**\n  Specify the output file path
  for diagnostics.\n  Default: `errors.err`\n  Alternative: Set environment variable
  `GHCI_QUICKFIX_FILE=<path>`\n\n- **`--quickfix-include-parser-errors`**\n  Include
  parser errors in the quickfix file.\n  Default: Parser errors are excluded (HLint
  typically reports them)\n  Alternative: Set environment variable `GHCI_QUICKFIX_INCLUDE_PARSER_ERRORS=true`\n\n-
  **`--quickfix-path-replace=<needle>:<replace>`**\n  Replace text in file paths in
  the quickfix output.\n  Example: `--quickfix-path-replace=/home/user:/Users/user`\n
  \ Can be specified multiple times for multiple replacements.\n  Useful for containerized
  or remote development environments.\n  Alternative: Set environment variable `GHCI_QUICKFIX_PATH_REPLACE=<needle>:<replace>`\n\n-
  **`--quickfix`**\n  Explicitly enable the plugin when using `pluginOffByDefault`
  (e.g., with repl-alliance).\n  Alternative: Set environment variable `GHCI_QUICKFIX_ENABLED=true`\n\n##
  Output Format\n\nThe plugin generates quickfix entries in GCC-style format:\n\n```\nfilename.hs:line:col:
  severity: message\n```\n\nThis format is automatically recognized by Vim's quickfix
  system.\n\n## Compatibility\n\nThis plugin aims to support the 4 latest GHC major
  releases (i.e. `9.6.*` through `9.12.*`).\nCheck the cabal file for the currently
  supported versions.\n"
description-type: markdown
hash: 0b8e7d1ca1a8e16eb3ebbde3819ba491a12b4217e745f627ff376b04c38752f7
homepage: ''
latest: 0.1.0.0
license-name: BSD-3-Clause
maintainer: aaronallen8455@gmail.com
synopsis: GHC plugin that writes errors to a file for use with quickfix
test-bench-deps:
  async: '>=0'
  base: '>=0'
  directory: '>=0'
  ghci-quickfix: '>=0'
  process: '>=0'
  tasty: '>=0'
  tasty-hunit: '>=0'

homepage: https://github.com/AndrasKovacs/flatparse#readme
changelog-type: ''
hash: 831c1ac0bfde04adea85a322d671596262331535437195101fa9752f8677564f
test-bench-deps:
  bytestring: -any
  flatparse: -any
  base: '>=4.7 && <5'
  megaparsec: -any
  parsec: -any
  integer-gmp: -any
  gauge: -any
  attoparsec: -any
  primitive: -any
  bytesmith: -any
maintainer: puttamalac@gmail.com
synopsis: High-performance parsing from strict bytestrings
changelog: ''
basic-deps:
  bytestring: -any
  base: '>=4.7 && <5'
  integer-gmp: -any
  containers: -any
  template-haskell: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.1.1
- 0.1.1.2
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
author: András Kovács
latest: 0.2.2.0
description-type: markdown
description: "# flatparse\r\n\r\n[![Hackage](https://img.shields.io/hackage/v/flatparse.svg)](https://hackage.haskell.org/package/flatparse)\r\n![CI](https://github.com/AndrasKovacs/flatparse/actions/workflows/haskell.yml/badge.svg)\r\n\r\n`flatparse`
  is a high-performance parsing library, focusing on __programming languages__ and
  __human-readable data formats__. The \"flat\" in the name\r\nrefers to the `ByteString`
  parsing input, which has pinned contiguous data, and also to the library internals,
  which avoids indirections and heap allocations\r\nwhenever possible.\r\n\r\n## Features
  and non-features\r\n\r\n* __Excellent performance__. On microbenchmarks, `flatparse`
  is around 10 times faster than `attoparsec` or `megaparsec`. On larger examples
  with heavier use of source positions and spans and/or indentation parsing, the performance
  difference grows to 20-30 times. Compile times and exectuable sizes are also significantly
  better with `flatparse` than with `megaparsec` or `attoparsec`. `flatparse` internals
  make liberal use of unboxed tuples and GHC primops. As a result, pure validators
  (parsers returning `()`) in `flatparse` are not difficult to implement with zero
  heap allocation.\r\n* __No incremental parsing__, and __only strict `ByteString`__
  is supported as input. However, it can be still useful to convert from `Text`, `String`
  or other types to `ByteString`, and then use `flatparse` for parsing, since `flatparse`
  performance usually more than makes up for the conversion costs.\r\n* __Only little-endian
  64 bit systems are currently supported__. This may change in the future. Getting
  good performance requires architecture-specific optimizations; I've only considered
  the most common setting at this point.\r\n* __Support for fast source location handling,
  indentation parsing and informative error messages__. `flatparse` provides a low-level
  interface to these. Batteries are _not included_, but it should be possible for
  users to build custom solutions, which are more sophisticated, but still as fast
  as possible. In my experience, the included batteries in other libraries often come
  with major unavoidable overheads, and often we still have to extend existing machinery
  in order to scale to production features.\r\n* The __backtracking model__ of `flatparse`
  is different to parsec libraries, and is more close to the [nom](https://github.com/Geal/nom)
  library in Rust. The idea is that _parser failure_ is distinguished from _parsing
  error_. The former is used for control flow, and we can backtrack from it. The latter
  is used for unrecoverable errors, and by default it's propagated to the top. `flatparse`
  does not track whether parsers have consumed inputs. In my experience, what we really
  care about is the failure/error distinction, and in `parsec` or `megaparsec` the
  consumed/non-consumed separation is often muddled and discarded in larger parser
  implementations. By default, basic `flatparse` parsers can fail but can not throw
  errors, with the exception of the specifically error-throwing operations. Hence,
  `flatparse` users have to be mindful about grammar, and explicitly insert errors
  where it is known that the input can't be valid.\r\n\r\n`flatparse` comes in two
  flavors: [`FlatParse.Basic`][basic] and [`FlatParse.Stateful`][stateful]. Both support
  a custom error type.\r\n\r\n* [`FlatParse.Basic`][basic] only supports the above
  features. If you don't need indentation\r\n  parsing, this is sufficient.\r\n* [`FlatParse.Stateful`][stateful]
  additionally supports a built-in `Int` worth of internal state\r\n  and an additional
  `Int` reader environment. This can support a wide range of indentation parsing\r\n
  \ features. There is a slight overhead in performance and code size compared to
  `Basic`. However, in\r\n  small parsers and microbenchmarks the difference between
  `Basic` and `Stateful` is often reduced\r\n  to near zero by GHC and/or LLVM optimization.\r\n\r\n##
  Tutorial\r\n\r\nInformative tutorials are work in progress. See [`src/FlatParse/Examples`](src/FlatParse/Examples)\r\nfor
  a lexer/parser example with acceptably good error messages.\r\n\r\n## Contribution\r\n\r\nPull
  requests are welcome. I'm fairly quick to add PR authors as collaborators.\r\n\r\n##
  Some benchmarks\r\n\r\nExecution times below. See source code in [bench](bench).
  Compiled with GHC 8.8.4 `-O2 -fllvm`.\r\n\r\n|      benchmark              |  runtime
  \  |\r\n|-----------------------------|-------------\r\n| sexp/fpbasic                |
  3.345 ms   |\r\n| sexp/fpstateful             | 3.441 ms   |\r\n| sexp/bytesmith
  \             | 5.646 ms   |\r\n| sexp/attoparsec             | 43.58 ms   |\r\n|
  sexp/megaparsec             | 57.76 ms   |\r\n| sexp/parsec                 | 182.4
  ms   |\r\n| long keyword/fpbasic        | 306.1 μs   |\r\n| long keyword/fpstateful
  \    | 220.3 μs   |\r\n| long keyword/bytesmith      | 1.707 ms   |\r\n| long keyword/attoparsec
  \    | 5.420 ms   |\r\n| long keyword/megaparsec     | 3.605 ms   |\r\n| long keyword/parsec
  \        | 50.10 ms   |\r\n| numeral csv/fpbasic         | 898.4 μs   |\r\n| numeral
  csv/fpstateful      | 868.3 μs   |\r\n| numeral csv/bytesmith       | 2.412 ms   |\r\n|
  numeral csv/attoparsec      | 21.30 ms   |\r\n| numeral csv/megaparsec      | 10.37
  ms   |\r\n| numeral csv/parsec          | 78.16 ms   |\r\n\r\nObject file sizes
  for each module containing the `s-exp`, `long keyword` and `numeral csv` benchmarks.\r\n\r\n|
  library    | object file size (bytes) |\r\n| -------    | ------------------------
  |\r\n| fpbasic    |  26456                   |\r\n| fpstateful |  30008                   |\r\n|
  bytesmith  |  39240                   |\r\n| attoparsec |  83288                   |\r\n|
  megaparsec |  188696                  |\r\n| parsec     |  75880                   |\r\n\r\n[basic]:
  https://hackage.haskell.org/package/flatparse/docs/FlatParse-Basic.html\r\n[stateful]:
  https://hackage.haskell.org/package/flatparse/docs/FlatParse-Stateful.html\r\n"
license-name: MIT

homepage: https://github.com/peti/flexible-defaults
changelog-type: ''
hash: 6a7ab000561e1075003cb1053dfbbb4020ae2b02916776d1479c9c3fc82f5d0d
test-bench-deps: {}
maintainer: Peter Simons <simons@cryp.to>
synopsis: Generate default function implementations for complex type classes.
changelog: ''
basic-deps:
  base: ! '>=3 && <5'
  containers: -any
  th-extras: -any
  transformers: -any
  template-haskell: -any
all-versions:
- 0.0.0.1
- 0.0.0.2
- 0.0.0.3
- 0.0.1.0
- 0.0.1.1
- 0.0.1.2
- 0.0.2
- 0.0.3
author: James Cook <mokus@deepbondi.net>
latest: 0.0.3
description-type: haddock
description: |-
  Template Haskell code to implement default implementations
  for type-class functions based on which functions are
  already implemented.  Currently extremely crude but
  still fairly effective.

  When defining a type class with many functions, each
  of which can be implemented based on arbitrary subsets
  of the others, the standard default-implementation
  concept breaks down quite badly.  This library provides
  a system by which more complex rules can be described
  for choosing default implementations based on which
  ones the user supplies.  These implementations can
  additionally be given \"suitability scores\", so that
  when multiple possible choices could be made, the
  library can choose the \"best\" one.
license-name: LicenseRef-PublicDomain

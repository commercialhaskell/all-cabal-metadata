homepage: https://github.com/esmolanka/sexp-grammar
changelog-type: ''
hash: 393ccb0366343d8b636e52a2913e46fac1b19ffe31225811bd85a745112a6ece
test-bench-deps:
  bytestring: -any
  base: -any
  text: -any
  criterion: -any
  semigroups: -any
  sexp-grammar: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
  scientific: -any
  QuickCheck: -any
maintainer: Eugene Smolanka <esmolanka@gmail.com>, Sergey Vinokurov <serg.foo@gmail.com>
synopsis: Invertible parsers for S-expressions
changelog: ''
basic-deps:
  bytestring: -any
  split: -any
  base: ! '>=4.7 && <5'
  text: -any
  semigroups: -any
  array: -any
  tagged: -any
  containers: -any
  mtl: ! '>=2.1'
  prettyprinter: -any
  transformers: -any
  scientific: -any
  template-haskell: -any
  profunctors: -any
all-versions:
- '1.1.1'
- '1.2.1'
- '1.2.2'
- '1.2.3'
- '1.2.4'
- '1.3.0'
author: Eugene Smolanka, Sergey Vinokurov
latest: '1.3.0'
description-type: markdown
description: ! "[![Build Status](https://travis-ci.org/esmolanka/sexp-grammar.svg?branch=master)](https://travis-ci.org/esmolanka/sexp-grammar)\n\nsexp-grammar\n============\n\nInvertible
  syntax library for serializing and deserializing Haskell structures\ninto S-expressions.
  Just write a grammar once and get both parser and\npretty-printer, for free.\n\n**WARNING:
  highly unstable and experimental software. Not intended for production**\n\nThe
  approach used in `sexp-grammar` is inspired by the paper\n[Invertible syntax descriptions:
  Unifying parsing and pretty printing]\n(http://www.informatik.uni-marburg.de/~rendel/unparse/)
  and a similar\nimplementation of invertible grammar approach for JSON, library by
  Martijn van\nSteenbergen called [JsonGrammar2](https://github.com/MedeaMelana/JsonGrammar2).\n\nLet's
  take a look at example:\n\n```haskell\nimport Language.SexpGrammar\nimport Language.SexpGrammar.Generic\n\ndata
  Person = Person\n  { pName    :: String\n  , pAddress :: String\n  , pAge     ::
  Maybe Int\n  } deriving (Show, Generic)\n\npersonGrammar :: SexpG Person\npersonGrammar
  = with $                -- Person is isomorphic to:\n  list (                              --
  a list with\n    el (sym \"person\") >>>             -- a symbol \"person\",\n    el
  string'        >>>             -- a string, and\n    props (                           --
  a property-list with\n      Kw \"address\" .:  string' >>>    -- a keyword :address
  and a string value, and\n      Kw \"age\"     .:? int))          -- an optional
  keyword :age with int value.\n```\n\nSo now we can use `personGrammar` to parse
  S-expressions to records of type\n`Person` and pretty-print records of type `Person`
  back to S-expressions:\n\n```haskell\nghci> import Language.SexpGrammar\nghci> import
  qualified Data.ByteString.Lazy.Char8 as B8\nghci> person <- either error id . decodeWith
  personGrammar . B8.pack <$> getLine\n(person \"John Doe\" :address \"42 Whatever
  str.\" :age 25)\nghci> person\nPerson {pName = \"John Doe\", pAddress = \"42 Whatever
  str.\", pAge = Just 25}\nghci> either print B8.putStrLn . encodeWith personGrammar
  $ person\n(person \"John Doe\" :address \"42 Whatever str.\" :age 25)\n```\n\nSee
  more [examples](https://github.com/esmolanka/sexp-grammar/tree/master/examples)
  in the repository.\n\nHow it works\n------------\n\nThe grammars are described in
  terms of isomorphisms and stack manipulation\noperations. Primitive grammars provided
  by the core library match Sexp literals,\nlists, and vectors to Haskell values and
  put them onto stack. Then isomorphisms\nbetween values on the stack and more complex
  Haskell ADTs (like `Person` record\nin the example above) take place. Such isomorphisms
  can be generated by\n`TemplateHaskell` or GHC Generics.\n\nThe simplest primitive
  grammars are atom grammars, which match `Sexp` atoms with\nHaskell counterparts:\n\n```haskell\n
  \                            --               grammar type   | consumes     | produces\n
  \                            --    --------------------------+--------------+-----------------\nbool
  \   :: SexpG Bool        -- or :: Grammar SexpGrammar     (Sexp :- t)    (Bool       :-
  t)\ninteger :: SexpG Integer     -- or :: Grammar SexpGrammar     (Sexp :- t)    (Integer
  \   :- t)\nint     :: SexpG Int         -- or :: Grammar SexpGrammar     (Sexp :-
  t)    (Int        :- t)\nreal    :: SexpG Scientific  -- or :: Grammar SexpGrammar
  \    (Sexp :- t)    (Scientific :- t)\ndouble  :: SexpG Double      -- or :: Grammar
  SexpGrammar     (Sexp :- t)    (Double     :- t)\nstring  :: SexpG Text        --
  or :: Grammar SexpGrammar     (Sexp :- t)    (Text       :- t)\nstring' :: SexpG
  String      -- or :: Grammar SexpGrammar     (Sexp :- t)    (String     :- t)\nsymbol
  \ :: SexpG Text        -- or :: Grammar SexpGrammar     (Sexp :- t)    (Text       :-
  t)\nsymbol' :: SexpG String      -- or :: Grammar SexpGrammar     (Sexp :- t)    (String
  \    :- t)\nkeyword :: SexpG Kw          -- or :: Grammar SexpGrammar     (Sexp
  :- t)    (Kw         :- t)\nsym     :: Text -> SexpG_    -- or :: Grammar SexpGrammar
  \    (Sexp :- t)    t\nkw      :: Kw   -> SexpG_    -- or :: Grammar SexpGrammar
  \    (Sexp :- t)    t\n```\n\nGrammars matching lists and vectors can be defined
  using an auxiliary grammar\ntype `SeqGrammar`. The following primitives embed `SeqGrammar`s
  into main\n`SexpGrammar` context:\n\n```haskell\nlist  :: Grammar SeqGrammar t t'
  -> Grammar SexpGrammar (Sexp :- t) t'\nvect  :: Grammar SeqGrammar t t' -> Grammar
  SexpGrammar (Sexp :- t) t'\n```\n\nGrammar type `SeqGrammar` basically describes
  the sequence of elements in a\n`Sexp` list (or vector). Single element grammar is
  defined with `el`, \"match\nrest of the sequence as list\" grammar could be defined
  with `rest` combinator.\nIf the rest of the sequence is a property list, `props`
  combinator should be\nused.\n\n```haskell\nel    :: Grammar SexpGrammar (Sexp :-
  a)  b       -> Grammar SeqGrammar a b\nrest  :: Grammar SexpGrammar (Sexp :- a)
  (b :- a) -> Grammar SeqGrammar a ([b] :- a)\nprops :: Grammar PropGrammar a b                  ->
  Grammar SeqGrammar a b\n```\n\n`props` combinator embeds properties grammar `PropGrammar`
  into a `SeqGrammar`\ncontext. `PropGrammar` describes what keys and values to match.\n\n```haskell\n(.:)
  \ :: Kw\n      -> Grammar SexpGrammar (Sexp :- t) (a :- t)\n      -> Grammar PropGrammar
  t (a :- t)\n\n(.:?) :: Kw\n      -> Grammar SexpGrammar (Sexp :- t) (a :- t)\n      ->
  Grammar PropGrammar t (Maybe a :- t)\n```\n\nPlease refer to Haddock on [Hackage](http://hackage.haskell.org/package/sexp-grammar)\nfor
  API documentation.\n\nDiagram of grammar contexts:\n\n```\n\n     --------------------------------------\n
  \    |              AtomGrammar           |\n     --------------------------------------\n
  \        ^\n         |  atomic grammar combinators\n         v\n ------------------------------------------------------\n
  |                      SexpGrammar                   |\n ------------------------------------------------------\n
  \        | list, vect     ^              ^\n         v                | el, rest
  \    |\n     ----------------------------------  |\n     |           SeqGrammar
  \          |  |\n     ----------------------------------  | (.:)\n              |
  props                    | (.:?)\n              v                          |\n          -------------------------------------\n
  \         |             PropGrammar           |\n          -------------------------------------\n\n```\n"
license-name: BSD3

homepage: https://github.com/valderman/selda
changelog-type: markdown
hash: 6c2d2c0f6f72c45e4458a50e91b6cb1e767ce148d7265bd2b89105426a6f8825
test-bench-deps: {}
maintainer: anton@ekblad.cc
synopsis: Type-safe, high-level EDSL for interacting with relational databases.
changelog: ! '# Revision history for selda


  ## 0.1.5.0 -- 2017-05-05


  * Inner join support.

  * More sensible names in backend API.

  * Fix rounding and casts.



  ## 0.1.4.1 -- 2017-05-04


  * Fix cache consistency bug in the presence of multiple databases.



  ## 0.1.4.0 -- 2017-05-04


  * Add uniqueness constraints and foreign keys.



  ## 0.1.3.3 -- 2017-05-04


  * Fix cache invalidation race when using transactions.



  ## 0.1.3.2 -- 2017-05-01


  * Only throw well-documented, Selda-specific exceptions.



  ## 0.1.3.1 -- 2017-05-01


  * More hackage-friendly README.



  ## 0.1.3.0 -- 2017-04-30


  * Add selectors for non-generic tables.

  * Allow default insertions on all columns.

  * More sensible API for LIMIT.

  * Fix broken SQL being generated for pathological corner cases.

  * Documentation fixes.



  ## 0.1.2.0 -- 2017-04-20


  * Replace `¤` with `:*:` in table definitions.



  ## 0.1.1.1 -- 2017-04-20


  * Generic tables, queries and mutation.

  * Select from inline tables.

  * Tutorial updates.

  * Minor bugfixes.



  ## 0.1.0.0 -- 2017-04-14


  * Initial release.

'
basic-deps:
  exceptions: ! '>=0.8 && <0.9'
  base: ! '>=4.8 && <5'
  time: ! '>=1.6 && <1.9'
  unordered-containers: ! '>=0.2 && <0.3'
  text: ! '>=1.0 && <1.3'
  mtl: ! '>=2.0 && <2.3'
  hashable: ! '>=1.1 && <1.3'
  transformers: ! '>=0.4 && <0.6'
  psqueues: ! '>=0.2 && <0.3'
all-versions:
- '0.1.0.0'
- '0.1.1.0'
- '0.1.1.1'
- '0.1.2.0'
- '0.1.3.0'
- '0.1.3.1'
- '0.1.3.2'
- '0.1.3.3'
- '0.1.4.0'
- '0.1.4.1'
- '0.1.5.0'
author: Anton Ekblad
latest: '0.1.5.0'
description-type: markdown
description: ! "Selda\n=====\n[![Hackage](https://img.shields.io/hackage/v/selda.svg?style=flat)](http://hackage.haskell.org/package/selda)\n[![IRC
  channel](https://img.shields.io/badge/IRC-%23selda-1e72ff.svg?style=flat)](https://www.irccloud.com/invite?channel=%23selda&amp;hostname=irc.freenode.net&amp;port=6697&amp;ssl=1)\n![MIT
  License](http://img.shields.io/badge/license-MIT-brightgreen.svg)\n[![Build Status](https://travis-ci.org/valderman/selda.svg?branch=master)](https://travis-ci.org/valderman/selda)\n![Hackage
  Dependencies](https://img.shields.io/hackage-deps/v/selda.svg)\n\n\nWhat is Selda?\n==============\nSelda
  is an embedded domain-specific language for interacting with relational\ndatabases.
  It was inspired by [LINQ](https://en.wikipedia.org/wiki/Language_Integrated_Query)
  and\n[Opaleye](http://hackage.haskell.org/package/opaleye).\n\n\nFeatures\n========\n\n*
  Monadic interface: no need to be a category theory wizard just to write a few\n
  \ database queries.\n* Portable: backends for SQLite and PostgreSQL.\n* Generic:
  easy integration with your existing Haskell types.\n* Creating, dropping and querying
  tables using type-safe database schemas.\n* Typed query language with products,
  filtering, joins and aggregation.\n* Inserting, updating and deleting rows from
  tables.\n* Transactions, uniqueness constraints and foreign keys.\n* Configurable,
  automatic, consistent in-process caching of query results.\n* Lightweight and modular:
  non-essential features are optional or split into\n  add-on packages.\n\n\nGetting
  started\n===============\n\nInstall the `selda` package from Hackage, as well as
  at least one of the\nbackends:\n\n    $ cabal update\n    $ cabal install selda
  selda-sqlite selda-postgresql\n\nThen, read the tutorial.\nThe [API documentation](http://hackage.haskell.org/package/selda)
  will probably\nalso come in handy.\n\n\nRequirements\n============\n\nSelda requires
  GHC 7.10+, as well as SQLite 3.7.11+ or PostgreSQL 9+.\nTo build the SQLite backend,
  you need a C compiler installed.\nTo build the PostgreSQL backend, you need the
  `libpq` development libraries\ninstalled (`libpq-dev` on Debian-based Linux distributions).\n\n\nA
  brief tutorial\n================\n\nDefining a schema\n-----------------\n\nTo work
  productively with Selda, you will need to enable the `TypeOperators` and\n`OverloadedStrings`
  extensions.\n\nTable schemas are defined as the product of one or more columns,
  stitched\ntogether using the `:*:` operator.\nA table is parameterized over the
  types of its columns, with the column types\nalso separated by the `:*:` operator.
  This, by the way, is why you need\n`TypeOperators`.\n\n```\npeople :: Table (Text
  :*: Int :*: Maybe Text)\npeople = table \"people\" $ primary \"name\" :*: required
  \"age\" :*: optional \"pet\"\n\naddresses :: Table (Text :*: Text)\naddresses =
  table \"addresses\" $ required \"name\" :*: required \"city\"\n```\n\nColumns may
  be either `required` or `optional`.\nAlthough the SQL standard supports nullable
  primary keys, Selda primary keys\nare always required.\n\n\nRunning queries\n---------------\n\nSelda
  operations are run in the `SeldaT` monad transformer, which can be layered\non top
  of any `MonadIO`. Throughout this tutorial, we will simply use the Selda\nmonad
  `SeldaM`, which is just a synonym for `SeldaT IO`.\n`SeldaT` is entered using a
  backend-specific `withX` function. For instance,\nthe SQLite backend uses the `withSQLite`
  function:\n\n```\nmain :: IO ()\nmain = withSQLite \"my_database.sqlite\" $ do\n
  \ people <- getAllPeople\n  liftIO (print people)\n\ngetAllPeople :: SeldaM [Text
  :*: Int :*: Maybe Text]\ngetAllPeople = query (select people)\n```\n\nThis will
  open the `my_database.sqlite` database for the duration of the\ncomputation. If
  the computation terminates normally, or if it raises an\nexception, the database
  is automatically closed.\n\nNote the somewhat weird return type of `getAllPeople`.
  In Selda, queries are\nrepresented using *inductive tuples*: a list of values, separated\nby
  the `:*:` operator, but where each element can have a different type.\nYou can think
  of them as tuples with a slightly different syntax.\nIn this example, `getAllPeople`
  having a return type of\n`[Text :*: Int :*: Maybe Text]` means that it returns a
  list of \"3-tuples\",\nwhere the three elements have the types `Text`, `Int` and
  `Maybe Text`\nrespectively.\n\nYou can pattern match on these values as you would
  on normal tuples:\n\n```\nfirstOfThree :: (a :*: b :*: c) -> a\nfirstOfThree (a
  :*: b :*: c) = a\n```\n\nSince inductive tuples are inductively defined, you may
  also choose to pattern\nmatch on just the first few elements:\n\n```\nfirstOfN ::
  (a :*: rest) -> a\nfirstOfN (a :*: _) = a\n```\n\nThroughout the rest of this tutorial,
  we will simply use inductive tuples as if\nthey were \"normal\" tuples.\n\n\nCreating
  and deleting databases\n-------------------------------\n\nYou can use a table definition
  to create the corresponding table in your\ndatabase backend, as well as delete it.\n\n```\nsetup
  :: SeldaM ()\nsetup = do\n  createTable people\n  createTable addresses\n\nteardown
  :: SeldaM ()\nteardown = do\n  tryDropTable people\n  tryDropTable addresses\n```\n\nBoth
  creating and deleting tables comes in two variants: the `try` version\nwhich is
  a silent no-op when attempting to create a table that already exists\nor delete
  one that doesn't, and the \"plain\" version which raises an error.\n\n\nInserting
  data\n--------------\n\nData insertion is done in batches. To insert a batch of
  rows, pass a list of\nrows where each row is an inductive tuple matching the type
  of the table.\nOptional values are encoded as `Maybe` values.\n\n```\npopulate ::
  SeldaM ()\npopulate = do\n  insert_ people\n    [ \"Link\"      :*: 125 :*: Just
  \"horse\"\n    , \"Velvet\"    :*: 19  :*: Nothing\n    , \"Kobayashi\" :*: 23  :*:
  Just \"dragon\"\n    , \"Miyu\"      :*: 10  :*: Nothing\n    ]\n  insert_ addresses\n
  \   [ \"Link\"      :*: \"Kakariko\"\n    , \"Kobayashi\" :*: \"Tokyo\"\n    , \"Miyu\"
  \     :*: \"Fuyukishi\"\n    ]\n```\n\nInsertions come in two variants: the \"plain\"
  version which reports back the\nnumber of inserted rows, and one appended with an
  underscore which returns `()`.\nUse the latter to explicitly indicate your intent
  to ignore the return value.\n\nThe following example inserts a few rows into a table
  with an\nauto-incrementing primary key:\n\n```\npeople' :: Table (Int :*: Text :*:
  Int :*: Maybe Text)\npeople' = table \"people_with_ids\"\n  $   autoPrimary \"id\"\n
  \ :*: required \"name\"\n  :*: required \"age\"\n  :*: optional \"pet\"\n\npopulate'
  :: SeldaM ()\npopulate' = do\n  insert_ people'\n    [ def :*: \"Link\"      :*:
  125 :*: Just \"horse\"\n    , def :*: \"Velvet\"    :*: 19  :*: Nothing\n    , def
  :*: \"Kobayashi\" :*: 23  :*: Just \"dragon\"\n    , def :*: \"Miyu\"      :*: 10
  \ :*: Nothing\n    ]\n```\n\nNote the use of the `def` value for the `id` field.
  This indicates that the\ndefault value for the column should be used in lieu of
  any user-provided value.\nSince the `id` field is an auto-incrementing primary key,
  it will automatically\nbe assigned a unique, increasing value.\nThus, the resulting
  table would look like this:\n\n```\nid | name      | age | pet\n-----------------------------\n
  0 | Link      | 125 | horse\n 1 | Velvet    | 19  |\n 2 | Kobayashi | 23  | dragon\n
  3 | Miyu      | 10  |\n```\n\nAlso note that `def` can *only* be used for columns
  that have default values.\nCurrently, only auto-incrementing primary keys can have
  defaults.\nAttempting to use `def` in any other context results in a runtime error.\n\n\nUpdating
  rows\n-------------\n\nTo update a table, pass the table and two functions to the
  `update` function.\nThe first is a predicate over table columns. The second is a
  mapping over table \ncolumns, specifying how to update each row. Only rows satisfying
  the predicate \nare updated.\n\n```\nage10Years :: SeldaM ()\nage10Years = do\n
  \ update_ people (\\(name :*: _ :*: _) -> name ./= \"Link\")\n                 (\\(name
  :*: age :*: pet) -> name :*: age + 10 :*: pet)\n```\n\nNote that you can use arithmetic,
  logic and other standard SQL operations on\nthe columns in either function. Columns
  implement the appropriate numeric\ntype classes. For operations with less malleable
  types -- logic and\ncomparisons, for instance -- the standard Haskell operators
  are prefixed\nwith a period (`.`).\n\n\nDeleting rows\n-------------\n\nDeleting
  rows is quite similar to updating them. The only difference is that\nthe `deleteFrom`
  operation takes a table and a predicate, specifying which rows\nto delete.\nThe
  following example deletes all minors from the `people` table:\n\n```\nbyeMinors
  :: SeldaM ()\nbyeMinors = deleteFrom_ people (\\(_ :*: age :*: _) -> age .< 20)\n```\n\n\nBasic
  queries\n-------------\n\nQueries are written in the `Query` monad, in which you
  can query tables,\nrestrict the result set, and perform inner, aggregate queries.\nQueries
  are executed in some Selda monad using the `query` function.\n\nThe following example
  uses the `select` operation to draw each row from the\n`people` table, and the `restrict`
  operation to remove out all rows except\nthose having an `age` column with a value
  greater than 20.\n\n\n```\ngrownups :: Query s (Col s Text)\ngrownups = do\n  (name
  :*: age :*: _) <- select people\n  restrict (age .> 20)\n  return name\n\nprintGrownups
  :: SeldaM ()\nprintGrownups = do\n  names <- query grownups\n  liftIO (print names)\n```\n\nYou
  may have noticed that in addition to the return type of a query,\nthe `Query` type
  has an additional type parameter `s`.\nWe'll cover this parameter in more detail
  when we get to\naggregating queries, so for now you can just ignore it.\n\n\nSelector
  functions\n------------------\n\nIt's often annoying to explicitly take the tuples
  returned by queries apart.\nFor this reason, Selda provides a function `selectors`
  to generate\n*selectors*: identifiers which can be used with the `!` operator to
  access\nelements of inductive tuples similar to how record selectors are used to
  access\nfields of standard Haskell record types.\n\nRewriting the previous example
  using selector functions:\n\n```\nname :*: age :*: pet = selectors people\n\ngrownups
  :: Query s (Col s Text)\ngrownups = do\n  p <- select people\n  restrict (p ! age
  .> 20)\n  return (p ! name)\n\nprintGrownups :: SeldaM ()\nprintGrownups = do\n
  \ names <- query grownups\n  liftIO (print names)\n```\n\nFor added convenience,
  the `tableWithSelectors` function creates both a table\nand its selector functions
  at the same time:\n\n```\nposts :: Table (Int :*: Maybe Text :*: Text)\n(posts,
  postId :*: author :*: content)\n  =   tableWithSelectors \"posts\"\n  $   autoPrimary
  \"id\"\n  :*: optional \"author\"\n  :*: required \"content\"\n\nallAuthors :: Query
  s Text\nallAuthors = do\n  p <- select posts\n  return (p ! author)\n```\n\nYou
  can also use selectors with the `with` function to update columns in a tuple.\n`with`
  takes a tuple and a list of *assignments*, where each assignment is a\nselector-value
  pair. For each assignment, the column indicated by the selector\nwill be set to
  the corresponding value, on the given tuple.\n\n```\ngrownupsIn10Years :: Query
  s (Col s Text)\ngrownupsIn10Years = do\n  p <- select people\n  let p' = p `with`
  [age := p ! age + 10]\n  restrict (p' ! age .> 20)\n  return (p' ! name)\n```\n\nOf
  course, selectors can be used for updates and deletions as well.\n\nFor the remainder
  of this tutorial, we'll keep matching on the tuples\nexplicitly.\n\n\nProducts and
  joins\n------------------\n\nOf course, data can be drawn from multiple tables.
  The unfiltered result set\nis essentially the cartesian product of all queried tables.\nFor
  this reason, `restrict` calls should be made as early as possible, to avoid\ncreating
  an unnecessarily large result set.\n\nArbitrary Haskell values can be injected into
  queries. As injected values are\npassed as parameters to prepared statements under
  the hood, there is no need\nto escape data; SQL injection is impossible by construction.\n\nThe
  following example uses data from two tables to find all grown-ups who\nreside in
  Tokyo. Note the use of the `text` function, to convert a Haskell\n`Text` value into
  an SQL column literal, as well as the use of `name .== name'`\nto remove all elements
  from the result set where the name in the `people` table\ndoes not match the one
  in the `addresses` table.\n\n```\ngrownupsIn :: Text -> Query s (Col s Text)\ngrownupsIn
  city = do\n  (name :*: age :*: _) <- select people\n  restrict (age .> 20)\n  (name'
  :*: home) <- select addresses\n  restrict (home .== text city .&& name .== name')\n
  \ return name\n\nprintGrownupsInTokyo :: SeldaM ()\nprintGrownupsInTokyo = do\n
  \ names <- query (grownupsIn \"Tokyo\")\n  liftIO (print names)\n```\n\nAlso note
  that this is slightly different from an SQL join. If, for instance,\nyou wanted
  to get a list of all people and their addresses, you might do\nsomething like this:\n\n```\nallPeople
  :: Query s (Col s Text :*: Col s Text)\nallPeople = do\n  (people_name :*: _ :*:
  _) <- select people\n  (addresses_name :*: city) <- select addresses\n  restrict
  (people_name == addresses_name)\n  return (people_name :*: city)\n```\n\nThis will
  give you the list of everyone who has an address, resulting in the\nfollowing result
  set:\n\n```\nname      | city\n---------------------\nLink      | Kakariko\nKobayashi
  | Tokyo\nMiyu      | Fuyukishi\n```\n\nNote the absence of Velvet in this result
  set. Since there is no entry for\nVelvet in the `addresses` table, there can be
  no entry in the product table\n`people × addresses` where both `people_name` and
  `addresses_name` are equal\nto `\"Velvet\"`. To produce a table like the above but
  with a `NULL` column for\nVelvet's address (or for anyone else who does not have
  an entry in the\n`addresses` table), you would have to use a join:\n\n```\nallPeople'
  :: Query s (Col s Text :*: Col s Maybe Text)\nallPeople' = do\n  (name :*: _ :*:
  _) <- select people\n  (_ :*: city) <- leftJoin (\\(name' :*: _) -> name .== name')\n
  \                          (select addresses)\n  return (name :*: city)\n```\n\nThis
  gives us the result table we want:\n\n```\nname      | city\n---------------------\nLink
  \     | Kakariko\nVelvet    |\nKobayashi | Tokyo\nMiyu      | Fuyukishi\n\n```\n\nThe
  `leftJoin` function left joins its query argument to the current result set\nfor
  all rows matching its predicate argument.\nNote that all columns returned from the
  inner (or right) query are converted by\n`leftJoin` into nullable columns. As there
  may not be a right counter part for\nevery element in the result set, SQL and Selda
  alike set any missing joined\ncolumns to `NULL`.\n\n\nAggregate queries, grouping
  and sorting\n---------------------------------------\n\nYou can also perform queries
  that sum, count, or otherwise aggregate their\nresult sets. This is done using the
  `aggregate` function.\nThis is where the additional type parameter to `Query` comes
  into play.\nWhen used as an inner query, aggregate queries must not depend on any
  columns\nfrom the outer query. To enforce this, the `aggregate` function forces
  all\noperations to take place in the `Query (Inner s)` monad, if the outer query\ntakes
  place in the `Query s` monad. This ensures that aggregate inner queries\ncan only
  communicate with their outside query by returning some value.\n\nLike in standard
  SQL, aggregate queries can be grouped by column name or by\nsome arbitrary expression.\nAn
  aggregate subquery must return at least one aggregate column, obtained using\n`sum_`,
  `avg`, `count`, or one of the other provided aggregate functions.\nNote that aggregate
  columns, having type `Aggr s a`, are different from normal\ncolumns of type `Col
  s a`.\nSince SQL does not allow aggregate functions in `WHERE` clauses, Selda prevents\nthem
  from being used in arguments to `restrict`.\n\nThe following example uses an aggregate
  query to calculate how many home each\nperson has, and order the result set with
  the most affluent homeowners at the\ntop.\n\n```\ncountHomes :: Query s (Col s Text
  :*: Col s Int)\ncountHomes = do\n  (name :*: _ :*: _) <- select people\n  (owner
  :*: homes) <- aggregate $ do\n    (owner :*: city) <- select addresses\n    owner'
  <- groupBy owner\n    return (count city :*: owner')\n  restrict (owner .== name)\n
  \ order homes descending\n  return (owner :*: homes)\n```\n\nNote how `groupBy`
  returns an aggregate version of its argument, which can be\nreturned from the aggregate
  query. In this example, returning `owner` instead of\n`owner'` wouldn't work since
  the former is a plain column and not an aggregate.\n\n\nTransactions\n------------\n\nAll
  databases supported by Selda guarantee that each query is atomic: either\nthe entire
  query is performed in one go, with no observable intermediate state,\nor the whole
  query fails without leaving a trace in the database.\nHowever, sometimes this guarantee
  is not enough.\nConsider, for instance, a money transfer from Alice's bank account
  to Bob's.\nThis involves at least two queries: one to remove the money from\nAlice's
  account, and one to add the same amount to Bob's.\nClearly, it would be *bad* if
  this operation were to be interrupted after\nwithdrawing the money from Alice's
  account but before depositing it into Bob's.\n\nThe solution to this problem is
  *transactions*: a mechanism by which\n*a list of queries* gain the same atomicity
  guarantees as a single query always\nenjoys. Using transactions in Selda is super
  easy:\n\n```\ntransferMoney :: Text -> Text -> Double -> SeldaM ()\ntransferMoney
  from to amount = do\n  transaction $ do\n    update_ accounts (\\(owner :*: _) ->
  owner .== text from)\n                     (\\(owner :*: money) -> owner :*: money
  - float amount)\n    update_ accounts (\\(owner :*: _) -> owner .== text to)\n                     (\\(owner
  :*: money) -> owner :*: money + float amount)\n```\n\nThis is all there is to it:
  pass the entire computation to the `transaction`\nfunction, and the whole computation
  is guaranteed to either execute atomically,\nor to fail without leaving a trace
  in the database.\nIf an exception is raised during the computation, it will of course
  be rolled\nback.\n\nDo be careful, however, to avoid performing IO within a query.\nWhile
  they will not affect the atomicity of the computation as far as the\ndatabase is
  concerned, the computations themselves can obviously not be\nrolled back.\n\n\nIn-process
  caching\n------------------\n\nIn many applications, read operations are orders
  of magnitude more common than\nwrite operations. For such applications, it is often
  useful to *cache* the\nresults of a query, to avoid having the database perform
  the same, potentially\nheavy, query over and over even though we *know* we'll get
  the same result\nevery time.\n\nSelda supports automatic caching of query results
  out of the box.\nHowever, it is turned off by default.\nTo enable caching, use the
  `setLocalCache` function.\n\n```\nmain = withPostgreSQL connection_info $ do\n  setLocalCache
  1000\n  ...\n```\n\nThis will enable local caching of up to 1,000 different results.\nWhen
  that limit is reached, the least recently used result will be discarded,\nso the
  next request for that result will need to actually execute the query\non the database
  backend.\nIf caching was already enabled, changing the maximum number of cached
  results\nwill discard the cache's previous contents.\nSetting the cache limit to
  0 disables caching again.\n\nTo make sure that the cache is always consistent with
  the underlying database,\nSelda keeps track of which tables each query depends on.\nWhenever
  an insert, update, delete or drop is issued on a table `t`, all cached\nqueries
  that depend on `t` will be discarded.\n\nThis guarantees consistency between cache
  and database, but *only* under the\nassumption that *no other process will modify
  the database*.\nIf this assumption does not hold for your application, you should
  avoid using\nin-process caching.\nIt is perfectly fine, however, to have multiple
  *threads* within the same\napplication modifying the same database as long as they're
  all using Selda\nto do it, as the cache is shared between all Selda computations\nrunning
  in the same process.\n\n\nGeneric tables and queries\n--------------------------\n\nSelda
  also supports building tables and queries from (almost) arbitrary\ndata types, using
  the `Database.Selda.Generic` module.\nRe-implementing the ad hoc `people` and `addresses`
  tables from before in a\nmore disciplined manner in this way is quite easy:\n\n```\ndata
  Person = Person\n  { personName :: Text\n  , age        :: Int\n  , pet        ::
  Maybe Int\n  } deriving Generic\n\ndata Address = Address\n  { addrName :: Text\n
  \ , city     :: Text\n  } deriving Generic\n\n\npeople :: GenTable Person\npeople
  = genTable \"people\" [personName :- primaryGen]\n\naddresses :: GenTable Address\naddresses
  = genTable \"addresses\" [personName :- primaryGen]\n```\n\nThis will declare two
  tables with the same structure as their ad hoc\npredecessors. Creating the tables
  is similarly easy:\n\n```\ncreate :: SeldaM ()\ncreate = do\n  createTable (gen
  people)\n  createTable (gen addresses)\n```\n\nNote the use of the `gen` function
  here, to extract the underlying table of\ncolumns from the generic table.\n\nHowever,
  queries over generic tables aren't magic; they still consist of the\nsame collections
  of columns as queries over non-generic tables.\n\n```\ngenericGrownups2 :: Query
  s (Col s Text)\ngenericGrownups2 = do\n  (name :*: age :*: _) <- select (gen people)\n
  \ restrict (age .> 20)\n  return name\n```\n\nFinally, with generics it's also quite
  easy to re-assemble Haskell objects\nfrom the results of a query using the `fromRel`
  function.\n\n```\ngetPeopleOfAge :: Int -> SeldaM [Person]\ngetPeopleOfAge yrs =
  do\n  ps <- query $ do\n    (name :*: age :*: _) <- select (gen people)\n    restrict
  (age .== yrs)\n    return p\n  return (map fromRel ps)\n```\n\nAnd with that, we
  conclude this tutorial. Hopefully it has been enough to get\nyou comfortable started
  using Selda.\nFor a more detailed API reference, please see Selda's\n[Haddock documentation](http://hackage.haskell.org/package/selda).\n\n\nTODOs\n=====\n\nFeatures
  that would be nice to have but are not yet implemented.\n\n* If/else.\n* Streaming\n*
  Type-safe migrations\n* `WHERE x IN (SELECT ...)`\n* `SELECT INTO`.\n* Database
  schema upgrades.\n* Stack build.\n* MySQL/MariaDB backend.\n"
license-name: MIT

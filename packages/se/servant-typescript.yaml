homepage: https://github.com/github.com/codedownio#readme
changelog-type: markdown
hash: 2dc94c15b8f532d7676f5b79747ffe7518eb978c97c9ff0111d8589a6041e732
test-bench-deps:
  string-interpolate: -any
  base: '>=4.7 && <5'
  text: -any
  servant-typescript: -any
  filepath: -any
  servant: -any
  containers: -any
  lens: -any
  aeson-typescript: -any
  servant-foreign: -any
  mtl: -any
  aeson: -any
  directory: -any
maintainer: tom@codedown.io
synopsis: TypeScript client generation for Servant
changelog: |
  # Changelog for servant-typescript

  ## Unreleased changes
basic-deps:
  string-interpolate: -any
  base: '>=4.7 && <5'
  text: -any
  servant-typescript: -any
  filepath: -any
  servant: -any
  containers: -any
  lens: -any
  aeson-typescript: -any
  servant-foreign: -any
  mtl: -any
  aeson: -any
  directory: -any
all-versions:
- 0.1.0.0
author: Tom McLaughlin
latest: 0.1.0.0
description-type: markdown
description: |
  # Welcome to `servant-typescript` [![Hackage](https://img.shields.io/hackage/v/servant-typescript.svg)](https://hackage.haskell.org/package/servant-typescript) ![servant-typescript](https://github.com/codedownio/servant-typescript/workflows/servant-typescript/badge.svg)


  This library generates TypeScript client libraries for Servant.

  First, make sure you have [TypeScript](https://hackage.haskell.org/package/aeson-typescript) instances defined for all of the types used in the API.

  ```haskell
  data User = User {
    name :: String
    , age :: Int
    , email :: String
    } deriving (Eq, Show)
  deriveJSONAndTypeScript A.defaultOptions ''User
  ```

  If you need to generate lots of boilerplate instances, the functions in `aeson-typescript`'s [Recursive](https://hackage.haskell.org/package/aeson-typescript-0.4.0.0/docs/Data-Aeson-TypeScript-Recursive.html) module can be your friend.
  I've used [recursivelyDeriveMissingTypeScriptInstancesFor](https://hackage.haskell.org/package/aeson-typescript-0.4.0.0/docs/Data-Aeson-TypeScript-Recursive.html#v:recursivelyDeriveMissingTypeScriptInstancesFor) to derive instances for the Kubernetes API.

  Next, you'll need some Servant API:

  ```haskell
  type UserAPI = "users" :> Get '[JSON] [User]
            :<|> "albert" :> Get '[JSON] User
            :<|> "isaac" :> Get '[JSON] User
  ```

  Generating the library is as simple as this:

  ```haskell
  main = writeTypeScriptLibrary (Proxy :: Proxy UserAPI) "/my/destination/folder/"
  ```
  ## Caveats

  * This library doesn't yet support generating generic TypeScript functions to match generic TypeScript instances. You can hack around this by writing your own `getFunctions` and hardcoding them manually for the necessary types.

  ## Supporting additional combinators

  If you use unusual Servant combinators in your API, you may need to define additional `HasForeign` instances to explain how to convert them to TypeScript. For example, when I work with the [servant-websockets](https://hackage.haskell.org/package/servant-websockets) package, I add instances like the following.

  The same applies to custom `AuthProtect` combinators from [Servant.API.Experimental.Auth](https://hackage.haskell.org/package/servant-0.19/docs/Servant-API-Experimental-Auth.html), etc.

  ```haskell
  instance HasForeign LangTS Text WebSocket where
      type Foreign Text WebSocket = Text
      foreignFor _lang _pf _ _req = "void"

  instance HasForeign LangTS Text WebSocketPending where
      type Foreign Text WebSocketPending = Text
      foreignFor _lang _pf _ _req = "void"

  instance HasForeign LangTSDecls [TSDeclaration] WebSocketPending where
      type Foreign [TSDeclaration] WebSocketPending = [TSDeclaration]
      foreignFor _lang _pf _ _req = []

  instance HasForeign LangTSDecls [TSDeclaration] WebSocket where
      type Foreign [TSDeclaration] WebSocket = [TSDeclaration]
      foreignFor _lang _pf _ _req = []
  ```
license-name: BSD-3-Clause

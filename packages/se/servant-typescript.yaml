homepage: https://github.com/codedownio/servant-typescript#readme
changelog-type: markdown
hash: 92cfd7f7d96de7a01d3834ef50daec181c54b94b1daa3f5a497d5561b86ea7d3
test-bench-deps:
  string-interpolate: -any
  base: '>=4.7 && <5'
  text: -any
  servant-typescript: -any
  filepath: -any
  servant: -any
  containers: -any
  lens: -any
  aeson-typescript: -any
  servant-foreign: -any
  mtl: -any
  aeson: -any
  directory: -any
maintainer: tom@codedown.io
synopsis: TypeScript client generation for Servant
changelog: |
  # Changelog for servant-typescript

  ## Unreleased changes

  ## 0.1.0.2

  * Fix to actually write to the configured directory.

  ## 0.1.0.1

  * Initial release
basic-deps:
  string-interpolate: -any
  base: '>=4.7 && <5'
  text: -any
  servant-typescript: -any
  filepath: -any
  servant: -any
  containers: -any
  lens: -any
  aeson-typescript: -any
  servant-foreign: -any
  mtl: -any
  aeson: -any
  directory: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
author: Tom McLaughlin
latest: 0.1.0.2
description-type: markdown
description: |
  # Welcome to `servant-typescript` [![Hackage](https://img.shields.io/hackage/v/servant-typescript.svg)](https://hackage.haskell.org/package/servant-typescript) ![servant-typescript](https://github.com/codedownio/servant-typescript/workflows/servant-typescript/badge.svg)


  This library generates TypeScript client libraries for Servant.

  First, make sure you have [TypeScript](https://hackage.haskell.org/package/aeson-typescript) instances defined for all of the types used in the API.

  ```haskell
  data User = User {
    name :: String
    , age :: Int
    , email :: String
    } deriving (Eq, Show)
  deriveJSONAndTypeScript A.defaultOptions ''User
  ```

  If you need to generate lots of boilerplate instances, the functions in `aeson-typescript`'s [Recursive](https://hackage.haskell.org/package/aeson-typescript-0.4.0.0/docs/Data-Aeson-TypeScript-Recursive.html) module can be your friend.
  I've used [recursivelyDeriveMissingTypeScriptInstancesFor](https://hackage.haskell.org/package/aeson-typescript-0.4.0.0/docs/Data-Aeson-TypeScript-Recursive.html#v:recursivelyDeriveMissingTypeScriptInstancesFor) to derive instances for the Kubernetes API.

  Next, you'll need some Servant API:

  ```haskell
  type UserAPI = "users" :> Get '[JSON] [User]
            :<|> "albert" :> Get '[JSON] User
            :<|> "isaac" :> Get '[JSON] User
  ```

  Generating the library is as simple as this:

  ```haskell
  main = writeTypeScriptLibrary (Proxy :: Proxy UserAPI) "/my/destination/folder/"
  ```
  ## Caveats

  * This library doesn't yet support generating generic TypeScript functions to match generic TypeScript instances. You can hack around this by writing your own `getFunctions` and hardcoding them manually for the necessary types.

  ## Supporting additional combinators

  If you use unusual Servant combinators in your API, you may need to define additional `HasForeign` instances to explain how to convert them to TypeScript. For example, when I work with the [servant-websockets](https://hackage.haskell.org/package/servant-websockets) package, I add instances like the following.

  The same applies to custom `AuthProtect` combinators from [Servant.API.Experimental.Auth](https://hackage.haskell.org/package/servant-0.19/docs/Servant-API-Experimental-Auth.html), etc.

  ```haskell
  instance HasForeign LangTS Text WebSocket where
      type Foreign Text WebSocket = Text
      foreignFor _ _ _ _ = "void"

  instance HasForeign LangTSDecls [TSDeclaration] WebSocket where
      type Foreign [TSDeclaration] WebSocket = [TSDeclaration]
      foreignFor _ _ _ _ = []
  ```
license-name: BSD-3-Clause

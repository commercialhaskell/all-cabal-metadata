homepage: https://github.com/tonyday567/readme-lhs#readme
changelog-type: ''
hash: 48f4cf6041ea391e6d8e0139409d23f3c7bf6820cd006450cac4d690dd9220ec
test-bench-deps:
  base: ! '>=4.7 && <5'
  doctest: -any
  protolude: -any
  tasty: -any
maintainer: tonyday567@gmail.com
synopsis: See readme.md
changelog: ''
basic-deps:
  optparse-generic: -any
  base: ! '>=4.7 && <5'
  text: -any
  protolude: -any
  pandoc-types: -any
  containers: -any
  pandoc: -any
  readme-lhs: -any
all-versions:
- 0.1.0.0
- 0.2.0
author: Tony Day
latest: 0.2.0
description-type: markdown
description: |-
  [readme-lhs](https://tonyday567.github.io/readme-lhs/index.html) [![Build Status](https://travis-ci.org/tonyday567/readme-lhs.svg)](https://travis-ci.org/tonyday567/readme-lhs)
  ================================================================================================================================================================================

  <blockquote cite>
  The language in which we express our ideas has a strong influence on our
  thought processes. \~ Knuth
  </blockquote>

  This is an example of mixing literate haskell with markdown, and in
  using Readme.Lhs. The file is composed of several elements:

  -   literate haskell. Bird-tracks are used, as the alternative method is
      latex rather than markdown, which doesn’t survive a pandoc round
      trip.
  -   markdown. All non bird-tracked lines are considered to be markdown.
      It’s probably incompatible with haddock, but this may well resolve
      with adoption of the [literate markdown ghc
      proposal](https://gitlab.haskell.org/ghc/ghc/wikis/literate-markdown).
  -   fenced code blocks with an output class, which are used to insert
      computation results. The fenced code blocks look like:

      \`\`\`{.output .example} \`\`\`

  [ghc options](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#flag-reference)
  --------------------------------------------------------------------------------------------------------

  ``` haskell
  {-# OPTIONS_GHC -Wall #-}
  ```

  [pragmas](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html)
  ------------------------------------------------------------------------------------

  ``` haskell
  -- doctest doesn't look at the cabal file, so you need pragmas here
  {-# LANGUAGE NoImplicitPrelude #-}
  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE ScopedTypeVariables #-}
  {-# LANGUAGE TypeOperators #-}
  {-# LANGUAGE FlexibleInstances #-}
  ```

  [libraries](https://www.stackage.org/)
  --------------------------------------

  -   [protolude](https://www.hackage.org/package/protolude)
  -   [readme-lhs](https://www.hackage.org/package/readme-lhs)

  ``` haskell
  import Protolude
  import Readme.Lhs
  ```

  code
  ----

  -   [hoogle](https://www.stackage.org/package/hoogle)

  ``` haskell
  main :: IO ()
  main = do
    let n = 10
    let answer = product [1..n::Integer]
    _ <- runOutput ("example.lhs", LHS) ("readme.md", GitHubMarkdown) $ do
      output "example1" "Simple example of an output"
  ```

  ``` output
  Simple example of an output
  ```

  ``` haskell
      output "example2" (show answer)
  ```

  10! is equal to:

  ``` output
  3628800
  ```

  ``` haskell
    pure ()
  ```

  Output that doesn’t exist is simply cleared.

  ``` output
  ```

  hsfiles writeup
  ===============

  A literate-programming friendly; tight work-flow stack template.

  other/readme-lhs.hsfiles

  other/batteries.hsfiles
  -----------------------

  This is my latest working template, overly influenced by [lexi-lambda’s
  opinionated
  guide](https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/).
  The template includes:

  -   some minor tweaks to protolude
  -   lens, foldl, formatting & text as must have libraries
  -   generic-lens-labels

  workflow
  --------

      stack build --exec "$(stack path --local-install-root)/bin/readme-lhs-example" --file-watch
license-name: BSD-3-Clause

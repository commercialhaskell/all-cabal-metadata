homepage: https://github.com/nomeata/haskell-rec-def
changelog-type: markdown
hash: 592f33156c2eda3134e334711d3deca53f954e8e52d47cbea1a55ca4fd499795
test-bench-deps:
  base: '>=4.9 && <5'
  doctest: ^>=0.18.2
  containers: '>=0.5.11 && <0.7'
  tasty-dejafu: -any
  concurrency: ^>=1.11.0.2
  random: -any
  tasty: -any
  QuickCheck: -any
  rec-def: -any
  template-haskell: -any
  dejafu: ^>=2.4.0.3
maintainer: mail@joachim-breitner.de
synopsis: Recusively defined values
changelog: |
  # Revision history for rec-def

  ## 0.1 -- 2022-09-03

  * First version. Released on an unsuspecting world.
basic-deps:
  base: '>=4.9 && <5'
  containers: '>=0.5.11 && <0.7'
all-versions:
- '0.1'
author: Joachim Breitner
latest: '0.1'
description-type: markdown
description: |
  rec-def - Pure recursive definition
  ===================================

  This library provides safe APIs that allow you to define and calculate values
  recursively, and still get a result out:

      >>> :{
        let s1 = rInsert 23 s2
            s2 = rInsert 42 s1
        in getR s1
       :}
      fromList [23,42]

  See the [`examples.hs`](examples.hs) file for more examples.

  It also provides (unsafe) building blocks to build such APIs, see `Data.Recursive.R.Internal`.

  Related work
  ------------

  * Edward Kmett's [`Data.Propagator.Prop` module](https://github.com/ekmett/propagators/blob/master/src/Data/Propagator/Prop.hs) achieves something similar, and allows to construct more the graphs more flexibly, but requires a stricter phase control akin to `runST`.

  * Jeannin, Kozen and Silva’s work on [“CoCaml: Functional Programming with
  Regular Coinductive
  Types”](https://www.cs.cornell.edu/~kozen/Papers/CoCaml.pdf) in Ocaml even goes
  a step further and not only allow the recursive definitions to be written down
  as here, but even allows functions _consume_ regular recursive values, and
  still produces something that can be solved.
license-name: BSD-2-Clause

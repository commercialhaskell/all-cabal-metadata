homepage: http://github.com/mgsloan/rex
changelog-type: markdown
hash: 3e8d9d06cac00b22e67899b004514175a89813ce6137cf27ea5956f48724bc6a
test-bench-deps: {}
maintainer: Michael Sloan <mgsloan at gmail>
synopsis: A quasi-quoter for typeful results of regex captures.
changelog: |
  # Changelog

  ## 0.6

    * Made the generated code total. See [#10][]

  [#10]: https://github.com/mgsloan/rex/issues/10

  ## 0.5.1 (2014-02-20)

    * Made the type of the default 'rexView' fully polymorphic.

  ## 0.5: (2014-02-20)

    * Changed the configuration datatype to allow custom preprocessing of expr /
      pat antiquotes.  The default match processing is now "rexView", an
      identifier that can be shadowed locally or hidden on import.

    * Removed 'maybeRead'.

  ## 0.4.3: (2013-12-21)

    * Patch from [aavogt](https://github.com/aavogt)! to use haskell-src-exts to
      parse view patterns.

    * Miscellaneous code cleanups.

  ## 0.4.2: (2013-02-04)

    * Precompilation bugs fixed by [takano-akio](https://github.com/takano-akio)!

  ## 0.4: (2012-10-11)

    * Made configuration into a datatype.

  ## 0.3: (2011-09-25)

    * Fixed a capture indexing bug, where capture fields which aren't bound would
      cause subsequent bound captures to be incorrect.

    * Above bug fix actually neatened up code.

    * Added configuration of default mapping pattern.

  ## 0.2: (2011-09-24)

    * Added custom configuration of PCRE options.

    * Added non-precompiling quasiquoters.

    * Fixed a bug where patterns with no captures would fail.

    * Decided to remove the defaulting to 'read' - too much magic.

  ## 0.1: (2011-07-25)

    * initial release
basic-deps:
  pcre-light: -any
  bytestring: -any
  base: ! '>=3.0 && <6'
  containers: -any
  haskell-src-exts: ! '>=1.14'
  haskell-src-meta: ! '>=0.5'
  template-haskell: ! '>=2.5.0.0'
all-versions:
- '0.1'
- '0.2'
- '0.3'
- 0.3.1
- 0.4.1
- 0.4.2
- 0.4.3
- '0.5'
- 0.5.1
- 0.5.2
- '0.6'
author: Michael Sloan
latest: '0.6'
description-type: markdown
description: "http://hackage.haskell.org/package/rex\n\nProvides a quasi-quoter for
  regular expressions which yields a tuple, of \nappropriate arity and types, representing
  the results of the captures.  Allows \nthe user to specify parsers for captures
  as inline Haskell.  Can also be used to\nprovide typeful pattern matching in function
  definitions and case patterns.\n\nTo build / install:\n\n```\n./Setup.hs configure
  --user\n./Setup.hs build\n./Setup.hs install\n```\n\nSee the haddock or `Text/Regex/PCRE/Rex.hs`
  for documentation.\n\nSome examples (verbatim from Test.hs):\n\n```haskell\nmath
  x = mathl x 0\n\nmathl [] x = x\nmathl [rex|^  \\s*(?{ read -> y }\\d+)\\s*(?{ s
  }.*)$|] x = mathl s y\nmathl [rex|^\\+\\s*(?{ read -> y }\\d+)\\s*(?{ s }.*)$|]
  x = mathl s $ x + y\nmathl [rex|^ -\\s*(?{ read -> y }\\d+)\\s*(?{ s }.*)$|] x =
  mathl s $ x - y\nmathl [rex|^\\*\\s*(?{ read -> y }\\d+)\\s*(?{ s }.*)$|] x = mathl
  s $ x * y\nmathl [rex|^ /\\s*(?{ read -> y }\\d+)\\s*(?{ s }.*)$|] x = mathl s $
  x / y\nmathl str x = error str\n\n-- math \"1 + 3\" == 4.0\n-- math \"3 * 2 + 100\"
  == 106.0\n-- math \"20 / 3 + 100 * 2\" == 213.33333333333334\n```\n\n\n```haskell\npeano
  :: String -> Maybe Int\npeano = [rex|^(?{ length . filter (=='S') } \\s* (?:S\\s+)*Z)\\s*$|]\n\n--
  \ peano \"S Z\" == Just 1\n--  peano \"S S S S Z\" == Just 4\n--  peano \"S   S
  \  Z\" == Just 2\n```\n\n```haskell\nparsePair :: String -> Maybe (String, String)\nparsePair
  = [rex|^<\\s* (?{ }[^\\s,>]+) \\s*,\\s* (?{ }[^\\s,>]+) \\s*>$|]\n\n--  parsePair
  \"<-1, 3>\" == Just (\"-1\",\"3\")\n--  parsePair \"<-4,3b0>\" == Just (\"-4\",\"3b0\")\n--
  \ parsePair \"< a,  -30 >\" == Just (\"a\",\"-30\")\n--  parsePair \"< a,  other>\"
  == Just (\"a\",\"other\")\n```\n\n\n```haskell\n-- From http://www.regular-expressions.info/dates.html\nparseDate
  :: String -> Maybe (Int, Int, Int)\nparseDate [rex|^(?{ read -> y }(?:19|20)\\d\\d)[-
  /.]\n                (?{ read -> m }0[1-9]|1[012])[- /.]\n                (?{ read
  -> d }0[1-9]|[12][0-9]|3[01])$|]\n  |  (d > 30 && (m `elem` [4, 6, 9, 11]))\n  ||
  (m == 2 &&\n       (d ==29 && not (mod y 4 == 0 && (mod y 100 /= 0 || mod y 400
  == 0)))\n    || (d > 29)) = Nothing\n  | otherwise = Just (y, m, d)\nparseDate _
  = Nothing\n\n--  parseDate \"1993.8.10\" == Nothing\n--  parseDate \"1993.08.10\"
  == Just (1993,8,10)\n--  parseDate \"2003.02.28\" == Just (2003,2,28)\n--  parseDate
  \"2003.02.27\" == Just (2003,2,27)\n```\n\n```haskell\nonNull a f [] = a\nonNull
  _ f xs = f xs\n\nnonNull = onNull Nothing\n\ndisjunct [rex| ^(?:(?{nonNull $ Just
  . head -> a} .)\n             | (?{nonNull $ Just . head -> b} ..)\n             |
  (?{nonNull $ Just . last -> c} ...))$|] =\n  head $ catMaybes [a, b, c]\n\n--  disjunct
  \"a\" == 'a'\n--  disjunct \"ab\" == 'a'\n--  disjunct \"abc\" == 'c'\n```\n"
license-name: BSD-3-Clause

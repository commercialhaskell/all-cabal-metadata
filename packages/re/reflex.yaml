homepage: https://reflex-frp.org
changelog-type: markdown
hash: 21fb0ce6d71243a7bfe8fd6efb1f205662e9d9ec8fab6bd9d96eaff655f36f98
test-bench-deps:
  hlint: -any
  these: -any
  dependent-sum: -any
  monoidal-containers: -any
  split: -any
  stm: -any
  filemanip: -any
  base: -any
  time: -any
  dependent-map: -any
  filepath: -any
  criterion: ! '>=1.1 && <1.6'
  process: -any
  ref-tf: -any
  semigroups: -any
  loch-th: -any
  containers: ! '>=0.5 && <0.7'
  lens: -any
  bifunctors: -any
  mtl: -any
  reflex: -any
  transformers: ! '>=0.3'
  deepseq: ! '>=1.3 && <1.5'
  primitive: -any
  directory: -any
maintainer: ryan.trinkle@gmail.com
synopsis: Higher-order Functional Reactive Programming
changelog: |
  # Revision history for reflex

  ## 0.6.0.0 -- 2019-03-20

  * Deprecate FunctorMaybe in favor of Data.Witherable.Filterable. We still export fmapMaybe, ffilter, etc., but they all rely on Filterable now.
  * Rename MonadDynamicWriter to DynamicWriter and add a deprecation for the old name.
  * Remove many deprecated functions.
  * Add a Num instance for Dynamic.
  * Add matchRequestsWithResponses to make it easier to use Requester with protocols that don't do this matching for you.
  * Add withRequesterT to map functions over the request and response of a RequesterT.
  * Suppress nil patches in QueryT as an optimization. The Query type must now have an Eq instance.
  * Add throttleBatchWithLag to Reflex.Time. See that module for details.

  ## 0.6.1.0

  * Re-export all of Data.Map.Monoidal
  * Fix QueryT and RequesterT tests
basic-deps:
  semigroupoids: ! '>=4.0 && <6'
  these: ! '>=0.4 && <0.7.7'
  dependent-sum: ! '>=0.3 && <0.5'
  reflection: ==2.1.*
  witherable: ! '>=0.2 && <0.4'
  monoidal-containers: ==0.4.*
  stm: ! '>=2.4 && <2.6'
  exception-transformers: ==0.4.*
  base: ! '>=4.9 && <4.13'
  time: ! '>=1.4 && <1.9'
  comonad: -any
  dependent-map: ! '>=0.2.4 && <0.3'
  prim-uniq: ! '>=0.1.0.1 && <0.2'
  syb: ! '>=0.5 && <0.8'
  unbounded-delays: ! '>=0.1.0.0 && <0.2'
  monad-control: ! '>=1.0.1 && <1.1'
  ref-tf: ==0.4.*
  data-default: ! '>=0.5 && <0.8'
  semigroups: ! '>=0.16 && <0.19'
  containers: ! '>=0.5 && <0.7'
  haskell-src-exts: ! '>=1.16 && <1.21'
  lens: ! '>=4.7 && <5'
  bifunctors: ! '>=5.2 && <5.6'
  mtl: ! '>=2.1 && <2.3'
  MemoTrie: ==0.6.*
  transformers: ! '>=0.2'
  random: ==1.1.*
  haskell-src-meta: ! '>=0.6 && <0.9'
  template-haskell: ! '>=2.9 && <2.15'
  primitive: ! '>=0.5 && <0.7'
  transformers-compat: ! '>=0.3'
all-versions:
- 0.0.1
- 0.1.0
- 0.1.1
- '0.2'
- '0.3'
- 0.3.1
- 0.3.2
- 0.4.0
- 0.4.0.1
- '0.5'
- 0.5.0.1
- '0.6'
- 0.6.1
author: Ryan Trinkle
latest: 0.6.1
description-type: markdown
description: |
  ## [Reflex](https://reflex-frp.org/)
  ### Practical Functional Reactive Programming

  Reflex is a fully-deterministic, higher-order Functional Reactive Programming (FRP) interface and an engine that efficiently implements that interface.

  [Reflex-DOM](https://github.com/reflex-frp/reflex-dom) is a framework built on Reflex that facilitates the development of web pages, including highly-interactive single-page apps.

  A summary of Reflex functions is available in the [quick reference](Quickref.md).

  **Visit https://reflex-frp.org/ for more information, tutorials, documentation and [examples](https://examples.reflex-frp.org/).**

  ### Resources
  [Get started with Reflex](https://github.com/reflex-frp/reflex-platform)

  [/r/reflexfrp](https://www.reddit.com/r/reflexfrp)

  [hackage](https://hackage.haskell.org/package/reflex)

  [irc.freenode.net #reflex-frp](http://webchat.freenode.net?channels=%23reflex-frp&uio=d4)

  ### Hacking

  Use the `./scripts/hack-on reflex` script in [Reflex Platform](https://github.com/reflex-frp/reflex-platform) to checkout the source code of `reflex` locally in `reflex-platform/reflex` directory.
  Then do modifications to the source in place, and use the `./try-reflex` or `./scripts/work-on` scripts to create the shell to test your changes.
license-name: BSD-3-Clause

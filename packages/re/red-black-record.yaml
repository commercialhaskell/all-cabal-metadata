homepage: ''
changelog-type: markdown
hash: eb77a44caa00773d1124067e81df8642df5619e67dc0744953ed1264b1bc77da
test-bench-deps:
  bytestring: ! '>=0.10'
  sop-core: ! '>=0.4.0.0 && <0.6'
  base: ! '>=4.10.0.0 && <5'
  text: ! '>=1.1'
  demoted: -any
  doctest: ! '>=0.16.2'
  red-black-record: -any
  tasty-hunit: ! '>=0.9.2'
  tasty: ! '>=0.10.1.1'
  aeson: ! '>=1.4.0.0 && <1.5'
  profunctors: ! '>=5'
maintainer: diaz_carrete@yahoo.com
synopsis: Extensible records and variants indexed by a type-level Red-Black tree.
changelog: "# Revision history for red-black-record\r\n\r\n## 2.1.0.0\r\n\r\n- Made
  the type-level map poly-kinded in the values, as there wasn't a real\r\n  reason
  to force them to the  Type kind. \r\n- Removed deprecated EmptyMap (use Empty instead).\r\n\r\n##
  2.0.4.0\r\n\r\n- Compatibility with sop-core 0.5.0.0.\r\n- Contravariant intance
  for Case newtype.\r\n\r\n## 2.0.3.0\r\n\r\n- Issue #7: FromVariant & ToVariant instances
  for sum types with branches with\r\n  no arguments.\r\n\r\n## 2.0.2.2\r\n\r\n- Improved
  compilation times for type-level deletion.\r\n\r\n## 2.0.0.0\r\n\r\n- BREAKING CHANGES\r\n
  \   - The constructors for the type-level map are now hidden.\r\n    - The name
  of the type-level map has changed from RBT to Map, to\r\n      de-emphasize implementation
  details. \r\n\r\n- Added the \"Deletable\" typeclass with de \"delete\" and \"winnow\"
  methods.\r\n\r\n- Solved bugs with coloring/balancing, added new tests.\r\n\r\n-
  Data.RBR.Internal is still exported, but it doesn't appear in the Haddocks.\r\n
  \ It appears that Haddock doesn't play well with reexported-modules sections in\r\n
  \ Cabal.\r\n\r\n## 1.1.0.0\r\n\r\n- Field and Branch type families to help speed
  up type-level computations. \r\n\r\n  Apparently, having identical invocations of
  a \"costly to compute\" type family\r\n  in a signature slowed things down.\r\n\r\n##
  1.0.0.2\r\n\r\n- Improved compilation times for getters by refactoring `KeyHelper`.\r\n\r\n##
  1.0.0.0\r\n\r\n- First version. Released on an unsuspecting world.\r\n"
basic-deps:
  sop-core: ! '>=0.4.0.0 && <0.6'
  base: ! '>=4.10.0.0 && <5'
all-versions:
- 1.0.0.0
- 1.0.0.1
- 1.0.0.2
- 1.1.0.0
- 2.0.0.0
- 2.0.0.1
- 2.0.1.0
- 2.0.2.0
- 2.0.2.1
- 2.0.2.2
- 2.0.3.0
- 2.0.4.0
- 2.1.0.0
- 2.1.0.1
- 2.1.0.2
author: Daniel Diaz
latest: 2.1.0.2
description-type: markdown
description: "# red-black-record\n\n## What's this?\n\nA library that provides extensible
  records and variants, both indexed by a\ntype-level [red-black](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)\ntree
  that maps `Symbol` keys to value types of any kind. The keys correspond to\nfield
  names in records, and to branch names in variants. Many record functions\nhave their
  variant mirror-images and viceversa.\n\nAt the term level, value types come wrapped
  in a type constructor of kind `q ->\nType`, where `q` is the kind of value types.
  Typically, the type constructor\nwill be an [identity\nfunctor](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:I),\nbut
  it can also be `Maybe` or some other `Applicative` for parsing, validation\nand
  so on.\n\nIf we forget about the keys and only keep the values, records are isomorphic
  to\n[n-ary unlabeled\nproducts](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:NP),\nand
  variants are isomorphic to [n-ary unlabeled\nsums](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:NS).\nThe
  [sop-core](http://hackage.haskell.org/package/sop-core) library provides\nsuch unlabeled
  types, along with a rich API for manipulating them. Instead of\nreinventing the
  wheel, red-black-record defines conversion functions to\nfacilitate working in the
  \"unlabeled\" world and then coming back to records and\nvariants.\n\nThere is another
  world towards which bridges must be built: the everyday\nHaskell world of conventional
  records and sums. In fact, one of the motivations\nof extensible records and variants
  is to serve as \"generalized\" versions of\nvanilla data types. Advanced use cases
  can rely on these generalized versions,\nthereby avoiding intrusive changes to the
  original types. red-black-record\nprovides conversion typeclasses with default implementations
  by way of\n[`GHC.Generic`](http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html).\n\nFor
  examples on how to use the library, check the haddocks for the\n`Data.RBR.Examples`
  module.\n\n## FAQ\n\n### What extensions do I need to use this library?\n\n* `DataKinds`.\n\n*
  `TypeApplications` to be able to specify field and branch names.\n\n* `TypeFamilies`.\n\n*
  `FlexibleContexts`.\n\n* `DeriveGeneric` for interfacing with normal records.\n\n*
  `PartialTypeSignatures` for hiding complex tree types.\n\n### My type signatures
  are getting big and scary because of those type-level trees. What to do?\n\nThe\n[`-XPartialTypeSignatures`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?#extension-PartialTypeSignatures)\nextension
  can help with that, in combination with the\n[-Wno-partial-type-signatures](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wpartial-type-signatures)\nGHC
  flag that disables the warning message emitted when the underscore is\nencountered
  in a signature.\n\nThe flag can be set globally in the\n[ghc-options](https://www.haskell.org/cabal/users-guide/developing-packages.html?#pkg-field-ghc-options)\nsection
  of the .cabal file, and also for particular modules with the\n[OPTIONS_GHC](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=options_ghc#options-ghc-pragma)\nfile-header
  pragma.\n\n### The `Show` instance for record doesn't show any field names.\n\nThe
  field names exist only at the type level. Also, the `Show` instance uses\nn-ary
  products and sums from\n[sop-core](http://hackage.haskell.org/package/sop-core),
  which do not have\nfield labels.\n\nFor fancier output, use the \"pretty-show\"
  functions instead.\n\n### Working with two records, I'm getting errors about incompatible
  types even as both records have the exact same fields.\n\nAlas, the order of insertion
  in the type-level tree matters :( Different\ninsertion orders can produce structurally
  different trees, even as they encode\nthe same symbol-to-type map.\n\nAs a workaround,
  one can use the `-Subset` functions to convert between\nequivalent structures.\n\n###
  I can't insert into a record when a field with the same name but different type
  already exists. Why not simply overwrite it?\n\nThat limitation was intentional,
  because allowing it would make impossible to\nimplement of `widen` for `Variant`.
  One solution is to explicitly delete the\nfield and then insert it again.\n\n###
  The library doesn't use Proxy and relies on type application instead. But what’s
  the order of the type parameters?\n\nFor standalone functions, it’s the order in
  which the type variables appear in\nthe `forall`.\n\n### What's the deal with all
  those -I suffixed versions of functions?\n\nThis library aims to provide\n[HKD](http://reasonablypolymorphic.com/blog/higher-kinded-data/)-like\nfunctionality
  by wrapping all the fields of a record in a type constructor.\n\nBut sometimes we
  are working with \"pure\" records without effects, and we just\nwant to get and
  set a field's value. In that case, the type constructor that\nwraps each field will
  be an identity functor `I` (from\n[sop-core](http://hackage.haskell.org/package/sop-core)).
  The -I suffixed\nfunctions wrap and unwrap the field's value on behalf of the user.\n\n###
  What's the deal with all those -Subset suffixed versions of functions?\n\nThese
  functions target multiple fields or branches at the same time. They can\nbe used
  to build lawful lenses and prisms over fragmenst of a structure.\n\nThey can also
  be used to convert between type-level trees that have the same\nentries but different
  structure.\n\n### What about compilation times?\n\nCompilation times balloon for
  large records. In the tests folder there's\nan example (not run by default in the
  tests) of the construction of a 50-field\nrecord whose fields are afterwards accessed
  one by one. It takes about 22\nseconds to compile in my machine. \n\nCode involving
  deletion of fields and branches (like using the `winnow`\nfunction for `Variant`s)
  is currently poorly optimized and will compile\n[slower](https://github.com/danidiaz/red-black-record/issues/12)
  than that.\n\nThe default generics-based implementations of `FromRecord` and `FromVariant`\nuse
  the same type-level machinery as the getters and its use will likely slow\ndown
  compilation as well.\n\n## Inspirations\n\n* The code for the red-black tree has
  been lifted from Stefan Kahrs's code\n  [available\n  here](https://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html).
  See also\n  [this post](https://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html).\n\n*
  Besides depending on sop-core, I have copied and adapted code from it. In\n  particular
  the `KeysValuessAll` typeclass is a version of the `All` typeclass\n  from sop-core.
  \n\n* [Surgery for data\n  types](https://blog.poisson.chat/posts/2018-11-26-type-surgery.html).\n
  \ [reddit](https://www.reddit.com/r/haskell/comments/a0gi4z/surgery_for_data_types/).\n\n##
  Alternatives\n\n* [generics-sop](http://hackage.haskell.org/package/generics-sop)
  and\n  [records-sop](http://hackage.haskell.org/package/records-sop). Like\n  red-black-record,
  both of these libraries build upon sop-core. They are in\n  fact written by the
  same author of sop-core. generics-sop can provide\n  sum-of-products representations
  of any datatype with a Generic instance\n  (red-black-record is more limited, it
  only converts types that fit the named\n  record or variant mold—so no types with
  anonymous fields for example). \n  \n  If you don't need to explicitly target *individual*
  fields in the generic\n  representation, you'll be better off using generics-sop
  instead of\n  red-black-record. \n  \n  On top of generics-sop, records-sop provides
  named field accessors and record\n  subtyping based on a type-level list of fields
  (unlike the type-level tree\n  used by red-black-record). It doesn't seem to provide
  variants.\n\n* [superrecord](http://hackage.haskell.org/package/superrecord). This
  library\n  provides very efficient field access at runtime because the fields are
  backed\n  internally by an array. Uses a *sorted* type-level list of fields, to
  avoid\n  the problems of multiple orderings of the same fields.\n\n* [vinyl](http://hackage.haskell.org/package/vinyl).
  One of the oldest and more\n  fully-featured extensible records libraries. Uses
  a type level list of\n  fields. The fields' values are wrapped in a type constructor,
  like in\n  sop-core. The records seem to use an auxiliary sum type that serves as
  a\n  \"code\" for the fields. See also\n  [vinyl-genercics](https://hackage.haskell.org/package/vinyl-generics).\n\n*
  [HTree](https://github.com/i-am-tom/learn-me-a-haskell#htree). Another\n  implementation
  of extensible records using type-level red-black trees.\n\n* [megarecord](https://github.com/jvanbruegge/Megarecord).
  Seems to be a\n  proof-of-concept for a future [row polymorphism\n  extension](https://github.com/ghc-proposals/ghc-proposals/pull/180)
  for\n  Haskell.\n\n* [generic-data-surgery](https://hackage.haskell.org/package/generic-data-surgery).\n
  \ Lots of useful machinery for manipulating generic representations of\n  dataytpes,
  without requiring intrusive changes to the original\n  representation.\n\n* [Coxswain](https://ghc.haskell.org/trac/ghc/wiki/Plugins/TypeChecker/RowTypes/Coxswain).\n\n"
license-name: BSD-3-Clause

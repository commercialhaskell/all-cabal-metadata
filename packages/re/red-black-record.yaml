homepage: ''
changelog-type: markdown
hash: 309a9f9007ac6bc5ba64532340c9170fce4fa019105a2fd505fd19ffe0859934
test-bench-deps:
  bytestring: ! '>=0.10'
  sop-core: ! '>=0.4.0.0 && <0.6'
  base: ! '>=4.10.0.0 && <5'
  text: ! '>=1.1'
  demoted: -any
  doctest: ! '>=0.16.2'
  red-black-record: -any
  tasty-hunit: ! '>=0.9.2'
  tasty: ! '>=0.10.1.1'
  aeson: ! '>=1.4.0.0 && <1.5'
  profunctors: ! '>=5'
maintainer: diaz_carrete@yahoo.com
synopsis: Extensible records and variants indexed by a type-level Red-Black tree.
changelog: "# Revision history for red-black-record\r\n\r\n## 2.1.0.0\r\n\r\n- Made
  the type-level map poly-kinded in the values, as there wasn't a real\r\n  reason
  to force them to the  Type kind. \r\n- Removed deprecated EmptyMap (use Empty instead).\r\n\r\n##
  2.0.4.0\r\n\r\n- Compatibility with sop-core 0.5.0.0.\r\n- Contravariant intance
  for Case newtype.\r\n\r\n## 2.0.3.0\r\n\r\n- Issue #7: FromVariant & ToVariant instances
  for sum types with branches with\r\n  no arguments.\r\n\r\n## 2.0.2.2\r\n\r\n- Improved
  compilation times for type-level deletion.\r\n\r\n## 2.0.0.0\r\n\r\n- BREAKING CHANGES\r\n
  \   - The constructors for the type-level map are now hidden.\r\n    - The name
  of the type-level map has changed from RBT to Map, to\r\n      de-emphasize implementation
  details. \r\n\r\n- Added the \"Deletable\" typeclass with de \"delete\" and \"winnow\"
  methods.\r\n\r\n- Solved bugs with coloring/balancing, added new tests.\r\n\r\n-
  Data.RBR.Internal is still exported, but it doesn't appear in the Haddocks.\r\n
  \ It appears that Haddock doesn't play well with reexported-modules sections in\r\n
  \ Cabal.\r\n\r\n## 1.1.0.0\r\n\r\n- Field and Branch type families to help speed
  up type-level computations. \r\n\r\n  Apparently, having identical invocations of
  a \"costly to compute\" type family\r\n  in a signature slowed things down.\r\n\r\n##
  1.0.0.2\r\n\r\n- Improved compilation times for getters by refactoring `KeyHelper`.\r\n\r\n##
  1.0.0.0\r\n\r\n- First version. Released on an unsuspecting world.\r\n"
basic-deps:
  sop-core: ! '>=0.4.0.0 && <0.6'
  base: ! '>=4.10.0.0 && <5'
all-versions:
- 1.0.0.0
- 1.0.0.1
- 1.0.0.2
- 1.1.0.0
- 2.0.0.0
- 2.0.0.1
- 2.0.1.0
- 2.0.2.0
- 2.0.2.1
- 2.0.2.2
- 2.0.3.0
- 2.0.4.0
- 2.1.0.0
- 2.1.0.1
author: Daniel Diaz
latest: 2.1.0.1
description-type: markdown
description: "# red-black-record\r\n\r\n## What's this?\r\n\r\nA library that provides
  extensible records and variants, both indexed by a\r\ntype-level [red-black](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)\r\ntree
  that maps `Symbol` keys to value types of any kind. The keys correspond to\r\nfield
  names in records, and to branch names in variants. Many record functions\r\nhave
  their variant mirror-images and viceversa.\r\n\r\nAt the term level, value types
  come wrapped in a type constructor of kind `q ->\r\nType`, where `q` is the kind
  of value types. Typically, the type constructor\r\nwill be an [identity\r\nfunctor](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:I),\r\nbut
  it can also be `Maybe` or some other `Applicative` for parsing, validation\r\nand
  so on.\r\n\r\nIf we forget about the keys and only keep the values, records are
  isomorphic to\r\n[n-ary unlabeled\r\nproducts](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:NP),\r\nand
  variants are isomorphic to [n-ary unlabeled\r\nsums](http://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html#t:NS).\r\nThe
  [sop-core](http://hackage.haskell.org/package/sop-core) library provides\r\nsuch
  unlabeled types, along with a rich API for manipulating them. Instead of\r\nreinventing
  the wheel, red-black-record defines conversion functions to\r\nfacilitate working
  in the \"unlabeled\" world and then coming back to records and\r\nvariants.\r\n\r\nThere
  is another world towards which bridges must be built: the everyday\r\nHaskell world
  of conventional records and sums. In fact, one of the motivations\r\nof extensible
  records and variants is to serve as \"generalized\" versions of\r\nvanilla data
  types. Advanced use cases can rely on these generalized versions,\r\nthereby avoiding
  intrusive changes to the original types. red-black-record\r\nprovides conversion
  typeclasses with default implementations by way of\r\n[`GHC.Generic`](http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html).\r\n\r\nFor
  examples on how to use the library, check the haddocks for the\r\n`Data.RBR.Examples`
  module.\r\n\r\n## FAQ\r\n\r\n### What extensions do I need to use this library?\r\n\r\n*
  `DataKinds`.\r\n\r\n* `TypeApplications` to be able to specify field and branch
  names.\r\n\r\n* `TypeFamilies`.\r\n\r\n* `FlexibleContexts`.\r\n\r\n* `DeriveGeneric`
  for interfacing with normal records.\r\n\r\n* `PartialTypeSignatures` for hiding
  complex tree types.\r\n\r\n### My type signatures are getting big and scary because
  of those type-level trees. What to do?\r\n\r\nThe\r\n[`-XPartialTypeSignatures`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?#extension-PartialTypeSignatures)\r\nextension
  can help with that, in combination with the\r\n[-Wno-partial-type-signatures](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wpartial-type-signatures)\r\nGHC
  flag that disables the warning message emitted when the underscore is\r\nencountered
  in a signature.\r\n\r\nThe flag can be set globally in the\r\n[ghc-options](https://www.haskell.org/cabal/users-guide/developing-packages.html?#pkg-field-ghc-options)\r\nsection
  of the .cabal file, and also for particular modules with the\r\n[OPTIONS_GHC](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=options_ghc#options-ghc-pragma)\r\nfile-header
  pragma.\r\n\r\n### The `Show` instance for record doesn't show any field names.\r\n\r\nThe
  field names exist only at the type level. Also, the `Show` instance uses\r\nn-ary
  products and sums from\r\n[sop-core](http://hackage.haskell.org/package/sop-core),
  which do not have\r\nfield labels.\r\n\r\nFor fancier output, use the \"pretty-show\"
  functions instead.\r\n\r\n### Working with two records, I'm getting errors about
  incompatible types even as both records have the exact same fields.\r\n\r\nAlas,
  the order of insertion in the type-level tree matters :( Different\r\ninsertion
  orders can produce structurally different trees, even as they encode\r\nthe same
  symbol-to-type map.\r\n\r\nAs a workaround, one can use the `-Subset` functions
  to convert between\r\nequivalent structures.\r\n\r\n### I can't insert into a record
  when a field with the same name but different type already exists. Why not simply
  overwrite it?\r\n\r\nThat limitation was intentional, because allowing it would
  make impossible to\r\nimplement of `widen` for `Variant`. One solution is to explicitly
  delete the\r\nfield and then insert it again.\r\n\r\n### The library doesn't use
  Proxy and relies on type application instead. But what’s the order of the type parameters?\r\n\r\nFor
  standalone functions, it’s the order in which the type variables appear in\r\nthe
  `forall`.\r\n\r\n### What's the deal with all those -I suffixed versions of functions?\r\n\r\nThis
  library aims to provide\r\n[HKD](http://reasonablypolymorphic.com/blog/higher-kinded-data/)-like\r\nfunctionality
  by wrapping all the fields of a record in a type constructor.\r\n\r\nBut sometimes
  we are working with \"pure\" records without effects, and we just\r\nwant to get
  and set a field's value. In that case, the type constructor that\r\nwraps each field
  will be an identity functor `I` (from\r\n[sop-core](http://hackage.haskell.org/package/sop-core)).
  The -I suffixed\r\nfunctions wrap and unwrap the field's value on behalf of the
  user.\r\n\r\n### What's the deal with all those -Subset suffixed versions of functions?\r\n\r\nThese
  functions target multiple fields or branches at the same time. They can\r\nbe used
  to build lawful lenses and prisms over fragmenst of a structure.\r\n\r\nThey can
  also be used to convert between type-level trees that have the same\r\nentries but
  different structure.\r\n\r\n### What about compilation times?\r\n\r\nCompilation
  times balloon for large records. In the tests folder there's\r\nan example (not
  run by default in the tests) of the construction of a 50-field\r\nrecord whose fields
  are afterwards accessed one by one. It takes about 22\r\nseconds to compile in my
  machine. \r\n\r\nCode involving deletion of fields and branches (like using the
  `winnow`\r\nfunction for `Variant`s) is currently poorly optimized and will compile\r\n[slower](https://github.com/danidiaz/red-black-record/issues/12)
  than that.\r\n\r\nThe default generics-based implementations of `FromRecord` and
  `FromVariant`\r\nuse the same type-level machinery as the getters and its use will
  likely slow\r\ndown compilation as well.\r\n\r\n## Inspirations\r\n\r\n* The code
  for the red-black tree has been lifted from Stefan Kahrs's code\r\n  [available\r\n
  \ here](https://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html). See also\r\n
  \ [this post](https://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html).\r\n\r\n*
  Besides depending on sop-core, I have copied and adapted code from it. In\r\n  particular
  the `KeysValuessAll` typeclass is a version of the `All` typeclass\r\n  from sop-core.
  \r\n\r\n* [Surgery for data\r\n  types](https://blog.poisson.chat/posts/2018-11-26-type-surgery.html).\r\n
  \ [reddit](https://www.reddit.com/r/haskell/comments/a0gi4z/surgery_for_data_types/).\r\n\r\n##
  Alternatives\r\n\r\n* [generics-sop](http://hackage.haskell.org/package/generics-sop)
  and\r\n  [records-sop](http://hackage.haskell.org/package/records-sop). Like\r\n
  \ red-black-record, both of these libraries build upon sop-core. They are in\r\n
  \ fact written by the same author of sop-core. generics-sop can provide\r\n  sum-of-products
  representations of any datatype with a Generic instance\r\n  (red-black-record is
  more limited, it only converts types that fit the named\r\n  record or variant mold—so
  no types with anonymous fields for example). \r\n  \r\n  If you don't need to explicitly
  target *individual* fields in the generic\r\n  representation, you'll be better
  off using generics-sop instead of\r\n  red-black-record. \r\n  \r\n  On top of generics-sop,
  records-sop provides named field accessors and record\r\n  subtyping based on a
  type-level list of fields (unlike the type-level tree\r\n  used by red-black-record).
  It doesn't seem to provide variants.\r\n\r\n* [superrecord](http://hackage.haskell.org/package/superrecord).
  This library\r\n  provides very efficient field access at runtime because the fields
  are backed\r\n  internally by an array. Uses a *sorted* type-level list of fields,
  to avoid\r\n  the problems of multiple orderings of the same fields.\r\n\r\n* [vinyl](http://hackage.haskell.org/package/vinyl).
  One of the oldest and more\r\n  fully-featured extensible records libraries. Uses
  a type level list of\r\n  fields. The fields' values are wrapped in a type constructor,
  like in\r\n  sop-core. The records seem to use an auxiliary sum type that serves
  as a\r\n  \"code\" for the fields. See also\r\n  [vinyl-genercics](https://hackage.haskell.org/package/vinyl-generics).\r\n\r\n*
  [HTree](https://github.com/i-am-tom/learn-me-a-haskell#htree). Another\r\n  implementation
  of extensible records using type-level red-black trees.\r\n\r\n* [megarecord](https://github.com/jvanbruegge/Megarecord).
  Seems to be a\r\n  proof-of-concept for a future [row polymorphism\r\n  extension](https://github.com/ghc-proposals/ghc-proposals/pull/180)
  for\r\n  Haskell.\r\n\r\n* [generic-data-surgery](https://hackage.haskell.org/package/generic-data-surgery).\r\n
  \ Lots of useful machinery for manipulating generic representations of\r\n  dataytpes,
  without requiring intrusive changes to the original\r\n  representation.\r\n\r\n*
  [Coxswain](https://ghc.haskell.org/trac/ghc/wiki/Plugins/TypeChecker/RowTypes/Coxswain).\r\n\r\n"
license-name: BSD-3-Clause

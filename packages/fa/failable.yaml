homepage: ''
changelog-type: markdown
hash: 735435c1ba96f47d59872380c683a3579164650d2c6215674d191a5ece0d3577
test-bench-deps: {}
maintainer: erick@codemonkeylabs.de
synopsis: A 'Failable' error monad class to unify failure across monads that can fail
changelog: |
  # Changelog for failable

  ## Unreleased changes
basic-deps:
  base: ! '>=4.7 && <5'
  mtl: -any
  transformers: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
author: Erick Gonzalez
latest: 0.1.0.3
description-type: markdown
description: "# Control.Monad.Failable\n#### Yet another \"error\" handling monad
  (class)\n\nThis library provides a 'Failable' error monad class to unify failure
  across monads and\ntransformers most commonly used to implement pipelines that can
  fail.\n\n*But.. don't we have 'MonadFail', 'MonadThrow', 'MonadError',.. and the
  true haskeller should be \nusing 'Alternative' anyway!*\n\nI am sure a lot of ink
  has been spilled in forums and around water coolers all around the world, \ndebating
  the merits and fallacies of one approach or the other. The reason for this package
  is not\nto participate in this discussion but rather to provide a simple no nonsense
  means of signaling a \ncomputation \"failure\" in those monads that provide the
  inherent means to do so, and to do it in a\nconsistent manner\n\n## Usage\n\n```haskell\n\ndata
  FooError = NotImplemented deriving (Typeable, Show)\n\ninstance Exception FooError\n\nfoo
  :: (Failable m) => m Int\nfoo = failure NotImplemented\n```\n\nNow, if one called
  `foo` in a `Maybe monad`:\n\n    > foo :: Maybe Int\n    > Nothing\n\nthe failure
  is then conveyed by returning `Nothing` as per definition of the `Maybe` monad.
  Now in the case of the `Either SomeException` monad:\n\n    > foo :: Either SomeException
  Int\n    > Left NotImplemented\n\nbut what if we are working in the `IO` monad?\n\n
  \   > foo :: IO Int\n    > * * * Exception: NotImplemented\n\nIn this case, the
  failure can only be conveyed by throwing an IO exception.\n\nNow, the point where
  `Failable` diverges from say `MonadThrow` for example is when it comes to monad\ntransformers.
  For example:\n\n    > runMaybeT foo :: IO (Maybe Int)\n\nWould throw an `Exception:
  NotImplemented` if it was implemented in a `MonadThrow` context. Since\nthe reason
  d'etre for the runMaybeT is to provide the underlying monad (transformer) with `Maybe`
  like behaviour, i.e. have `Nothing` be returned in case of aborting the `Maybe`
  pipeline so to speak, then throwing an exception defeats IMHO the purpose of using
  `MaybeT` in the first place. So, in the\ncase of `Failable`:\n\n    > runMaybeT
  foo :: IO (Maybe Int)\n    > Nothing\n\nAnd the same thing applies to `runExceptT`
  etc. \n\n"
license-name: BSD-3-Clause

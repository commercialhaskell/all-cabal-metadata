all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
- 0.4.0.0
- 0.5.0.0
- 0.6.0.1
- 0.7.0.0
- 0.8.0.0
author: Adam Conner-Sax
basic-deps:
  Glob: '>=0.10.0 && <0.11.0'
  aeson-pretty: '>=0.8.7 && <0.9'
  base: '>=4.12.0 && <4.15'
  base64-bytestring: '>=1.0.0.2 && <1.2'
  blaze-colonnade: '>=1.2.2 && <1.3'
  blaze-html: '>=0.9.1 && <0.10'
  bytestring: '>=0.10.8 && <0.11'
  case-insensitive: '>=1.2.0.11 && <1.3'
  cereal: '>=0.5.7 && <0.6'
  colonnade: '>=1.1 && <1.3'
  constraints: '>=0.10 && <0.13'
  containers: '>=0.5.0 && <0.7'
  diagrams-lib: '>=1.4 && <1.5.0.0'
  diagrams-svg: '>=1.4.1 && <1.5.0.0'
  directory: '>=1.3.3.0 && <1.4.0.0'
  doctemplates: '>=0.2 && <0.9'
  exceptions: '>=0.10.0 && <0.11'
  http-client: '>=0.6.4 && <0.8'
  http-client-tls: '>=0.3.5.3 && <0.4'
  http-types: '>=0.12.3 && <0.13'
  hvega: '>=0.2.0 && <0.11'
  lucid: '>=2.9.11 && <2.10'
  monad-control: '>=1.0.2 && <1.1'
  mtl: '>=2.2.2 && <2.3'
  network: '>=2.8.0.0 && <3.2'
  network-uri: '>=2.6.1.0 && <2.8'
  pandoc: '>=2.7.2 && <2.11'
  polysemy: '>=1.3.0 && <1.4'
  polysemy-plugin: '>=0.2.0.0 && <0.3'
  polysemy-zoo: '>=0.6.0 && <0.8'
  prettyprinter: '>=1.2.1 && <1.7'
  random: '>=1.1 && <1.3'
  say: '>=0.1.0 && <0.2'
  stm: '>=2.4.5.1 && <2.6'
  streamly: '>=0.7.2 && <0.7.3'
  streamly-bytestring: '>=0.1.0 && <0.2'
  svg-builder: '>=0.1.1 && <0.2'
  text: '>=1.2.3 && <1.3'
  time: '>=1.8.0 && <2.0.0'
  transformers-base: '>=0.4.5 && <0.5'
changelog: "v0.8.0.0\n* BREAKING: moved config arguments to ```knit-html``` and ```knit-htmls```
  into a data structure ```KnitConfig```.  This breaks\nall existing uses of those
  functions but is designed to future-proof against additions to the knit configuration.
  \ A breaking\nchange was more-or-less necessitated by the addition of a cache directory
  parameter for the persistent caching effect. See below.\n\n* New persistent caching
  effect.  Anything which has an instance of ```Serialize``` (from the cereal package)
  may be cached,\nin memory and backed by a disk-based cache (cache effect will attempt
  to create \ndirectories as required).  When knit-html(s) is next run, the cached
  version can be used in \nplace of running an expensive computation. This comes with
  some built-in dependency management, via modification times of the\nfiles in cache
  or user-provided time for dependencies on non-cached assets. For more information,
  \nsee the [Readme](https://github.com/adamConnerSax/knit-haskell/blob/master/Readme.md).\nFor
  an example, see examples/CacheExample.hs.\n\n* Added Async into knit-haskell effects.
  \ For an example, see examples/AsyncExample.hs.\n\n* Logging changes:\n\n1. Added
  a ```Debug Int``` level below ```Diagnostic``` with an integer argument to allow
  various and unlimited debug levels\n2. Changed the previous ```[LogSeverity]```
  argument given to run functions to ```(LogSeverity -> Bool)``` \nto accomdate the
  non-Boundedness of the new ```Debug Int``` levels.\n3. Made logging thread-aware
  by making prefixes thread-local  \nand doing IO output of logs via the [```Say```
  library](https://hackage.haskell.org/package/say)\n4. Added type synonyms ```PrefixedLogEffects```
  and ```PrefixedLogEffectsLE``` for type-level-lists of logging effects \n\n* Added
  functions to handle the failure branch of ```Maybe``` and ```Either Text``` as errors.\n*
  Added ```knitMapError``` to absorb other types of errors.\n* Updated some dependency
  bounds (NB: tests now depend on random-fu >= 2.7.3 since previous versions had bad
  log-domain bounds)\n* Updated for Pandoc >= 2.8.  String to Text and template handling
  changes.  All conditional (via CPP) so should work with < 2.8 as well.\n\nv0.7.0.0\n*
  Updated vega versions in pandoc templates\n* removed (internal) datadir function
  because we now use the function\nfrom the autogenerated ```Paths_knit-haskell```
  module.  Which has its own\ncomplications but the other version didn't work at all.\n*
  Added more constraints to Knit.Report.KnitEffects to simplify things.  \nIf you
  use them to constrain a function to procuce something that can be knitted\nyou will
  have all the knit effects available.\n* Where possible changed package bounds to
  >= A.B.C && < D.E. Most were already and\nsome were easy to change.  There are some
  lower bounds that are more specific and I\nwon't generalize those unless I test
  them.\n* Changed bounds for hvega, polysemy and polysemy-zoo. Downstream changes
  to account for this.\n* SimpleExample now uses default template so that it also
  serves as a test that default templates are found.\n\n\nv 0.6.0.1 - (Released 2019-06-21)\n*
  Moved the Pandoc default templates so they will be installed where Pandoc expects
  them. This is hard to test!\n\nv 0.6.0.0 - (Released: 2019-06-19)\n* updated to
  use polysemy-zoo version of constraint absorbers in PandocMonad.\n* Hackage download
  should now include templates and associated css\n* Added mkPandocWriterConfig and
  addCss function in Knit.Report.Output to handle loading things in \nthe included
  directory, which may be installed in a platform independent way.\n* Added two more
  html templates, pandoc-bootstrap-KH.html and pandoc-adaptive-bootstrap-KH.html\nwith
  pandoc-bootstrap.css and used them in some of the examples.\n* Added the default
  html templates into the pandoc-templates directory where Pandoc will expect\nthem
  if the given template fails.\n* Reorganized data directory with \"pandoc-data\"
  \"knit-haskell-templates\" and \"knit-haskell-css\"\n* Added output helpers for
  Pandoc results which are lazy text (html).  These create the\nrequired parent directories
  if necessary. See examples for details.\n* Removed ```Knit.Effect.RandomFu``` and
  modified the example which uses it to use the\n\"polysemy-RandomFu\" package instead.\n\nv
  0.5.0.0\n* Added plots example back since there is a version of plots on hackage
  with \na relaxed upper bound on containers.\n* Changed the Doc effect so that instead
  of Text name, it carries a polymorphic info type.  \nThis is then specified in the
  Pandoc case to be a Text name and set of template var overrides.\nThis creates several
  other changes and will break any multi-doc examples since now \n\"newPandoc\" takes
  a first argument of the type ```PandocInfo``` (which is just a \nproduct of a ```Text```
  and a ```Map String String```).\n* raised lower bound and relaxed upper bound on
  polysemy\n\nv 0.4.0.0 \n* Added  \n```absorbPandocMonad :: PandocEffects r => (forall
  m. PandocMonad m => m a) -> Sem r a``` \nto ```Knit.Effect.PandocMonad```\n* Removed
  (orphan) instances: ```PandocMonad (Sem r)``` and \n```MonadError PandocError (Sem
  r)``` in favor  of using \n```absorbPandocMonad``` when required.\n* Deprecated
  name \"Random\" in favor of \"RandomFu\" for clarity and \neventual consistency
  with Polysemy\n* Added \n```absorbMonadRandom :: Member RandomFu r => (forall m.
  MonadRandom m => m a) -> Sem r a``` \nto allow some\ninteroperation with actions
  constrained by ```MonadRandom```\n* Removed orphan ```Random.MonadRandom``` instance
  from \n```Knit.Effect.RandomFu``` because orphan instances are bad.\n* Changed return
  type of ```Knit.Report.knitError``` to ```Sem r a``` \n(from ```Sem r ()```)\n*
  Bumped lower bound on polysemy-plugin (because of a buggy version)\n* Bumped lower
  bound on polysemy\n* Removed plots example in \"SimpleExample\" and added a diagrams
  one.  \nWill add plots back once a version issue  with containers is resolved.\n\nv
  0.3.0.1\n* Examples were \"executables\" and are now \"tests\" so that depending
  on \nknit-haskell does not pull in the dependencies of the examples.\n\nv 0.3.0.0
  \n* Added exports of \"Colonnade\" and \"Text.Blaze.Colonnade\" to \n\"Knit.Report.Input.Table.Colonnade\"\n*
  Added \"knitError\" function to Knit.Report to allow user throwing of errors.  \nThese
  will become PandocSomeError and handled as a PandocError.\n* Lowered bound on containers
  (to 0.5.0) to accomodate use of Plots.\n* Added Knit.Report.Input.Visualization.Diagrams.
  \ \nAdds Diagrams from diagrams-lib via SVG backend.\n* Added some more re-exports
  (Colonnade, Diagrams.Prelude) \nfrom Knit.Report to simplify imports on use.\n*
  Added an optional figure caption argument to Hvega and Diagrams inputs. \n(this
  is a breaking change since it requires another argument).\n* Added a state effect
  wrapper to facilitate getting unused ids for figures, etc.\n* Changed id argument
  for Hvega and Diagrams \nvisualizations to \"Maybe Text\" from Text.  \nWill use
  built-in facilities for unique ids when set to Nothing.\n* Visualization \"addXXX\"
  functions now return the figure id (as \"Sem r Text\") \nso it can be referred to
  elsewhere.\n* Added KnitOne and KnitMany constraint-type-aliases to Knit.Report
  \nto simplify constraining doc producing functions.\n* Updated examples.  Added
  a diagrams example to SimpleExample \nand fixed id and caption arguments throughout.\n*
  Bumped upper bounds (network)\n\nv 0.2.0.0\n* Documentation Fixes\n* Added export
  of newPandoc and NamedDoc to Knit.Report to \nfacilitate multi-doc use.\n* Removed
  redundant imports from Knit.Report.Input.Table.Colonnade\n* Added a multi-doc example\n*
  (internal) Removed odd, and no longer necessary, \"LastMember\" \nconstraint from
  knit functions. \n* Updated effects for polysemy 1.2\n\nv 0.1.0.0  \n* Initial version\n\n"
changelog-type: markdown
description: "# knit-haskell v0.8.0.0\n\n[![Build Status][travis-badge]][travis]\n[![Hackage][hackage-badge]][hackage]\n[![Hackage
  Dependencies][hackage-deps-badge]][hackage-deps]\n\n## Breaking Changes\nTo move
  from v0.7.x.x to v0.8.x.x requires a change in how configuration parameters given
  to ```knit-html``` and ```knit-htmls``` are \nhandled: they are now all placed inside
  a ```KnitConfig```.  \nIt's a trivial change to make and should make the configuration
  more future-proof as long as you build your ```KnitConfig``` like, e.g., \n```haskell\nmyConfig
  :: KnitConfig\nmyConfig = (defaultKnitConfig $ Just \"myCache\") { outerLogPrefix
  = Just \"MyReport\"}\n```\n\nAlso note that newer versions of Pandoc (2.9+) have
  their own breaking changes.  knit-haskell can be \ncompiled against these as\nwell
  as the older versions, but there are some major changes which may affect you should
  you use any of the pandoc \nfunctions directly.  In particular, Pandoc has now switched
  to using ```Text``` instead of ```String``` for\nmost (all ?) things.\n\n## Introduction\nknit-haskell
  is an attempt to emulate parts of the RMarkdown/knitR experience in haskell. \nThe
  idea is to be able to build HTML (or, perhaps, some other things [Pandoc](http://hackage.haskell.org/package/pandoc)
  can write) \ninside a haskell executable.  \nThis package wraps Pandoc and the \n[PandocMonad](http://hackage.haskell.org/package/pandoc-2.7.2/docs/Text-Pandoc-Class.html#t:PandocMonad),
  \nhas logging facilities and support for inserting [hvega](http://hackage.haskell.org/package/hvega),
  \n[diagrams](https://hackage.haskell.org/package/diagrams), and \n[plots](https://hackage.haskell.org/package/plots)
  based \nvisualizations.  \nAll of that is handled via writer-like effects, so additions
  to the documents can be interspersed with regular haskell code. \n\nAs of version
  0.8.0.0, the effect stack includes a couple of new features. \nFirstly, an \"Async\"
  effect ([Polysemy.Async](https://hackage.haskell.org/package/polysemy-1.2.3.0/docs/Polysemy-Async.html))
  \nfor running computations concurrently. Combinators for launching a concurrent
  action (```async```), \nawaiting (```await```) it's result and running some traversable
  structure of concurrent actions\n(```sequenceConcurrently```) are re-exported via
  ```Knit.Report```.  NB: Polysemy returns a ```Maybe a``` where\nthe traditional
  interface returns an ```a```. \nFrom the docs \"The Maybe returned by async is due
  to the fact that we can't be sure an Error effect didn't fail locally.\"\n\nA persistent
  (using memory and disk) cache for \"shelving\" the results of computations during
  and between runs.  \nUsing the default setup, anything which has\na ```Serialize```
  instance from the [cereal](https://hackage.haskell.org/package/cereal) \npackage
  can be cached. You can use a different serializer if you so choose, but you will
  have write\na bit of code to bridge the serializer's interface and, depending on
  what the serializer encodes to, \nyou may also  have to write your own persistence
  functions for saving/loading that type to/from disk.  See \n```Knit.Effect.Serialize```
  and ```Knit.Effect.AtomicCache``` for details.\n\nIf you use the cache, and you
  are running in a version-controlled directory,\nyou probably want to add your cache
  directory, specified in ```KnitConfigure``` and defaulting to\n\".knit-haskell-cache\",
  to \".gitignore\" or equivalent.\n\nOnce data has been loaded from disk/produced
  once, it remains available in memory (in serialized form) via its key. \nThe cache
  handles multi-threading gracefully.  The in-memory cache is stored in a TVar so
  only one thread \nmay make requests at a time.\nIf multiple threads request the
  same item, one not currently in-memory--a \nrelatively common pattern if multiple
  analyses of the same data are \nrun asynchronously--the first request will fetch
  or create the data and the rest will block until the first one\ngets a result, at
  which point the blocked threads will received the now in-memory data and proceed.\n\nData
  can be put into the cache via ```store```, and retrieved via ```retrieve```. Retrieval
  from cache\ndoes not actually retrieve the data, but a structure with a time-stamp
  \n([```Maybe Time.Clock.UTCTime```](https://hackage.haskell.org/package/time-1.10/docs/Data-Time-Clock.html#t:UTCTime))\nand
  a monadic computation which can produce the data:\n```haskell\ndata WithCacheTime
  m a where\n  WithCacheTime :: Maybe Time.UTCTime -> m a -> WithCacheTime m a\n```\n\nTo
  get the data from a ```WithCacheTime``` you can use functions from the \nlibrary
  to \"ignore\" the time and bind the result:\n```ignoreCacheTime :: WithCacheData
  m a -> m a```\nor\n```haskell\nignoreCacheTimeM :: m (WithCacheData m a) -> ma \nignoreCacheTimeM
  = join . ignoreCacheTime\n```\n\nThough direct storage and retrieval is useful,
  typically, one would use the cache to store \nthe result of a long-running computation
  so it need only be run once.  This pattern is \nfacilitated via \n```\nretrieveOrMake
  :: k -> WithCacheTime m b -> (b -> m a) -> m (WithCacheTime m a)\n```\n\nwhich takes
  a key, a set of dependencies, of type ```b```, with a time-stamp,\na (presumably
  expensive) function taking those dependencies and producing a \ntime-stamped monadic
  computation for the desired result. If the requested\ndata is cached, the time stamp
  (modification time of the file in cache, more or less) \nis compared to the time-stamp
  on the dependencies.  As long as the dependencies are older\nthan the cached data,
  an action producing the cached result is returned.  If there is no\ndata in the
  cache for that key or the in-cache data is too old, the action producing the dependencies\nis
  \"run\" and those dependencies are fed to the computation given, producing the data
  and \ncaching the result.\n\nNB: The returned monadic computation is *not* simply
  the result of applying the dependencies to\nthe given function.  That computation
  is run, if necessary, in order to produce the data, which\nis then serialized and
  cached.  The returned monadic computation is either the data produced\nby the given
  computation, put into the monad via ```pure```, or the result pulled from the \ncache
  *before* it is deserialized.  Running the returned computation performs the deserialization\nso
  the data can be used.  This allows checking the time-stamp of data without deserializing
  it\nin order to make the case where it's never actually used more efficient.  \n\n```WithCacheTime```
  is an applicative functor, which facilitates its primary use, to store \na set of
  dependencies *and* the latest time at which something which depends on them could\nhave
  been computed and still be valid. As an example, suppose you have three long-running\ncomputations,
  the last of which depends on the first two:\n```haskell\nlongTimeA :: AData\nlongTimeB
  :: BData\nlongTimeC :: AData -> BData -> CData\n```\n\nYou might approach caching
  this sequence thusly:\n```\ncachedA <- retrieveOrMake \"A.bin\" (pure ()) (const
  longTimeA)\ncachedB <- retrieveOrMake \"B.bin\" (pure ()) (const longTimeB)\nlet
  cDeps = (,) <$> cachedA <*> cachedB\ncachedC <- retrieveOrMake \"C.bin\" cDeps $
  \\(a, b) -> longTimeC a b\n```\nand each piece of data will get cached when this
  is first run.  Now suppose you change the computation\n```longTimeA```.  You realize
  that the cached data is invalid, so you delete \"A.bin\" from the\ncache.  The next
  time this code runs, it will recompute and cache the result of ```longTimeA```,
  \nload the ```BData```  (serialized) from cache, see that\nthe cached version of
  ```CData``` is out of date, \nand then deserialize ```BData````, and use it and
  the new ```AData``` \nto recompute and re-cache ```CData```.  This doesn't eliminate
  the \nneed for user intervention: the user still had to manually delete \"A.bin\"
  to force re-running ```longTimeA```, \nbut it handles the downstream work of tracking
  the uses of that data and recomputing where required. \nI've found this extremely
  useful.\n\nEntries can be cleared from the cache via ```clear```.\n\nThe cache types
  are flexible:\n\n-The default key type is ```Text``` but you may use anything with
  an ```Ord``` and ```Show``` \ninstance (the latter for logging).  The persistence
  layer will need to be able to turn the key\ninto a key in that layer, e.g., a ```FilePath```.\n\n-The
  default serializer is the \n[cereal](https://hackage.haskell.org/package/cereal)
  package but you may\nuse another (e.g., the \n[binary](https://hackage.haskell.org/package/binary-0.8.7.0/docs/Data-Binary.html)
  \npackage or \n[store](https://hackage.haskell.org/package/store).\n\n-The default
  in-memory storage is a [streamly](https://hackage.haskell.org/package/streamly)
  \n[array](https://hackage.haskell.org/package/streamly-0.7.2/docs/Streamly-Memory-Array.html)
  of bytes \n([```Word8```](https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Word.html))
  but this can\nalso be changed.\n\nTo change these, the user must provide a serializer
  capable of serializing any data-type to be stored into\nthe desired in-memory storage
  type,  and a persistence layer which can persist that in-memory type.\n\nPlease
  see  [CacheExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/CacheExample.hs)
  for an example using\nthe default serializer and in-memory storage type. \nSee [CacheExample2](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/CacheExample2.hs)
  for an\nidentical example, but with a custom serializer (based on the \n[store](https://hackage.haskell.org/package/store))
  package and using strict ```ByteStreams``` as the in-memory cache type. \n\nNotes:\n1.
  Using Streamly requires some additional support for both Cereal and Polysemy.  The
  encoding/decoding \nfor Cereal are in this library, in ```Streamly.External.Cereal```.
  The Polysemy issue is more complex.\nSince concurrent streamly streams can only
  be run over a monad with instances of ```MonadCatch``` and \n```MonadBaseControl```.
  The former is \n[complex](https://hackage.haskell.org/package/polysemy-zoo-0.7.0.0/docs/Polysemy-ConstraintAbsorber-MonadCatch.html)
  \nin Polysemy and the latter impossible, [for good reason](https://github.com/polysemy-research/polysemy/issues/73).
  \nSo knit-haskell contains some helpers for Streamly streams: basically a wrapper
  over IO which allows use of\nknit-haskell logging.  Concurrent streaming operations
  can be done over this monad and then, once the stream\nis serial or the result computed,
  that monad can be lifted into the regular knit-haskell Polysemy stack.  \nSee ```Knit.Utilities.Streamly```
  for more details.\n\n2. ```Knit.Report```, the main import, provides constraint
  helpers to use these effects.  The clearest way to\nsee how they are used is to
  look at the examples.  The Cache effects are split into their own constraint helper\nbecause
  they have type-parameters and thus add a lot of inference complications.  If you
  don't need them in a \nfunction, you need not specify them.  Some of that inference
  can be improved using the \n[polysemy-plugin](https://hackage.haskell.org/package/polysemy-plugin)
  in the source files where you\nhave issues.  Otherwise, you may need to use \n[type
  applications](https://gitlab.haskell.org/ghc/ghc/-/wikis/type-application)\nwhen
  calling some functions in \n```Knit.Report.Cache```.\n\n- ```KnitEffects r```: All
  effects except caching or the addition of document fragments.  \nIncludes logging,
  error handling, and any direct use of funtions in PandocMonad or IO.  \nThis is
  often useful to wrap computations that need logging and perhaps IO but that don't
  \nwrite any part of your document.  This is a constraint on the polysemy ```EffectRow```,
  \n```r```, typically part of the return type of the function: ```Sem r a```.\n\n-
  ```CacheEffects sc ct k r```: Effects related to caching. ```sc``` is the Serializer
  constraint, e.g.,\n```Serialize``` for cereal (the default) or ```Store``` for store.
  ```ct``` is the in-memory data type,\n```Streamly.Memory.Array.Array Word8``` by
  default but some flavor of ```ByteStream``` could also make sense. \n```k``` is
  the key type, ```Text``` by default but anything with ```Ord``` and ```Show``` instances
  will do.\n\n- ```CacheEffectsD r```: provides the same effects as ```CacheEffects```
  but sets the various types to their defaults.\n\n- ```KnitOne r```: ```KnitEffects
  r``` and the additional effect required to write Pandoc fragments.\n\n- ```KnitMany
  r```: ```KnitEffects r``` and the additional effects required to write multiple
  Pandoc \ndocuments.\n\n\n## Supported Inputs\n* [markdown](https://pandoc.org/MANUAL.html#pandocs-markdown)\n*
  HTML ([blaze](http://hackage.haskell.org/package/blaze-html), [lucid](http://hackage.haskell.org/package/lucid)
  or Text)\n* [latex](https://en.wikipedia.org/wiki/LaTeX)\n* [colonnade tables](https://hackage.haskell.org/package/colonnade)\n*
  [hvega](http://hackage.haskell.org/package/hvega) visualizations (via [blaze](http://hackage.haskell.org/package/blaze-html)
  HTML) \n* [Diagrams](https://archives.haskell.org/projects.haskell.org/diagrams/)
  (via Diagrams SVG backend, inserted as HTML) \n\n## Examples\nThere are a few examples
  in the \"examples\" directory.  \n* [SimpleExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/SimpleExample.hs)
  \ndemonstrates the bare bones features of the library.  Creating a document from
  a few fragments and then \n\"knitting\" it into HTML text and writing that to a
  file. This includes hvega, diagrams and plots examples.\n* [MultiDocExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/MultiDocExample.hs)
  \ndemonstrates how to build multiple documents.\n* [MtlExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/MtlExample.hs)
  \ndemonstrates the same simple features as above, but runs them atop an example
  mtl stack, \nallowing access to the mtl stack's functionality during document assembly.\n*
  [RandomExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/RandomExample.hs)
  \nbuilds on the mtl example to show how you can also add an additional polysemy
  effect (in this case, \nPolysemy.RandomFu from [polysemy-RandomFu](https://hackage.haskell.org/package/polysemy-RandomFu))\nto
  your document-building. \nThis one also demonstrates a use of [colonnade](https://hackage.haskell.org/package/colonnade)
  \nfor adding a formatted table to the document.\n* [ErrorExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/ErrorExample.hs).
  \ \nSimilar to \"SimpleExample\" but throws a user error during document assembly.\n*
  [AsyncExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/AsyncExample.hs).
  \ \nSimilar to \"SimpleExample\" but uses Polysemy's ```sequenceConcurrently```
  to run some example\ncomputations concurrently (as long as you compile with \"-threaded\")\n*
  [CacheExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/CacheExample.hs).
  \ \nSimilar to \"SimpleExample\" but uses the \"AtomicCache\" effect to store the
  result of a computation. \nDemonstrates the behavior of the cache when multiple
  threads attempt to access the same item--the first\nthread loads/creates the data
  while the other blocks until the data is in-memory.  Also demonstrates\nuse of time-stamps
  to force rebuilding when tracked inputs change.\n* [CacheExample2](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/CacheExample2.hs).
  \ \nSimilar to \"CacheExample\" but implements and uses a different serializer and
  persistence layer than the\ndefault.\n\n\n## Notes\n* You can often get everything
  you need by just importing the \n[Knit.Report](https://github.com/adamConnerSax/knit-haskell/blob/master/src/Knit/Report.hs)
  \nmodule. It's meant to be \"batteries included.\"  \nThis re-exports the main functions
  for \"knitting\" documents and re-exports \nall the required functions to input
  the supported fragment types and create/write Html, \nas well as various utilties
  and\ncombinators for logging, using the cache facility, or throwing errors.\n* This
  uses [polysemy](https://github.com/polysemy-research/polysemy#readme) for its effect
  management rather than mtl.  \nPolysemy's inference (and performance?) are greatly
  improved if you enable \nthe [polysemy-plugin](https://hackage.haskell.org/package/polysemy-plugin),\nwhich
  involves:\n1. adding \"polysemy-plugin\" in build-depends and\n2. Add \"ghc-options:
  -fplugin=Polysemy.Plugin\" to your package configuration or\n```{-# OPTIONS_GHC
  -fplugin=Polysemy.Plugin #-}``` at the top of any source file\nwith inference issues.
  \n\nPandoc effects and writer effects for document building are also provided.\n\n*
  Polysemy is capable of \"absorbing\" some mtl-style monad constraints.  This is
  demonstrated in\n[RandomExample](https://github.com/adamConnerSax/knit-haskell/blob/master/examples/RandomExample.hs#L113)
  and\ncomposable absorbers for MonadReader, MonadWriter, MonadState and MonadError\ncan
  be found in the [polysemy-zoo](https://github.com/isovector/polysemy-zoo).\n\n*
  Pandoc templates are included for HTML output.  See the examples for how to access
  them\nor specify others.\n\n* If you use knit-haskell via an installed executable,
  it will find the templates that \ncabal installs.  But if you use from a local build
  directory and use \"cabal new-\" or \"cabal v2-\"\nstyle commands, you will need
  to run the executable via some \"cabal v2-\" command as well, e.g.,\n\"cabal v2-run\"
  (but not \"cabal v2-exec\") otherwise the \ntemplates--installed in the nix-style-build
  store--won't be found.\n* Though you can theoretically output to any format Pandoc
  can \nwrite--and it would be great to add some output formats!--some \nfeatures
  only work with some output formats. \nMy goal was the production of Html and that
  is the only output format that supports the hvega charting \nsince hvega itself
  is just a wrapper that builds javascript to render in a browser.  \nAnd so far that
  is the only supported output format.\n\n* This is very much a WIP. So it's rough
  around the edges and in the middle.  \nIf you find it useful but have suggestions,
  please submit issues on github.\n\n* I'm very interested in adding to the \"zoo\"
  of input fragments.  Any PRs of that sort would be most welcome!\n* I'm also interested
  in widening the possible output types--currently only HTML is supported--but \nthat
  is quite limited now by hvega which only works in html output.  \nBut support could
  be added for other output types if hvega input is not required.\n\n[travis]:        <https://travis-ci.org/adamConnerSax/knit-haskell>\n[travis-badge]:
  \ <https://travis-ci.org/adamConnerSax/knit-haskell.svg?branch=master>\n[hackage]:
  \      <https://hackage.haskell.org/package/knit-haskell>\n[hackage-badge]: <https://img.shields.io/hackage/v/knit-haskell.svg>\n[hackage-deps-badge]:
  <https://img.shields.io/hackage-deps/v/knit-haskell.svg>\n[hackage-deps]: <http://packdeps.haskellers.com/feed?needle=knit-haskell>\n"
description-type: markdown
hash: b413c018dcc1313965c9dca560ee48fb41fef2d78c4c1c8283e57b913e92506a
homepage: https://github.com/adamConnerSax/knit-haskell#readme
latest: 0.8.0.0
license-name: BSD-3-Clause
maintainer: adam_conner_sax@yahoo.com
synopsis: a minimal Rmarkdown sort-of-thing for haskell, by way of Pandoc
test-bench-deps:
  base: '>=0'
  blaze-html: '>=0'
  bytestring: '>=0'
  colonnade: '>=1.2.0.2'
  containers: '>=0'
  here: '>=1.2.10 && <1.3.0'
  hvega: '>=0'
  knit-haskell: '>=0'
  mtl: '>=2.2.2'
  plots: '>=0.1.1.0 && <=0.2'
  polysemy: '>=0'
  polysemy-RandomFu: '>=0.4.0 && <0.5'
  polysemy-plugin: '>=0'
  random-fu: '>=0.2.7.3 && <0.3'
  random-source: '>=0.3.0.6'
  store: '>=0'
  streamly: '>=0'
  text: '>=0'

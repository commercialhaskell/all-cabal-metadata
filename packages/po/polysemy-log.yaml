homepage: https://github.com/tek/polysemy-log#readme
changelog-type: markdown
hash: cbed86fd6380a75500700d471d5c6bec2cd1836dc4a832ae196fe268445cabe9
test-bench-deps:
  polysemy-conc: '>=0.1.0.0'
  string-interpolate: '>=0.2.1'
  base: ==4.*
  time: -any
  tasty-hedgehog: -any
  text: -any
  polysemy-test: -any
  hedgehog: -any
  polysemy-log: -any
  ansi-terminal: '>=0.10.3'
  relude: '>=0.7'
  polysemy-time: '>=0.1.1.0'
  polysemy: '>=1.5'
  tasty: -any
  template-haskell: -any
maintainer: tek@tryp.io
synopsis: Polysemy Effects for Logging
changelog: |
  # 0.2.1.0
  * add naive stderr interpreters for `DataLog` and `Log`.

  # 0.2.0.0

  * `DataLog` got a second constructor, `Local`. It takes a higher-order `Sem` and a transformation function, the latter
    of which is applied to all messages logged within the former.
    This allows context manipulation for blocks of code.
  * `interceptDataLogConc` adds support for concurrent processing of log messages to any interpretation of `DataLog`.
basic-deps:
  polysemy-conc: '>=0.1.0.0'
  string-interpolate: '>=0.2.1'
  base: ==4.*
  time: -any
  text: -any
  ansi-terminal: '>=0.10.3'
  relude: '>=0.7'
  polysemy-time: '>=0.1.1.0'
  polysemy: '>=1.5'
  template-haskell: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.0.1
- 0.2.1.0
- 0.2.2.0
- 0.2.2.1
- 0.2.2.2
- 0.2.2.3
author: Torsten Schmits
latest: 0.2.2.3
description-type: markdown
description: |
  > Log thrice, debug once.
  >
  > –– Г. Любенов

  # About

  A common interface for the polysemy logging backend adapters.

  An example program using [co-log], for the simple logger with predefined formatting and a custom data type:

  ```haskell
  import Colog (logTextStdout)
  import Colog.Polysemy (runLogAction)
  import Polysemy (runM)

  import Polysemy.Log.Colog (interpretDataLogColog, interpretLogStdout)
  import qualified Polysemy.Log.Data.DataLog as DataLog
  import Polysemy.Log.Data.DataLog (DataLog)
  import qualified Polysemy.Log.Data.Log as Log
  import Polysemy.Log.Data.Log (Log)

  progSimple ::
    Member Log r =>
    Sem r ()
  progSimple = do
    Log.debug "debug"
    Log.warn "warn"

  data Message =
    Message {
      severity :: Text,
      message :: Text
    }
    deriving (Eq, Show)

  progData ::
    Member (DataLog Message) r =>
    Sem r ()
  progData = do
    DataLog.dataLog (Message "warn" "warning!")
    DataLog.local (\ msg@Message{message} -> msg {message = "context: " <> message}) do
      DataLog.dataLog (Message "error" "segfault!")

  main :: IO ()
  main =
    runM do
      interpretLogStdout progSimple
      runLogAction @IO (contramap message logTextStdout) $ interpretDataLogColog @Message $ progData
  ```

  For more documentation, please consult Hackage:
  * [polysemy-log](https://hackage.haskell.org/package/polysemy-log)
  * [polysemy-log-co](https://hackage.haskell.org/package/polysemy-log-co)
  * [polysemy-log-di](https://hackage.haskell.org/package/polysemy-log-di)

  # Building the Project

  The build is defined in [nix], supporting `flake` and legacy `nix-build`.

  With `nix-build`:

  ```bash
  nix-build -A defaultPackage
  nix-build -A packages.x86_64-linux.polysemy-log-co
  ```

  With `nix flake`:

  ```
  nix build
  nix build '.#polysemy-log-co'
  ```

  To run all tests:

  ```bash
  nix flake check
  ```

  [nix]: https://nixos.org/manual/nix/unstable
  [co-log]: https://hackage.haskell.org/package/co-log
license-name: BSD-2-Clause-Patent

homepage: https://github.com/waivio/posit#readme
changelog-type: markdown
hash: 7842a501d39904f38a719343a8f7795d89f7d561b0cbe4f2c2ea683fa87e9e0c
test-bench-deps:
  Chart: -any
  Chart-cairo: -any
  base: '>=4.7 && <5'
  posit: '>=2022.0.1'
  weigh: -any
  vector: -any
maintainer: nathan.waivio@gmail.com
synopsis: Posit Numbers
changelog: |+
  # Changelog for Posit Numbers

  # posit-2022.0.1.1

    * Fixed loss of precision bug in some of the Floating instances (exp,sin,cos)
    * Added a Charting test; command to run: stack test posit:test-posit-functions
    * Added test results to the README.md file

  # posit-2022.0.1.0

    * Added Random and Uniform Instances
    * `Uniform` provides a uniform distribution over all possible posits, sampling the entire projective real line
    * `Random` provides a uniform distribution between 0 and 1, sampling the real numbers in that range
    * Example: take 10 (randomRs (1,100) (mkStdGen 2023)) :: [Posit64]
    * Added `hypot2`, `hypot3`, `hypot4`, to the `AltFloating` class

  # posit-2022.0.0.1

    * Added `PositF` constraint synonym to simplify the usage of `(PositC es, PositC (Next es))`, as is needed for `Floating` instances
    * More coverage in the test suite for multiple types

  # posit-2022

    * Added Types (P8, P16, P32, P64, P128, P256) for the Posit Standard 2022 encoding, exponent size = 2, and with nBytes = 2^es
    * Refactored `Floating` to step up in resolution and then calculate a function, and then round it down to the the lower resolution
    * Added polymorphic `Posit es` approximations for the `Floating` class
    * Moved functions used in the test suite to the Test.Algorithms module, to eliminate the `do-test` flag
    * Since the test flag has been removed the test can be run by: stack test
    * Please forgive the lack of camelCase in some of the Floating functions... I think it reads better this time
    * The Weigh test can be run as a benchmark: stack bench

  # posit-3.2.0.5

    * Bug fix for `mkIntRep` to resolve an overflow issue with the fractional part when it rounds up, in anticipation of the 2022 Standard release

  # posit-3.2.0.4

    * No more Orphan Instances for Storable!
    * Figured out how to resolve the orphan instances problem with `newtype`, `DerivingVia` and `UndecidableInstances`.
    * Added a "weigh" based test to verify the proper size of each Posit type
    * Added a WeighPosit test; command to run: stack test posit:test-posit-weigh
    * Added NFData instance.
    * New GitHub Snapshot of Liquid Haskell makes it work with GHC 9.0.2!

  # posit-3.2.0.3

    * Made the following changes in anticipation of adding the 2022 Posit Standard:
        * Made the `IntN` type family non-Injective, and added more visable type applications to help the compiler select the proper types
        * Corrected some bad uses of `nBytes @es`, with `2^(exponentSize @es)`, in order to be more general
        * Chagned `maxPosRat` to match the more general form as described in "Posit Arithmetic" (John L Gustafson, 10 October 2017)
        * Changed `lnOf2` to be a long decimal value, in order to be more general
    * Changed Borwein's algorithm, with quintic convergence, to check for a fixed point of both `a` and `s`
    * Added Borwein's Quadradic 1985
    * Added Borewein's Cubic

  # posit-3.2.0.2

    * Added `FlexableContexts` back in to Posit.hs, a build error occured on GHC-9.2 that didn't occur with GHC-9.0 or GHC-8.10

  # posit-3.2.0.1

    * Refactored `IntN` Type Family to be a closed type family instead of an associated type family
    * Refactored `IntN` constraints to use `ConstraintKinds` and made that to be a Super Class of `PositC` to improve the encapsulation the Constraints of the internal implementation
    * Refactored `PositC` to make use of `ConstrainedClassMethods` vastly reducing code duplication
    * Eliminated the `FlexableContexts` Language Extension from Posit.hs Interface, since the `InN` constraints no longer bleed into that file
    * Added test of Heegner numbers (almost integers)
    * Added test of various Gamma Function approximations
    * Improved function names in the Orphan Instance for `Storable` ( `Word128` )
    * Improved documentation

  ## posit-3.2.0.0

    * Posit Standard 3.2 [Posit Standard] (https://posithub.org/docs/posit_standard.pdf)
    * LiquidHaskell support: stack build --flag posit:do-liquid
    * To run the test suite: stack test --flag posit:do-test
    * To play around: stack repl --flag posit:do-test

basic-deps:
  data-dword: -any
  base: '>=4.7 && <5'
  random: -any
  deepseq: '>=1.1 && <2'
  scientific: -any
all-versions:
- 3.2.0.0
- 3.2.0.1
- 3.2.0.2
- 3.2.0.3
- 3.2.0.4
- 3.2.0.5
- 2022.0.0.0
- 2022.0.0.1
- 2022.0.1.0
- 2022.0.1.1
author: Nathan Waivio
latest: 2022.0.1.1
description-type: markdown
description: "# posit 2022.0.1.1\n\nThe [Posit Standard 2022](https://posithub.org/docs/posit_standard-2.pdf),\nand
  [Posit Standard 3.2](https://posithub.org/docs/posit_standard.pdf), \nwhere Real
  numbers are approximated by Maybe Rational.  The Posit \nNumbers are a drop in replacement
  for `Float` or `Double` mapped to a \n2's complement integer type; smoothly and
  with tapering precision, in a \nsimilar way to the projective real line.  The 'posit'
  library implements\nthe following standard classes:\n\n * Show\n * Eq\n * Ord  --
  compare as an integer representation\n * Num  -- Addition, subtraction, multiplication,
  and other operations\n * Enum  -- Successor and Predecessor\n * Fractional  -- division,
  divide by zero is Not a Real (NaR) number\n * Real\n * Bounded\n * FusedOps  --
  dot product and others\n * Convertable  -- Conversions between different posit formats\n
  * AltShow\n * Read\n * Storable  -- Formats for binary data, for computation and
  data interchange\n * Random\n * Uniform\n * RealFrac\n * RealFloat\n * Floating
  \ -- Mathematical functions such as logarithm, exponential, trigonometric, and hyperbolic
  functions. Warning! May induce trance.\n\nThe Posits are indexed by the type (es
  :: ES) where exponent size and\nword size are related.  In `posit-3.2` es is instantiated
  as Z, I,\nII, III, IV, V.  In `posit-2022` es is instantiated as Z_2022, I_2022,
  \nII_2022, III_2022, IV_2022, V_2022.  The word size (in bits) of the \nvalue is
  `= 8 * 2^es`, that is `2^es` bytes.  The Types: 'Posit8', \n'Posit16', 'Posit32',
  'Posit64', 'Posit128', and 'Posit256' as well as,\n'P8', 'P16', 'P32', 'P64', 'P128',
  and 'P256' are implemented and \ninclude a couple of auxiliary classes, like AltShow,
  AltFloating, and \nFusedOps.  So, 3.2 scales by dynamic range, 2022 scales by precision.\n\n```\nclass
  AltShow a where\n  -- Display the Posit in its Binary Representation\n  displayBinary
  :: a -> String\n  -- Display the Posit in its Integral Representation\n  displayIntegral
  :: a -> String\n  -- Display the Posit as a Rational\n  displayRational :: a ->
  String\n  -- Display the Posit as a Decimal until the Repented occurs\n  displayDecimal
  :: a -> String\n```\n\n```\nclass AltFloating p where\n  eps :: p  -- Machine Epsilon
  near 1.0\n  phi :: p\n  gamma :: p -> p\n  sinc :: p -> p\n  expm1 :: p -> p\n  hypot2
  :: p -> p -> p\n  hypot3 :: p -> p -> p -> p\n  hypot4 :: p -> p -> p -> p -> p\n```\n\n```\nclass
  Num a => FusedOps a where\n  -- |Fused Multiply Add: (a * b) + c\n  fma :: a ->
  a -> a -> a\n  -- |Fused Add Multiply: (a + b) * c\n  fam :: a -> a -> a -> a\n
  \ -- |Fused Multiply Multiply Subtract: (a * b) - (c * d)\n  fmms :: a -> a -> a
  -> a -> a\n  -- |Fused Sum of 3 values: a + b + c\n  fsum3 :: a -> a -> a -> a\n
  \ -- |Fused Sum of 4 values: a + b + c + d\n  fsum4 :: a -> a -> a -> a -> a\n  --
  |Fused Sum of a List of Posits\n  fsumL :: Foldable t => t a -> a\n  -- |Fused Dot
  Product of 3 element vector: (a1 * b1) + (a2 * b2) + (a3 * b3)\n  fdot3 :: a ->
  a -> a -> a -> a -> a -> a\n  -- |Fused Dot Product of 4 element veector: (a0 *
  b0) + (a1 * b1) + (a2 * b2) + (a3 * b3)\n  fdot4 :: a -> a -> a -> a -> a -> a ->
  a -> a -> a\n  -- |Fused Dot Product of Two Lists\n  fdotL :: Foldable t => t a
  -> t a -> a\n  -- |Fused Subtract Multiply: a - (b * c)\n  fsm :: a -> a -> a ->
  a\n```\n\nThe Posit type is 'Convertible' between other Posit lengths.\n\n```\nclass
  Convertible a b where\n  convert :: a -> b\n```\n\nThe Posit Library is built on
  top of two of the most excellent libraries:\n[data-dword](https://hackage.haskell.org/package/data-dword),
  and\n[scientific](https://hackage.haskell.org/package/scientific).  The\n'data-dword'
  library provides the underlining machine word\nrepresentation, it can provide 2^es
  word size, 2's complement fixed\nlength integers.  The 'scientific' library provides
  'read' and 'show'\ninstances.\n\n\nWell, so...\nIron sharpens Iron, or so they say.\nSo,
  the implementations might not be perfect, but... they pretty good!\n\nNumber of
  Accurate Bits `exp`:\n![exp](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of exp with P16 and Posit16.png \"Number of Accurate Bits exp\")\n\nNumber
  of Accurate Bits `log`:\n![log](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of log with P16 and Posit16.png \"Number of Accurate Bits log\")\n\nNumber
  of Accurate Bits `sqrt`:\n![sqrt](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of sqrt with P16 and Posit16.png \"Number of Accurate Bits sqrt\")\n\nNumber
  of Accurate Bits `sin`:\n![sin](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of sin with P16 and Posit16.png \"Number of Accurate Bits sin\")\n\nNumber
  of Accurate Bits `cos`:\n![cos](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of cos with P16 and Posit16.png \"Number of Accurate Bits cos\")\n\nNumber
  of Accurate Bits `asin`:\n![asin](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of asin with P16 and Posit16.png \"Number of Accurate Bits asin\")\n\nNumber
  of Accurate Bits `acos`:\n![acos](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of acos with P16 and Posit16.png \"Number of Accurate Bits acos\")\n\nNumber
  of Accurate Bits `atan`:\n![atan](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of atan with P16 and Posit16.png \"Number of Accurate Bits atan\")\n\nNumber
  of Accurate Bits `sinh`:\n![sinh](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of sinh with P16 and Posit16.png \"Number of Accurate Bits sinh\")\n\nNumber
  of Accurate Bits `cosh`:\n![cosh](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of cosh with P16 and Posit16.png \"Number of Accurate Bits cosh\")\n\nNumber
  of Accurate Bits `asinh`:\n![asinh](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of asinh with P16 and Posit16.png \"Number of Accurate Bits asinh\")\n\nNumber
  of Accurate Bits `acosh`:\n![acosh](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of acosh with P16 and Posit16.png \"Number of Accurate Bits acosh\")\n\nNumber
  of Accurate Bits `atanh`:\n![atanh](https://github.com/waivio/posit/tree/posit-2022/test/Results/Bits
  Accuracy of atanh with P16 and Posit16.png \"Number of Accurate Bits atanh\")\n\n\n\n"
license-name: BSD-3-Clause

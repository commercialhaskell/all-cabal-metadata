all-versions:
- 0.1.0.0
- 0.1.0.1
author: ''
basic-deps:
  aeson: '>=0'
  aeson-pretty: '>=0'
  attoparsec: '>=0'
  base: '>=4.10 && <5'
  binary: '>=0'
  binary-orphans: '>=0'
  bytestring: '>=0'
  cassava: '>=0'
  clock: '>=0'
  conduit: '>=0'
  containers: '>=0'
  contravariant: '>=0'
  data-default: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  docrecords: '>=0.1 && <0.2'
  filepath: '>=0'
  foldl: '>=0'
  formatting: '>=0'
  funflow: '>=1.5.0'
  hashable: '>=0'
  hvega: '>=0'
  katip: '>=0.8 && <0.9'
  lens: '>=0'
  log-domain: '>=0'
  monad-bayes: '>=0'
  monad-control: '>=0'
  mtl: '>=0'
  optparse-applicative: '>=0'
  path: '>=0'
  porcupine-core: '>=0'
  profunctors: '>=0'
  reader-soup: '>=0.1 && <0.2'
  resourcet: '>=0'
  safe-exceptions: '>=0'
  store: '>=0'
  streaming: '>=0'
  streaming-bytestring: '>=0'
  streaming-conduit: '>=0'
  streaming-utils: '>=0'
  template-haskell: '>=0'
  temporary: '>=0'
  text: '>=0'
  transformers: '>=0'
  transformers-base: '>=0'
  unix: '>=0'
  unliftio-core: '>=0'
  unordered-containers: '>=0'
  url: '>=0'
  vector: '>=0'
  vinyl: '>=0'
  yaml: '>=0'
  zlib: '>=0'
changelog: ''
changelog-type: ''
description: |-
  porcupine is centered around the PTask datatype, which represents a
  computation that will request access to some resources (both in read and write
  modes) and require some options (parameters, with docstrings and default
  values). PTasks are composable both sequentially and in parallel, into a
  pipeline of tasks. The resources and parameters are organized in a tree which
  will be automatically exposed to the outside world. This makes the pipeline
  self-documented, and makes it so any option or file required at some point by
  any task can be visualized and set or remapped (via a combination of a YAML or
  JSON config file and command-line arguments) before the pipeline will
  run. That means that the PTasks are completely agnostic of their data inputs,
  and that new data sources can be added without having to change any of the
  tasks' logic or even their types. This is done via the LocationAccessor
  typeclass. `porcupine-core` provides only access to local files (via
  resourcet), other location accessors will be in separate packages. See for
  instance the <https://hackage.haskell.org/package/porcupine-http> package to
  access HTTP urls. PTasks also provide caching thanks to the funflow
  package. See the README at <https://github.com/tweag/porcupine#README.md> and
  the examples in `porcupine-core` package.
description-type: haddock
hash: 37919f2abf40e4f25b8fae6b58e3d6e0b67aa7ccd9022a01082369216cd6b588
homepage: https://github.com/tweag/porcupine#readme
latest: 0.1.0.1
license-name: MIT
maintainer: Yves Par√®s <yves.pares@tweag.io>
synopsis: Express portable, composable and reusable data tasks and pipelines
test-bench-deps: {}

homepage: https://github.com/polysemy-research/polysemy-check#readme
changelog-type: markdown
hash: 210748d277c348b5dffad237c66aed1cdbb9e4a6d8bdef2068f127c698d10a84
test-bench-deps:
  polysemy-plugin: -any
  base: '>=4.7 && <5'
  hspec: -any
  containers: -any
  kind-generics: -any
  polysemy: -any
  QuickCheck: -any
  polysemy-check: -any
  kind-generics-th: -any
maintainer: sandy@sandymaguire.me
synopsis: QuickCheck for Polysemy
changelog: |+
  # Changelog for polysemy-check

  ## v0.3.0.0 (2021-10-09)

  - `prepropLaw` now synthesizes a monadic prelude and postlude to your laws, to
      ensure they hold under every context. The type has changed as a result.
  - `prepropEquivalent` now allows you to produce a functor `f` result, so you can
      check equivalence of the underlying state as well.

  ## v0.2.0.0 (2021-10-09)

  - Updated the signature of `prepropEquivalent` to take a `Proxy r`. This lets
      you bind the `r` type variable, and use it as an argument to
      `arbitraryAction` et al.

  ## v0.1.0.0 (2021-10-08)

  - Released!

  ## Unreleased changes

basic-deps:
  base: '>=4.7 && <5'
  containers: -any
  kind-generics: -any
  polysemy: -any
  QuickCheck: -any
  kind-generics-th: -any
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
author: Sandy Maguire
latest: 0.3.0.0
description-type: markdown
description: |+
  # polysemy-check

  [![Hackage](https://img.shields.io/hackage/v/polysemy-check.svg?logo=haskell&label=polysemy-check)](https://hackage.haskell.org/package/polysemy-check)

  ## Dedication

  > Success is most often achieved by those who don't know that failure is
  > inevitable.
  >
  > --Coco Chanel

  ## Overview

  `polysemy-check` is a little package that integrates
  [`polysemy`](https://hackage.haskell.org/package/polysemy) with
  [`QuickCheck`](https://hackage.haskell.org/package/QuickCheck). It allows you to
  prove the equivalence of effects (see `prepropLaw`), the equivalence of
  interpreters (`prepropEquivalent`), and that two effects don't affect one
  another (`prepropCommutative`). These three things are about the only problems
  you could possibly run into with Polysemy --- and now you won't.

  In addition `polysemy-check` provides lots of machinery to help avoid
  boilerplate, such as free `Arbitrary` instances for effects.


  ## Usage

  `polysemy-check` requires a `Show` and `GenericK` instance for every effect
  you'd like to run tests over.

  ```haskell
  {-# LANGUAGE TemplateHaskell #-}

  import Polysemy
  import Polysemy.Check

  data Stack m a where
    Push :: Int -> Stack m ()
    Pop  :: Stack m (Maybe Int)
    Size :: Stack m Int

  deriving instance Show (Stack m a)
  makeSem ''Stack
  deriveGenericK ''Stack
  ```


  ## Examples

  Check the [test
  suite](https://github.com/polysemy-research/polysemy-check/tree/master/test).

license-name: BSD-3-Clause

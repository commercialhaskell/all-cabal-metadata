homepage: https://github.com/adituv/typenums#readme
changelog-type: markdown
hash: fb2f31ceab9ca7137ceba77dc9eb77b3abca806efee9e5fb48b7aa8eb067b0b8
test-bench-deps:
  base: '>4.9 && <5.0'
  hspec: '>=2.0'
  typenums: -any
  QuickCheck: '>=2.0'
maintainer: aditu.venyhandottir@gmail.com
synopsis: Type level numbers using existing Nat functionality
changelog: |+
  Change log
  ==========

  typenums uses [PVP Versioning][1].
  The change log is available [on GitHub][2].

  0.1.3
  =====
  * Dropped support for GHC 8.2
  * Added support for GHCs 8.8+
  * ([#4](https://github.com/adituv/typenums/issues/4))
    Added more cases for (<=?) type level comparison
  * Fixed incorrect behaviour with (<=?) type level comparison
    * Comparison of two rationals was previously incorrect
  * Added tests for comparison

  0.1.2.1
  =======
  * Fix build failure on GHC 8.6 by adding conditional NoStarIsType langauge
  pragma

  0.1.2
  =====
  * ([#2](https://github.com/adituv/typenums/issues/2))
    Refactored type-level arithmetic so that the type families are exposed from
    an Internal module.

  0.1.1.1
  =======
  * Add UndecidableInstances language extension to Data.TypeNums.Rats.  This
    fixes a compilation error with GHC HEAD.

  0.1.1
  =====
  * ([#1](https://github.com/adituv/typenums/issues/1))
    Added existentially-quantified datatypes SomeInt and SomeRat to handle
    type-level Ints and Rats that are not statically known.  Added functions
    someIntVal and someRatVal to construct these from an Integer/Rational value.

  0.1.0.0
  =======
  * Initial Haddock release
  * Defined type-level integers and rationals
  * Defined polykinded arithmetic over nats, ints and rats
  * Defined polykinded comparison over nats, ints and rats
  * Added Data.TypeLits module

  [1]: https://pvp.haskell.org
  [2]: https://github.com/adituv/typenums/releases

basic-deps:
  base: '>4.9 && <5.0'
all-versions:
- 0.1.3
author: AdituV
latest: 0.1.3
description-type: markdown
description: |
  # typenums

  [![Hackage](https://img.shields.io/hackage/v/typenums.svg)](https://hackage.haskell.org/package/typenums)
  ![example workflow](https://github.com/adituv/typenums/actions/workflows/haskell-ci.yml/badge.svg)
  [![BSD3 license](https://img.shields.io/badge/license-BSD3-blue.svg)](https://github.com/adituv/typenums/blob/master/LICENSE)

  Type level numbers using existing Nat functionality. Uses kind-polymorphic
  typeclasses and type families to facilitate more general code compatible with
  existing code using type-level Naturals.

  ## Usage
  Import either Data.TypeNums or Data.TypeLits instead of GHC.TypeLits.  Some
  definitions conflict with GHC.TypeLits, so if you really must import it, use
  an explicit import list.

  This library is intended to be used in a kind-polymorphic way, such that
  a type-level integer parameter can be written as a natural, and a rational
  can be written as either of the other two.  As an example:

  ```haskell
  {-# LANGUAGE PolyKinds #-}

  data SomeType (n :: k) = SomeType

  useSomeType :: KnownInt n => SomeType n -> _
  useSomeType = -- ...
  ```

  ## Syntax
  * Positive integers are written as natural numbers, as before.  Optionally
    they can also be written as `Pos n`.
  * Negative integers are written as `Neg n`.
  * Ratios are written as `n :% d`, where `n` can be a natural number, `Pos n`,
    or `Neg n`, and `d` is a natural number.

  Addition, subtraction and multiplication at type level are all given as infix
  operators with standard notation, and are compatible with any combination of
  the above types.  Equality and comparison constraints are likewise available
  for any combination of the above types.

  N.B. The equality constraint conflicts with that in Data.Type.Equality.  The
  (==) operator from Data.Type.Equality is re-exported as (==?) from both
  Data.TypeNums and Data.TypeLits.
license-name: BSD-3-Clause

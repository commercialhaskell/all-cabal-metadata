homepage: https://github.com/lykahb/typeable-mock#readme
changelog-type: markdown
hash: f865e7d3b59330d4ba4a6024b9752fe995090fd846981d693b953381d00416e8
test-bench-deps:
  variadic-function: '>=0.1.0.0 && <0.2'
  base: '>=4.7 && <5'
  typeable-mock: -any
  hspec: -any
  containers: -any
  call-stack: '>=0.2.0'
maintainer: lykahb@gmail.com
synopsis: ''
changelog: |
  # Changelog for typeable-mock

  ## 0.1.0.0
  - The first release
basic-deps:
  variadic-function: '>=0.1.0.0 && <0.2'
  base: '>=4.7 && <5'
  containers: -any
  call-stack: '>=0.2.0'
all-versions:
- 0.1.0.0
author: Boris Lykah
latest: 0.1.0.0
description-type: markdown
description: |
  Mock any `Typeable` function or expression anywhere.

  A common approach to mocking in Haskell is with type classes, with instances for the real and test logic. Typeable-mock fills a niche for the projects that do not use granular type classes so much. It lets you mock any `Typeable` expression in context of nearly any monad. It works in a monad of a concrete type or a polymorphic one with class constraints.

  ```haskell
  -- Use mock in application. Here `useMock` is a user-written helper that
  -- is aware of the application context and can look up mocks in there.
  useMock "writeFile" writeFile >>= \f -> liftIO (f path contents)

  -- Declare mock in test.
  writeFileMock <- makeMock "writeFile"
    ((\_ _ -> pure ()) :: FilePath -> String -> IO ())

  -- Check assertions
  assertHasCalls
    [ expectCall "/tmp/1.txt" "Hello world",
      expectCall AnyVal (PredicateVal $ elem "Hello" . words)
    ]
    writeFileMock
  ```

  See the package documentation and [examples/App.hs](https://github.com/lykahb/typeable-mock/blob/master/examples/App.hs) for more.
license-name: BSD-3-Clause

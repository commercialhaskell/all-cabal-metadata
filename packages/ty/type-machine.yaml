all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
author: Arthi-chaud
basic-deps:
  base: '>=4.7 && <5'
  containers: '>=0.7 && <0.9'
  mtl: '>=2.3.1 && <2.4'
  syb: '>=0.7.2 && <0.7.3'
  template-haskell: '>=2.22 && <2.24'
  type-machine: '>=0'
changelog: |
  # Changelog for `type-machine`

  ## 0.1.0.2 - 2025-09-02

  - Add `union`/`intersectionWithSelector`

  ## 0.1.0.1 - 2025-08-11

  - Expose 'Liftable' module
  - Rename 'Infix' module to 'Functions.Infix'
  - Set boundaries on dependencies

  ## 0.1.0.0 - 2025-08-08

  - First release
changelog-type: markdown
description: "# Type Machine\n\nTypeScript offers [*Utility Types*](https://www.typescriptlang.org/docs/handbook/utility-types.html),
  which allows creating a type from another.\nThere is no way of doing this in Haskell.
  You have to maintain all your types yourselves, and handle conversions from one
  to another yourself.\n\n`type-machine` brings a solution to this problem. Using
  Template Haskell, generate new types using Type-Script-inspired functions like `omit`,
  `pick` and `record`.\nIt can also generate a conversion type-class that allows you
  to access fields and convert one type to another.\n\n- Requirements\n    - Requires
  a couple of language extensions (see example)\n    - Input ADT must have exactly
  one record constructor\n- Limitations\n    - Does not support type parameters yet\n
  \   - `require` and `partial` only work with `Maybe` fields \n\n## Examples\n\n```haskell\n{-#
  LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n\ndata User
  = User {\n    id :: Int,\n    name :: String,\n    email :: Maybe String\n}\n\n$(type_
  \"UserWithEmail\" (required [\"email\"] <::> ''User))\n-- data UserWithEmail = UserWithEmail
  {\n--     id :: Int,\n--     name :: String,\n--     email :: String\n-- }\n\n$(type_
  \"UserWithoutId\" (omit [\"id\"] <::> ''User))\n-- data UserWithoutId = UserWithoutId
  {\n--     name :: String,\n--     email :: String\n-- }\n\n$(type_ \"UserId\" (pick
  [\"id\"] <::> ''User))\n-- data UserId = UserId {\n--     id :: Int\n-- }\n\n$(type_
  \"Vector3\" (record [\"x\", \"y\", \"z\"] [t|Int|]))\n-- data Vector3 = Vector3
  {\n--     x :: Int,\n--     y :: Int,\n--     z :: Int\n-- }\n\n-----\n-- Type Parameters\n-----\n\ndata
  MyMaybe a = { content :: Maybe a }\n\n$(type_ \"MyString\" (apply [t|String|] <::>
  ''MyMaybe))\n-- data MyString = MyString { \n--     content :: Maybe String\n--
  }\n\n-----\n-- Is\n-----\n\n$(declareIs ''User)\n-- class IsUser a where\n--     getId
  :: a -> Int\n--     getName :: a -> String\n--     getEmail :: a -> String\n--     setId
  :: Int -> a -> a\n--     setName :: String -> a -> a\n--     setEmail :: String
  -> a -> a\n--\n-- instance IsUser User where\n--     getId = id\n--     getName
  = name\n--     getEmail = email\n--     setId = ...\n--     setName = ...\n--     setEmail
  = ...\n\n$(type_ \"UserWithoutEmail\" (omit [\"email\"] <::> ''User))\n$(deriveIs
  ''User ''UserWithoutEmail)\n-- instance IsUser UserWithoutEmail where\n--     ...\n\n$(type_
  \"UserWithoutId\" (omit [\"id\"] <::> ''User))\n$(deriveIs ''User ''UserWithoutId)
  -- Will fail\n```\n"
description-type: markdown
hash: 9ff5fc9a07a31ed2eafe3efa69c63e10b8731a9eafafe247978a35584fdcef7e
homepage: https://github.com/Arthi-chaud/type-machine#readme
latest: 0.1.0.2
license-name: BSD-3-Clause
maintainer: aj530@kent.ac.uk
synopsis: Type-level functions for record types
test-bench-deps:
  base: '>=4.7 && <5'
  containers: '>=0.7 && <0.9'
  criterion: '>=0'
  extensible: '>=0'
  hspec: '>=0'
  lens: '>=0'
  mtl: '>=2.3.1 && <2.4'
  superrecord: '>=0'
  syb: '>=0.7.2 && <0.7.3'
  template-haskell: '>=2.22 && <2.24'
  type-machine: '>=0'

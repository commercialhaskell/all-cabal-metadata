all-versions:
- 0.1.0.0
author: Arthi-chaud
basic-deps:
  base: '>=4.7 && <5'
  containers: '>=0'
  mtl: '>=0'
  syb: '>=0'
  template-haskell: '>=0'
  type-machine: '>=0'
changelog: |
  # Changelog for `type-machine`

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
  and this project adheres to the
  [Haskell Package Versioning Policy](https://pvp.haskell.org/).

  ## Unreleased

  ## 0.1.0.0 - YYYY-MM-DD
changelog-type: markdown
description: "# Type Machine\n\nTypeScript offers [*Utility Types*](https://www.typescriptlang.org/docs/handbook/utility-types.html),
  which allows creating a type from another.\nThere is no way of doing this in Haskell.
  You have to maintain all your types yourselves, and handle conversions from one
  to another yourself.\n\n`type-machine` brings a solution to this problem. Using
  Template Haskell, generate new types using Type-Script-inspired functions like `omit`,
  `pick` and `record`.\nIt can also generate a conversion type-class that allows you
  to access fields and convert one type to another.\n\n- Requirements\n    - Requires
  a couple of language extensions (see example)\n    - Input ADT must have exactly
  one record constructor\n- Limitations\n    - Does not support type parameters yet\n
  \   - `require` and `partial` only work with `Maybe` fields \n\n## Examples\n\n```haskell\n{-#
  LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE DuplicateRecordFields #-}\n\ndata User
  = User {\n    id :: Int,\n    name :: String,\n    email :: Maybe String\n}\n\n$(type_
  \"UserWithEmail\" (required [\"email\"] <::> ''User))\n-- data UserWithEmail = UserWithEmail
  {\n--     id :: Int,\n--     name :: String,\n--     email :: String\n-- }\n\n$(type_
  \"UserWithoutId\" (omit [\"id\"] <::> ''User))\n-- data UserWithoutId = UserWithoutId
  {\n--     name :: String,\n--     email :: String\n-- }\n\n$(type_ \"UserId\" (pick
  [\"id\"] <::> ''User))\n-- data UserId = UserId {\n--     id :: Int\n-- }\n\n$(type_
  \"Vector3\" (record [\"x\", \"y\", \"z\"] [t|Int|]))\n-- data Vector3 = Vector3
  {\n--     x :: Int,\n--     y :: Int,\n--     z :: Int\n-- }\n\n-----\n-- Type Parameters\n-----\n\ndata
  MyMaybe a = { content :: Maybe a }\n\n$(type_ \"MyString\" (apply [t|String|] <::>
  ''MyMaybe))\n-- data MyString = MyString { \n--     content :: Maybe String\n--
  }\n\n-----\n-- Is\n-----\n\n$(declareIs ''User)\n-- class IsUser a where\n--     getId
  :: a -> Int\n--     getName :: a -> String\n--     getEmail :: a -> String\n--     setId
  :: Int -> a -> a\n--     setName :: String -> a -> a\n--     setEmail :: String
  -> a -> a\n--\n-- instance IsUser User where\n--     getId = id\n--     getName
  = name\n--     getEmail = email\n--     setId = ...\n--     setName = ...\n--     setEmail
  = ...\n\n$(type_ \"UserWithoutEmail\" (omit [\"email\"] <::> ''User))\n$(deriveIs
  ''User ''UserWithoutEmail)\n-- instance IsUser UserWithoutEmail where\n--     ...\n\n$(type_
  \"UserWithoutId\" (omit [\"id\"] <::> ''User))\n$(deriveIs ''User ''UserWithoutId)
  -- Will fail\n```\n"
description-type: markdown
hash: 6ff7b5963618827b42b8853722334dfeeacdc0145cef923bb86ca2f2c43ca640
homepage: https://github.com/Arthi-chaud/type-machine#readme
latest: 0.1.0.0
license-name: BSD-3-Clause
maintainer: aj530@kent.ac.uk
synopsis: Template Haskell-based Type functions on record types in Haskell
test-bench-deps:
  base: '>=4.7 && <5'
  containers: '>=0'
  criterion: '>=0'
  extensible: '>=0'
  hspec: '>=0'
  lens: '>=0'
  mtl: '>=0'
  superrecord: '>=0'
  syb: '>=0'
  template-haskell: '>=0'
  type-machine: '>=0'

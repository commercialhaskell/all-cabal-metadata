homepage: https://github.com/rudymatela/speculate#readme
changelog-type: ''
hash: 345f5dff167532386e55dc994c529d939f712be0cf356ae13a6f6c130bea6d84
test-bench-deps:
  base: ==4.*
  leancheck: -any
  containers: -any
  cmdargs: -any
maintainer: Rudy Matela <rudy@matela.com.br>
synopsis: discovery of properties about Haskell functions
changelog: ''
basic-deps:
  base: ! '>=4 && <5'
  leancheck: ! '>=0.6.1'
  containers: -any
  cmdargs: -any
all-versions:
- '0.2.0'
- '0.2.1'
- '0.2.2'
- '0.2.3'
author: Rudy Matela,  Colin Runciman
latest: '0.2.3'
description-type: markdown
description: ! "Speculate\n=========\n\nSpeculate automatically discovers laws about
  Haskell functions.\nGive Speculate a bunch of Haskell functions and it will discover
  laws like:\n\n  * equations, such as `id x == x`;\n  * inequalities, such as `0
  <= x * x`;\n  * conditional equations, such as `x <= 0  ==>  x + abs x == 0`.\n\nSpeculate
  is similar to, and inspired by, [QuickSpec].\n\n\nCrash Course\n------------\n\nInstall
  pre-requisites:\n\n\t$ cabal install cmdargs\n\t$ cabal install leancheck\n\nClone
  and enter the repository:\n\n\t$ git clone https://github.com/rudymatela/speculate\n\t$
  cd speculate\n\nThere are some examples in the `eg` folter.  For example `eg/plus-abs.hs`:\n\n\t$
  cat eg/plus-abs.hs\n\t...\n\t...\n\nCompile and run with:\n\n\t$ ghc -isrc eg/plus-abs.hs\n\t$
  ./eg/plus-abs\n\t...\n\n\nInstalling Speculate\n--------------------\n\nPre-requisites
  are [cmdargs] and [leancheck].\nYou can install them with:\n\n\t$ cabal install
  cmdargs\n\t$ cabal install leancheck\n\nNo `cabal` package has been made yet.  For
  now, clone the repository with:\n\n\t$ git clone https://github.com/rudymatela/speculate\n\nand
  compile programs that use it with:\n\n\t$ ghc -ipath/to/speculate/src program.hs\n\n\nUsing
  Speculate\n---------------\n\nSpeculate is used as a library: import it, then call
  the function `speculate`\nwith relevant arguments.  The following program Speculates
  about the functions\n`(+)` and `abs`:\n\n\timport Test.Speculate\n\n\tmain :: IO
  ()\n\tmain = speculate args\n\t  { constants =\n\t      [ showConstant (0::Int)\n\t
  \     , showConstant (1::Int)\n\t      , constant \"+\"   ((+)  :: Int -> Int ->
  Int)\n\t      , constant \"abs\" (abs  :: Int -> Int)\n\t      ]\n\t  }\n\nwhen
  run, it prints the following:\n\n\t_ :: Int  (holes: Int)\n\t0 :: Int\n\t1 :: Int\n\t(+)
  :: Int -> Int -> Int\n\tabs :: Int -> Int\n\n\t    abs (abs x) == abs x\n\t          x
  + 0 == x\n\t          x + y == y + x\n\t    (x + y) + z == x + (y + z)\n\tabs (x
  + abs x) == x + abs x\n\t  abs x + abs x == abs (x + x)\n\tabs (1 + abs x) == 1
  + abs x\n\n\tx <= abs x\n\t0 <= abs x\n\tx <= x + 1\n\n\nNow, if we add `<=` and
  `<` as background constants on `args`\n\n\t  , constants =\n\t      [ showConstant
  (0::Int)\n\t      , showConstant (1::Int)\n\t      , constant \"+\"   ((+)  :: Int
  -> Int -> Int)\n\t      , constant \"abs\" (abs  :: Int -> Int)\n\t      , background\n\t
  \     , constant \"<=\"  ((<=) :: Int -> Int -> Bool)\n\t      , constant \"<\"
  \  ((<)  :: Int -> Int -> Bool)\n\t      ]\n\nthen run again, we get the following
  as well:\n\n\t    y <= x ==> abs (x + abs y) == x + abs y\n\t    x <= 0 ==>       x
  + abs x == 0\n\tabs x <= y ==>     abs (x + y) == x + y\n\tabs y <= x ==>     abs
  (x + y) == x + y\n\nFor more examples, see the [eg](eg) folder.\n\n\nSimilarities
  and Differences to QuickSpec\n-----------------------------------------\n\nSpeculate
  is inspired by [QuickSpec].\nLike QuickSpec, Speculate uses testing to speculate
  equational laws about given\nHaskell functions.  There are some differences:\n\n|
  \                  | Speculate                 | QuickSpec                         |\n|
  ----------------: | ------------------------- | ---------------------------------
  |\n| testing           | enumerative ([LeanCheck]) | random ([QuickCheck])             |\n|
  equational laws   | yes (after completion)    | yes (as discovered)               |\n|
  inequational laws | yes                       | no                                |\n|
  conditional laws  | yes                       | restricted to a set of predicates
  |\n| polymorphism      | no                        | yes                               |\n|
  performance       | slower                    | faster                            |\n\nFor
  most examples, Speculate runs slower than QuickSpec 2 but faster than QuickSpec
  1.\n\n\nMore documentation\n------------------\n\nFor more examples, see the [eg](eg)
  and [bench](bench) folders.\n\n[leancheck]: https://hackage.haskell.org/package/leancheck\n[LeanCheck]:
  https://hackage.haskell.org/package/leancheck\n[QuickSpec]: https://github.com/nick8325/quickspec\n[QuickCheck]:
  https://hackage.haskell.org/package/QuickCheck\n[cmdargs]: https://hackage.haskell.org/package/cmdargs\n"
license-name: BSD3

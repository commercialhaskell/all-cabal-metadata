homepage: https://github.com/msakai/numeric-optimization#readme
changelog-type: markdown
hash: 7a3634af564629ce1465c4182dcd4c656da1cb1179e8abe64c642ab0947f457e
test-bench-deps:
  base: '>=4.12 && <5'
  data-default-class: '>=0.1.2.0 && <0.2'
  hspec: '>=2.7.1 && <3.0'
  HUnit: '>=1.6.0.0 && <1.7'
  containers: '>=0.6.0.1 && <0.7'
  numeric-optimization: -any
  vector: '>=0.12.0.2 && <0.14'
maintainer: masahiro.sakai@gmail.com
synopsis: Unified interface to various numerical optimization algorithms
changelog: |
  # Changelog for `numeric-optimization`

  All notable changes to this project will be documented in this file.

  The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
  and this project adheres to the
  [Haskell Package Versioning Policy](https://pvp.haskell.org/).

  ## Unreleased

  ## 0.1.0.0 - YYYY-MM-DD
basic-deps:
  base: '>=4.12 && <5'
  data-default-class: '>=0.1.2.0 && <0.2'
  constraints: -any
  lbfgs: ==0.1.*
  numeric-optimization: -any
  hmatrix: '>=0.20.0.0'
  primitive: '>=0.6.4.0'
  vector: '>=0.12.0.2 && <0.14'
all-versions:
- 0.1.0.0
author: Masahiro Sakai
latest: 0.1.0.0
description-type: markdown
description: |
  # numeric-optimization

  Unified interface to various numerical optimization algorithms.

  Note that the package name is numeric-optimization and not numeri**cal**-optimization.
  The name `numeric-optimization` comes from the module name `Numeric.Optimization`.


  ## Example Usage

  ```haskell
  {-# LANGUAGE OverloadedLists #-}
  import Data.Vector.Storable (Vector)
  import Numeric.Optimization

  main :: IO ()
  main = do
    result <- minimize LBFGS def (WithGrad rosenbrock rosenbrock') [-3,-4]
    print (resultSuccess result)  -- True
    print (resultSolution result)  -- [0.999999999009131,0.9999999981094296]
    print (resultValue result)  -- 1.8129771632403013e-18

  -- https://en.wikipedia.org/wiki/Rosenbrock_function
  rosenbrock :: Vector Double -> Double
  rosenbrock [x,y] = sq (1 - x) + 100 * sq (y - sq x)

  rosenbrock' :: Vector Double -> Vector Double
  rosenbrock' [x,y] =
    [ 2 * (1 - x) * (-1) + 100 * 2 * (y - sq x) * (-2) * x
    , 100 * 2 * (y - sq x)
    ]

  sq :: Floating a => a -> a
  sq x = x ** 2
  ```

  ## Supported Algorithms

  |Algorithm|Solver implemention|Haskell binding| |
  |---------|-------------------|---------------|-|
  |CG\_DESCENT|[CG_DESCENT-C](https://www.math.lsu.edu/~hozhang/SoftArchive/CG_DESCENT-C-3.0.tar.gz)|[nonlinear-optimization](https://hackage.haskell.org/package/nonlinear-optimization)|Requires `with-cg-descent` flag|
  |Limited memory BFGS (L-BFGS)|[liblbfgs](https://github.com/chokkan/liblbfgs)|[lbfgs](https://hackage.haskell.org/package/lbfgs)|
  |Newton's method|Pure Haskell implementation using [HMatrix](https://hackage.haskell.org/package/hmatrix)|-|


  ## Related Packages

  * Packages for using with automatic differentiation:
    * [numerical-optimization-ad](https://hackage.haskell.org/package/numerical-optimization-ad) for using with [ad](https://hackage.haskell.org/package/ad) package
    * [numerical-optimization-backprop](https://hackage.haskell.org/package/numerical-optimization-backprop) for using with [backprop](https://hackage.haskell.org/package/backprop) package
  * [MIP](https://hackage.haskell.org/package/MIP) for solving linear programming and mixed-integer linear programming problems

  ## LICENSE

  The code in thie packaged is licensed under [BSD-3-Clause](LIENSE).

  If you enable `with-cg-descent` flag, it uses GPL-licensed packages and the resulting binary should be distributed under GPL.
license-name: BSD-3-Clause

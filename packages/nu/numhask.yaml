all-versions:
- 0.0.1
- 0.0.2
- 0.0.3
- 0.0.4
- 0.0.5
- 0.0.6
- 0.0.7
- 0.0.8
- 0.0.9
- 0.1.0
- 0.1.1
- 0.1.2
- 0.1.3
- 0.1.4.0
- 0.2.0.0
- 0.2.1.0
- 0.2.2.0
- 0.2.3.0
- 0.2.3.1
- 0.3.0.0
- 0.3.1
- 0.4.0
- 0.5.0
- 0.6.0
- 0.6.0.1
- 0.6.0.2
- 0.7.0.0
- 0.7.1.0
- 0.8.0.0
- 0.8.1.0
- 0.9.0.0
- 0.10.0.0
- 0.10.1.0
- 0.10.1.1
- 0.11.0.1
- 0.11.0.2
- 0.11.1.0
- 0.12.0.0
- 0.12.0.1
- 0.12.0.2
author: Tony Day
basic-deps:
  QuickCheck: '>=2.14 && <2.15'
  base: '>=4.7 && <5'
changelog: "0.12\n===\n\n- added SemiField, and bumped QuotientField to default for
  Subtraction.\n\n- moved infinity & nqn to SemiField, from Field.\n\n- introduced
  NumHask.Data.Positive\n\n- introduced NumHask.Data.Wrapped\n\n- Monus & Addus\n\n-
  hiding Prelude.Rational\n\n0.11.1.0\n===\n* Added Sum (..)\n* Added Product (..)\n\n0.11.0.0\n===\n\n*
  TypeFamilies introduced replacing FunDep usage for QuotientField, AdditiveAction,
  MultiplicativeAction, Basis. Classes go from Multi-parameter to single.\n* EuclideanPair
  introduced as an intended DerivingVia support for 2 dimensional Basis & Direction
  instances. \n* Complex modified to use EuclideanPair. Underlying representation
  changed to tuple and (+:) constructor as a top-level function.\n* Action class operators
  changed from (.\\*) to (|\\*), and (\\*.) to (\\*|) etc.\n* Ring, Field, Distributive
  & Module become type synonyms (were classes).\n* Added Basis class replacing Norm
  & Signed\n* extra type synonyms added for Basis specialisations: Absolute, Sign,
  EndoBased.\n* abs becomes top-level function (previously method of Norm).\n* sign
  removed and replaced with signum, mirroring Num.\n* aboutEqual & nearZero moved
  outside Epsilon class definition.\n* rationalised Language pragmas around GHC2021\n*
  introduced QuotientField instance for Complex & EuclideanPair without Ord constraint.\n\n0.10.0\n===\n*
  Moved operators back in.\n* added doctests and properties\n* added accsum & accproduct\n*
  fixed Ratio Eq instance\n\n0.9.0\n===\n* Removed bounded classes.\n* Moved operators
  outside of class definitions where possible. \n\n0.8.0\n=====\n\n* GHC 9.0.1 support\n*
  Removed protolude and replaced it with prelude\n* Removed NumHask.Data.Positive,
  NumHask.Data.LogFloat, NumHask.Data.Wrapper\n* modified project build to cabal\n*
  removed NegativeLiterals recommendation.\n\n0.7.0\n=====\n\n* GHC 8.10.2 support\n*
  Modules `NumHask.Algebra.Abstract.*` renamed to `NumHask.Algebra.*`\n* Renamed `Normed`
  to `Norm` and added `basis`\n* Removed `Metric` and added `distance`\n* Added `Direction`,
  `Polar`, `polar`, `coord`; streamlined `Complex`\n* Removed `NumHask.Data.Pair`\n*
  Fixed `FromIntegral` and `FromRational` to work in well with rebindable syntax.\n*
  Added fundeps to `Norm`, `Direction`\n* Integrated `NumHask.Algebra.Action` into
  `NumHask.Algebra.Module`\n* Added `atan2`\n* Added doctests and laws\n* Improved
  haddocks\n* Made (^) a monomorphic `a -> Int -> a` and accept negative Ints\n\n\n0.6.0\n=====\n\n*
  GHC 8.10.1 support\n"
changelog-type: markdown
description: |+
  numhask
  ===

  [![Hackage](https://img.shields.io/hackage/v/numhask.svg)](https://hackage.haskell.org/package/numhask)
  [![Build Status](https://github.com/tonyday567/numhask/workflows/haskell-ci/badge.svg)](https://github.com/tonyday567/numhask/actions?query=workflow%3Ahaskell-ci)

  ![](other/nh12.svg)

  Usage
  ===

  ``` haskell
  {-# LANGUAGE RebindableSyntax #-}
  import NumHask.Prelude
  ```
  See the documentation in the NumHask module for a detailed overview.

  v0.12 notes
  ===

  SemiField
  ---

  Compared to previous library versions, Ring and Field have been removed as super classes of QuotientField, and SemiField introduced as the new constraint.

  Old version:

  ![](other/nh11.svg)

  ```
  type SemiField a = (Distributive a, Divisive a)

  class (SemiField a) => QuotientField a where
    type Whole a :: Type
    properFraction :: a -> (Whole a, a)
  ```

  The notion of a quotient is now that which distributes and divides.

  Subtractive originally slipped in as a super class due to the notion of rounding down (or, specifically, towards zero). By using DefaultSignatures, a default for Subtractive-type numbers can be provided and still allow non-Subtractive (SemiField) things to be quotient fields.

  Infinity and nan move from a Field to a SemiField constraint - subtraction is not needed to come up with an infinity or silly compute.

  Positive
  ---

  A motivation for SemiField was to introduce NumHask.Data.Positive into the library. Positive has no sane Subtractive instance (but should be able to be rounded).

  Out of the many approaches that can be taken in defining a positive number, the definition relies on a notion of truncated subtraction; that subtraction can be performed on positive numbers but, for answers outside the typed range, the lower bound should be returned.

  Specifically, the positive constructor needs to be supplied with a number that has a MeetSemiLattice instance, so that complex numbers and other geometries are correctly handled:

  ``` haskell
  ghci> 2 +: (-2)
  Complex {complexPair = (2,-2)}
  ghci> positive (2 +: (-2))
  UnsafePositive {unPositive = Complex {complexPair = (2,0)}}
  ```

  Truncated Arithmetic
  ---

  Truncated subtraction can be generalised to a notion of truncated arithmetic on a number with a typed range. This may be a direction explored further in the library including:

  - [epsilon, +infinity): A positive number type which is a safe divisor.
  - /= zero, non-zero arithmetic (x - x returns epsilon, say)
  - [0,1]: probability and weight arithmetic
  - [-1,1]: correlation math

  magnitudes are positive
  ---

  The current Basis instance of Double:

  ``` haskell
  instance Basis Double where
    type Mag Double = Double
    type Base Double = Double
    magnitude = P.abs
    basis = P.signum
  ```

  is probably more correctly written as:

  ``` haskell
  instance Basis Double where
    type Mag Double = Positive Double
    type Base Double = Sign Double
    magnitude = Positive . P.abs
    basis = Sign . P.signum
  ```

  where Sign is a future-imagined type representing {-1,0,1} or {-1,1}

  In Haskell, there is a basic choice between using multiple parameters for a type or embedding types using type families. Using multiple parameters would, in practice, force users to have to chose and write 'Basis Double Double Double' or 'Basis Positive Sign Double'.

  On balance, a computational chain involving magnitude is likely to be a single, underlying type, so that providing a Basis instance returning a Positive would result in a lot of unwrapping.

  ``` haskell
  -- endo-based
  x == basis x * magnitude x

  -- if hetero-typed ...
  x == (unSign $ basis x) * (unPositive $ magnitude x)
  ```

  The library awaits real-world feedback on safety versus ergonomics.

  Monus
  ---

  Truncated subtraction is encapsulated within the Monus class and supplied operator:

  ``` haskell
  ghci> 4 ∸ 7 :: Positive Int
  UnsafePositive {unPositive = 0}
  ghci> unPositive (4 ∸ 7 :: Positive Int)
  0
  ghci> unPositive (7 ∸ 4 :: Positive Int)
  3
  ```

  NumHask.Data.Wrapped
  ---

  The introduction of Positive provoked including a wrapper type for most numhask types. This type can be used with derivingvia:

  ``` haskell
  newtype Positive a = UnsafePositive {unPositive :: a}
    deriving stock
      (Eq, Ord, Show)
    deriving
      ( Additive,
        Multiplicative,
        Divisive,
        Integral,
        FromInteger,
        FromRational,
        Basis,
        Direction,
        Epsilon,
        AdditiveAction,
        SubtractiveAction,
        MultiplicativeAction,
        DivisiveAction,
        JoinSemiLattice,
        MeetSemiLattice,
        BoundedMeetSemiLattice
      )
      via (Wrapped a)
  ```

description-type: markdown
hash: d5b9e17dab81433f3b0a46a16c7d42b63289fa51be2d9cabfe95e4e9e4317ba0
homepage: https://github.com/tonyday567/numhask#readme
latest: 0.12.0.2
license-name: BSD-3-Clause
maintainer: tonyday567@gmail.com
synopsis: A numeric class hierarchy.
test-bench-deps: {}

all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.2.2.0
- 0.2.3.0
- 0.2.3.1
- 0.2.3.2
- 0.3.0.0
- 0.3.0.1
- 0.4.0.0
- 0.5.0.0
- 0.5.0.1
- 0.6.0.1
- 0.7.0.1
- 0.7.0.2
- 0.7.0.3
- 0.7.0.5
- 0.7.0.6
- 0.7.0.7
- 0.8.0.2
- 0.8.10.1
- 0.8.10.2
- 0.8.10.7
- 0.9.0.2.1
- 0.9.2.5
- 0.9.4.7
- 0.9.6.3
- 0.9.6.3.1
- 0.9.6.3.2
- 0.9.6.3.3
- 0.9.6.3.4
author: Ranjit Jhala, Niki Vazou, Eric Seidel
basic-deps:
  aeson: '>=0'
  ansi-terminal: '>=0'
  array: '>=0'
  ascii-progress: '>=0.3'
  async: '>=0'
  attoparsec: '>=0'
  base: '>=4.9.1.0 && <5'
  binary: '>=0'
  boxes: '>=0'
  bytestring: '>=0.10.2.1'
  cereal: '>=0'
  cmdargs: '>=0'
  containers: '>=0'
  deepseq: '>=0'
  directory: '>=0'
  fgl: '>=0'
  filepath: '>=0'
  gitrev: '>=1.3.1'
  hashable: '>=0'
  intern: '>=0'
  lens-family: '>=0'
  liquid-fixpoint: '>=0'
  megaparsec: '>=7.0.0 && <10'
  mtl: '>=0'
  parser-combinators: '>=0'
  pretty: '>=1.1.3.1'
  process: '>=0'
  rest-rewrite: '>=0.3.0'
  smtlib-backends: '>=0.3'
  smtlib-backends-process: '>=0.3'
  stm: '>=0'
  store: '>=0'
  syb: '>=0'
  text: '>=0'
  transformers: '>=0'
  unordered-containers: '>=0'
  vector: <0.14
changelog: |
  # CHANGES

  ## NEXT

  ## 0.9.6.3.4 (2026-01-14)

  - Implement `--sortedsolution` to keep elaborated sorts in fqout/solution [#821](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/821)
  - Retire old parser for horn queries [#820](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/820)
  - Stop the parser from simplifying expressions during parsing [#819](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/819)
  - Add `--explicitKvars` option and generalize horn syntax to accept expressions for kvars arguments [#818](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/818)
  - Provide more comments in the SMT queries to relate them to the source code [#814](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/814)
  - Remove `--no-lazy-ple` [#813](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/813)
  - Allow PLE to unfold in kvar solutions  [#811](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/811)
  - Remove redundant question marks from expression [#807](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/807)
  - Remove distinction of predicates and expressions in the parser [#805](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/805)
  - Shrink kvar solutions [#799](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/799) [#809](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/809) [#821](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/821)
  - Disable the progress bar when not on a terminal [#798](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/798)
  - Retire existential binds [#797](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/797)
  - Provide stack traces for more crashes [#794](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/794)
  - Support string operators [#793](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/793)
  - Apply kvar solutions to constraints before PLE [#792](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/792)
  - Retire implementation of gradual refinement types [#789](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/789)
  - Retire old PLE variations [#788](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/788)
  - Add set cardinality support when using cvc5 [#774](https:://github.com/ucsd-progsys/liquid-fixpoint/pull/774)
  - Have `--scrape` consider global constants and ADTs [#772](https://github.com/ucsd-progsys/liquid-fixpoint/pull/772)
  - Shorten flags of a few flags and add git-version [#762](https://github.com/ucsd-progsys/liquid-fixpoint/pull/762)
  - Add support/conversions for Bitv8 and Bitv16 [#759](https://github.com/ucsd-progsys/liquid-fixpoint/pull/759)
  - Support the finite field theory of CVC5 [#755](https://github.com/ucsd-progsys/liquid-fixpoint/pull/755)
  - Fix SMT crashes on reflected functions on polymorphic data types [#753](https://github.com/ucsd-progsys/liquid-fixpoint/pull/753)
  - Allow function names to start with prefix mod [#751](https://github.com/ucsd-progsys/liquid-fixpoint/pull/751)
  - Implement let bindings for Horn queries [#748](https://github.com/ucsd-progsys/liquid-fixpoint/pull/748)
  - Fix elaboration of `define_fun` declarations [#747](https://github.com/ucsd-progsys/liquid-fixpoint/pull/747) [#749](https://github.com/ucsd-progsys/liquid-fixpoint/pull/749)

  ## 0.9.6.3.3 (2025-03-22)

  - Add support for GHC HEAD (9.13) [#745](https://github.com/ucsd-progsys/liquid-fixpoint/pull/745).
  - Expose SMTLIB define-fun to users of liquid-fixpoint [#744](https://github.com/ucsd-progsys/liquid-fixpoint/pull/744).
  - Check that expressions in refinements are Bool-sorted [#743](https://github.com/ucsd-progsys/liquid-fixpoint/pull/743).
  - Fix crashes when a datatype is declared with a `Map_t` field [#738](https://github.com/ucsd-progsys/liquid-fixpoint/issues/738).
  - Simplify expressions in fqout files [#741](https://github.com/ucsd-progsys/liquid-fixpoint/pull/741).

  ## 0.9.6.3.2 (2025-03-06)

  - Expose relatedSymbols from EnvironmentReduction. Needed for improving error
    messages in LH
    [#2346](https://github.com/ucsd-progsys/liquidhaskell/issues/2346).
  - Support extensionality in PLE [#704](https://github.com/ucsd-progsys/liquid-fixpoint/pull/704)
  - Add a new flag `--etabeta` to reason with lambdas in PLE [#705](https://github.com/ucsd-progsys/liquid-fixpoint/pull/705)
  - Add support for reflected lambdas in PLE [#725](https://github.com/ucsd-progsys/liquid-fixpoint/pull/725)
  - Implement Bags and Maps reasoning with Arrays [#703](https://github.com/ucsd-progsys/liquid-fixpoint/pull/703)
  - Support conditional elaboration of theories for cvc5 [#734](https://github.com/ucsd-progsys/liquid-fixpoint/pull/734)
  - Generate smt2 files only when using `--save` [#712](https://github.com/ucsd-progsys/liquid-fixpoint/pull/712)
  - Parameterize Expr and Reft by the variable type [#708](https://github.com/ucsd-progsys/liquid-fixpoint/pull/721)
  - Preserve location of operators in the parser [#721](https://github.com/ucsd-progsys/liquid-fixpoint/pull/721)
  - Optimize elaboration [#736](https://github.com/ucsd-progsys/liquid-fixpoint/pull/736)

  ## 0.9.6.3.1 (2024-08-21)

  - Added support for ghc-9.10.1
  - Use `;` for comments in SMTParse (as done in SMTLIB) [#700](https://github.com/ucsd-progsys/liquid-fixpoint/pull/700).
  - Extend SMTParser to support lits e.g. for bitvec [#698](https://github.com/ucsd-progsys/liquid-fixpoint/pull/698).
  - refactor `Set->Array` elaboration [#696](https://github.com/ucsd-progsys/liquid-fixpoint/pull/696).
  - Fixed the polymorphism-related crash caused by a restrictive Set theory encoding [#688](https://github.com/ucsd-progsys/liquid-fixpoint/pull/688).
  - Do not constant-fold div by zero [#686](https://github.com/ucsd-progsys/liquid-fixpoint/issue/686).
  - Copy over the HOF configuraration options in hornFInfo [#684](https://github.com/ucsd-progsys/liquid-fixpoint/pull/684).
  - Use SMTLIB style serialization/deserialization for Horn queries [#683](https://github.com/ucsd-progsys/liquid-fixpoint/pull/683).
  - Print SMT preamble to the logfile when constructing context [#681](https://github.com/ucsd-progsys/liquid-fixpoint/pull/681).
  - Allow reading/saving horn queries from/to JSON [#680](https://github.com/ucsd-progsys/liquid-fixpoint/pull/680).
  - Extend parser to allow boolean function arguments [#678](https://github.com/ucsd-progsys/liquid-fixpoint/pull/678).

  ## 0.9.6.3 (2024-01-29)

  - For now we stopped folding constants that contain NaN [#670](https://github.com/ucsd-progsys/liquid-fixpoint/pull/670)

  ## 0.9.4.7

  - Support GHC 9.6 tuples with `--extensionality` [#666](https://github.com/ucsd-progsys/liquid-fixpoint/issues/641) [#667](https://github.com/ucsd-progsys/liquid-fixpoint/issues/641)

  ## 0.9.2.5

  - Adopt smtlib-backends for interactions with the SMT solvers [#641](https://github.com/ucsd-progsys/liquid-fixpoint/issues/641)

  ## 0.9.0.2

  - Simplified the equalities dumped by PLE [#569](https://github.com/ucsd-progsys/liquid-fixpoint/issues/569) [#605](https://github.com/ucsd-progsys/liquid-fixpoint/issues/605)
  - Add PLE implementation based on interpreting expressions [#502](https://github.com/ucsd-progsys/liquid-fixpoint/pull/502)

  ## 0.8.10.2

  - Dump equalities discovered by PLE [#491](https://github.com/ucsd-progsys/liquid-fixpoint/pull/491) [#569](https://github.com/ucsd-progsys/liquid-fixpoint/issues/569)
  - Dump prettified version of constraints [#473](https://github.com/ucsd-progsys/liquid-fixpoint/pull/473)
  - Constraints now indicate the source code location that originated them [#471](https://github.com/ucsd-progsys/liquid-fixpoint/pull/471)
  - Add support for term rewriting to PLE [#428](https://github.com/ucsd-progsys/liquid-fixpoint/pull/428)

  ## 0.8.6.4

  - Fix bugs in PLE
  - Move to GHC 8.6.4
  - Add `fuel` parameter to debug unfolding in PLE

  ## 0.8.0.1

  - Support for HORN-NNF format clauses, see `tests/horn/{pos,neg}/*.smt2`
  - Support for "existential binders", see `tests/pos/ebind-*.fq` for example.
    This only works with `--eliminate`.
  - Move to GHC 8.4.3

  ## 0.7.0.0

  - New `eliminate` based solver (see ICFP 2017 paper for algorithm)
  - Proof by Logical Evaluation see `tests/proof`
  - SMTLIB2 ADTs to make data constructors injective
  - Uniformly support polymorphic functions via `apply` and elaborate

  ## 0.3.0.0

  - Make interpreted mul and div the default, when `solver = z3`
  - Use `higherorder` flag to allow higher order binders into the environment

  ## 0.2.2.0

  - Added support for theory of Arrays `Map_t`, `Map_select`, `Map_store`

  - Added support for theory of Bitvectors -- see `Language.Fixpoint.Smt.Bitvector`

  - Added support for string literals

  ## 0.2.1.0

  - Pre-compiled binaries of the underlying ocaml solver are now
    provided for Linux, Mac OSX, and Windows.

    No more need to install Ocaml!

  ## 0.2.0.0

  - Parsing has been improved to require *much* fewer parentheses.

  - Experimental support for Z3's theory of real numbers with the `--real` flag.
changelog-type: markdown
description: |
  Liquid Fixpoint
  ===============


  [![Hackage](https://img.shields.io/hackage/v/liquid-fixpoint.svg)](https://hackage.haskell.org/package/liquid-fixpoint) [![Hackage-Deps](https://img.shields.io/hackage-deps/v/liquid-fixpoint.svg)](http://packdeps.haskellers.com/feed?needle=liquid-fixpoint)
  [![CircleCI](https://circleci.com/gh/ucsd-progsys/liquid-fixpoint.svg?style=svg)](https://circleci.com/gh/ucsd-progsys/liquid-fixpoint)
  [![hlint](https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/hlint.yml/badge.svg)](https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/hlint.yml)
  [![cabal](https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/cabal.yml/badge.svg)](https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/cabal.yml)
  [![stack](https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/stack.yml/badge.svg)](https://github.com/ucsd-progsys/liquid-fixpoint/actions/workflows/stack.yml)


  This package implements a Horn-Clause/Logical Implication constraint solver used
  for various Liquid Types. The solver uses SMTLIB2 to implement an algorithm similar to:

  + [Houdini](https://users.soe.ucsc.edu/~cormac/papers/fme01.pdf)
  + [Cartesian predicate abstraction](http://swt.informatik.uni-freiburg.de/berit/papers/boolean-and-cartesian-....pdf)

  Algorithms implemented in liquid-fixpoint:

  + [FUSION](https://ranjitjhala.github.io/static/local_refinement_typing.pdf) Local refinement typing
  + [PLE](https://ranjitjhala.github.io/static/refinement_reflection.pdf) Refinement Reflection: Complete Verification with SMT
  + [REST](https://drops.dagstuhl.de/entities/document/10.4230/DARTS.8.2.12) REST: Integrating Term Rewriting with Program Verification


  Requirements
  ------------

  In addition to the .cabal dependencies you require an SMTLIB2 compatible solver binary:

  - [Z3](https://github.com/Z3Prover/z3)
  - [CVC4](https://cvc4.github.io/)
  - [CVC5](https://cvc5.github.io/)
  - [MathSat](http://mathsat.fbk.eu/download.html)

  If on Windows, please make sure to place the binary and any associated DLLs somewhere
  in your path.

  How To Build and Install
  ------------------------

  ```
  $ git clone https://github.com/ucsd-progsys/liquid-fixpoint.git
  $ cd liquid-fixpoint
  $ stack install # alternatively, use `cabal install`.
  ```

  Test with

  ```
  $ stack test
  ```

  Run with

  ```
  $ stack exec fixpoint -- tests/pos/adt.fq
  ```

  Using SMTLIB-based SMT Solvers
  ------------------------------

  You can use one of several SMTLIB2 compliant solvers, by:

      fixpoint --solver=z3 path/to/file.hs

  Currently, we support

      * Z3
      * CVC4
      * CVC5
      * MathSat

  "Horn" Format
  -------------

  See the examples in `tests/horn/{pos, neg}` eg

  - [sum](tests/horn/pos/ple_sum.smt2)
  - [list00](tests/horn/pos/ple_list00.smt2)
  - [list03](tests/horn/neg/ple_list03.smt2)

  For how to write VCs "by hand".

  See [this tutorial](https://arxiv.org/abs/2010.07763)
  with [accompanying code](https://github.com/ranjitjhala/sprite-lang)
  for an example of how to generate Horn queries.

  The main datatypes are described in [src/Language/Fixpoint/Horn/Types.hs](src/Language/Fixpoint/Horn/Types.hs)


  Configuration Management
  ------------------------

  It is very important that the version of Liquid Fixpoint be maintained properly.

  Suppose that the current version of Liquid Haskell is `A.B.C.D`:

  + After a release to hackage is made, if any of the components `B`, `C`, or `D` are missing, they shall be added and set to `0`. Then the `D` component of Liquid Fixpoint shall be incremented by `1`. The version of Liquid Fixpoint is now `A.B.C.(D + 1)`

  + The first time a new function or type is exported from Liquid Fixpoint, if any of the components `B`, or `C` are missing, they shall be added and set to `0`. Then the `C` component shall be incremented by `1`, and the `D` component shall stripped. The version of Liquid Fixpoint is now `A.B.(C + 1)`

  + The first time the signature of an exported function or type is changed, or an exported function or type is removed (this includes functions or types that Liquid Fixpoint re-exports from its own dependencies), if the `B` component is missing, it shall be added and set to `0`. Then the `B` component shall be incremented by `1`, and the `C` and `D` components shall be stripped. The version of Liquid Fixpoint is now `A.(B + 1)`

  + The `A` component shall be updated at the sole discretion of the project owners.

  It is recommended to use the [Bumper](https://hackage.haskell.org/package/bumper) utility to manage the versioning of Liquid Fixpoint. Bumper will automatically do the correct update to the cabal file. Additionally, it will update any packages that you have the source for that depend on Liquid Fixpoint.

  To update Liquid Fixpoint and Liquid Haskell, first clone Liquid Haskell and Liquid Fixpoint to a common location:

  ```
  git clone https://github.com/ucsd-progsys/liquidhaskell.git
  git clone https://github.com/ucsd-progsys/liquid-fixpoint.git
  ```

  To increment the `D` component of Liquid Fixpoint:

  ```
  ./path/to/bumper -3 liquid-fixpoint
  ```

  This will update the `D` component of Liquid Fixpoint. If necessary, this will update the `Build-Depends` of Liquid Haskell. If the `Build-Depends` was updated, Liquid Haskell's `D` component will be incremented.

  To increment the `C` component of Liquid Fixpoint, and strip the `D` component:

  ```
  ./path/to/bumper --minor liquid-fixpoint
  ```

  As before, this will update Liquid Fixpoint and, if necessary, Liquid Haskell.

  To increment the `B` component of Liquid Fixpoint, and strip the `D` and `C` components:

  ```
  ./path/to/bumper --major liquid-fixpoint
  ```

  As before, this will update Liquid Fixpoint and, if necessary, Liquid Haskell

  ## SMTLIB2 Interface

  There is a new SMTLIB2 interface directly from Haskell:

  + Language.Fixpoint.SmtLib2

  See `tests/smt2/{Smt.hs, foo.smt2}` for an example of how to use it.

  ### Command Line for SMT2 interface

  You can use the `.smt2` interface from the command-line as follows:

  Use `--stdin` to read files from `stdin`

  ```
  $ more tests/horn/pos/test01.smt2 | fixpoint --stdin

  Liquid-Fixpoint Copyright 2009-25 Regents of the University of California.
  All Rights Reserved.

  Working 166% [===============================================================]
  Safe ( 2  constraints checked)
  ```

  Use `-q` to disable all output (banner, progress bar etc.)

  ```
  $ more tests/horn/pos/test01.smt2 | fixpoint -q --stdin
  ```

  Use `--json` to get the output as a JSON object (rendered to `stdout`)

  ```
  $ more tests/horn/pos/abs02-re.smt2 | stack exec -- fixpoint -q --json --stdin
  {"contents":{"numIter":3,"numCstr":3,"numChck":3,"numBrkt":3,"numVald":3},"tag":"Safe"}
  ```


  ## Options

  `--higherorder` allows higher order binders into the environment

  `--extsolver` runs the **deprecated** external solver.

  `--parts` Partitions an `FInfo` into a `[FInfo]` and emits a bunch of files. So:

      $ fixpoint -n -p path/to/foo.fq

  will now emit files:

      path/to/.liquid/foo.1.fq
      path/to/.liquid/foo.2.fq
      . . .
      path/to/.liquid/foo.k.fq

  and also a dot file with the constraint dependency graph:

      path/to/.liquid/foo.fq.dot


  ## FInfo Invariants

  ### Binders

  This is the field

  ```
       , bs       :: !BindEnv         -- ^ Bind  |-> (Symbol, SortedReft)
  ```

  or in the .fq files as

  ```
  bind 1 x : ...
  bind 2 y : ...
  ```

  * Each `BindId` must be a distinct `Int`,
  * Each `BindId` that appears in a constraint
    environment i.e. inside _any_ `IBindEnv`
    must appear inside the `bs`

  ### Environments

  * Each constraint's environment is a set of `BindId`
    which must be defined in the `bindInfo`. Furthermore

  * Each constraint should not have _duplicate_ names in its
    environment, that is if you have two binders

  ```
    bind 1 x : ...
    bind 12 x : ...
  ```

    Then a single `IBindEnv` should only mention _at most_
    one of `1` or `12`.

  * [NOTE:TREE-LIKE] There is also a "tree-shape" property required by PLE:

  ```
    forall constraints c, c'.
      if i in c and i in c' then
        forall 0 <= j < i, j in c and j in c'
  ```

  ### LHS

  Each `slhs` of a constraint is a `SortedReft`.

  - Each `SortredReft` is basically a `Reft` -- a logical predicate.
    The important bit is that a `KVar` i.e. terms of the form

  ```
       $k1[x1:=y1][x2:=y2]...[xn:=yn]
  ```

    That is represented in the `Expr` type as

  ```
    | PKVar  !KVar !Subst
  ```

    must appear _only_ at the **top-level** that is not under _any_
    other operators, i.e. not as a sub-`Expr` of other expressions.


  - This is basically a predicate that needs to be "well sorted"
    with respect to the `BindId`, intuitively

  ```
      x:int, y:int |- x + y : int
  ```

    is well sorted. but

  ```
      x:int  |- x + y : int
  ```

    is not, and

  ```
      x:int, y: list |- x + y : int
  ```

    is not. The exact definition is formalized in `Language.Fixpoint.SortCheck`

  ### RHS

  Similarly each `rhs` of a `SubC` must either be a single `$k[...]` or an plain `$k`-free `Expr`.

  ### KVar occurrences

  * Each `KVar` that appears in any binding or constraint must have exactly one
    associated wf constraint.

  * Each `KVar` that appears in any binding or constraint must have an
    accompanying substitution whose domain has the same symbols as the environment
    of the corresponding wf constraint plus the symbol of its refinement type.

  For example, if the wf constraint is
  ```
      x:int, y: int |- {v:int | $k_##42 }
  ```

  any occurrence of `$k_##42` must be of the form

  ```
      $k_##42 [x:=e1][y:=e2][v:=e3]
  ```

  ### Global vs. Distinct Literals

  ```
       , gLits    :: !(SEnv Sort)               -- ^ Global Constant symbols
       , dLits    :: !(SEnv Sort)
  ```

  The _global_ literals `gLits` are symbols that
  are in scope _everywhere_ i.e. need not be separately
  defined in individual environments. These include things like

  - uninterpreted _measure_ functions `len`, `height`,
  - uninterpreted _data constructor_ literals `True`, `False`

  Suppose you have an enumerated type like:

  ```
  data Day = Sun | Mon | Tue | Wed | ... | Sat
  ```

  You can model the above values in fixpoint as:

  ```
  constant lit#Sun : Day
  constant lit#Mon : Day
  constant lit#Tue : Day
  constant lit#Wed : Day
  ```

  The _distinct_ literals are a subset of the above where we
  want to tell the SMT solver that the values are *distinct*
  i.e. **not equal** to each other, for example, you can
  **additionally** specify this as:

  ```
  distinct lit#Sun : Day
  distinct lit#Mon : Day
  distinct lit#Tue : Day
  distinct lit#Wed : Day
  ```

  The above two are represented programmatically by generating
  suitable `Symbol` values (for the literals  see `litSymbol`)
  and `Sort` values as `FTC FTycon` and then making an `SEnv`
  from the `[(Symbol, Sort)]`.

  ### Sorts

  > What's the difference between an FTC and an FObj?

  In early versions of fixpoint, there was support for
  three sorts for expressions (`Expr`) that were sent
  to the SMT solver: `int`, `bool` and "other". The
  `FObj` sort was introduced to represent essentially _all_
  non-int and non-bool values (e.g. tuples, lists, trees, pointers...)

  However, we later realized that it is valuable to keep _more_
  precise information for `Expr`s and so we introduced the `FTC`
  (fixpoint type constructor), which lets us represent the above
  respectively as:

  - `FTC "String" []`                   -- in Haskell `String`
  - `FTC "Tuple"  [FInt, Bool]`         -- in Haskell `(Int, Bool)`
  - `FTC "List" [FTC "List" [FInt]]`    -- in Haskell `[[Int]]`

  > There is a comment that says FObj's are uninterpretted types;
  > so probably a type the SMT solver doesn't know about?
  > Does that then make FTC types that the SMT solver does
  > know about (bools, ints, lists, sets, etc.)?

  The SMT solvers we currently use know about following sorts:

  * `bool`
  * `int`
  * `real`
  * `string`
  * `array` (aka `map`)
  * `bitvector`
  * `set` and `bag` (in Z3, they are both also represented internally as `array`s)
  * `finitefield` (CVC5 only)

  _All_ other types are _currently_ represented as plain
  `Int` inside the SMT solver. However, we _will be_ changing this
  to make use of SMT support for ADTs ...

  To sum up: the `FObj` is there for historical reasons; it has been
  subsumed by `FTC` which is what I recomend you use. However `FObj`
  is there if you want a simple "unitype" / "any" type for terms
  that are not "interpreted".

  ## Qualifier Patterns

  ```haskell
  位> doParse' (qualParamP sortP) "" "z as (mon . $1) : int"
  QP {qpSym = "z", qpPat = PatPrefix "mon" 1, qpSort = FInt}
  位> doParse' (qualParamP sortP) "" "z as ($1 . mon) : int"
  QP {qpSym = "z", qpPat = PatSuffix 1 "mon", qpSort = FInt}
  位> doParse' (qualParamP sortP) "" "z as mon : int"
  QP {qpSym = "z", qpPat = PatExact "mon", qpSort = FInt}
  位> doParse' (qualParamP sortP) "" "z : int"
  QP {qpSym = "z", qpPat = PatNone, qpSort = FInt}
  ```
description-type: markdown
hash: 30ab809184b1f7400fa3df3f9e78b474490e303e0839168d322001119657e3cb
homepage: https://github.com/ucsd-progsys/liquid-fixpoint#readme
latest: 0.9.6.3.4
license-name: BSD-3-Clause
maintainer: jhala@cs.ucsd.edu
synopsis: Predicate Abstraction-based Horn-Clause/Implication Constraint Solver
test-bench-deps:
  base: '>=4.9.1.0 && <5'
  containers: '>=0.5'
  directory: '>=0'
  filepath: '>=0'
  hashable: '>=0'
  liquid-fixpoint: '>=0'
  mtl: '>=2.2.2'
  optparse-applicative: '>=0'
  process: '>=0'
  stm: '>=2.4'
  tagged: '>=0'
  tasty: '>=1.5 && <1.6'
  tasty-ant-xml: '>=0'
  tasty-hunit: '>=0.9'
  tasty-quickcheck: '>=0'
  tasty-rerun: '>=1.1.12'
  text: '>=0'
  transformers: '>=0.5'
  unordered-containers: '>=0'

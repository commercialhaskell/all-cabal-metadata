homepage: https://github.com/ucsd-progsys/liquidhaskell
changelog-type: markdown
hash: df809a9a71555b7bb95134f67fff7cac24a0dc31dbd518f59e547f7bde4694f9
test-bench-deps:
  ghc: -any
  extra: -any
  base: '>=4.8.1.0 && <5'
  text: -any
  megaparsec: -any
  syb: -any
  filepath: -any
  process: -any
  liquid-fixpoint: '>=0.8.10.1'
  tasty-hunit: '>=0.9'
  liquidhaskell: -any
  tasty: '>=0.10'
  tasty-ant-xml: -any
  directory: '>=1.2.5 && <1.4'
maintainer: Ranjit Jhala <jhala@cs.ucsd.edu>
synopsis: Liquid Types for Haskell
changelog: "# Changes\n\n## NEXT 0.8.10.1\n\n- Support for GHC 8.10.1\n- LiquidHaskell
  is now available as a GHC Plugin\n\n## 0.8.6.0\n\n- Automatically check (transitive)
  dependencies\n- Built with GHC 8.6.4\n- Structural termination checker (on by default)\n-
  Support for specifying class-laws and that they hold on instances\n- Bug fixes for
  PLE\n- Need to run LH on imported libs (with source) first; can use `--compile-spec`
  to avoid checking.\n\n## 0.8.4.0\n\n- Support for GHC 8.4.3\n- Significant restructuring
  of `Bare` front-end to shrink dependency on GHC-API\n\n## 0.8.2.2\n\n- Support for
  GHC 8.2.2\n\n- Support for GADTs and TypeFamilies, see\n\t- `tests/{pos,neg}/ExactGADT*.hs`\n\n-
  Add support for Bags/Multisets, see\n\t- `tests/pos/bag.hs`\n\t- `tests/neg/bag.hs`\n\t-
  `tests/pos/ListISort-bag.hs`\n\n- Add support for *inductive predicates* see\n\t-
  `tests/pos/IndEven.hs`\n\t- `tests/pos/IndPerm.hs`\n\t- `tests/pos/IndStar.hs`\n\n##
  0.8.0.1\n\n- Support for GHC 8.0.2 \n\n## 0.7.0.1\n\n- **DELETED** the gsDcons and
  generally carrying DataConP beyond Bare; this _may_ cause\n  problems with `target`
  as I removed the `dconEnv` field in `TargetState`. Is it live?\n  To restore: have
  to apply the substitution syms/su in Bare.hs ALSO to gsDconsP (after \n  restoring
  the gsDconsP field to [(DataCon, DataConP)])\n\n\n- **breaking change** Remove the
  `Bool` vs. `Prop` distinction. This means that: \n\n    * signatures that use(d)
  `Prop` as a type, e.g. \n      `foo :: Int -> Prop` should just be `foo :: Int ->
  Bool`.\n\n    * refinements that use(d) `Prop v` e.g. \n      `isNull :: xs:[a]
  -> {v:Bool | Prop v <=> len xs > 0}`\n      should just be `isNull :: xs:[a] ->
  {v:Bool | v <=> len xs > 0}`.\n\n- Add `--eliminate={none, some, all}`. Here\n  *
  `none` means don't use eliminate at all, use qualifiers everywhere (old-style)\n
  \ * `some` which is the **DEFAULT**  -- means eliminate all the **non-cut** variables\n
  \ * `all`  means eliminate where you can, and solve *cut* variables to `True`.\n\n-
  Change `--higherorder` so that it uses *only* the qualifiers obtained from\n  type
  aliases (e.g. `type Nat = {v:Int | ... }`) and nothing else. This\n  requires `eliminate=some`.\n\n-
  Add a `--json` flag that runs in quiet mode where all output is\n  suppressed and
  only the list of errors is returned as a JSON object to be\n  consumed by an editor.\n\n-
  Add `--checks` flag (formerly `--binders`), which checks a given binder's\n  definition,
  assuming specified types for all callees (but inferring types for\n  callees without
  signatures.)\n\n- Add `--time-binds` which is like the above, but checks all binders
  in a module\n  and prints out time taken for each.\n\n## 0.5.0.1\n\n- Fixed a bug
  in the specification for `Data.Traversable.sequence`\n- Make interpreted mul and
  div the default, when `solver = z3`\n- Use `--higherorder` to allow higher order
  binders into the fixpoint environment \n\n## 0.5.0.0\n\n- Added support for building
  with `stack`\n\n- Added support for GHC 7.10 (in addition to 7.8)\n\n- Added '--cabaldir'
  option that will automatically find a .cabal file in the ancestor\n  path from which
  the target file belongs, and then add the relevant source and dependencies\n  to
  the paths searched for by LiquidHaskell.\n\n  This means we don't have to manually
  do `-i src` etc. when checking large projects,\n  which can be tedious e.g. within
  emacs.\n\n\n## 0.4.0.0\n\n- Bounds as an alternative for logical constraints see
  `benchmarks/icfp15/pos/Overview.lhs`\n\n## 0.3.0.0\n\n- Logical constraints: add
  extra subtyping constraints to signatures, e.g.\n\n    {-@ \n    (.) :: forall <p
  :: b -> c -> Prop, q :: a -> b -> Prop, r :: a -> c -> Prop>. \n           {x::a,
  w::b<q x> |- c<p w> <: c<r x>}\n           (y:b -> c<p y>)\n        -> (z:a -> b<q
  z>)\n        ->  x:a -> c<r x>\n    @-}\n    (.) f g x = f (g x)\n\n- Inlining haskell
  functions as predicates and expressions, e.g.\n\n    {-@ inline max @-}\n    max
  x y = if x >= y then x else y\n\n- Refining class instances. For example\n\n    {-@
  instance Compare Int where\n        cmax :: Odd -> Odd -> Odd @-}\n\n- Major restructuring
  of internal APIs\n\n## 0.2.1.0\n- Experimental support for lifting haskell functions
  to measures\nIf you annotate a Haskell function `foo` with {-@ measure foo @-},
  LiquidHaskell will attempt to derive an equivalent measure from `foo`'s definition.
  This should help eliminate some boilerplate measures that used to be required.\n\n##
  0.2.0.0\n\n- Move to GHC-7.8.3\nLiquidHaskell now *requires* ghc-7.8.3.\n\n- Termination\nLiquidHaskell
  will now attempt to prove all recursive functions terminating. It tries to prove
  that some parameter (or combination thereof) decreases at each recursive callsite.
  By default, this will be the first parameter with an associated size measure (see
  Size Measures), but can be overridden with the `Decreases` annotation or a termination
  expression (see Termination Expressions). \n\nIf proving termination is too big
  of burden, it can be disabled on a per-module basis with the `--no-termination`
  flag, or on a per-function basis with the `Lazy` annotation.\n\n- Size Measures\nData
  declarations now optionally take a *size measure*, which LiquidHaskell will use
  to prove termination of recursive functions. The syntax is:\n\n    {-@ data List
  a [len] = Nil | Cons a (List a) @-}\n\n- Termination Expressions\nTermination Expressions
  can be used to specify the decreasing metric of a recursive function. They can be
  any valid LiquidHaskell expression and must be placed after the function's LiquidHaskell
  type, e.g.\n\n    {-@ map :: (a -> b) -> xs:[a] -> [a] / [len xs] @-}\n\n- Type
  Holes\nTo reduce the annotation burden, LiquidHaskell now accepts `_` as a placeholder
  for types and refinements. It can take the place of any base Haskell type and LiquidHaskell
  will query GHC to fill in the blanks, or it can take the place of a refinement predicate,
  in which case LiquidHaskell will infer an appropriate refinement. For example,\n\n
  \   {-@ add :: x:_ -> y:_ -> {v:_ | v = x + y} @-}\n    add x y = x + y\n\nbecomes\n\n
  \   {-@ add :: Num a => x:a -> y:a -> {v:a | v = x + y} @-}\n    add x y = x + y\n\n-
  Assumed Specifications\nThe `assume` annotation now works as you might expect it
  to, i.e. LiquidHaskell will *not* verify that the implementation is correct. Furthermore,
  `assume` can be used to locally override the type of an imported function.\n\n-
  Derived Measure Selectors\nGiven a data definition\n\n    {-@ data Foo = Foo { bar
  :: Int, baz :: Bool } @-}\n\nLiquidHaskell will automatically derive measures\n\n
  \   {-@ measure bar :: Foo -> Int @-}\n    {-@ measure baz :: Foo -> Bool @-}\n\n-
  Type-Class Specifications\nLiquidHaskell can now verify prove that type-class instances
  satisfy a specification. Simply use the new `class` annotation\n\n    {-@ class
  Num a where\n          (+) :: x:a -> y:a -> {v:a | v = x + y}\n          (-) ::
  x:a -> y:a -> {v:a | v = x - y}\n          ...\n      @-}\n\nand LiquidHaskell will
  attempt to prove at each instance declaration that the implementations satisfy the
  class specification.\n\nWhen defining type-class specifications you may find the
  need to use overloaded measures, to allow for type-specific definitions (see Type-Indexed
  Measures).\n\n- Type-Indexed Measures\nLiquidHaskell now accepts measures with *type-specific*
  definitions, e.g. a measure to describe the size of a value. Such measures are defined
  using the `class measure` syntax\n\n    {-@ class measure size :: forall a. a ->
  Int @-}\n\nand instances can be defined using the `instance measure` syntax, which
  mirrors the regular measure syntax\n\n    {-@ instance measure size :: [a] -> Int\n
  \       size ([])   = 0\n        size (x:xs) = 1 + size xs\n      @-}\n    {-@ instance
  measure size :: Tree a -> Int\n        size (Leaf)       = 0\n        size (Node
  l x r) = 1 + size l + size r\n      @-}\n\n- Parsing\nWe have greatly improved our
  parser to require fewer parentheses! Yay!\n\n- Emacs/Vim Support\nLiquidHaskell
  now comes with syntax checkers for [flycheck](https://github.com/flycheck/flycheck)
  in Emacs and [syntastic](https://github.com/scrooloose/syntastic) in Vim. \n\n-
  Incremental Checking\nLiquidHaskell has a new `--diffcheck` flag that will only
  check binders that have changed since the last run, which can drastically improve
  verification times.\n\n- Experimental Support for Z3's theory of real numbers with
  the `--real` flag.\n"
basic-deps:
  exceptions: <0.11
  free: -any
  cereal: -any
  ghc: ^>=9
  bytestring: '>=0.10'
  fingertree: '>=0.1'
  data-fix: -any
  extra: -any
  split: -any
  Cabal: <3.5
  base: '>=4.11.1.0 && <5'
  th-compat: <0.2
  time: '>=1.4'
  Diff: '>=0.3 && <0.5'
  unordered-containers: '>=0.2.11'
  text: '>=1.2'
  megaparsec: '>=8'
  syb: '>=0.4.4'
  filepath: '>=1.3'
  gitrev: -any
  data-default: '>=0.5'
  containers: '>=0.5'
  ghc-paths: '>=0.1'
  ghc-boot: -any
  binary: -any
  ghc-prim: -any
  optics: '>=0.2'
  liquid-fixpoint: ==0.9.0.2.1
  mtl: '>=2.1'
  cmdargs: '>=0.10'
  githash: -any
  hashable: '>=1.3 && <1.4'
  liquidhaskell: -any
  transformers: '>=0.3'
  temporary: '>=1.2'
  optparse-applicative: <0.17
  deepseq: '>=1.3'
  recursion-schemes: <5.3
  hscolour: '>=1.22'
  pretty: '>=1.1'
  aeson: -any
  template-haskell: '>=2.9'
  vector: '>=0.10'
  directory: '>=1.2'
all-versions:
- '0.1'
- 0.2.0.0
- 0.2.1.0
- 0.3.0.0
- 0.3.1.0
- 0.4.0.0
- 0.4.0.1
- 0.4.1.0
- 0.4.1.1
- 0.5.0.0
- 0.5.0.1
- 0.6.0.0
- 0.7.0.0
- 0.8.0.0
- 0.8.0.1
- 0.8.0.2
- 0.8.0.3
- 0.8.0.5
- 0.8.2.0
- 0.8.2.2
- 0.8.2.3
- 0.8.2.4
- 0.8.6.0
- 0.8.6.2
- 0.8.10.1
- 0.8.10.2
- 0.8.10.7
- 0.9.0.2.1
author: Ranjit Jhala, Niki Vazou, Eric Seidel
latest: 0.9.0.2.1
description-type: markdown
description: "![LiquidHaskell](/resources/logo.png)\n\n\n[![Hackage](https://img.shields.io/hackage/v/liquidhaskell.svg)](https://hackage.haskell.org/package/liquidhaskell)
  [![Hackage-Deps](https://img.shields.io/hackage-deps/v/liquidhaskell.svg)](http://packdeps.haskellers.com/feed?needle=liquidhaskell)
  [![Build Status](https://img.shields.io/circleci/project/ucsd-progsys/liquidhaskell/master.svg)](https://circleci.com/gh/ucsd-progsys/liquidhaskell)\n[![Windows
  build status](https://ci.appveyor.com/api/projects/status/78y7uusjcgor5p16/branch/develop?svg=true)](https://ci.appveyor.com/project/varosi/liquidhaskell-nlhra/branch/develop)\n\nThis
  is the **development** site of the LiquidHaskell formal verification tool.\n\nIf
  you're a LiquidHaskell **user** (or just curious), you probably want to go to [the
  documentation website](https://ucsd-progsys.github.io/liquidhaskell/) instead.\n\n#
  Contributing\n\nThis is an open-source project, and we love getting feedback (and
  patches)!\n\n## Reporting a Bug\n\nIf something doesn't work as it should, please
  consider opening a [github issue](https://github.com/ucsd-progsys/liquidhaskell/issues)\nto
  let us know. If possible, try to:\n\n* Try to use a descriptive title;\n* State
  as clearly as possible what is the problem you are facing;\n* Provide a small Haskell
  file producing the issue;\n* Write down the expected behaviour vs the actual behaviour;\n*
  If possible, let us know if you have used the [plugin](install.md) or the [executable](legacy.md)
  and\n  which _GHC version_ you are using.\n\n## Your first Pull Request\n\nWe are
  thrilled to get PRs! Please follow these guidelines, as doing so will increase the
  chances of \nhaving your PR accepted:\n\n* The main LH repo [lives here](https://github.com/ucsd-progsys/liquidhaskell)\n*
  Please create pull requests against the `develop` branch.\n* Please be sure to include
  test cases that illustrate the effect of the PR\n    - e.g. show new features that
  that are supported or how it fixes some previous issue\n* If you're making user-visible
  changes, please also add documentation\n    - e.g. [options.md](docs/mkDocs/docs/options.md),
  [specifications.md](docs/mkDocs/docs/specifications.md), the [main tutorial](https:///github.com/ucsd-progsys/intro-refinement-types)
  (as relevant)\n\nPull requests don't just have to be about code: documentation can
  often be improved too!\n\n## Ask for Help\n\nIf you have further questions or you
  just need help, you can always reach out on our [slack channel](https://join.slack.com/t/liquidhaskell/shared_invite/enQtMjY4MTk3NDkwODE3LTFmZGFkNGEzYWRkNDJmZDQ0ZGU1MzBiZWZiZDhhNmY3YTJiMjUzYTRlNjMyZDk1NDU3ZGIxYzhlOTIzN2UxNWE),
  [google groups mailing list](https://groups.google.com/forum/#!forum/liquidhaskell),
  [GitHub issue tracker](https://github.com/ucsd-progsys/liquidhaskell/issues), or
  by emailing [Ranjit Jhala](https://github.com/ranjitjhala), [Niki Vazou](https://github.com/nikivazou).\n\n#
  General Development Guide\n\nFor those diving into the implementation of LiquidHaskell,
  here are a few tips:\n\n## Fast (re)compilation\n\nWhen working on the `liquidhaskell`
  library, usually all we want is to make changes and quickly recompile\nonly the
  bare minimum, to try out new ideas. Using a fully-fledged GHC plugin doesn't help
  in this sense,\nbecause packages like `liquid-base` or `liquid-ghc-prim` all have
  a direct dependency on `liquidhaskell`, and\ntherefore every time the latter changes,
  an expensive rebuild of those packages is triggered, which\nmight become tedious
  overtime. To mitigate this, we offer a faster, \"dev-style\" build mode which is
  based\non the assumption that most changes to the `liquidhaskell` library do not
  alter the validity of\nalready-checked libraries, and therefore things like `liquid-base`
  and `liquid-ghc-prim` can be considered\n\"static assets\", avoiding the need for
  a recompilation. In other terms, we explicitly disable recompilation\nof any of
  the `liquid-*` ancillary library in dev mode, so that rebuilds would also influence
  the \n`liquidhaskell` library.\n\n### Usage and recommended workflow\n\nThis is
  how you can use this:\n\n* To begin with, perform a **full** build of **all** the
  libraries, by doing either `cabal v2-build` or `stack build`,\n  **without** specifying
  any extra environment variables from the command line. This is needed to ensure
  that\n  we things like `liquid-base` and `liquid-ghc-prim` are compiled at least
  once, as we would need the\n  refinements they contain to correctly checks other
  downstream programs;\n\n* At this point, the content of the `liquid-*` packages
  is considered \"trusted\" and \"frozen\", until you won't\n  force another full,
  _non-dev_ build;\n\n* In order to quickly test changes to the `liquidhaskell` library
  without recompiling the `liquid-*` packages,\n  we need to start a build passing
  the `LIQUID_DEV_MODE` env var as part of the build command. Examples:\n\n#### Stack\n\n```\nLIQUID_DEV_MODE=true
  stack build\n```\n\nIf on NixOS\n\n```\nLIQUID_DEV_MODE=true stack --no-nix-pure
  build\n```\n\nWith the above, `stack` will unregister and re-register the libraries,\nbut
  hopefully it won't rebuild any modules.\n\n#### Cabal\n\n```\nLIQUID_DEV_MODE=true
  cabal v2-build\n```\n\nIt's also possible (but not recommended) to add `LIQUID_DEV_MODE`
  to .bashrc or similar, but this would\npermanently disable building the `liquid-*`
  packages, and this might silently mask breaking changes to the\n`liquidhaskell`
  library that would manifest only when compiling these other packages.\n\nIf you
  wish to force building all the libraries again, it's sufficient to issue the same
  builds commands \nwithout the `LIQUID_DEV_MODE`.\n\n## How To Run Regression Tests\n\nFor
  documentation on the `test-driver` executable itself, please refer to the\n`README.md`
  in `tests/` or run `cabal run tests:test-driver -- --help` or `stack\nrun test-driver
  -- --help`\n\n_For a way of running the test suite for multiple GHC versions, consult
  the General Development FAQs. below_\n\nThere are particular scripts for running
  LH in the different modes, e.g. for different \ncompiler versions. These scripts
  are in:\n\n    $ ./scripts/test\n\nSo you can run *all* the tests for say the ghc-8.10
  version by\n\n    $ ./scripts/test/test_810_plugin.sh\n\nYou can run a bunch of
  particular test-groups instead by\n\n    $ LIQUID_DEV_MODE=true ./scripts/test/test_810_plugin.sh
  <test-group-name1> <test-group-name2> ...\n\nand you can list all the possible test
  options with \n\n    $ LIQUID_DEV_MODE=true ./scripts/test/test_810_plugin.sh --help\n\nor
  get a list of just the test groups, one per line, with\n\n    $ LIQUID_DEV_MODE=true
  ./scripts/test/test_810_plugin.sh --show-all\n\nTo pass in specific parameters and
  run a subset of the tests, you can invoke cabal directly with\n\n    $ LIQUID_DEV_MODE=true
  cabal build tests:<test-group-name> --ghc-options=-fplugin-opt=LiquidHaskell:--no-termination
  MySpecificTest\n\nFor example:\n\n    $ LIQUID_DEV_MODE=true cabal build tests:unit-neg
  --ghc-options=--fplugin-opt=LiquidHaskell:--no-termination AbsApp\n\nOr your favorite
  number of threads, depending on cores etc.\n\nYou can directly extend and run the
  tests by modifying the files in\n\n    tests/harness/\n\n### Parallelism in Tests\n\nMost
  tests run in parallel, with a few module dependencies built sequentially in\nadvance.
  Benchmarks are run sequentially after all other tests have finished.\nFor details
  on adding tests, see note [Parallel_Tests] in `tests/test.hs`.\n\n## How to create
  performance comparison charts\n\nWhen `liquidhaskell` tests run, we can collect
  timing information with\n\n    $ ./scripts/test/test_810_plugin.sh --measure-timings\n\nMeasures
  will be collected in `.dump-timings` files. These can be converted to json\ndata
  with\n\n```bash\ncabal v2-build ghc-timings\ncabal v2-exec ghc-timings dist-newstyle\n```\n\nwhich
  will produce `tmp/*.json` files.\n\nThen a csv report can be generated from this
  json files with\n```\ncabal v2-run benchmark-timings -- tmp/*.json --phase LiquidHaskell
  -o summary.csv\n```\nOn each line, the report will contain the time taken by each
  test.\n\nThere is a script `scripts/plot-performance/chart_perf.sh` that can be\nused
  to generate comparison charts in `svg` and `png` formats. It\nrequires [gnuplot](http://www.gnuplot.info/)
  to run. The following\ncommand will produce two files `perf.svg` and `perf.png`
  in the\ncurrent directory.\n\n    $ scripts/plot-performance/chart_perf.sh path_to_before_summary.csv
  path_to_after_summary.csv\n\nThe current formatting is optimized for comparing the
  outputs of running\nthe benchmarks alone.\n\n    $ scripts/test/test_810_plugin.sh
  \\\n        benchmark-stitch-lh \\\n        benchmark-bytestring \\\n        benchmark-vector-algorithms
  \\\n        benchmark-cse230 \\\n        benchmark-esop2013 \\\n        benchmark-icfp15-pos
  \\\n        benchmark-icfp15-neg\n\n## How to Profile\n\n1. Build with profiling
  on\n\n    ```\n    $ stack build liquidhaskell --fast --profile\n    ```\n\n2. Run
  with profiling\n\n    ```\n    $ stack exec -- liquid range.hs +RTS -hc -p\n    $
  stack exec -- liquid range.hs +RTS -hy -p\n    ```\n\n    Followed by this which
  shows the stats file\n\n    ```\n    $ more liquid.prof\n    ```\n\n    or by this
  to see the graph\n\n    ```\n    $ hp2ps -e8in -c liquid.hp\n    $ gv liquid.ps\n
  \   ```\n\n    etc.\n\n## How to Get Stack Traces On Exceptions\n\n1. Build with
  profiling on\n\n    ```\n    $ stack build liquidhaskell --fast --profile\n    ```\n\n2.
  Run with backtraces\n\n    ```\n    $ liquid +RTS -xc -RTS foo.hs\n    ```\n\n    ```\n
  \   stack exec -- liquid List00.hs +RTS -p -xc -RTS\n    ```\n\n## Working With
  Submodules\n\nTo update the `liquid-fixpoint` submodule, run:\n\n```\ncd ./liquid-fixpoint\ngit
  fetch --all\ngit checkout <remote>/<branch>\ncd ..\n```\n\nThis will update `liquid-fixpoint`
  to the latest version on `<branch>` (usually `master`) \nfrom `<remote>` (usually
  `origin`). After updating `liquid-fixpoint`, make sure to include this change in
  a\ncommit! Running:\n\n```\ngit add ./liquid-fixpoint\n```\n\nwill save the current
  commit hash of `liquid-fixpoint` in your next commit to the `liquidhaskell` repository.\nFor
  the best experience, **don't** make changes directly to the `./liquid-fixpoint`
  submodule, or else git\nmay get confused. Do any `liquid-fixpoint` development inside
  a separate clone/copy elsewhere. If something\ngoes wrong, run:\n\n```\nrm -r ./liquid-fixpoint\ngit
  submodule update --init\n```\n\nto blow away your copy of the `liquid-fixpoint`
  submodule and revert to the last saved commit hash.\n\nWant to work fully offline?
  `git` lets you add a local directory as a remote. Run:\n\n```\ncd ./liquid-fixpoint\ngit
  remote add local /path/to/your/fixpoint/clone\ncd ..\n```\n\nThen to update the
  submodule from your local clone, you can run:\n\n```\ncd ./liquid-fixpoint\ngit
  fetch local\ngit checkout local/<branch>\ncd ..\n```\n\n## Releasing on Hackage\n\n*NOTE:
  The following section is relevant only for few developers, i.e. the ones which are
  directly involved\nin the release process. Most contributors can skip this section.*\n\nWe
  provide a convenience script to upload all the `liquid-*` packages (**including**
  `liquid-fixpoint`) on\nHackage, in a lockstep fashion. To do so, it's possible to
  simply run the `scripts/release_to_hackage.sh`\nBash script. The script doesn't
  accept any argument and it tries to determine the packages\nto upload by scanning
  the `$PWD` for packages named appropriately. It will ask the user for confirmation\nbefore
  proceeding, and `stack upload` will be used under the hood.\n\n## GHC support policy\n\nLH
  supports only one version of GHC at any given time. This is because LH depends heavily
  on the `ghc` library\nand there is currently no distinction between public API's
  and API's internal to GHC. There are currently no\nrelease notes for the `ghc` library
  and breaking changes happen without notice and without deprecation\nperiods. Supporting
  only one GHC version saves developer time because it obviates the need for `#ifdef`'s\nthroughout
  the codebase, or for an compatibility layer that becomes increasingly difficult
  to write as we\nattempt to support more GHC versions. Porting to newer GHC versions
  takes less time, the code is easier to\nread and there is less code duplication.\n\nUsers
  of older versions of GHC can still use older versions of LH.\n\n## The GHC.API module\n\nIn
  order to minimize the effort in porting LH to new releases of GHC, we need a way
  to abstract over breaking\nchanges in the `ghc` library, which might change substantially
  with every major GHC release. This is\naccomplished by the [GHC.API][] module. The
  idea is that **rather than importing multiple `ghc` modules,\nLH developers must
  import this single module in order to write future-proof code**. This is especially\nimportant
  for versions of the compiler greater than 9, where the module hierarchy changed
  substantially,\nand using the [GHC.API][] makes it easier to support new versions
  of GHC when they are released.\n\n### Fragile import strategy\n\n```haskell\nimport
  Predicate\nimport TyCoRep\n\n...\n\n-- This will break if 'isEqPrimPred' is (re)moved
  or the import hierarchy changes.\nfoo :: Type -> Bool\nfoo = isEqPrimPred\n```\n\n###
  Recommended import strategy\n\n```haskell\nimport qualified Language.Haskell.Liquid.GHC.API
  as GHC\n\n...\n\nfoo :: GHC.Type -> Bool\nfoo = GHC.isEqPrimPred -- OK.\n```\n\n#
  GHC Plugin Development Guide\n\nThis code commentary describes the current architecture
  for the GHC [Plugin][] that enables LiquidHaskell\nto check files as part of the
  normal compilation process. For the sake of this commentary, we refer to\nthe code
  provided as part of the `release/0.8.10.2` branch, commit `9a2f8284c5fe5b18ed0410e842acd3329a629a6b`.\n\n##
  GHC.Interface vs GHC.Plugin\n\nThe module [GHC.Plugin][] is the main entrypoint
  for all the plugin functionalities. Whenever possible, this\nmodule is reusing common
  functionalities from the [GHC.Interface][], which is the original module used to\ninterface
  LH with the old executable. Generally speaking, the [GHC.Interface][] module is
  considered \"legacy\"\nand it's rarely what one wants to modify. It will probably
  be removed once the old executable stops being\nsupported, with the functions now
  in use by the [GHC.Plugin][] being moved into the latter.\n\n## The GhcMonadLike
  shim\n\nPart of the tension in designing the plugin was trying to reuse as much
  code as possible from the original\n[GHC.Interface][] shipped with LiquidHaskell.
  Unfortunately this was not possible from the get-go due to the\nfact most of the
  functions provided by that module were requiring a [GhcMonad][] constraint or usually\nliving
  in the [Ghc monad][], which is also the only concrete type which derives an instance
  for [GhcMonad][].\nWhile we could have run each and every function with `runGhc`,
  this was not very satisfactory due to the\nfact running the `Ghc` monad is fairly
  expensive as it requires a bit of extra state in order to run it.\n\nHowever, most
  of the functions used by the [Ghc.Interface][] didn't require anything specific
  from the\nunderlying [Ghc monad][] if not access to the [HscEnv][] and the ability
  to grab the [DynFlags][], as well\nas doing `IO`. Therefore, the [GhcMonadLike][]
  shim was born with the intent of replicating some of the\nfunctions used by the
  [GHC.Interface][] but crucially making those polymorphic in a generic [GhcMonadLike][]\nfor
  which we can give instances for `CoreM`, `TcM` etc. We can do this because we do
  not require the extra\n`ExceptionMonad` constraint and we do not require to implement
  `setHscEnv`.\n\nThis allowed us to change ever so slightly the functions provided
  by the [GHC.Interface][], expose them and\nreuse them in the [Plugin][] module.\n\n##
  Plugin architecture\n\nBroadly speaking, the Plugin is organised this way: In the
  [typechecking phase][], we typecheck and desugar\neach module via the GHC API in
  order to extract the unoptimised [core binds][] that are needed by\nLH to work correctly.
  This is due to a tension in the design space; from one side LH needs access to the\n\"raw\"
  core binds (binds where primitives types are not unboxed in the presence of a PRAGMA
  annotation,\nfor example) but yet the user can specify any arbitrary optimisation
  settings during compilation and we do\nnot want to betray the principle of least
  expectation by silently compiling the code with `-O0`. Practically\nspeaking, this
  introduces some overhead and is far from ideal, but for now it allows us to iterate
  quickly.\nThis phase is also responsible for:\n\n* Extracting the [BareSpec][]s
  associated to any of the dependent modules;\n* Producing the [LiftedSpec][] for
  the currently-compiled module;\n* Storing the [LiftedSpec][] into an interface annotation
  for later retrieval;\n* Checking and verifying the module using LH's existing API.\n\nThe
  reason why we do everything in the [typechecking phase][] is also to allow integrations
  with tools like\n[ghcide][]. There are a number of differences between the plugin
  and the operations performed as part of the\n[GHC.Interface][], which we are going
  to outline in the next section.\n\n## Differences with the GHC.Interface\n\n- The
  [GHC.Interface][] pre-processes the input files and calls into [configureGhcTargets][]
  trying to\n  build a dependency graph by discovering dependencies the target files
  might require. Then, from this\n  list any file in the include directory is filtered
  out, as well as any module which has\n  a \"fresh\" `.bspec` file on disk, to save
  time during checking. In the [GHC.Plugin][] module though\n  we don't do this and
  for us, essentially, each input file is considered a target, where we exploit the\n
  \ fact GHC will skip recompilation if unnecessary. This also implies that while
  the [GHC.Interface][] calls\n  into [processTargetModule][] only for target files,
  the [GHC.Plugin][] has a single, flat function simply\n  called [processModule][]
  that essentially does the same as `GHC.Interface.processModule` and\n  `GHC.Interface.processTargetModule`
  fused together.\n\n- While the [GHC.Interface][] sometimes \"assembles\" a [BareSpec][]
  by `mappend`ing the `commSpec` (i.e. comment spec)\n  with the [LiftedSpec][] fetched
  from disk, if any, the Plugin doesn't do this but rather piggybacks on the\n  [SpecFinder][]
  (described later) to fetch dependencies' specs.\n\n- There is a difference in how
  we process LIQUID pragmas. In particular, for the executable they seems to\n  be
  accumulated \"in bulk\" i.e. if we are refining a *target* module `A` that depends
  on `B`, `B` seems to\n  inherit whichever flags we were using in the *target* module
  `A`. Conversely, the source plugin is \"stateless\"\n  when it comes to LIQUID options,
  i.e. it doesn't have memory of _past_ options, what it counts when compiling\n  a
  module `B` is the _global_ options and _any_ option this module defines. The analogy
  is exactly the\n  same as with GHC language extensions, they have either global
  scope (i.e. `default-extensions` in the\n  cabal manifest) or local scope (i.e.
  `{-# LANGUAGE ... #-}`).\n\n## Finding specs for existing modules\n\nThis is all
  done by a specialised module called the [SpecFinder][]. The main exported function
  is\n[findRelevantSpecs][] which, given a list of `Module`s, tries to retrieve the
  `LiftedSpec`s associated with\nthem. Typically this is done by looking into the
  interface files of the input modules, trying to deserialise\nany `LiftedSpec` from
  the interface file's annotations.\n\n# General Development FAQs\n\n## A new version
  of GHC is out. How do I support it?\n\nTypically the first thing you might want
  to do is to run a \"clean\" `cabal v2-build` or `stack build` using\nthe latest
  compiler and \"check the damage\". If you are lucky, everything works out of the
  box, otherwise\ncompilation might fail with an error, typically because some `ghc`
  API function has been removed/moved/renamed.\nThe way to fix it is to modify the
  [GHC.API][] shim module and perform any required change, likely by \nconditionally
  compiling some code in a `CPP` block. For minor changes, it's usually enough to
  perform small\nchanges, but for more tricky migrations it might be necessary to
  backport some GHC code, or create some\npatter synonym to deal with changes in type
  constructors. You can see an example of this technique in\naction by looking at
  the pattern synonym for [FunTy][].\n\n## Is there a way to run the testsuite for
  different versions of GHC?\n\nYes. The easiest way is to run one of the scripts
  inside the `scripts/test` directory. We provide scripts\nto run the testsuite for
  a variety of GHC versions, mostly using `stack` but also with `cabal` (e.g.\n`test_810_plugin.sh`).
  If run without arguments, the script will run the _full_ testsuite. If an argument\nis
  given, only a particular pattern/test will be run. Running\n\n```\n./scripts/test/test_810_plugin.sh
  BST\n```\n\nwill run all the tests which name matches \"BST\". In case the \"fast
  recompilation\" is desired, it's totally\npossibly to pass `LIQUID_DEV_MODE` to
  the script, for example:\n\n```\nLIQUID_DEV_MODE=true ./scripts/test/test_810_plugin.sh\n```\n\n[GHC.API]:
  https://github.com/ucsd-progsys/liquidhaskell/blob/develop/src/Language/Haskell/Liquid/GHC/API.hs\n[FunTy]:
  https://github.com/ucsd-progsys/liquidhaskell/blob/develop/src/Language/Haskell/Liquid/GHC/API.hs#L224\n\n#
  GHC Plugin Development FAQs\n\n## Is it possible that the behaviour of the old executable
  and the new / the plugin differ?\n\nIt might happen, yes, but the surface area is
  fairly small. Both modules work by producing a [TargetSrc][]\nthat is passed to
  the internal LH API, which is shared by _both_ modules. Therefore, any difference
  in \nbehaviour has to be researched in the code path that produces such [TargetSrc][].
  For the [GHC.Plugin][] this\nhappens in the `makeTargetSrc`, whereas for the [GHC.Interface][]
  this happens inside the [makeGhcSrc][] function.\n\n## Why is the GHC.Interface
  using slightly different types than the GHC.Plugin module?\n\nMostly for backward-compatibility
  and for historical reasons. Types like [BareSpec][] used to be type alias\nrather
  than `newtype`s, and things were slightly renamed to reflect better purpose when
  the support for the\nplugin was added. While doing so we also added a compatibility
  layer in the form of some `optics` that can be used\nto map back and forth (sometimes
  in a partial way) between old and new data structures. When in doubt,\n**consider
  the GHC.Plugin as the single source of truth, and prefer whichever data structure
  the latter is\nusing**.\n\n\n[Plugin]:              https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs\n[GHC.Plugin]:
  \         https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs\n[GHC.Interface]:
  \      https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs\n[SpecFinder]:
  \         https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin/SpecFinder.hs\n[BareSpec]:
  \           https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L301\n[LiftedSpec]:
  \         https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L476\n[TargetSrc]:
  \          https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/Types/Specs.hs#L160\n[Ghc
  monad]:           https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:Ghc\n[HscEnv]:
  \             https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:HscEnv\n[DynFlags]:
  \           https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:DynFlags\n[GhcMonad]:
  \           https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#t:GhcMonad\n[GhcMonadLike]:
  \       https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/GhcMonadLike.hs\n[typechecking
  phase]:  https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs#L196-L224\n[ghcide]:
  \             https://github.com/haskell/ghcide\n[findRelevantSpecs]:   https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin/SpecFinder.hs#L61\n[core
  binds]:          https://hackage.haskell.org/package/ghc-8.10.1/docs/CoreSyn.html#t:CoreBind\n[configureGhcTargets]:
  https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs#L268\n[processTargetModule]:
  https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Interface.hs#L468\n[processModule]:
  \      https://github.com/ucsd-progsys/liquidhaskell/blob/9a2f8284c5fe5b18ed0410e842acd3329a629a6b/src/Language/Haskell/Liquid/GHC/Plugin.hs#L393\n\n"
license-name: BSD-3-Clause

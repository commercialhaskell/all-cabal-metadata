homepage: https://github.com/ucsd-progsys/liquidhaskell
changelog-type: markdown
hash: 34cae57f2921ac3c6a87197563990033d2fdd3310cf04fbf90c616d39eb4bb92
test-bench-deps:
  stm: ! '>=2.4'
  base: ! '>=4.8.1.0 && <5'
  text: -any
  syb: -any
  filepath: ! '>=1.3'
  process: ! '>=1.2'
  parsec: -any
  tagged: ! '>=0.7.3'
  containers: ! '>=0.5'
  liquid-fixpoint: ! '>=0.8.0.0'
  mtl: ! '>=2.1'
  tasty-hunit: ! '>=0.9'
  liquidhaskell: -any
  tasty-rerun: ! '>=1.1'
  transformers: ! '>=0.3'
  optparse-applicative: ! '>=0.11'
  tasty: ! '>=0.10'
  tasty-ant-xml: -any
  directory: ! '>=1.2'
maintainer: Ranjit Jhala <jhala@cs.ucsd.edu>
synopsis: Liquid Types for Haskell
changelog: "# Changes\n\n## NEXT 0.8.6.0\n\n- Automatically check (transitive) dependencies\n-
  Built with GHC 8.6.4\n- Structural termination checker (on by default)\n- Support
  for specifying class-laws and that they hold on instances\n- Bug fixes for PLE\n-
  Need to run LH on imported libs (with source) first; can use `--compile-spec` to
  avoid checking.\n\n## 0.8.4.0\n\n- Support for GHC 8.4.3\n- Significant restructuring
  of `Bare` front-end to shrink dependency on GHC-API\n\n## 0.8.2.2\n\n- Support for
  GHC 8.2.2\n\n- Support for GADTs and TypeFamilies, see\n\t- `tests/{pos,neg}/ExactGADT*.hs`\n\n-
  Add support for Bags/Multisets, see\n\t- `tests/pos/bag.hs`\n\t- `tests/neg/bag.hs`\n\t-
  `tests/pos/ListISort-bag.hs`\n\n- Add support for *inductive predicates* see\n\t-
  `tests/pos/IndEven.hs`\n\t- `tests/pos/IndPerm.hs`\n\t- `tests/pos/IndStar.hs`\n\n##
  0.8.0.1\n\n- Support for GHC 8.0.2 \n\n## 0.7.0.1\n\n- **DELETED** the gsDcons and
  generally carrying DataConP beyond Bare; this _may_ cause\n  problems with `target`
  as I removed the `dconEnv` field in `TargetState`. Is it live?\n  To restore: have
  to apply the substitution syms/su in Bare.hs ALSO to gsDconsP (after \n  restoring
  the gsDconsP field to [(DataCon, DataConP)])\n\n\n- **breaking change** Remove the
  `Bool` vs. `Prop` distinction. This means that: \n\n    * signatures that use(d)
  `Prop` as a type, e.g. \n      `foo :: Int -> Prop` should just be `foo :: Int ->
  Bool`.\n\n    * refinements that use(d) `Prop v` e.g. \n      `isNull :: xs:[a]
  -> {v:Bool | Prop v <=> len xs > 0}`\n      should just be `isNull :: xs:[a] ->
  {v:Bool | v <=> len xs > 0}`.\n\n- Add `--eliminate={none, some, all}`. Here\n  *
  `none` means don't use eliminate at all, use qualifiers everywhere (old-style)\n
  \ * `some` which is the **DEFAULT**  -- means eliminate all the **non-cut** variables\n
  \ * `all`  means eliminate where you can, and solve *cut* variables to `True`.\n\n-
  Change `--higherorder` so that it uses *only* the qualifiers obtained from\n  type
  aliases (e.g. `type Nat = {v:Int | ... }`) and nothing else. This\n  requires `eliminate=some`.\n\n-
  Add a `--json` flag that runs in quiet mode where all output is\n  suppressed and
  only the list of errors is returned as a JSON object to be\n  consumed by an editor.\n\n-
  Add `--checks` flag (formerly `--binders`), which checks a given binder's\n  definition,
  assuming specified types for all callees (but inferring types for\n  callees without
  signatures.)\n\n- Add `--time-binds` which is like the above, but checks all binders
  in a module\n  and prints out time taken for each.\n\n## 0.5.0.1\n\n- Fixed a bug
  in the specification for `Data.Traversable.sequence`\n- Make interpreted mul and
  div the default, when `solver = z3`\n- Use `--higherorder` to allow higher order
  binders into the fixpoint environment \n\n## 0.5.0.0\n\n- Added support for building
  with `stack`\n\n- Added support for GHC 7.10 (in addition to 7.8)\n\n- Added '--cabaldir'
  option that will automatically find a .cabal file in the ancestor\n  path from which
  the target file belongs, and then add the relevant source and dependencies\n  to
  the paths searched for by LiquidHaskell.\n\n  This means we don't have to manually
  do `-i src` etc. when checking large projects,\n  which can be tedious e.g. within
  emacs.\n\n\n## 0.4.0.0\n\n- Bounds as an alternative for logical constraints see
  `benchmarks/icfp15/pos/Overview.lhs`\n\n## 0.3.0.0\n\n- Logical constraints: add
  extra subtyping constraints to signatures, e.g.\n\n    {-@ \n    (.) :: forall <p
  :: b -> c -> Prop, q :: a -> b -> Prop, r :: a -> c -> Prop>. \n           {x::a,
  w::b<q x> |- c<p w> <: c<r x>}\n           (y:b -> c<p y>)\n        -> (z:a -> b<q
  z>)\n        ->  x:a -> c<r x>\n    @-}\n    (.) f g x = f (g x)\n\n- Inlining haskell
  functions as predicates and expressions, e.g.\n\n    {-@ inline max @-}\n    max
  x y = if x >= y then x else y\n\n- Refining class instances. For example\n\n    {-@
  instance Compare Int where\n        cmax :: Odd -> Odd -> Odd @-}\n\n- Major restructuring
  of internal APIs\n\n## 0.2.1.0\n- Experimental support for lifting haskell functions
  to measures\nIf you annotate a Haskell function `foo` with {-@ measure foo @-},
  LiquidHaskell will attempt to derive an equivalent measure from `foo`'s definition.
  This should help eliminate some boilerplate measures that used to be required.\n\n##
  0.2.0.0\n\n- Move to GHC-7.8.3\nLiquidHaskell now *requires* ghc-7.8.3.\n\n- Termination\nLiquidHaskell
  will now attempt to prove all recursive functions terminating. It tries to prove
  that some parameter (or combination thereof) decreases at each recursive callsite.
  By default, this will be the first parameter with an associated size measure (see
  Size Measures), but can be overridden with the `Decreases` annotation or a termination
  expression (see Termination Expressions). \n\nIf proving termination is too big
  of burden, it can be disabled on a per-module basis with the `--no-termination`
  flag, or on a per-function basis with the `Lazy` annotation.\n\n- Size Measures\nData
  declarations now optionally take a *size measure*, which LiquidHaskell will use
  to prove termination of recursive functions. The syntax is:\n\n    {-@ data List
  a [len] = Nil | Cons a (List a) @-}\n\n- Termination Expressions\nTermination Expressions
  can be used to specify the decreasing metric of a recursive function. They can be
  any valid LiquidHaskell expression and must be placed after the function's LiquidHaskell
  type, e.g.\n\n    {-@ map :: (a -> b) -> xs:[a] -> [a] / [len xs] @-}\n\n- Type
  Holes\nTo reduce the annotation burden, LiquidHaskell now accepts `_` as a placeholder
  for types and refinements. It can take the place of any base Haskell type and LiquidHaskell
  will query GHC to fill in the blanks, or it can take the place of a refinement predicate,
  in which case LiquidHaskell will infer an appropriate refinement. For example,\n\n
  \   {-@ add :: x:_ -> y:_ -> {v:_ | v = x + y} @-}\n    add x y = x + y\n\nbecomes\n\n
  \   {-@ add :: Num a => x:a -> y:a -> {v:a | v = x + y} @-}\n    add x y = x + y\n\n-
  Assumed Specifications\nThe `assume` annotation now works as you might expect it
  to, i.e. LiquidHaskell will *not* verify that the implementation is correct. Furthermore,
  `assume` can be used to locally override the type of an imported function.\n\n-
  Derived Measure Selectors\nGiven a data definition\n\n    {-@ data Foo = Foo { bar
  :: Int, baz :: Bool } @-}\n\nLiquidHaskell will automatically derive measures\n\n
  \   {-@ measure bar :: Foo -> Int @-}\n    {-@ measure baz :: Foo -> Bool @-}\n\n-
  Type-Class Specifications\nLiquidHaskell can now verify prove that type-class instances
  satisfy a specification. Simply use the new `class` annotation\n\n    {-@ class
  Num a where\n          (+) :: x:a -> y:a -> {v:a | v = x + y}\n          (-) ::
  x:a -> y:a -> {v:a | v = x - y}\n          ...\n      @-}\n\nand LiquidHaskell will
  attempt to prove at each instance declaration that the implementations satisfy the
  class specification.\n\nWhen defining type-class specifications you may find the
  need to use overloaded measures, to allow for type-specific definitions (see Type-Indexed
  Measures).\n\n- Type-Indexed Measures\nLiquidHaskell now accepts measures with *type-specific*
  definitions, e.g. a measure to describe the size of a value. Such measures are defined
  using the `class measure` syntax\n\n    {-@ class measure size :: forall a. a ->
  Int @-}\n\nand instances can be defined using the `instance measure` syntax, which
  mirrors the regular measure syntax\n\n    {-@ instance measure size :: [a] -> Int\n
  \       size ([])   = 0\n        size (x:xs) = 1 + size xs\n      @-}\n    {-@ instance
  measure size :: Tree a -> Int\n        size (Leaf)       = 0\n        size (Node
  l x r) = 1 + size l + size r\n      @-}\n\n- Parsing\nWe have greatly improved our
  parser to require fewer parentheses! Yay!\n\n- Emacs/Vim Support\nLiquidHaskell
  now comes with syntax checkers for [flycheck](https://github.com/flycheck/flycheck)
  in Emacs and [syntastic](https://github.com/scrooloose/syntastic) in Vim. \n\n-
  Incremental Checking\nLiquidHaskell has a new `--diffcheck` flag that will only
  check binders that have changed since the last run, which can drastically improve
  verification times.\n\n- Experimental Support for Z3's theory of real numbers with
  the `--real` flag.\n"
basic-deps:
  cereal: -any
  ghc: -any
  bytestring: ! '>=0.10'
  fingertree: ! '>=0.1'
  base: ! '>=4.11.1.0 && <5'
  time: ! '>=1.4'
  Diff: ! '>=0.3 && <0.4'
  unordered-containers: ! '>=0.2'
  text: ! '>=1.2'
  syb: ! '>=0.4.4'
  hint: -any
  filepath: ! '>=1.3'
  gitrev: -any
  parsec: ! '>=3.1'
  data-default: ! '>=0.5'
  containers: ! '>=0.5'
  ghc-paths: ! '>=0.1'
  ghc-boot: -any
  binary: -any
  ghc-prim: -any
  liquid-fixpoint: ! '>=0.8.0.0'
  mtl: ! '>=2.1'
  cmdargs: ! '>=0.10'
  optparse-simple: -any
  githash: -any
  hashable: ! '>=1.2'
  liquidhaskell: -any
  transformers: ! '>=0.3'
  temporary: ! '>=1.2'
  deepseq: ! '>=1.3'
  hscolour: ! '>=1.22'
  pretty: ! '>=1.1'
  aeson: -any
  template-haskell: ! '>=2.9'
  vector: ! '>=0.10'
  directory: ! '>=1.2'
all-versions:
- '0.1'
- 0.2.0.0
- 0.2.1.0
- 0.3.0.0
- 0.3.1.0
- 0.4.0.0
- 0.4.0.1
- 0.4.1.0
- 0.4.1.1
- 0.5.0.0
- 0.5.0.1
- 0.6.0.0
- 0.7.0.0
- 0.8.0.0
- 0.8.0.1
- 0.8.0.2
- 0.8.0.3
- 0.8.0.5
- 0.8.2.0
- 0.8.2.2
- 0.8.2.3
- 0.8.2.4
- 0.8.6.0
- 0.8.6.2
author: Ranjit Jhala, Niki Vazou, Eric Seidel
latest: 0.8.6.2
description-type: markdown
description: "![LiquidHaskell](/resources/logo.png)\n\n\n\n[![Hackage](https://img.shields.io/hackage/v/liquidhaskell.svg)](https://hackage.haskell.org/package/liquidhaskell)
  [![Hackage-Deps](https://img.shields.io/hackage-deps/v/liquidhaskell.svg)](http://packdeps.haskellers.com/feed?needle=liquidhaskell)
  [![Build Status](https://img.shields.io/circleci/project/ucsd-progsys/liquidhaskell/master.svg)](https://circleci.com/gh/ucsd-progsys/liquidhaskell)\n[![Windows
  build status](https://ci.appveyor.com/api/projects/status/78y7uusjcgor5p16/branch/develop?svg=true)](https://ci.appveyor.com/project/varosi/liquidhaskell-nlhra/branch/develop)\n\nMain
  Web site\n-------------\n\n* [Try LiquidHaskell in your browser](http://goto.ucsd.edu:8090/index.html)\n*
  [Splash page with examples and link to blog](https://ucsd-progsys.github.io/liquidhaskell-blog/)\n*
  [120 minute workshop with more examples](http://ucsd-progsys.github.io/lh-workshop/01-index.html)\n*
  [Long ish Tutorial](http://ucsd-progsys.github.io/liquidhaskell-tutorial/)\n\nQuestions\n-----------\nIf
  you have any questions\n\n* Join the Liquid Haskell [slack channel](https://join.slack.com/t/liquidhaskell/shared_invite/enQtMjY4MTk3NDkwODE3LTY1YzBiY2JlZjBjMTM5M2ZkMjNmZDk5ZjA2MGQyZjQ5ZjBmYjZjNGMzOTUyMTU2MDlmM2YzZDM2YjhiMWFjM2I)\n*
  Mail the [users mailing list](https://groups.google.com/forum/#!forum/liquidhaskell)\n*
  Create a github issue\n\nContributing Guide\n------------------\n\nPlease see the
  [contributing guide](CONTRIBUTING.md)\n\nRequirements\n------------\n\nLiquidHaskell
  requires (in addition to the cabal dependencies)\n\n- SMTLIB2 compatible solver
  installed and its executable found on PATH\n\nHow To Clone, Build and Install\n-------------------------------\n\nYou
  may want to [try LiquidHaskell online](http://goto.ucsd.edu:8090/index.html)\n\nSee
  [install instructions](INSTALL.md)\n\nHow To Run\n----------\n\nTo verify a file
  called `foo.hs` at type\n\n    $ liquid foo.hs\n\nHow to Run inside GHCi\n----------------------\n\nTo
  run inside `ghci` e.g. when developing do:\n\n    $ stack ghci liquidhaskell\n    ghci>
  :m +Language.Haskell.Liquid.Liquid\n    ghci> liquid [\"tests/pos/Abs.hs\"]\n\nSee
  [this file](NIX.md) for instructions on running inside a custom `nix`-shell.\n\n\nHow
  To Get Editor Support\n-------------------------\n\nTo get Liquid Haskell in your
  editor use the Haskell IDE Engine and activate the liquid plugin. \nFor example,
  \n\n- [VS Code](https://code.visualstudio.com/)\n\n    1. Install the [haskell-ide-engine](https://github.com/haskell/haskell-ide-engine)\n
  \   2. Enable Haskell Language Server extension from VS Code. \n    3. In the VS
  Code settings search for `liquid` and enable the `Liquid On` extension.\n\n\n\nHow
  To Run Regression Tests\n---------------------------\n\nYou can run all the tests
  by\n\n    $ stack test\n\nTo pass in specific parameters and run a subset of the
  tests \n\n    $ stack test liquidhaskell --fast  --test-arguments \"--liquid-opts
  --no-termination -p Unit\"\n\nOr your favorite number of threads, depending on cores
  etc.\n\nYou can directly extend and run the tests by modifying\n\n    tests/test.hs\n\nHow
  to Profile\n--------------\n\n1. Build with profiling on\n\n    ```\n    $ stack
  build liquidhaskell --fast --profile\n    ```\n\n\n2. Run with profiling\n\n    ```\n
  \   $ stack exec -- liquid range.hs +RTS -hc -p\n    $ stack exec -- liquid range.hs
  +RTS -hy -p\n    ```\n\n    Followed by this which shows the stats file\n\n    ```\n
  \   $ more liquid.prof\n    ```\n\n    or by this to see the graph\n\n    ```\n
  \   $ hp2ps -e8in -c liquid.hp\n    $ gv liquid.ps\n    ```\n\n    etc.\n\nHow to
  Get Stack Traces On Exceptions\n-------------------------------------\n\n1. Build
  with profiling on\n\n    ```\n    $ stack build liquidhaskell --fast --profile\n
  \   ```\n\n2. Run with backtraces\n\n    ```\n    $ liquid +RTS -xc -RTS foo.hs\n
  \   ```\n\n    ```\n    stack exec -- liquid List00.hs +RTS -p -xc -RTS\n    ```\n\nWorking
  With Submodules\n-----------------------\n\n - To update the `liquid-fixpoint` submodule,
  run\n\n    ```\n    cd ./liquid-fixpoint\n    git fetch --all\n    git checkout
  <remote>/<branch>\n    cd ..\n    ```\n\n   This will update `liquid-fixpoint` to
  the latest version on `<branch>`\n   (usually `master`) from `<remote>` (usually
  `origin`).\n\n - After updating `liquid-fixpoint`, make sure to include this change
  in a\n   commit! Running\n\n    ```\n    git add ./liquid-fixpoint\n    ```\n\n
  \  will save the current commit hash of `liquid-fixpoint` in your next commit\n
  \  to the `liquidhaskell` repository.\n\n - For the best experience, **don't** make
  changes directly to the\n   `./liquid-fixpoint` submodule, or else git may get confused.
  Do any\n   `liquid-fixpoint` development inside a separate clone/copy elsewhere.\n\n
  - If something goes wrong, run\n\n    ```\n    rm -r ./liquid-fixpoint\n    git
  submodule update --init\n    ```\n\n   to blow away your copy of the `liquid-fixpoint`
  submodule and revert to the\n   last saved commit hash.\n\n - Want to work fully
  offline? git lets you add a local directory as a remote.\n   Run\n\n    ```\n    cd
  ./liquid-fixpoint\n    git remote add local /path/to/your/fixpoint/clone\n    cd
  ..\n    ```\n\n   Then to update the submodule from your local clone, you can run\n\n
  \   ```\n    cd ./liquid-fixpoint\n    git fetch local\n    git checkout local/<branch>\n
  \   cd ..\n    ```\n\nCommand Line Options\n====================\n\nLiquidHaskell
  supports several command line options, to configure the\nchecking. Each option can
  be passed in at the command line, or directly\nadded to the source file via:\n\n```haskell\n
  \   {-@ LIQUID \"option-within-quotes\" @-}\n```\n\nfor example, to disable termination
  checking (see below)\n\n```haskell\n    {-@ LIQUID \"--no-termination\" @-}\n```\n\nYou
  may also put command line options in the environment variable\n`LIQUIDHASKELL_OPTS`.
  For example, if you add the line:\n\n```\n    LIQUIDHASKELL_OPTS=\"--diff\"\n```\n\nto
  your `.bashrc` then, by default, all files will be\n*incrementally checked* unless
  you run with the overriding\n`--full` flag (see below).\n\nTheorem Proving \n---------------\n\nTo
  enable theorem proving, e.g. as [described here](https://ucsd-progsys.github.io/liquidhaskell-blog/tags/reflection.html)\nuse
  the option \n\n```haskell\n    {-@ LIQUID \"--reflection\" @-}\n```\n\nTo additionally
  turn on _proof by logical evaluation_ use the option\n\n```haskell\n    {-@ LIQUID
  \"--ple\" @-}\n```\n\nYou can see many examples of proofs by logical evaluation
  in `benchmarks/popl18/ple/pos`\n\nThis flag is **global** and will symbolically
  evaluate all the terms that appear in the specifications.\n\nAs an alternative,
  the `liquidinstanceslocal` flag has local behavior. [See](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/benchmarks/proofautomation/pos/Unification.hs)\n\n```\n{-@
  LIQUID \"--ple-local\" @-}\n```\n\nwill only evaluate terms appearing in the specifications\nof
  the function `theorem`, in the function `theorem` is\nannotated for automatic instantiation
  using the following\nliquid annotation\n\n```\n{-@ automatic-instances theorem @-}\n```\n\nIncremental
  Checking\n--------------------\n\nLiquidHaskell supports *incremental* checking
  where each run only checks\nthe part of the program that has been modified since
  the previous run.\n\n```\n    $ liquid --diff foo.hs\n```\n\nEach run of `liquid`
  saves the file to a `.bak` file and the *subsequent* run\n\n    + does a `diff`
  to see what has changed w.r.t. the `.bak` file\n    + only generates constraints
  for the `[CoreBind]` corresponding to the\n       changed top-level binders and
  their transitive dependencies.\n\nThe time savings are quite significant. For example:\n\n```\n
  \   $ time liquid --notermination -i . Data/ByteString.hs > log 2>&1\n\n    real\t7m3.179s\n
  \   user\t4m18.628s\n    sys\t    0m21.549s\n```\n\nNow if you go and tweak the
  definition of `spanEnd` on line 1192 and re-run:\n\n```\n    $ time liquid -d --notermination
  -i . Data/ByteString.hs > log 2>&1\n\n    real\t0m11.584s\n    user\t0m6.008s\n
  \   sys\t    0m0.696s\n```\n\nThe diff is only performed against **code**, i.e.
  if you only change\nspecifications, qualifiers, measures, etc. `liquid -d` will
  not perform\nany checks. In this case, you may specify individual definitions to
  verify:\n\n```\n    $ liquid -b bar -b baz foo.hs\n```\n\nThis will verify `bar`
  and `baz`, as well as any functions they use.\n\nIf you always want to run a given
  file with diff-checking, add\nthe pragma:\n\n    {-@ LIQUID \"--diff\" @-}\n\n\nFull
  Checking (DEFAULT)\n-----------------------\n\nTo force LiquidHaskell to check the
  **whole** file (DEFAULT), use:\n\n    $ liquid --full foo.hs\n\nto the file. This
  will override any other `--diff` incantation\nelsewhere (e.g. inside the file.)\n\n\nIf
  you always want to run a given file with full-checking, add\nthe pragma:\n\n    {-@
  LIQUID \"--full\" @-}\n\nSpecifying Different SMT Solvers\n--------------------------------\n\nBy
  default, LiquidHaskell uses the SMTLIB2 interface for Z3.\n\nTo run a different
  solver (supporting SMTLIB2) do:\n\n    $ liquid --smtsolver=NAME foo.hs\n\nCurrently,
  LiquidHaskell supports\n\n+ [CVC4](http://cvc4.cs.stanford.edu/web/)\n+ [MathSat](http://mathsat.fbk.eu/download.html
  )\n\nTo use these solvers, you must install the corresponding binaries\nfrom the
  above web-pages into your `PATH`.\n\nYou can also build and link against the Z3
  API (faster but requires more\ndependencies). If you do so, you can use that interface
  with:\n\n    $ liquid --smtsolver=z3mem foo.hs\n\n\nShort Error Messages\n--------------------\n\nBy
  default, subtyping error messages will contain the inferred type, the\nexpected
  type -- which is **not** a super-type, hence the error -- and a\ncontext containing
  relevant variables and their type to help you understand\nthe error. If you don't
  want the above and instead, want only the\n**source position** of the error use:\n\n
  \   --short-errors\n\nShort (Unqualified) Module Names\n-------------------------------\n\nBy
  default, the inferred types will have fully qualified module names.\nTo use unqualified
  names, much easier to read, use:\n\n    --short-names\n\nDisabling Checks on Functions\n-----------------------------\n\nYou
  can _disable_ checking of a particular function (e.g. because it is unsafe,\nor
  somehow not currently outside the scope of LH) by using the `ignore` directive.\n\nFor
  example,\n\n```haskell\n{-@ ignore foo @-}\n```\n\nwill _disable_ the checking of
  the code for the top-level binder `foo`.\n\nSee `tests/pos/Ignores.hs` for an example.\n\n\nTotality
  Check\n--------------\n\nLiquidHaskell proves the absence of pattern match failures.\n\nFor
  example, the definition\n\n    fromJust :: Maybe a -> a\n    fromJust (Just a) =
  a\n\nis not total and it will create an error message.\nIf we exclude `Nothing`
  from its domain, for example using the following specification\n\n    {-@ fromJust
  :: {v:Maybe a | (isJust v)} -> a @-}\n\n`fromJust` will be safe.\n\nUse the `no-totality`
  flag to disable totality checking.\n\n    liquid --no-totality test.hs\n\nTermination
  Check\n-----------------\n\nBy **default** a termination check is performed on all
  recursive functions.\n\nUse the `--no-termination` option to disable the check\n\n
  \   liquid --no-termination test.hs\n\nIn recursive functions the *first* algebraic
  or integer argument should be decreasing.\n\nThe default decreasing measure for
  lists is length and Integers its value.\n\n### Default Termination Metrics\n\nThe
  user can specify the *size* of a data-type in the data definition\n\n```haskell\n
  \   {-@ data L [llen] a = Nil | Cons { x::a, xs:: L a} @-}\n```\n\nIn the above,
  the measure `llen`, which needs to be defined by the user\n(see below), is defined
  as the *default metric* for the type `L a`. LH\nwill use this default metric to
  _automatically_ prove that the following\nterminates:\n\n```haskell\n    append
  :: L a -> L a -> L a  \n    append N           ys = ys\n    append (Cons x xs) ys
  = Cons x (append xs ys)\n```\n\nas, by default the *first* (non-function) argument
  with an\nassociated size metric is checked to be strictly terminating\nand non-negative
  at each recursive call.\n\nA default termination metric is a Haskell function that
  is proved terminating \nusing structural induction. To deactivate structional induction
  check on the \ntermination metric, use the `--trust-sizes` flag. \n\n### Explicit
  Termination Metrics\n\nHowever, consider the function `reverse`\n\n```haskell\n
  \   reverseAcc :: L a -> L a -> L a  \n    reverseAcc acc N           = acc\n    reverseAcc
  acc (Cons x xs) = reverseAcc (Cons x acc) xs\n```\n\nHere, the first argument does
  not decrease, instead\nthe second does. We can tell LH to use the second\nargument
  using the *explicit termination metric*\n\n```haskell\n    reverseAcc :: L a ->
  xs:L a -> L a / [llen xs]  \n```  \n\nwhich tells LH that the `llen` of the second
  argument `xs`\nis what decreases at each recursive call.\n\nDecreasing expressions
  can be arbitrary refinement expressions, e.g.,\n\n```haskell\n    {-@ merge :: Ord
  a => xs:L a -> ys:L a -> L a / [llen xs + llen ys] @-}\n```\n\nstates that at each
  recursive call of `merge` the _sum of the lengths_\nof its arguments will decrease.\n\n###
  Lexicographic Termination Metrics\n\nSome functions do not decrease on a single
  argument, but rather a\ncombination of arguments, e.g. the Ackermann function.\n\n```haskell\n
  \   {-@ ack :: m:Int -> n:Int -> Nat / [m, n] @-}\n    ack m n\n      | m == 0          =
  n + 1\n      | m > 0 && n == 0 = ack (m-1) 1\n      | m > 0 && n >  0 = ack (m-1)
  (ack m (n-1))\n```\n\nIn all but one recursive call `m` decreases, in the final
  call `m`\ndoes not decrease but `n` does. We can capture this notion of `m`\nnormally
  decreases, but if it does not, `n` will decrease with a\n*lexicographic* termination
  metric `[m, n]`.\n\n\nAn alternative way to express this specification is by annotating\nthe
  function's type with the appropriate *numeric* decreasing expressions.\nAs an example,
  you can give `ack` a type\n\n    {-@ ack :: m:Nat -> n:Nat -> Nat / [m,n] @-}\n\nstating
  that the *numeric* expressions `[m, n]` are lexicographically decreasing.\n\n###
  Mutually Recursive Functions\n\nWhen dealing with mutually recursive functions you
  may run into a\nsituation where the decreasing parameter must be measured *across*
  a\nseries of invocations, e.g.\n\n```haskell\n    even :: Int -> Bool\n    even
  0 = True\n    even n = odd (n-1)\n\n    odd :: Int -> Bool\n    odd  n = not (even
  n)\n```\n\nIn this case, you can introduce a ghost parameter that *orders the functions*\n\n```haskell\n
  \   {-@ isEven :: n:Nat -> z:{v:Int | v = 0} -> Bool / [n, z] @-}\n    isEven ::
  Int -> Int -> Bool\n    isEven 0 _ = True\n    isEven n _ = isOdd (n-1) 1\n\n    {-@
  isOdd :: n:Nat -> z:{v:Int | v = 1} -> Bool / [n, z] @-}\n    isOdd :: Int -> Int
  -> Bool\n    isOdd  n _ = not (isEven n 0)\n```\n\nthus recovering a decreasing
  measure for the pair of functions, the\npair of arguments. This can be encoded with
  the lexicographic\ntermination annotation as shown above.\nSee [tests/pos/mutrec.hs](tests/pos/mutrec.hs)
  for the full example.\n\n### Automatic Termination Metrics\n\nApart from specifying
  a specific decreasing measure for\nan Algebraic Data Type, the user can specify
  that the ADT\nfollows the expected decreasing measure by\n\n```haskell\n    {-@
  autosize L @-}\n```\n\nThen, LH will define an instance of the function `autosize`\nfor
  `L` that decreases by 1 at each recursive call and use\n`autosize` at functions
  that recurse on `L`.\n\nFor example, `autosize L` will refine the data constructors\nof
  `L a` with the `autosize :: a -> Int` information, such\nthat\n\n```haskell\n    Nil
  \ :: {v:L a | autosize v = 0}\n    Cons :: x:a -> xs:L a -> {v:L a | autosize v
  = 1 + autosize xs}\n```\n\nAlso, an invariant that `autosize` is non negative will
  be generated\n\n```haskell\n    invariant  {v:L a| autosize v >= 0 }\n```\n\nThis
  information is all LiquidHaskell needs to prove termination\non functions that recurse
  on `L a` (on ADTs in general.)\n\n\n### Disabling Termination Checking\n\nTo *disable*
  termination checking for `foo` that is,\nto *assume* that it is terminating (possibly
  for some\ncomplicated reason currently beyond the scope of LH)\nyou can write\n\n```haskell\n
  \   {-@ lazy foo @-}\n```\n\nTotal Haskell\n--------------\n\nLiquidHaskell provides
  a total Haskell flag that checks both totallity and termination of the program,\noverriding
  a potential no-termination flag.\n\n    liquid --total-Haskell test.hs\n\n\nLazy
  Variables\n--------------\n\nA variable can be specified as `LAZYVAR`\n\n    {-@
  LAZYVAR z @-}\n\nWith this annotation the definition of `z` will be checked at the
  points where\nit is used. For example, with the above annotation the following code
  is SAFE:\n\n    foo   = if x > 0 then z else x\n      where\n        z = 42 `safeDiv`
  x\n        x = choose 0\n\nBy default, all the variables starting with `fail` are
  marked as LAZY, to defer\nfailing checks at the point where these variables are
  used.\n\nNo measure fields\n------------------\n\nWhen a data type is refined, Liquid
  Haskell automatically turns the data constructor fields into measures.\nFor example,\n\n
  \   {-@ data L a = N | C {hd :: a, tl :: L a} @-}\n\nwill automatically create two
  measures `hd` and `td`.\nTo deactivate this automatic measure definition, and speed
  up verification, you can use the `no-measure-fields` flag.\n\n    liquid --no-measure-fields
  test.hs\n\n\n\nPrune Unsorted Predicates\n--------------------------\n\nThe `--prune-unsorted`
  flag is needed when using *measures over specialized instances* of ADTs. \n\nFor
  example, consider a measure over lists of integers\n\n```haskell\n    sum :: [Int]
  -> Int\n    sum [] = 0\n    sum (x:xs) = 1 + sum xs\n```\n\nThis measure will translate
  into strengthening the types of list constructors\n\n```\n    [] :: {v:[Int] | sum
  v = 0 }\n    (:) :: x:Int -> xs:[Int] -> {v:[Int] | sum v = x + sum xs}\n```\n\nBut
  what if our list is polymorphic `[a]` and later instantiate to list of ints?\nThe
  workaround we have right now is to strengthen the polymorphic list with the \n`sum`
  information\n\n```\n    [] :: {v:[a] | sum v = 0 }\n    (:) :: x:a -> xs:[a] ->
  {v:[a] | sum v = x + sum xs}\n```\n\nBut for non numeric `a`s, refinements like
  `x + sum xs` are ill-sorted! \n\nWe use the flag `--prune-unsorted` to prune away
  unsorted expressions \n(like `x + sum xs`) inside refinements.\n\n\n```\n    liquid
  --prune-unsorted test.hs\n```\n\n\nCase Expansion\n-------------------------\n\nBy
  default LiquidHaskell expands all data constructors to the case statements.\nFor
  example,\nif `F = A1 | A2 | .. | A10`,\nthen LiquidHaskell will expand the code\n`case
  f of {A1 -> True; _ -> False}`\nto `case f of {A1 -> True; A2 -> False; ...; A10
  -> False}`.\nThis expansion can lead to more precise code analysis\nbut it can get
  really expensive due to code explosion.\nThe `no-case-expand` flag prevents this
  expansion and keeps the user\nprovided cases for the case expression.\n\n    liquid
  --no-case-expand test.hs\n\n\nHigher order logic\n-------------------\nThe flag
  `--higherorder` allows reasoning about higher order functions.\n\n\nRestriction
  to Linear Arithmetic\n---------------------------------\nWhen using `z3` as the
  solver, LiquidHaskell allows for non-linear arithmetic:\ndivision and multiplication
  on integers are interpreted by `z3`. To treat division\nand multiplication as uninterpreted
  functions use the `linear` flag\n\n    liquid --linear test.hs\n\nCounter examples
  (Experimental!)\n--------------------------------\nWhen given the `--counter-examples`
  flag, LiquidHaskell will attempt to produce\ncounter-examples for the type errors
  it discovers. For example, see\n[tests/neg/ListElem.hs](https://github.com/ucsd-progsys/liquidhaskell/blob/master/tests/neg/ListElem.hs)\n\n```\n%
  liquid --counter-examples tests/neg/ListElem.hs\n\n...\n\ntests/neg/ListElem.hs:12:1-8:
  Error: Liquid Type Mismatch\n\n 12 | listElem _ []      = False\n      ^^^^^^^^\n\n
  \  Inferred type\n     VV : {VV : Bool | VV == True}\n     VV = True\n\n   not a
  subtype of Required type\n     VV : {VV : Bool | Prop VV <=> Set_mem ?b (listElts
  ?a)}\n\n   In Context\n     ?a : {?a : [a] | len ?a >= 0}\n     ?a = [1]\n\n     ?b
  : a\n     ?b = 0\n```\n\nThe `--counter-examples` flag requires that each type in
  the context be\nan instance of `GHC.Generics.Generic` or `Test.Targetable.Targetable`\n(provided
  as part of LiquidHaskell).  LiquidHaskell cannot generate\ncounter-examples for
  polymorphic types, but will try (naively) to\ninstantiate type variables with `Int`
  (as seen in the example above).\n\nWriting Specifications\n======================\n\nModules
  WITHOUT code\n--------------------\n\nWhen checking a file `target.hs`, you can
  specify an _include_ directory by\n\n    liquid -i /path/to/include/  target.hs\n\nNow,
  to write specifications for some **external module** `Foo.Bar.Baz` for which\nyou
  **do not have the code**, you can create a `.spec` file at:\n\n    /path/to/include/Foo/Bar/Baz.spec\n\nSee,
  for example, the contents of\n\n+ [include/Prelude.spec](https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Prelude.spec)\n+
  [include/Data/List.spec](https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/List.spec)\n+
  [include/Data/Vector.spec](https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/Vector.spec)\n\n**Note**:\n\n+
  The above directories are part of the LH prelude, and included by\n  default when
  running `liquid`.\n+ The `.spec` mechanism is *only for external modules** without
  code,\n  see below for standalone specifications for **internal** or **home** modules.\n\n\nModules
  WITH code: Data\n-----------------------\n\nWrite the specification directly into
  the .hs or .lhs file,\nabove the data definition. See, for example, [tests/pos/Map.hs](tests/pos/Map.hs)\n\n
  \   {-@\n    data Map k a <l :: k -> k -> Prop, r :: k -> k -> Prop>\n      = Tip\n
  \     | Bin (sz    :: Size)\n            (key   :: k)\n            (value :: a)\n
  \           (left  :: Map <l, r> (k <l key>) a)\n            (right :: Map <l, r>
  (k <r key>) a)\n    @-}\n    data Map k a = Tip\n                 | Bin Size k a
  (Map k a) (Map k a)\n\nYou can also write invariants for data type definitions\ntogether
  with the types. For example, see [tests/pos/record0.hs](tests/pos/record0.hs)\n\n
  \   {-@ data LL a = BXYZ { size  :: {v: Int | v > 0 }\n                         ,
  elems :: {v: [a] | (len v) = size }\n                         }\n    @-}\n\nFinally
  you can specify the variance of type variables for data types.\nFor example, see
  [tests/pos/Variance.hs](tests/pos/Variance.hs), where data type `Foo` has four\ntype
  variables `a`, `b`, `c`, `d`, specified as invariant, bivariant,\ncovariant and
  contravariant, respectively.\n\n    data Foo a b c d\n    {-@ data variance Foo
  invariant bivariant covariant contravariant @-}\n\n\nModules WITH code: Functions\n----------------------------\n\nWrite
  the specification directly into the .hs or .lhs file,\nabove the function definition.
  [For example](tests/pos/spec0.hs)\n\n    {-@ incr :: x:{v: Int | v > 0} -> {v: Int
  | v > x} @-}\n    incr   :: Int -> Int\n    incr x = x + 1\n\nModules WITH code:
  Type Classes\n-------------------------------\n\nWrite the specification directly
  into the .hs or .lhs file,\nabove the type class definition. [For example](tests/pos/Class.hs)\n\n
  \   {-@ class Sized s where\n          size :: forall a. x:s a -> {v:Int | v = (size
  x)}\n    @-}\n    class Sized s where\n      size :: s a -> Int\n\nAny measures
  used in the refined class definition will need to be\n*generic* (see [Specifying
  Measures](#specifying-measures)).\n\n\nAs an alternative, you can refine class instances.\n[For
  example](tests/classes/pos/Inst00.hs)\n\n~~~~\ninstance Compare Int where\n\n{-@
  instance Compare Int where\n    cmax :: Odd -> Odd -> Odd\n  @-}\n\ncmax y x = if
  x >= y then x else y\n~~~~\n\nWhen `cmax` method is used on `Int`, liquidHaskell
  will give it\nthe refined type `Odd -> Odd -> Odd`.\n\nNote that currently liquidHaskell
  does not allow refining instances of\nrefined classes.\n\nModules WITH code: QuasiQuotation\n---------------------------------\n\nInstead
  of writing both a Haskell type signature *and* a\nLiquidHaskell specification for
  a function, the `lq`\nquasiquoter in the `LiquidHaskell` module can be used\nto
  generate both from just the LiquidHaskell specification.\n\n```haskell\nmodule Nats
  (nats) where\n\n{-@ nats :: [{v:Int | 0 <= v}] @-}\nnats :: [Int]\nnats = [1,2,3]\n```\n\ncan
  be written as\n\n```haskell\n{-# LANGUAGE QuasiQuotes #-}\nmodule Nats (nats) where\n\nimport
  LiquidHaskell\n\n[lq| nats :: [{v:Int | 0 <= v}] |]\nnats = [1,2,3]\n```\n\nand
  the `lq` quasiquoter will generate the plain `nats :: [Int]` when GHC\ncompiles
  the module.\n\nRefined type aliases (see the next section) can also be written inside
  `lq`; for\nexample:\n\n```haskell\n{-# LANGUAGE QuasiQuoters #-}\nmodule Nats (Nat,
  nats) where\n\n[lq| type Nat = {v:Int | 0 <= v} |]\n\n[lq| nats :: [Nat] |]\nnats
  = [1,2,3]\n```\n\nHere, the `lq` quasiquoter will generate a plain Haskell\ntype
  synonym for `Nat` as well as the refined one.\n\nNote that this is still an experimental
  feature, and\ncurrently requires that one depend on LiquidHaskell\nas a build dependency
  for your project; the quasiquoter\nwill be split out eventually into an independent,\ndependency-light
  package. Also, at this time, writing\na type inside `lq` which refers to a refined
  type alias\nfor which there is not a plain Haskell type synonym of the\nsame name
  will result in a \"not in scope\" error from GHC.\n\nStandalone Specifications for
  Internal Modules\n----------------------------------------------\n\nRecall that
  the `.spec` mechanism is only for modules whose\ncode is absent; if code is present
  then there can be multiple,\npossibly conflicting specifications. Nevertheless,
  you may want,\nfor one reason or another, to write (assumed) specifications\noutside
  the file implementing the module.\n\nYou can do this as follows.\n\n`Lib.hs`\n\n```haskell\nmodule
  Lib (foo) where\n\nfoo a = a\n```\n\nnow, instead of a `.spec` file, just use a
  haskell module, e.g. `LibSpec.hs`\n\n```haskell\nmodule LibSpec ( module Lib ) where\n\nimport
  Lib\n\n-- Don't forget to qualify the name!\n\n{-@ Lib.foo :: {v:a | false} -> a
  @-}\n```\n\nand then here's `Client.hs`\n\n```haskell\nmodule Client where\n\nimport
  Lib      -- use this if you DON'T want the spec\nimport LibSpec  -- use this if
  you DO want the spec, in addition to OR instead of the previous import.\n\nbar =
  foo 1     -- if you `import LibSpec` then this call is rejected by LH\n```\n\nInductive
  Predicates\n--------------------\n\n**Very Experimental**\n\nLH recently added support
  for *Inductive Predicates*\nin the style of Isabelle, Coq etc. These are encoded\nsimply
  as plain Haskell GADTs but suitably refined.\n\nApologies for the minimal documentation;
  see the\nfollowing examples for details:\n\n* [Even and Odd](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/IndEven.hs)\n*
  [Permutations](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/IndPerm.hs)\n*
  [Transitive Closure](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/IndStar.hs)\n*
  [RegExp Derivatives](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/RegexpDerivative.hs)\n*
  [Type Safety of STLC](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/ple/pos/STLC2.hs)\n\nImplicit
  Arguments\n------------------\n\n**Experimental**\n\nThere is experimental support
  for implicit arguments, solved for with congruence closure. For example, consider
  [Implicit1.hs](https://github.com/ucsd-progsys/liquidhaskell/blob/develop/tests/pos/Implicit1.hs):\n\n```haskell\n{-@
  type IntN N = {v:Int | v = N} @-}\n\n{-@ foo :: n:Int ~> (() -> IntN n) -> IntN
  {n+1} @-}\nfoo f = 1 + f ()\n\n{-@ test1 :: IntN 11 @-}\ntest1 = foo (\\_ -> 10)\n```\n\nHere,
  the refinement on `(\\_ -> 10) :: Int -> { v:Int | v = 10 }` allows us to solve
  for `n = 10`, the implicit argument to `foo`.\n\n\nRefinement Type Aliases\n-----------------------\n\n####
  Predicate Aliases\n\nOften, the propositions in the refinements can get rather long
  and\nverbose. You can write predicate aliases like so:\n\n    {-@ predicate Lt X
  Y = X < Y        @-}\n    {-@ predicate Ge X Y = not (Lt X Y) @-}\n\nand then use
  the aliases inside refinements, [for example](tests/pos/pred.hs)\n\n    {-@ incr
  :: x:{v:Int | (Pos v)} -> { v:Int | ((Pos v) && (Ge v x))} @-}\n    incr :: Int
  -> Int\n    incr x = x + 1\n\nSee [Data.Map](benchmarks/esop2013-submission/Base.hs)
  for a more substantial\nand compelling example.\n\n**Syntax:** The key requirements
  for type aliases are:\n\n- Value parameters are specified in **upper**case: `X`,
  `Y`, `Z` etc.\n\n\n#### Class Laws\n\nClass laws can be defined and checked using
  the `class laws` \nand `instance laws` keywords. For an example, see: \n\n* [class-laws/pos/SemiGroup.hs](https://github.com/ucsd-progsys/liquidhaskell/blob/06d22aa070933d9ea833e30d84ed91de2a28eaee/tests/class-laws/pos/SemiGroup.hs)\n*
  [class-laws/pos/SemiGroup.hs](tests/class-laws/pos/SemiGroup.hs)\n\n#### Type Aliases\n\n\nSimilarly,
  it is often quite tedious to keep writing\n\n    {v: Int | v > 0}\n\nThus, LiquidHaskell
  supports refinement-type aliases of the form:\n\n    {-@ type Gt      N = {v: Int
  | N <  v} @-}\n    {-@ type GeNum a N = {v: a   | N <= v} @-}\n\nor\n\n    {-@ type
  SortedList a = [a]<{\\fld v -> (v >= fld)}> @-}\n\nor\n\n    {-@ type OMap k a =
  Map <{\\root v -> v < root}, {\\root v -> v > root}> k a @-}\n\nor\n\n    {-@ type
  MinSPair a = (a, OSplay a) <\\fld -> {v : Splay {v:a|v>fld} | 0=0}> @-}\n\nand then
  use the above in signatures like:\n\n    {-@ incr: x: Int -> GeNum Int x @-}\n\nor\n\n
  \   {-@ incr: x: Int -> Gt x @-}\n\nand:\n\n    {-@ assert insert :: (Ord a) =>
  a -> SortedList a -> SortedList a @-}\n\nsee [tests/pos/ListSort.hs](tests/pos/ListSort.hs)\n\nand:\n\n
  \   {-@ assert insert :: (Ord k) => k -> a -> OMap k a -> OMap k a @-}\n\nsee [tests/pos/Map.hs](tests/pos/Map.hs)\n\n**Syntax:**
  The key requirements for type aliases are:\n\n1. Type parameters are specified in
  **lower**case: `a`, `b`, `c` etc.\n2. Value parameters are specified in **upper**case:
  `X`, `Y`, `Z` etc.\n\n\nInfix Logic Operators\n---------------------\n\nYou can
  define infix operators in logic, following [Haskell's infix notation](https://www.haskell.org/onlinereport/decls.html#fixity).\nFor
  example, if `(+++)` is defined as a measure or reflected function, you can use it
  infix by declaring\n\n    {-@ infixl 9 +++ @-}\n\n\nNote: infix operators cannot
  contain the dot character `.`.\n\n\nSpecifying Measures\n-------------------\n\nCan
  be placed in .spec file or in .hs/.lhs file wrapped around `{-@ @-}`\n\nValue measures:
  [include/GHC/Base.spec](include/GHC/Base.spec)\n\n    measure len :: forall a. [a]
  -> GHC.Types.Int\n    len ([])     = 0\n    len (y:ys)   = 1 + len(ys)\n\nPropositional
  measures: [tests/pos/LambdaEval.hs](tests/pos/LambdaEval.hs)\n\n    {-@\n    measure
  isValue      :: Expr -> Bool\n    isValue (Const i)    = true\n    isValue (Lam
  x e)    = true\n    isValue (Var x)      = false\n    isValue (App e1 e2)  = false\n
  \   isValue (Plus e1 e2) = false\n    isValue (Fst e)      = false\n    isValue
  (Snd e)      = false\n    isValue (Pair e1 e2) = ((? (isValue(e1))) && (? (isValue(e2))))\n
  \   @-}\n\nRaw measures: [tests/pos/meas8.hs](tests/pos/meas8.hs)\n\n    {-@ measure
  rlen :: [a] -> Int\n    rlen ([])   = {v | v = 0}\n    rlen (y:ys) = {v | v = (1
  + rlen(ys))}\n    @-}\n\nGeneric measures: [tests/pos/Class.hs](tests/pos/Class.hs)\n\n
  \   {-@ class measure size :: a -> Int @-}\n    {-@ instance measure size :: [a]
  -> Int\n        size ([])   = 0\n        size (x:xs) = 1 + (size xs)\n    @-}\n
  \   {-@ instance measure size :: Tree a -> Int\n        size (Leaf)       = 0\n
  \       size (Node x l r) = 1 + (size l) + (size r)\n    @-}\n\n**Note:** Measure
  names **do not** have to be the same as\nfield name, e.g. we could call the measure
  `sz` in the above\nas shown in [tests/pos/Class2.hs](tests/pos/Class2.hs).\n\n\nHaskell
  Functions as Measures (beta): [tests/pos/HaskellMeasure.hs](tests/pos/HaskellMeasure.hs)\n\nInductive
  Haskell Functions from Data Types to some type can be lifted to logic\n\n```haskell\n
  \   {-@ measure llen @-}\n    llen        :: [a] -> Int\n    llen []     = 0\n    llen
  (x:xs) = 1 + llen xs\n```\n\nThe above definition\n  - refines list's data constructors
  types with the llen information, and\n  - specifies a singleton type for the haskell
  function\n        `llen :: xs:[a] -> {v:Int | v == llen xs}`\n    If the user specifies
  another type for llen, say\n        `llen :: xs:[a] -> {v:Int | llen xs >= 0}`\n
  \   then the auto generated singleton type is overwritten.\n\nInlines \n-------\n\nThe
  `inline`  lets you use a Haskell function in a type specification. \n\n```\n{-@
  inline max @-}\n{-@ max :: Int -> Int -> Int @-}\nmax :: Int -> Int -> Int\nmax
  x y = if x > y then x else y\n```\n\nFor example, if you write the above you can
  then write a function:\n\n```haskell \n{-@ floor :: x:Int -> {v:Int | max 0 x} @-}\nfloor
  :: Int -> Int\nfloor x \n  | x <= 0    = 0\n  | otherwise = x\n``` \n\nThat is,
  you can use the haskell `max` in the refinement type and \nit will automatically
  get “expanded” out to the full definition. \nThis makes it useful e.g. to reuse
  plain Haskell code to compose \nspecifications, and to share definitions common
  to refinements and code.\n\nHowever, as they are *expanded* at compile time, `inline`
  functions \n**cannot be recursive**. The can call _other_ (non-recursive) inline
  functions.\n\nIf you want to talk about arbitrary (recursive) functions inside your
  types, \nthen you need to use `reflect` described [in the blog] (https://ucsd-progsys.github.io/liquidhaskell-blog/tags/reflection.html)\n\nSelf-Invariants\n===============\n\nSometimes,
  we require specifications that allow *inner* components of a\ntype to refer to the
  *outer* components, typically, to measure-based\nproperties of outer components.
  For example, the following invariant\nabout `Maybe` values\n\n    {-@ type IMaybe
  a = {v0 : Maybe {v : a | ((isJust v0) && v = (fromJust v0))} | 0 = 0 } @-}\n\nstates
  that the *inner* `a` enjoys the property that the *outer* container\nis definitely
  a `Just` and furthermore, the inner value is exactly the same\nas the `fromJust`
  property of the outer container.\n\nAs another example, suppose we have a [measure](include/Data/Set.spec):\n\n
  \   measure listElts :: [a] -> (Set a)\n    listElts([])   = {v | (? Set_emp(v))}\n
  \   listElts(x:xs) = {v | v = Set_cup(Set_sng(x), listElts(xs)) }\n\nNow, all lists
  enjoy the property\n\n    {-@ type IList a = {v0 : List  {v : a | (Set_mem v (listElts
  v0)) } | true } @-}\n\nwhich simply states that each *inner* element is indeed,
  a member of the\nset of the elements belonging to the entire list.\n\nOne often
  needs these *circular* or *self* invariants to connect different\nlevels (or rather,
  to *reify* the connections between the two levels.) See\n[this test](tests/pos/maybe4.hs)
  for a simple example and `hedgeUnion` and\n[Data.Map.Base](benchmarks/esop2013-submission/Base.hs)
  for a complex one.\n\n\n\nAbstract and Bounded Refinements\n================================\n\nThis
  is probably the best example of the abstract refinement syntax:\n\n+ [Abstract Refinements](tests/pos/Map.hs)\n+
  [Bounded Refinements](benchmarks/icfp15/pos/Overview.lhs)\n\nUnfortunately, the
  best documentation for these two advanced features\nis the relevant papers at\n\n+
  [ESOP 2013](https://ranjitjhala.github.io/static/abstract_refinement_types.pdf)\n+
  [ICFP 2015](https://arxiv.org/abs/1507.00385)\n\nThe bounds correspond to Horn implications
  between abstract refinements,\nwhich, as in the classical setting, correspond to
  subtyping constraints\nthat must be satisfied by the concrete refinements used at
  any call-site.\n\nDependent Pairs\n===============\nDependent Pairs are expressed
  by binding the initial tuples of the pair. For example\n`incrPair` defines an increasing
  pair.\n\n    {-@ incrPair :: Int -> (x::Int, {v:Int | x <= v}) @-}\n    incrPair
  i = (i, i+1)\n\nInternally dependent pairs are implemented using abstract refinement
  types.\nThat is `(x::a, {v:b | p x})` desugars to `(a,b)<\\x -> {v:b | p x}>`.\n\nInvariants\n==========\n\nLH
  lets you locally associate invariants with specific data types.\n\nFor example,
  in [tests/measure/pos/Using00.hs](tests/measure/pos/Using00.hs) every\nlist is treated
  as a Stream. To establish this local invariant one can use the\n`using` declaration\n\n
  \   {-@ using ([a]) as  {v:[a] | (len v > 0)} @-}\n\ndenoting that each list is
  not empty.\n\nThen, LiquidHaskell will prove that this invariant holds, by proving
  that *all\ncalls* to List's constructors (ie., `:` and `[]`) satisfy it, and\nwill
  assume that each list element that is created satisfies\nthis invariant.\n\nWith
  this, at the [above](tests/measure/neg/Using00.hs) test LiquidHaskell\nproves that
  taking the `head` of a list is safe.\nBut, at [tests/measure/neg/Using00.hs](tests/measure/neg/Using00.hs)
  the usage of\n`[]` falsifies this local invariant resulting in an \"Invariant Check\"
  error.\n\n\n**WARNING:** There is an older _global_ invariant mechanism that\nattaches
  a refinement to a datatype globally.\nDo not use this mechanism -- it is *unsound*
  and about to\ndeprecated in favor of something that is [actually sound](https://github.com/ucsd-progsys/liquidhaskell/issues/126)\n\nForexample,
  \ the length of a list cannot be negative\n\n    {-@ invariant {v:[a] | (len v >=
  0)} @-}\n\nLiquidHaskell can prove that this invariant holds, by proving that all
  List's\nconstructors (ie., `:` and `[]`) satisfy it.(TODO!) Then, LiquidHaskell\nassumes
  that each list element that is created satisfies\nthis invariant.\n\nFormal Grammar
  of Refinement Predicates\n=======================================\n\n(C)onstants\n-----------\n\n
  \   c := 0, 1, 2, ...\n\n(V)ariables\n-----------\n\n    v := x, y, z, ...\n\n\n(E)xpressions\n-------------\n\n
  \   e := v                      -- variable\n       | c                      --
  constant\n       | (e + e)                -- addition\n       | (e - e)                --
  subtraction\n       | (c * e)                -- multiplication by constant\n       |
  (v e1 e2 ... en)       -- uninterpreted function application\n       | (if p then
  e else e)   -- if-then-else\n\n(R)elations\n-----------\n\n    r := ==               --
  equality\n       | /=               -- disequality\n       | >=               --
  greater than or equal\n       | <=               -- less than or equal\n       |
  >                -- greater than\n       | <                -- less than\n\n\n(P)redicates\n------------\n\n
  \   p := (e r e)          -- binary relation\n       | (v e1 e2 ... en) -- predicate
  (or alias) application\n       | (p && p)         -- and\n       | (p || p)         --
  or\n       | (p => p)         -- implies\n       | (not p)          -- negation\n
  \      | true\n       | false\n\n\nSpecifying Qualifiers\n=====================\n\nThere
  are several ways to specify qualifiers.\n\nBy Separate `.hquals` Files\n---------------------------\n\nYou
  can write qualifier files e.g. [Prelude.hquals](include/Prelude.hquals)\n\nIf a
  module is called or imports\n\n    Foo.Bar.Baz\n\nThen the system automatically
  searches for\n\n    include/Foo/Bar/Baz.hquals\n\nBy Including `.hquals` Files\n----------------------------\n\nAdditional
  qualifiers may be used by adding lines of the form:\n\n    {-@ include <path/to/file.hquals>
  @-}\n\nto the Haskell source. See, [this](tests/pos/meas5.hs) for example.\n\n\nIn
  Haskell Source or Spec Files\n-------------------------------\n\nFinally, you can
  specifiers directly inside source (.hs or .lhs) or spec (.spec)\nfiles by writing
  as shown [here](tests/pos/qualTest.hs)\n\n    {-@ qualif Foo(v:Int, a: Int) : (v
  = a + 100)   @-}\n\n\n**Note** In addition to these, LiquidHaskell scrapes qualifiers
  from all\nthe specifications you write i.e.\n\n1. all imported type signatures,\n2.
  measure bodies and,\n3. data constructor definitions.\n\n\nGenerating HTML Output\n======================\n\nThe
  system produces HTML files with colorized source, and mouseover\ninferred type annotations,
  which are quite handy for debugging failed\nverification attempts.\n\n- **Regular
  Haskell** When you run: `liquid foo.hs` you get a file\n  `foo.hs.html` with the
  annotations. The coloring is done using\n  `hscolour`.\n\n- **Markdown + Literate
  Haskell** You can also feed in literate haskell files\n  where the comments are
  in [Pandoc markdown](http://johnmacfarlane.net/pandoc/demo/example9/pandocs-markdown.html).\n
  \ In this case, the tool will run `pandoc` to generate the HTML from the comments.\n
  \ Of course, this requires that you have `pandoc` installed as a binary on\n  your
  system. If not, `hscolour` is used to render the HTML.\n\n  It is also possible
  to generate *slide shows* from the above.\n  See the [slides directory](docs/slides)
  for an example.\n\nEditor Integration\n==================\n\n+ [Emacs/Flycheck](https://github.com/ucsd-progsys/liquid-types.el)\n+
  [Vim/Syntastic](https://github.com/ucsd-progsys/liquid-types.vim)\n\nCommand Line
  Options\n====================\n\nTo see all options, run `liquid --help`. Here are
  some common options:\n\n- `--cabaldir` will automatically find a .cabal file in
  the ancestor\n  path from which the target file belongs, and then add the relevant\n
  \ source and dependencies to the paths searched for by LiquidHaskell.\n\n  This
  means we don't have to manually do `-i src` etc. when checking\n  large projects,
  which can be tedious e.g. within emacs.\n\n- `--diff` performs differential checking,
  i.e. only checks those binders\n  that have transitively affected by edits since
  the previous check.\n  Can speed things up greatly during editing.\n\n- `--short-names`
  prints out non-qualified names i.e. `Int` instead of\n  `GHC.Types.Int` for inferred
  type annotations and error messages.\n\n**Pragmas** are useful for embedding options
  directly within the source file,\nthat is, somewhere in the file (perhaps at the
  top) put in:\n\n    {-@ LIQUID \"--diff\"        @-}\n    {-@ LIQUID \"--short-names\"
  @-}\n    {-@ LIQUID \"--cabaldir\"    @-}\n\nto have the relevant option be used
  for that file.\n\nGenerating Performance Reports\n------------------------------\n\nWe
  have set up infrastructure to generate performance reports using [Gipeda](https://github.com/nomeata/gipeda).\n\nGipeda
  will generate a static webpage that tracks the performance improvements\nand regressions
  between commits. To generate the site, first ensure you have the\nfollowing dependencies
  available:\n\n* Git\n* Cabal >= 1.18\n* GHC\n* Make\n* Bash (installed at `/bin/bash`)\n\nAfter
  ensuring all dependencies are available, from the Liquid Haskell\ndirectory, execute:\n\n
  \   cd scripts/performance\n    ./deploy-gipeda.bash\n\nThis will download and install
  all the relevant repositories and files. Next, to\ngenerate the performance report,
  use the `generate-site.bash` script. This script\nhas a few options:\n\n* `-s [hash]`:
  Do not attempt to generate performance reports for any commit\nolder than the commit
  specified by the entered git hash\n* `-e [hash]`: Do not attempt to generate performance
  reports for any commit\nnewer than the commit specified by the entered git hash\n*
  `-f`: The default behavior of `generate-site.bash` is to first check if logs\nhave
  been created for a given hash. If logs already exist, `generate-site.bash`\nwill
  not recreate them. Specify this option to skip this check and regenerate\nall logs.\n\nYou
  should expect this process to take a very long time. `generate-site.bash`\nwill
  compile each commit, then run the entire test suite and benchmark suite\nfor each
  commit. It is suggested to provide a manageable range to `generate-site.bash`:\n\n
  \   ./generate-site.bash -s [starting hash] -e [ending hash]\n\n...will generate
  reports for all commits between (inclusive) [starting hash]\nand [ending hash].\n\n
  \   ./generate-site.bash -s [starting hash]\n\n... will generate reports for all
  commits newer than [starting hash]. This command\ncan be the basis for some automated
  report generation process (i.e. a cron job).\n\nFinally, to remove the Gipeda infrastructure
  from your computer, you may execute:\n\n    ./cleanup-gipeda.bash\n\n...which will
  remove any files created by `deploy-gipeda.bash` and `generate-site.bash`\nfrom
  your computer.\n\n\nConfiguration Management\n------------------------\n\nIt is
  very important that the version of Liquid Haskell be maintained properly.\n\nSuppose
  that the current version of Liquid Haskell is `A.B.C.D`:\n\n+ After a release to
  hackage is made, if any of the components `B`, `C`, or `D` are missing, they shall
  be added and set to `0`. Then the `D` component of Liquid Haskell shall be incremented
  by `1`. The version of Liquid Haskell is now `A.B.C.(D + 1)`\n\n+ The first time
  a new function or type is exported from Liquid Haskell, if any of the components
  `B`, or `C` are missing, they shall be added and set to `0`. Then the `C` component
  shall be incremented by `1`, and the `D` component shall stripped. The version of
  Liquid Haskell is now `A.B.(C + 1)`\n\n+ The first time the signature of an exported
  function or type is changed, or an exported function or type is removed (this includes
  functions or types that Liquid Haskell re-exports from its own dependencies), if
  the `B` component is missing, it shall be added and set to `0`. Then the `B` component
  shall be incremented by `1`, and the `C` and `D` components shall be stripped. The
  version of Liquid Haskell is now `A.(B + 1)`\n\n+ The `A` component shall be updated
  at the sole discretion of the project owners.\n\nUpdating GHC\n============\n\nHere's
  a script to generate the diff for the `desugar` modules.\n\n```\nexport GHCSRC=$HOME/Documents/ghc\n\n#
  Checkout GHC-8.2.2\n(cd $GHCSRC && git checkout ghc-8.2.2 && git pull)\n\n# make
  a patch\ndiff -ur $GHCSRC/compiler/deSugar src/Language/Haskell/Liquid/Desugar >
  liquid.patch\n\n# Checkout GHC-8.4.3\n(cd $GHCSRC && git checkout ghc-8.2.2 && git
  pull)\n\n# Copy GHC desugarer to temporary directory\ncp -r $GHCSRC/compiler/deSugar
  .\n\n# Patch\n(cd deSugar && patch -p5 --merge --ignore-whitespace < ../liquid.patch)\n\n#
  Copy stuff over\nfor i in src/Language/Haskell/Liquid/Desugar/*.*; do j=$(basename
  $i); echo $j; cp deSugar/$j src/Language/Haskell/Liquid/Desugar; done\n```\n\n\nHere's
  the magic diff that we did at some point that we keep bumping up to new GHC versions:\n\nhttps://github.com/ucsd-progsys/liquidhaskell/commit/d380018850297b8f1878c33d0e4c586a1fddc2b8#diff-3644b76a8e6b3405f5492d8194da3874R224
  \n\n\n"
license-name: BSD-3-Clause

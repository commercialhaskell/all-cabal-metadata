homepage: https://github.com/thma/generic-persistence#readme
changelog-type: ''
hash: 54b22ae9ba281da88865e237dd847eb63029447fd79b891cbe7c78ca8a0816d2
test-bench-deps:
  base: '>=4.7 && <5'
  HDBC: <2.5
  hspec: <2.10
  generic-deriving: <1.15
  convertible: <1.2
  HDBC-sqlite3: <2.4
  generic-persistence: -any
  QuickCheck: <2.15
  hspec-discover: <2.10
maintainer: thma@apache.org
synopsis: Database persistence using generics
changelog: ''
basic-deps:
  base: '>=4.7 && <5'
  HDBC: <2.5
  generic-deriving: <1.15
  convertible: <1.2
  HDBC-sqlite3: <2.4
  generic-persistence: -any
all-versions:
- 0.2.0.0
- 0.2.0.1
- 0.3.0.0
author: Thomas Mahler
latest: 0.3.0.0
description-type: markdown
description: "# GenericPersistence - A Haskell Persistence Layer using Generics\n\n[![Actions
  Status](https://github.com/thma/generic-persistence/workflows/Haskell%20CI/badge.svg)](https://github.com/thma/generic-persistence/actions)\n\n![GP
  Logo](https://github.com/thma/generic-persistence/blob/main/gp-logo-300.png?raw=true)\n\n##
  Introduction\n\nGenericPersistence is a minimalistic Haskell persistence layer for
  relational databases. \nThe approach relies on [GHC.Generics](https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Generics.html).
  The actual database access is provided by the [HDBC](https://hackage.haskell.org/package/HDBC)
  library.\n\nThe *functional goal* of the persistence layer is to provide hassle-free
  RDBMS persistence for Haskell data types in \nRecord notation (for brevity I call
  them *Entities*).\n\nThat is, it provides means for inserting, updating, deleting
  and quering such enties to/from relational databases.\n\nThe main *design goal*
  is to minimize the *boilerplate* code required:\n\n- no manual instantiation of
  type classes\n- no implementation of encoders/decoders\n- no special naming convention
  for types and their attributes \n- no special types to define entities and attributes\n-
  no Template Haskell scaffolding of glue code\n\nIn an ideal world we would be able
  to take any POHO (Plain old Haskell Object) \nand persist it to any RDBMS without
  any additional effort.\n\n## Status\n\nThe library is in an early stage of development.
  All test cases are green and it should be ready for early adopters.\nSeveral things
  are still missing:\n\n- A query language\n- Handling auto-incrementing primary keys\n-
  caching\n- coding free support for 1:1 and 1:n relationships (using more generics
  magic)\n- schema migration\n- ...\n\nFeature requests, feedback and pull requests
  are welcome!\n\n## Available on Hackage\n\n[https://hackage.haskell.org/package/generic-persistence](https://hackage.haskell.org/package/generic-persistence)\n\nAdd
  the following to your `package.yaml` file:\n\n```yaml\ndependencies:\n- generic-persistence\n```\n\nI
  would also recommend to add the setting `language: GHC2021`  to your `package.yaml`
  file:\n\n```yaml\nlanguage: GHC2021\n```\n\nThis drastically reduces the amount
  of LANGUAGE extensions that need to be added to your source files.\n\n\n## Short
  demo\n\nHere now follows a short demo that shows how the library looks and feels
  from the user's point of view.\n\n```haskell\n{-# LANGUAGE DeriveAnyClass #-} --
  allows automatic derivation from Entity type class\n\nmodule Main (main) where\n\nimport
  \          Database.GP         \nimport           Database.HDBC\nimport           Database.HDBC.Sqlite3\nimport
  \          GHC.Generics\n\n-- | An Entity data type with several fields, using record
  syntax.\ndata Person = Person\n  { personID :: Int,\n    name     :: String,\n    age
  \     :: Int,\n    address  :: String\n  }\n  deriving (Generic, Entity, Show) --
  deriving Entity allows us to use the GenericPersistence API\n\n\nmain :: IO ()\nmain
  = do\n  -- connect to a database\n  conn <- connect SQLite <$> connectSqlite3 \"sqlite.db\"\n\n
  \ -- initialize Person table\n  setupTableFor @Person conn\n\n  -- create a Person
  entity\n  let alice = Person {personID = 123456, name = \"Alice\", age = 25, address
  = \"Elmstreet 1\"}\n\n  -- insert a Person into a database\n  insert conn alice\n\n
  \ -- update a Person\n  update conn alice {address = \"Main Street 200\"}\n\n  --
  select a Person from a database\n  -- The result type must be provided by the call
  site, \n  -- as `retrieveEntityById` has a polymorphic return type `IO (Maybe a)`.\n
  \ alice' <- retrieveById @Person conn \"123456\" \n  print alice'\n\n  -- select
  all Persons from a database\n  allPersons <- retrieveAll @Person conn\n  print allPersons\n\n
  \ -- delete a Person from a database\n  delete conn alice\n\n  -- select all Persons
  from a database. Now it should be empty.\n  allPersons' <- retrieveAll conn :: IO
  [Person]\n  print allPersons'\n\n  -- close connection\n  disconnect conn\n```\n\n##
  How it works\n\nIn order to store Haskell data types in a relational database, we
  need to define a mapping between Haskell types and database tables.\nThis mapping
  is defined by the `Entity` type class. This type class comes with default implementations
  for all methods which define \nthe standard behaviour. (The default implementations
  internally use `GHC.Generics`.)\n\nThis default mapping will work for many cases,
  but it can be customized by overriding the default implementations.\n\n### The Entity
  type class\n\nThe `Entity` type class specifies the following methods:\n\n```haskell\nclass
  (Generic a, HasConstructor (Rep a), HasSelectors (Rep a)) => Entity a where\n  --
  | Converts a database row to a value of type 'a'.\n  fromRow :: Conn -> [SqlValue]
  -> IO a\n\n  -- | Converts a value of type 'a' to a database row.\n  toRow :: Conn
  -> a -> IO [SqlValue]\n\n  -- | Returns the name of the primary key field for a
  type 'a'.\n  idField :: String\n\n  -- | Returns a list of tuples that map field
  names to column names for a type 'a'.\n  fieldsToColumns :: [(String, String)]\n\n
  \ -- | Returns the name of the table for a type 'a'.\n  tableName :: String\n```\n\n###
  Default Behaviour\n\n`idField`, `fieldsToColumns` and `tableName` are used to define
  the mapping between Haskell types and database tables.\n\n- The default implementations
  of `idField` returns a default value for the field name of the primary key field
  of a type `a`:\nThe type name in lower case, plus \"ID\".\nE.g. `idField @Book`
  will return `\"bookID\"`.\n\n- `tableName` returns the name of the database table
  used for type `a`. The default implementation simply returns the constructor name
  of `a`. E.g. `tableName @Book` will return `\"Book\"`.\n\n- `fieldsToColumns` returns
  a list of tuples that map field names of type `a` to database column names for a
  type. The default implementation simply returns a list of tuples that map the field
  names of `a` to the field names of `a`. E.g. `fieldsToColumns @Person` will return
  `[(\"personID\",\"personID\"),(\"name\",\"name\"),(\"age\",\"age\"),(\"address\",\"address\")]`.\n\n`fromRow`
  and `toRow` are used to convert between Haskell types and database rows. \n\n- `fromRow`
  converts a database row, represented by a `[SqlValue]` to a value of type `a`. \n\n-
  `toRow` converts a value of type `a` to a `[SqlValue]`, representing a database
  row. \n\nThe default implementations of `fromRow` and `toRow` expects that type
  `a` has a single constructor and a selector for each field. All fields are expected
  to have a 1:1 mapping to a column in the database table.\nThus each field must have
  a type that can be converted to and from a `SqlValue`. \n\nFor example \n\n```haskell\ntoRow
  conn (Person {personID = 1234, name = \"Alice\", age = 27, address = \"Elmstreet
  1\"}) \n````\n\nwill return \n\n```haskell\n[SqlInt64 1234,SqlString \"Alice\",SqlInt64
  27,SqlString \"Elmstreet 1\"]\n```\n\nAnd `fromRow` does the inverse: \n```haskell\nfromRow
  conn [SqlInt64 1234,SqlString \"Alice\",SqlInt64 27,SqlString \"Elmstreet 1\"] ::
  IO Person\n``` \n\nreturns \n\n```haskell\nPerson {personID = 1234, name = \"Alice\",
  age = 27, address = \"Elmstreet 1\"}\n```\n\nThe conversion functions `toRow` and
  `fromRow` both carry an additional `Conn` argument. This argument is not used by
  the default implementations, but it can be used to provide database access during
  the conversion process. We will cover this later.\n\n### Customizing the default
  behaviour\n\nThe default implementations of `idField`, `fieldsToColumns`, `tableName`,
  `fromRow` and `toRow` can be customized by overriding the default implementations.\nOveriding
  `idField`, `fieldsToColumns` and `tableName` will be required when your database
  tables do not follow the default naming conventions.\n\nFor example, if we have
  a database table `BOOK_TBL` with the following columns:\n\n```sql\nCREATE TABLE
  BOOK_TBL \n  ( bookId INTEGER PRIMARY KEY, \n    bookTitle TEXT, \n    bookAuthor
  TEXT, \n    bookYear INTEGER\n  );\n```\nand we want to map this table to a Haskell
  data type `Book`:\n\n```haskell\ndata Book = Book\n  { book_id :: Int,\n    title
  \  :: String,\n    author  :: String,\n    year    :: Int\n  }\n  deriving (Generic,
  Show)\n```\n\nThen we can customize the default implementations of `idField`, `fieldsToColumns`
  and `tableName` to achieve the desired mapping:\n\n```haskell\ninstance Entity Book
  where\n  -- this is the primary key field of the Book data type (not following the
  default naming convention)\n  idField = \"book_id\"\n\n  -- this defines the mapping
  between the field names of the Book data type and the column names of the database
  table\n  fieldsToColumns = [(\"book_id\", \"bookId\"), (\"title\", \"bookTitle\"),
  (\"author\", \"bookAuthor\"), (\"year\", \"bookYear\")]\n\n  -- this is the name
  of the database table\n  tableName = \"BOOK_TBL\"\n```\n\nOverriding `fromRow` and
  `toRow` will be required when your database tables do not follow the default mapping
  conventions.\nWe will see some examples in later sections.\n\n## Handling enumeration
  fields\n\nSay we have a data type `Book` with an enumeration field of type `BookCategory`:\n\n```haskell\ndata
  Book = Book\n  { bookID :: Int,\n    title   :: String,\n    author  :: String,\n
  \   year    :: Int,\n    category :: BookCategory\n  }\n  deriving (Generic, Entity,
  Show)\n\ndata BookCategory = Fiction | Travel | Arts | Science | History | Biography
  | Other\n  deriving (Generic, Show, Enum)\n```\n\nIn this case everything works
  out of the box, because *GenericPersistence* provides `Convertible` instances for
  all `Enum` types. `Convertible` instances are used to convert between Haskell types
  and database types.\n\nIf you do not want to use `Enum` types for your enumeration
  fields, you have to implement `Convertible` instances manually:\n\n```haskell\ndata
  BookCategory = Fiction | Travel | Arts | Science | History | Biography | Other\n
  \ deriving (Generic, Show, Read)\n\ninstance Convertible BookCategory SqlValue where\n
  \ safeConvert = Right . toSql . show\n  \ninstance Convertible SqlValue BookCategory
  where\n  safeConvert = Right . read . fromSql  \n```\n\n## Handling embedded Objects\n\nSay
  we have a data type `Article` with a field of type `Author`:\n\n```haskell\ndata
  Article = Article\n  { articleID :: Int,\n    title     :: String,\n    author    ::
  Author,\n    year      :: Int\n  }\n  deriving (Generic, Show, Eq)\n\ndata Author
  = Author\n  { authorID :: Int,\n    name     :: String,\n    address  :: String\n
  \ }\n  deriving (Generic, Show, Eq)  \n```\n\nIf we don't want to store the `Author`
  as a separate table, we can use the following approach to embed the `Author` into
  the `Article` table:\n\n```haskell\ninstance Entity Article where\n  -- in the fields
  to column mapping we specify that all fields of the \n  -- Author type are also
  mapped to columns of the Article table:\n  fieldsToColumns :: [(String, String)]\n
  \ fieldsToColumns = [(\"articleID\", \"articleID\"),\n                       (\"title\",
  \"title\"), \n                       (\"authorID\", \"authorID\"), \n                       (\"authorName\",
  \"authorName\"), \n                       (\"authorAddress\", \"authorAddress\"),\n
  \                      (\"year\", \"year\")\n                    ]\n\n  -- in fromRow
  we have to manually construct the Author object from the \n  -- respective columns
  of the Article table and insert it \n  -- into the Article object:\n  fromRow _conn
  row = return $ Article (col 0) (col 1) author (col 5)\n    where\n      col i =
  fromSql (row !! i)\n      author = Author (col 2) (col 3) (col 4)\n\n  -- in toRow
  we have to manually extract the fields of the Author object\n  -- and insert them
  into the respective columns of the Article table:\n  toRow _conn a = return [toSql
  (articleID a), toSql (title a), toSql authID, toSql authorName, toSql authorAddress,
  toSql (year a)]\n    where \n      authID = authorID (author a)\n      authorName
  = name (author a)\n      authorAddress = address (author a)\n```\n\n## Handling
  1:1 references\n\nIf we have the same data types as in the previous example, but
  we want to store the `Author` in a separate table, we can use the following approach:\n\n```haskell\ndata
  Article = Article\n  { articleID :: Int,\n    title     :: String,\n    author    ::
  Author,\n    year      :: Int\n  }\n  deriving (Generic, Show, Eq)\n\ndata Author
  = Author\n  { authorID :: Int,\n    name     :: String,\n    address  :: String\n
  \ }\n  deriving (Generic, Entity, Show, Eq)\n\n\ninstance Entity Article where\n
  \ fieldsToColumns :: [(String, String)]                      -- ommitting the author
  field,\n  fieldsToColumns =                                          -- as this
  can not be mapped to a single column\n    [ (\"articleID\", \"articleID\"),                            --
  instead we invent a new column authorID         \n      (\"title\", \"title\"),\n
  \     (\"authorID\", \"authorID\"),\n      (\"year\", \"year\")\n    ]\n\n  fromRow
  :: Conn -> [SqlValue] -> IO Article\n  fromRow conn row = do    \n    authorById
  <- fromJust <$> retrieveById conn (row !! 2)  -- load author by foreign key\n    return
  $ rawArticle {author = authorById}                -- add author to article\n    where\n
  \     rawArticle = Article (col 0) (col 1)                   -- create article from
  row, \n                           (Author (col 2) \"\" \"\") (col 3)    -- using
  a dummy author\n        where\n          col i = fromSql (row !! i)\n\n  toRow ::
  Conn -> Article -> IO [SqlValue]\n  toRow conn a = do\n    persist conn (author
  a)                                  -- persist author first\n    return [toSql (articleID
  a), toSql (title a),            -- return row for article table where \n            toSql
  $ authorID (author a), toSql (year a)]     -- authorID is foreign key to author
  table \n```\n\nPersisting the `Author`as a side effect in `toRow` may sound like
  an *interesting* idea...\nThis step is optional. But then the user has to make sure
  that the `Author` is persisted before the `Article` is persisted.\n\n\n## Handling
  1:n references\n\nNow let's change the previous example by having a list of Articles
  in the `Author` type:\n\n```haskell\ndata Author = Author\n  { authorID :: Int,\n
  \   name     :: String,\n    address  :: String,\n    articles :: [Article]\n  }\n
  \ deriving (Generic, Show, Eq)\n\ndata Article = Article\n  { articleID :: Int,\n
  \   title     :: String,\n    authorId  :: Int,\n    year      :: Int\n  }\n  deriving
  (Generic, Entity, Show, Eq)\n```\n\nSo now we have a `1:n` relationship between
  `Author` and `Article`. \n\nWe can handle this situation by using the following
  instance declaration for `Author`:\n\n```haskell\ninstance Entity Author where\n
  \ fieldsToColumns :: [(String, String)]                   -- ommitting the articles
  field, \n  fieldsToColumns =                                       -- as this can
  not be mapped to a single column\n    [ (\"authorID\", \"authorID\"),\n      (\"name\",
  \"name\"),\n      (\"address\", \"address\")\n    ]\n\n  fromRow :: Conn -> [SqlValue]
  -> IO Author\n  fromRow conn row = do\n    let authID = head row                                 --
  authorID is the first column\n    articlesBy <- retrieveAllWhere conn \"authorId\"
  authID -- retrieve all articles by this author\n    return rawAuthor {articles =
  articlesBy}              -- add the articles to the author\n    where\n      rawAuthor
  = Author (col 0) (col 1) (col 2) []       -- create the author from row (w/o articles)\n
  \     col i = fromSql (row !! i)                          -- helper function to
  convert SqlValue to Haskell type\n\n  toRow :: Conn -> Author -> IO [SqlValue]\n
  \ toRow conn a = do\n    mapM_ (persist conn) (articles a)                     --
  persist all articles of this author (update or insert)\n    return [toSql (authorID
  a),                           -- return the author as a list of SqlValues\n            toSql
  (name a), toSql (address a)]\n```\n\nPersisting all articles of an author as a side
  effect during the conversion of the author to a row may seem *special*...\nYou can
  ommit this step. But then you have to persist the articles manually before persisting
  the author.\n\n## Integrating user defined queries\n\nAs of now, the library only
  supports very basic support for queries:\n\n- `retrieveById` retrieves a single
  row of a table by its primary key\n- `retrieveAll` retrieves all rows of a table\n-
  `retrieveAllWhere` retrieves all rows of a table where a given column has a given
  value\n\nIf you want to use more complex queries, you can integrate HDBC SQL queries
  by using the `entitiesFromRows` function as in the following example:\n\n```haskell\nmain
  :: IO ()\nmain = do\n  -- connect to a database\n  conn <- connect SQLite <$> connectSqlite3
  \":memory:\" \n\n  -- initialize Person table\n  setupTableFor @Person conn\n\n
  \ let alice = Person 1 \"Alice\" 25 \"123 Main St\"\n      bob = Person 2 \"Bob\"
  30 \"456 Elm St\"\n      charlie = Person 3 \"Charlie\" 35 \"789 Pine St\"\n      dave
  = Person 4 \"Dave\" 40 \"1011 Oak St\"\n      eve = Person 5 \"Eve\" 45 \"1213 Maple
  St\"\n      frank = Person 6 \"Frank\" 50 \"1415 Walnut St\"\n      people = [alice,
  bob, charlie, dave, eve, frank]\n      \n  -- insert all persons into the database\n
  \ insertMany conn people\n\n  -- perform a custom query with HDBC\n  stmt = \"SELECT
  * FROM Person WHERE age >= ?\"\n  resultRows <- quickQuery conn stmt [toSql (40
  :: Int)]\n\n  -- convert the resulting rows into a list of Person objects\n  fourtplussers
  <- entitiesFromRows @Person conn resultRows\n  print fourtplussers\n```\n\nOf course
  this approach is not type safe. It is up to the user to make sure that the query
  returns the correct columns. \n\n## The `Conn` Connection Type\n\nThe `Conn` type
  is a wrapper around an `IConnection` obtained from an HDBC backend driver like `HDBC-sqlite3`
  or `hdbc-postgresql`. It is used to pass the connection to the database to *Generic-Persistence*.
  All functions of the library that require a database connection take a `Conn` as
  an argument.\n\nHDBC provides a very similar type called `ConnectionWrapper`. The
  main reason for such a wrapper type is to simplify the type signatures of the library
  functions. \n\nIn addition, the `Conn` type provides additional database related
  information that is not available in the `ConnectionWrapper` type. For example,
  the `Conn` type contains the name of the database driver that is used. This information
  can be used to generate the correct SQL statements for different database backends.\n`Conn`
  also carries a flag that indicates whether implicit commits should be used by the
  library. This flag is set to `True` by default. If you want to use explicit commits,
  you can set the flag to `False` by modifying the `Conn` value:\n  \n```haskell\nc
  <- connect SQLite <$> connectSqlite3 \":memory:\"\nlet conn = c {implicitCommit
  = False}\n```\n\n\n"
license-name: BSD-3-Clause

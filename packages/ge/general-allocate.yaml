homepage: ''
changelog-type: markdown
hash: a70b43477ce63da8ad7d841b8924506f34c1e55433ff3a81b86715d6c3da9fb3
test-bench-deps: {}
maintainer: shea@shealevy.com
synopsis: Exception-safe resource management in more monads
changelog: |
  # Revision history for general-allocate

  ## 0.1.0.0 -- 2022-12-14

  * First version.
basic-deps:
  base: ^>=4.14 || ^>=4.16 || ^>=4.17
  safe-exceptions: ^>=0.1
  containers: ^>=0.6
  mtl: ^>=2.2 || ^>=2.3
  transformers: ^>=0.5 || ^>=0.6
  resourcet: ^>=1.3
  primitive: ^>=0.7
all-versions:
- 0.1.0.0
author: Shea Levy
latest: 0.1.0.0
description-type: haddock
description: |-
  Write monad-generic resource-safe code that can be instantiated in both
  IO and pure contexts.

  [exceptions](https://hackage.haskell.org/package/exceptions) provides @MonadMask@,
  which generalizes the @bracket@ pattern but only for monads that can catch exceptions
  (i.e., transformer stacks on top of @IO@ or @Either SomeException@). [resourcet](https://hackage.haskell.org/package/resourcet)
  provides @MonadResource@,
  which allows for arbitrarily interleaved allocations and releases of resources, but only
  for @MonadUnliftIO@. This module provides type-classes for both types of resource allocation
  which can be properly instantiated at more monads, through the expedient of weakening a
  requirement which doesn't matter in the cases where it's not met: In monads that can't catch
  exceptions, release actions will not be called in the case of an exception (asynchronous or
  otherwise), but in those same monads the entire monadic computation will be terminated by
  the same exception and so resource management has ended anyway.

  See "Control.Monad.With" for scoped (@bracket@-style) resource management.

  See "Control.Monad.Allocate" for arbitrary lifetime resource management.

  See "Data.GeneralAllocate" to define values that can be used for allocation in
  either resource management style.
license-name: Apache-2.0

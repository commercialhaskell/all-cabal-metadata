homepage: https://github.com/Lysxia/generic-data#readme
changelog-type: markdown
hash: f8a4e0ccb6016826567bb47e72dbf8652a2cd725f83a315a46f13331fcd24438
test-bench-deps:
  generic-data: -any
  base: -any
  one-liner: ! '>=1.0'
  criterion: -any
  tasty-hunit: -any
  generic-lens: ! '>=1.1.0.0'
  tasty: -any
  deepseq: -any
maintainer: lysxia@gmail.com
synopsis: Deriving instances with GHC.Generics and related utilities
changelog: |
  # 0.7.0.0

  - Changed `Monoid` instance for `Generically`, to be compatible with users'
    non-generic instances of `Semigroup`. Thanks to yairchu.
  - Add `gcoerce`, `gcoerceBinop`.

  # 0.6.0.1

  - Fix derivation of `Show1` for `(:.:)`

  # 0.6.0.0

  - Add `Surgery` newtype for DerivingVia
  - `Derecordify`, `Typeage`, `RenameFields`, `RenameConstrs`, `OnFields`
    are no longer type families, but defunctionalized symbols
    to be applied using `GSurgery`.

  # 0.5.0.0

  - Specialize `onData` to `Data`
  - Add some instances for `U1` and `V1` in `Microsurgery`
  - Add `OnFields` and `DOnFields` surgeries ("higher-kindification")

  # 0.4.0.0

  - Created `Microsurgery` module. Initial set of surgeries:

      + `Derecordify`
      + `Typeage`
      + `RenameFields`, `RenameConstrs`
      + Some doc about using generic-lens for surgeries

  # 0.3.0.0

  - Add generic implementations of `enumFrom`, `enumFromThen`, `enumFromTo`,
    `enumFromThenTo`. They are actually required to be explicit for correct
    `Enum` instances. Thanks to Topsii.
  - Parameterize `GEnum` by a type-level option, and add `FiniteEnum` option
    to allow `Enum` to be derived for composite types. Thanks to Topsii.

  # 0.2.0.0

  - Remove `Generic.Data.Types.Map`
  - Add `Generic.Data.Data.Types.toData` and `fromData`
  - Remove `Defun` module (subsumed by `first-class-families` package)

  # 0.1.1.0

  - Add `gconIndex`
  - Interface for constructor tags
  - Type-level `Meta` accessors
  - Add basic `Newtype` functions

  # 0.1.0.0

  Released generic-data
basic-deps:
  base: ! '>=4.9 && <5'
  show-combinators: -any
  base-orphans: ! '>=0.8'
  contravariant: -any
all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.2.0.0
- 0.3.0.0
- 0.4.0.0
- 0.5.0.0
- 0.6.0.0
- 0.6.0.1
- 0.7.0.0
author: Li-yao Xia
latest: 0.7.0.0
description-type: markdown
description: |
  # Generic data types in Haskell [![Hackage](https://img.shields.io/hackage/v/generic-data.svg)](https://hackage.haskell.org/package/generic-data) [![Build Status](https://travis-ci.org/Lysxia/generic-data.svg)](https://travis-ci.org/Lysxia/generic-data)

  Utilities for `GHC.Generics`.

  ## Generic deriving for standard classes

  ### Example: generically deriving Semigroup instances for products

  Semi-automatic method using `gmappend`

  ```haskell
  data Foo a = Bar [a] [a] deriving Generic

  instance Semigroup (Foo a) where
    (<>) = gmappend
  ```

  This library also synergizes with the `DerivingVia` extension
  (introduced in GHC 8.6), thanks to the `Generically` newtype.

  ```haskell
  data Foo a = Bar [a] [a]
    deriving Generic
    deriving Semigroup via (Generically (Foo a))
  ```

  These examples can be found in `test/example.hs`.

  ---

  Note for completeness, the first example uses the following extensions and
  imports:

  ```haskell
  {-# LANGUAGE DeriveGeneric #-}

  -- base
  import Data.Semigroup (Semigroup(..))
  import GHC.Generics

  -- generic-data
  import Generic.Data (gmappend)
  import Generic.Data.Orphans ()
  ```

  The second example makes these additions on top:

  ```haskell
  {-# LANGUAGE
      DerivingStrategies,
      DerivingVia #-}  -- since GHC 8.6.1

  -- In addition to the previous imports
  import Generic.Data (Generically(..))
  ```

  ### Supported classes

  Supported classes that GHC currently can't derive: `Semigroup`, `Monoid`,
  `Applicative`, `Alternative`, `Eq1`, `Ord1`, `Show1`.

  Other classes from base are also supported, even though GHC can already derive
  them:

  - `Eq`, `Ord`, `Enum`, `Bounded`, `Show` (derivable by the standard);
  - `Functor`, `Foldable`, `Traversable` (derivable via extensions,
    `DeriveFunctor`, etc.).

  (`Read` is currently not implemented.)

  To derive type classes outside of the standard library, it might be worth
  taking a look at [one-liner](https://hackage.haskell.org/package/one-liner).

  ## Type metadata

  Extract type names, constructor names, number and arities of constructors, etc..

  ## Type surgery

  generic-data offers simple operations (microsurgeries) on generic
  representations.

  More surgeries can be found in
  [generic-data-surgery](https://hackage.haskell.org/package/generic-data-surgery),
  and suprisingly, in
  [generic-lens](https://hackage.haskell.org/package/generic-lens) and
  [one-liner](https://hackage.haskell.org/package/one-liner).

  For more details, see also:

  - the module `Generic.Data.Microsurgery`;

  - the files `test/lens-surgery.hs` and `one-liner-surgery.hs`.

  ### Surgery example

  Derive an instance of `Show` generically for a record type,
  but as if it were not a record.

  ```haskell
  {-# LANGUAGE DeriveGeneric #-}
  import GHC.Generic (Generic)
  import Generic.Data (gshowsPrec)
  import Generic.Data.Microsurgery (toData, derecordify)

  -- An example record type
  newtype T = T { unT :: Int } deriving Generic

  -- Naively deriving Show would result in this being shown:
  --
  -- show (T 3) = "T {unT = 3}"
  --
  -- But instead, with a simple surgery, unrecordify, we can forget T was
  -- declared as a record:
  --
  -- show (T 3) = "T 3"

  instance Show T where
    showsPrec n = gshowsPrec n . derecordify . toData

  -- This example can be found in test/microsurgery.hs
  ```

  Alternatively, using `DerivingVia`:

  ```haskell
  {-# LANGUAGE DeriveGeneric, DerivingVia #-}
  import GHC.Generic (Generic)

  -- Constructors must be visible to use DerivingVia
  import Generic.Data.Microsurgery (Surgery, Surgery'(..), Generically(..), Derecordify)

  data V = V { v1 :: Int, v2 :: Int }
    deriving Generic
    deriving Show via (Surgery Derecordify V)

  -- show (V {v1 = 3, v2 = 4}) = "V 3 4"
  ```

  ---

  ## Related links

  generic-data aims to subsume generic deriving features of the following
  packages:

  - [semigroups](https://hackage.haskell.org/package/semigroups): generic
    `Semigroup`, `Monoid`, but with a heavier dependency footprint.
  - [transformers-compat](https://hackage.haskell.org/package/transformers-compat):
    generic `Eq1`, `Ord1`, `Show1`.
  - [generic-deriving](https://hackage.haskell.org/package/generic-deriving):
    doesn't derive the classes in base (defines clones of these classes as a toy
    example); has Template Haskell code to derive `Generic` (not in generic-data).

  Other relevant links.

  - [deriving-compat](https://hackage.haskell.org/package/deriving-compat):
    deriving with Template Haskell.
  - [one-liner](https://hackage.haskell.org/package/one-liner): another approach
    to using `GHC.Generics` to derive instances of many type classes, including
    but not restricted to the above classes (this is done in
    [one-liner-instances](https://hackage.haskell.org/package/one-liner-instances)).
  - [singletons](https://hackage.haskell.org/package/singletons),
    [first-class-families](https://hackage.haskell.org/package/first-class-families)
    (second one written by me)
    libraries for dependently-typed programming in Haskell.

  ---

  ## Internal module policy

  Modules under `Generic.Data.Internal` are not subject to any versioning policy.
  Breaking changes may apply to them at any time.

  If something in those modules seems useful, please report it or create a pull
  request to export it from an external module.

  ---

  All contributions are welcome. Open an issue or a pull request on Github!
license-name: MIT

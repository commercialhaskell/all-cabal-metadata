homepage: https://github.com/MMZK1526/mmzk-typeid
changelog-type: markdown
hash: fc931fcc35e2c9b26ce1322b411dfeeabc403ec1793415c74f815d24bdb354ff
test-bench-deps:
  bytestring: -any
  base: -any
  time: -any
  hspec: ^>=2.11
  text: -any
  uuid: -any
  entropy: -any
  array: -any
  containers: ^>=0.6
  binary: -any
  hashable: -any
  random: -any
  uuid-types: -any
  aeson: -any
maintainer: Yitang Chen <mmzk1526@ic.ac.uk>
synopsis: A TypeID implementation for Haskell
changelog: "# Revision history for mmzk-typeid\n\n\n## 0.4.0.0 -- 2023-08-08\n\n*
  Support `TypeID` and `KindID` with `UUID` suffixes of version 4.\n  * They are exported
  in `Data.TypeID.V4` and `Data.KindID.V4`.\n  * By default, `TypeID` and `KindID`
  has a `UUID` suffix of version 7.\n  * The default `TypeID` and `KindID` is also
  exported via `Data.TypeID.V7` and\n    `Data.KindID.V7`.\n  * The constructor shapes
  have been changed, but it should not cause any\n    problems since they are not
  exported.\n\n* Remove deprecated `nil` functions.\n\n* Provide some default implementations
  for methods of `IDConv`.\n\n* Fix typoes in the Haddock.\n  \n* Tests for V4 `TypeID`
  and `KindID`.\n\n\n## 0.3.1.0 -- 2023-07-23\n\n* Add `parseStringM`, `parseTextM`,
  and `parseByteStringM` to `IDConv`.\n  * Instead of returning an `Either`, they
  throw an exception when the input is\n    invalid.\n\n* Add unsafe methods to `IDConv`.\n\n*
  Implement `Storable` and `Binary` instances for `TypeID` and `KindID`.\n  * These
  instances are experimental since the specification does not propose\n    any serialisation
  format.\n\n\n## 0.3.0.1 -- 2023-07-18\n\n* Add a version upper-bound for 'uuid-types'.\n\n*
  Fix documentation typos. \n\n\n## 0.3.0.0 -- 2023-07-17\n\n* Use 'uuid-types' package's
  `UUID` instead of a custom type.\n  * `Data.UUID.V7` only retains the generation
  functions.\n  * Other modules are not affected by this change.\n\n* Add `Read` and
  `Hashable` instances for `TypeID` and `KindID`.\n\n* Move `ValidPrefix` and `ToPrefix`
  to `Data.KindID.Class` module.\n  * They are no longer exported from `Data.KindID`.\n\n*
  Remove deprecated functions `unUUID`, `parseStringWithPrefix`,\n  `parseTextWithPrefix`,
  `parseByteStringWithPrefix`, `nil`, and `decorate`.\n\n* Re-implement `Show` instances
  for `TypeID` and `KindID` using pretty-print\n  `toString`.\n\n* Implement `TypeID`
  generation based on stateless `UUID`v7.\n  * It is faster but does not guarantee
  monotonicity if multiple processes are\n    generating `TypeID`s at the same time.\n\n*
  Introduce unsafe `TypeID` and `KindID` functions for parsing and generating.\n  They
  do not check the validity of the input and only behave well when the\n  input is
  guaranteed to be valid.\n\n* Add validity check on `TypeID` and `KindID` generation.\n
  \ * `checkID` checks the prefix and the `UUID`'s version and variant.\n  * `checkIDWithEnv`
  also checks that the `UUID` is generated in the past.\n\n* Deprecate `nilTypeID`
  and `nilKindID` since they are not useful.\n\n* Remove dependency on 'transformers'.\n\n*
  Fix typos in the documentation.\n\n* More tests.\n\n\n## 0.2.0.0 -- 2023-07-14\n\n*
  Implement `KindID` to take arbitrary prefix type.\n  * It can be a `Symbol` as before,
  but it can also be any type that implements\n    `ToPrefix` which dictates how to
  translate the prefix type to a `Symbol`.\n\n* Fix orphan instances for `TypeID`
  and `KindID`.\n\n* Add `FromJSONKey` and `ToJSONKey` instances for `TypeID` and
  `KindID`.\n\n* Introduce `IDType` class to unify the `getPrefix`, `getUUID`, and
  `getTime`\n  functions of `TypeID` and `KindID`.\n\n* Introduce `IDConv` class to
  unify the various conversion functions between\n  `TypeID`/`KindID` and `String`/`Text`/`ByteString`.\n
  \ * The original concrete functions remain, and the class is provided as an\n    alternative.\n\n*
  Make the generation functions work with any `MonadIO` than just `IO`.\n\n* Introduct
  `IDGen` class to unify the generation functions for `TypeID` and\n  `KindID`.\n
  \ * The original concrete functions remain, and the class is provided as an\n    alternative.\n\n*
  Deprecate `unUUID`, `parseStringWithPrefix`, `parseTextWithPrefix`,\n  `parseByteStringWithPrefix`,
  `nil`, and `decorate`. They are either replaced\n  by functions of other names or
  are no longer necessary.\n  * They will be removed in the next major version.\n\n*
  The `UUID` type is expected to be removed in the next major version in favour\n
  \ of the type from the 'uuid-types' package.\n\n* More tests.\n\n\n## 0.1.0.0 --
  2023-07-11\n\n* First version. Released on an unsuspecting world.\n\n* Implement
  `TypeID` as specified at https://github.com/jetpack-io/typeid.\n\n* Add unit tests.\n\n*
  Add type-level `TypeID` prefixes.\n\n* Add `FromJSON` and `ToJSON` instances for
  `TypeID` and `KindID`.\n"
basic-deps:
  bytestring: ^>=0.11
  base: '>=4.16 && <5'
  time: '>=1.11 && <1.13'
  text: ^>=2.0
  uuid: ^>=1.3
  entropy: ^>=0.4
  array: ^>=0.5
  binary: '>=0.8.5 && <0.9'
  hashable: ^>=1.4
  random: ^>=1.2
  uuid-types: ^>=1.0
  aeson: '>=2.1 && <3'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
- 0.3.0.1
- 0.3.1.0
- 0.4.0.0
author: Yitang Chen <mmzk1526@ic.ac.uk>
latest: 0.4.0.0
description-type: markdown
description: |
  # mmzk-typeid

  ## Introduction

  A [TypeID](https://github.com/jetpack-io/typeid) implementation in Haskell. It is a "type-safe, K-sortable, globally unique identifier" extended on top of UUIDv7.

  TypeIDs are canonically encoded as lowercase strings consisting of three parts:

  1. A type prefix (at most 63 characters in all lowercase ASCII [a-z]);
  2. An underscore '_' separator;
  3. A 128-bit UUIDv7 encoded as a 26-character string using a modified base32 encoding.

  For more information, please check out the [specification](https://github.com/jetpack-io/typeid/blob/main/README.md).

  It also serves as a (temporary) UUIDv7 implementation in Haskell, since there are no official ones yet.

  If you notice any issues or have any suggestions, please feel free to open an issue or contact me via email.

  ## Highlights

  In addition to the features provided by [TypeID](https://github.com/jetpack-io/typeid), this implementation also supports:

  1. Generating TypeIDs in a batch. They are guaranteed to have the same timestamp (up to the first 32768 ids) and of ascending order;
  2. Encoding the prefix in the [type level](src/Data/KindID.hs), so that if you accidentally pass in a wrong prefix, the code won't compile, avoiding the need for runtime checks.
  3. Support TypeID with other UUID versions. Currently v7 (default) and v4 are supported.

  ## Quick start

  ```Haskell
  {-# LANGUAGE OverloadedStrings #-}

  import           Control.Exception
  import           Data.TypeID (TypeID)
  import qualified Data.TypeID as TID

  main :: IO ()
  main = do

    -- Make a TypeID with prefix 'mmzk':
    typeID <- TID.genTypeID "mmzk"
    putStrLn $ TID.toString typeID

    -- Get components from the TypeID:
    let prefix = TID.getPrefix typeID -- "mmzk"
        uuid   = TID.getUUID typeID
        time   = TID.getTime typeID -- A 'Word64' representing the timestamp in milliseconds

    -- Make a TypeID without prefix:
    typeID' <- TID.genTypeID ""
    print typeID'

    -- Make 10 TypeIDs in a batch. They are guaranteed to have the same timestamp and of ascending order:
    typeIDs <- TID.genTypeIDs "mmzk" 10
    mapM_ print typeIDs

    -- Parse a TypeID from string:
    case TID.parseString "mmzk_01h455vb4pex5vsknk084sn02q" of
      Left err     -> throwIO err
      Right typeID -> print typeID
  ```

  For a full list of functions on `TypeID`, see [Data.TypeID](src/Data/TypeID.hs).

  ## More Usages

  ### V4 TypeID

  We also support TypeID using UUIDv4, which loses the monoticity property. To use it, simply import `Data.TypeID.V4` instead of `Data.TypeID`.

  ```Haskell
  {-# LANGUAGE OverloadedStrings #-}

  import           Control.Exception
  import           Data.TypeIDV4 (TypeIDV4)
  import qualified Data.TypeIDV4 as TID

  main :: IO ()
  main = do

    -- Make a TypeID with prefix 'mmzk':
    typeID <- TID.genTypeID "mmzk"
    putStrLn $ TID.toString typeID

    -- Get components from the TypeID:
    let prefix = TID.getPrefix typeID -- "mmzk"
        uuid   = TID.getUUID typeID

    -- Make a TypeID without prefix:
    typeID' <- TID.genTypeID ""
    print typeID'

    -- Parse a TypeID from string:
    case TID.parseString "mmzk_5hjpeh96458fct8t49fnf9farw" of
      Left err     -> throwIO err
      Right typeID -> print typeID
  ```

  ### Type-level TypeID (KindID)
  When using `TypeID`, if we want to check if the type matches, we usually need to get the prefix of the `TypeID` and compare it with the desired prefix at runtime. However, with Haskell's type system, we can do this at compile time instead. We call this TypeID with compile-time prefix a KindID.

  Of course, that would require the desired prefix to be known at compile time. This is actually quite common, especially when we are using one prefix for one table in the database.

  For example, suppose we have a function that takes a KindID with the prefix "user", it may have a signature like this: `f :: KindID "user" -> IO ()`.

  Then if we try to pass in a KindID with the prefix "post", the compiler will complain, thus removing the runtime check and the associated overhead.

  All the prefixes are type-checked at compile time, so if we try to pass in invalid prefixes, the compiler (again) will complain.

  ```Haskell
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE TypeApplications #-}

  import           Control.Exception
  import           Data.KindID (KindID)
  import qualified Data.KindID as KID

  main :: IO ()
  main = do

    -- Make a KindID with prefix 'mmzk':
    kindID <- KID.genKindID @"mmzk" -- Has type `KindID "mmzk"`
    putStrLn $ KID.toString kindID

    -- Get components from the KindID:
    let prefix = KID.getPrefix kindID -- "mmzk"
        uuid   = KID.getUUID kindID
        time   = KID.getTime kindID -- A 'Word64' representing the timestamp in milliseconds

    -- Make a KindID without prefix:
    kindID' <- KID.genKindID @"" -- Has type `KindID ""`
    print kindID'

    -- Make 10 KindIDs in a batch. They are guaranteed to have the same timestamp and of ascending order:
    kindIDs <- KID.genKindIDs @"mmzk" 10
    mapM_ print kindIDs

    -- Parse a KindID from string:
    case KID.parseString @"mmzk" "mmzk_01h455vb4pex5vsknk084sn02q" of
      Left err     -> throwIO err
      Right kindID -> print kindID
  ```

  For a full list of functions on `KindID`, see [Data.KindID](src/Data/KindID.hs).

  ### Functions with More General Types
  `TypeID` and `KindID` shares many functions with the same name and functionality. So far, we are using qualified imports to diffentiate them (*e.g* `KID.fromString` and `TID.fromString`). Alternatively, we can use the methods of `IDConv` to use the same functions for both `TypeID` and `KindID`.

  ```Haskell
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE TypeApplication #-}

  import           Control.Exception
  import           Data.KindID
  import           Data.TypeID

  main :: IO ()
  main = do
    -- Make a TypeID with prefix 'mmzk':
    typeID <- genID @TypeID "mmzk"
    print typeID

    -- Make a KindID with prefix 'mmzk':
    kindID <- genID @(KindID "mmzk")
    print kindID

    -- Parse a TypeID from string:
    case string2ID "mmzk_01h455vb4pex5vsknk084sn02q" :: Maybe TypeID of
      Left err     -> throwIO err
      Right typeID -> print typeID

    -- Parse a KindID from string:
    case string2ID "mmzk_01h455vb4pex5vsknk084sn02q" :: Maybe (KindID "mmzk") of
      Left err     -> throwIO err
      Right kindID -> print kindID
  ```

  We no longer need to use qualified imports, but on the down side, we need to add explicit type annotations. Therefore it is a matter of preference.

  Note that with the class methods, the type application with `Symbol` no longer works as the full type must be provided. For example, `string2ID @"mmzk" "mmzk_01h455vb4pex5vsknk084sn02q"` will not compile.

  For a full list of these functions, see [Data.TypeID.Class](src/Data/TypeID/Class.hs).

  ### KindID with Data Kinds
  Instead of using raw `Symbol`s as `KindID` prefixes, we can also define our custom data type for better semantics.

  For example, suppose we have three tables for users, posts, and comments, and each table has a unique prefix, we can design the structure as following:

  ```Haskell
  {-# LANGUAGE DataKinds #-}
  {-# LANGUAGE OverloadedStrings #-}
  {-# LANGUAGE TypeApplications #-}

  import           Data.KindID
  import           Data.KindID.Class

  data Prefix = User | Post | Comment

  instance ToPrefix 'User where
    type PrefixSymbol 'User = "user"

  instance ToPrefix 'Post where
    type PrefixSymbol 'Post = "post"

  instance ToPrefix 'Comment where
    type PrefixSymbol 'Comment = "comment"
  ```

  Now we can use `Prefix` as a prefix for `KindID`s, e.g.

  ```Haskell
  main :: IO ()
  main = do
    -- ...
    userID <- genKindID @'User -- Same as genKindID @"user"
    postID <- genKindID @'Post -- Same as genKindID @"post"
    commentID <- genKindID @'Comment -- Same as genKindID @"comment"
    -- ...
  ```

  For more information, see [Data.KindID.Class](src/Data/KindID/Class.hs).

  ## Note
  Not explicitly exported functions are considered internal and are subjected to changes.
license-name: MIT

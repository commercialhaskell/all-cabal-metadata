homepage: https://github.com/agentm/curryer
changelog-type: markdown
hash: d8bedf3bb94f278d45d53d6f59d9ac08bef968998f7d921790b2fe78f3b898cd
test-bench-deps:
  curryer-rpc: -any
  bytestring: -any
  stm: -any
  base: -any
  criterion: -any
  network: -any
  async: -any
  tasty-hunit: -any
  tasty: -any
  winery: -any
maintainer: agentm@themactionfaction.com
synopsis: Fast, Haskell RPC
changelog: "# v0.2.2 (2022-08-17)\n\n* add support for GHC 9.2\n\t\n# v0.2.1 (2021-12-28)\n\n*
  bump up streamly dependency to 0.8.1 due to streamly internals API change since
  0.8.0\n\n# v0.2 (2021-12-13)\n\n* update for streamly 0.8.0 (we are no longer pegged
  to a pre-release streamly)\n\n# v0.1 (2020-12-27)\n\n* initial release to support
  [Project:M36](https://github.com/agentm/project-m36)\n\t"
basic-deps:
  curryer-rpc: -any
  fast-builder: -any
  exceptions: -any
  bytestring: -any
  optparse-generic: -any
  network-byte-order: -any
  stm: -any
  base: '>=4.12 && <4.17'
  time: -any
  uuid: -any
  network: -any
  async: -any
  containers: -any
  binary: -any
  hashable: -any
  stm-containers: -any
  winery: -any
  streamly: '>=0.8.1'
all-versions:
- '0.1'
- '0.2'
- 0.2.1
- 0.2.2
author: AgentM
latest: 0.2.2
description-type: markdown
description: "# Curryer - Fast Haskell-to-Haskell RPC\n\nCurryer (pun intended) is
  a fast, Haskell-exclusive RPC (remote procedure call) library. By using the latest
  Haskell serialization and streaming libraries, curryer aims to be the fastest and
  easiest means of communicating between Haskell-based processes.\n\nCurryer is inspired
  by the now unmaintained [distributed-process](https://hackage.haskell.org/package/distributed-process)
  library, but is lighter-weight and uses a higher-performance serialization package.\n\n##
  Features\n\n* blocking and non-blocking remote function calls\n* asynchronous server-to-client
  callbacks (for server-initiated notifications)\n* timeouts\n* leverages [winery](https://hackage.haskell.org/package/winery)
  for high-performance serialization\n\n## Requirements\n\n* GHC 8.6+\n\n## Code Example\n\n[Server](https://github.com/agentm/curryer/examples/SimpleKeyValueServer.hs):\n\n```haskell\ndata
  SetKey = SetKey String String\n  deriving (Generic, Show)\n  deriving Serialise
  via WineryVariant SetKey\n\ndata GetKey = GetKey String\n  deriving (Generic, Show)\n
  \ deriving Serialise via WineryVariant GetKey\n\nmain :: IO ()\nmain = do\n  kvmap
  <- M.newIO\n  void $ serve kvRequestHandlers kvmap localHostAddr 8765 Nothing\n
  \ \nkvRequestHandlers :: RequestHandlers (M.Map String String)\nkvRequestHandlers
  = [ RequestHandler $ \\state (SetKey k v) ->\n                        atomically
  $ M.insert v k (connectionServerState state)\n                    , RequestHandler
  $ \\state (GetKey k) ->\n                        atomically $ M.lookup k (connectionServerState
  state)\n                    ]\n```\n\n[Client](https://github.com/agentm/curryer/examples/SimpleKeyValueClient.hs):\n\n```haskell\ndata
  SetKey = SetKey String String\n  deriving (Generic, Show)\n  deriving Serialise
  via WineryVariant SetKey\n\ndata GetKey = GetKey String\n  deriving (Generic, Show)\n
  \ deriving Serialise via WineryVariant GetKey\n\ndata CommandOptions = Get {name
  :: String}\n                    | Set {name :: String, value :: String}\n                    deriving
  (Generic, Show)\n\ninstance ParseRecord CommandOptions\n                    \nmain
  :: IO ()\nmain = do\n  opts <- getRecord \"SimpleKeyValueClient\"\n  conn <- connect
  [] localHostAddr 8765\n  case opts of\n    Get k -> do\n      eRet <- call conn
  (GetKey k)\n      case eRet of\n        Left err -> error (show err)\n        Right
  (Just val) -> putStrLn val\n        Right Nothing -> error \"no such key\"\n    Set
  k v -> do\n      eRet <- call conn (SetKey k v)\n      case eRet of\n        Left
  err -> error (show err)\n        Right () -> pure ()\n\n```"
license-name: LicenseRef-PublicDomain

homepage: https://github.com/agentm/curryer
changelog-type: markdown
hash: f2d45fc5794e502ccf258f9c43d18b11a5dd33b7ab7582ae6e1f6ded402bd86d
test-bench-deps:
  curryer-rpc: -any
  bytestring: -any
  stm: -any
  base: -any
  criterion: -any
  streamly-bytestring: -any
  network: -any
  async: -any
  streamly-core: -any
  tasty-hunit: -any
  tasty: -any
  winery: -any
maintainer: agentm@themactionfaction.com
synopsis: Fast, Haskell RPC
changelog: "# v0.3.1 (2023-10-30)\n\n* enable TCP_NODELAY to reduce intermessage latency\n\n#
  v0.3.0 (2023-04-01)\n\n* require streamly 0.9.0+\n\n# v0.2.2 (2022-08-17)\n\n* add
  support for GHC 9.2\n\t\n# v0.2.1 (2021-12-28)\n\n* bump up streamly dependency
  to 0.8.1 due to streamly internals API change since 0.8.0\n\n# v0.2 (2021-12-13)\n\n*
  update for streamly 0.8.0 (we are no longer pegged to a pre-release streamly)\n\n#
  v0.1 (2020-12-27)\n\n* initial release to support [Project:M36](https://github.com/agentm/project-m36)\n\t"
basic-deps:
  curryer-rpc: -any
  fast-builder: -any
  exceptions: -any
  bytestring: -any
  optparse-generic: -any
  network-byte-order: -any
  stm: -any
  base: '>=4.12 && <4.17'
  time: -any
  uuid: -any
  streamly-bytestring: '>=0.2.0'
  network: -any
  async: -any
  containers: -any
  binary: -any
  streamly-core: '>=0.1.0'
  hashable: -any
  stm-containers: -any
  winery: -any
  streamly: '>=0.9.0'
all-versions:
- '0.1'
- '0.2'
- 0.2.1
- 0.2.2
- 0.3.0
- 0.3.1
author: AgentM
latest: 0.3.1
description-type: markdown
description: "# Curryer - Fast Haskell-to-Haskell RPC\n\nCurryer (pun intended) is
  a fast, Haskell-exclusive RPC (remote procedure call) library. By using the latest
  Haskell serialization and streaming libraries, curryer aims to be the fastest and
  easiest means of communicating between Haskell-based processes.\n\nCurryer is inspired
  by the now unmaintained [distributed-process](https://hackage.haskell.org/package/distributed-process)
  library, but is lighter-weight and uses a higher-performance serialization package.\n\n##
  Features\n\n* blocking and non-blocking remote function calls\n* asynchronous server-to-client
  callbacks (for server-initiated notifications)\n* timeouts\n* leverages [winery](https://hackage.haskell.org/package/winery)
  for high-performance serialization\n\n## Requirements\n\n* GHC 8.6+\n\n## Code Example\n\n[Server](examples/SimpleKeyValueServer.hs):\n\n```haskell\ndata
  SetKey = SetKey String String\n  deriving (Generic, Show)\n  deriving Serialise
  via WineryVariant SetKey\n\ndata GetKey = GetKey String\n  deriving (Generic, Show)\n
  \ deriving Serialise via WineryVariant GetKey\n\nmain :: IO ()\nmain = do\n  kvmap
  <- M.newIO\n  void $ serve kvRequestHandlers kvmap localHostAddr 8765 Nothing\n
  \ \nkvRequestHandlers :: RequestHandlers (M.Map String String)\nkvRequestHandlers
  = [ RequestHandler $ \\state (SetKey k v) ->\n                        atomically
  $ M.insert v k (connectionServerState state)\n                    , RequestHandler
  $ \\state (GetKey k) ->\n                        atomically $ M.lookup k (connectionServerState
  state)\n                    ]\n```\n\n[Client](examples/SimpleKeyValueClient.hs):\n\n```haskell\ndata
  SetKey = SetKey String String\n  deriving (Generic, Show)\n  deriving Serialise
  via WineryVariant SetKey\n\ndata GetKey = GetKey String\n  deriving (Generic, Show)\n
  \ deriving Serialise via WineryVariant GetKey\n\ndata CommandOptions = Get {name
  :: String}\n                    | Set {name :: String, value :: String}\n                    deriving
  (Generic, Show)\n\ninstance ParseRecord CommandOptions\n                    \nmain
  :: IO ()\nmain = do\n  opts <- getRecord \"SimpleKeyValueClient\"\n  conn <- connect
  [] localHostAddr 8765\n  case opts of\n    Get k -> do\n      eRet <- call conn
  (GetKey k)\n      case eRet of\n        Left err -> error (show err)\n        Right
  (Just val) -> putStrLn val\n        Right Nothing -> error \"no such key\"\n    Set
  k v -> do\n      eRet <- call conn (SetKey k v)\n      case eRet of\n        Left
  err -> error (show err)\n        Right () -> pure ()\n\n```\n"
license-name: LicenseRef-PublicDomain

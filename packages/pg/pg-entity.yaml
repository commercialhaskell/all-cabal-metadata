homepage: https://tchoutri.github.io/pg-entity
changelog-type: markdown
hash: a080352564474dd77929e0ca5acdf39fa993ce9ccee7273fa1bfe6c58b196e14
test-bench-deps:
  postgresql-simple-migration: ^>=0.1
  base: -any
  time: -any
  hspec: -any
  text: -any
  uuid: -any
  hspec-pg-transact: ==0.1.0.3
  pg-entity: -any
  hspec-expectations-lifted: -any
  postgresql-simple: -any
  pg-transact: -any
  vector: -any
maintainer: Théophile Choutri
synopsis: A pleasant PostgreSQL layer
changelog: |
  # Revision history for Entity

  ## 0.1.0.0 -- YYYY-mm-dd

  * First version. Released on an unsuspecting world.
basic-deps:
  exceptions: ^>=0.10
  bytestring: ^>=0.10
  base: '>=4.12 && <=4.16'
  time: ^>=1.9
  text: ^>=1.2
  uuid: ^>=1.3
  safe-exceptions: ^>=0.1
  monad-control: ^>=1.0
  resource-pool: ^>=0.2
  parsec: ^>=3.1.14.0
  colourista: ^>=0.1
  text-manipulate: ^>=0.3
  postgresql-simple: ^>=0.6
  pg-transact: ^>=0.3
  template-haskell: '>=2.15.0.0 && <=2.17.0.0'
  vector: ^>=0.12
all-versions:
- 0.0.1.0
author: Théophile Choutri
latest: 0.0.1.0
description-type: markdown
description: "# PG-Entity [![CI-badge][CI-badge]][CI-url] [![docs][docs]][docs-url]
  ![simple-haskell][simple-haskell]\n\nThis library is a pleasant layer on top of
  [postgresql-simple][pg-simple] to safely expand the fields of a table when\nwriting
  SQL queries.  \nIt aims to be a convenient middle-ground between rigid ORMs and
  hand-rolled SQL query strings. Here is its philosophy:\n\n* The serialisation/deserialisation
  part is left to the consumer, so you have to go with your own FromRow/ToRow instances.\n
  \ You are encouraged to adopt data types that model your business, rather than restrict
  yourself within the limits of what\n  an SQL schema can represent. Use an intermediate
  Data Access Object (DAO) that can easily be serialised and deserialised\n  to and
  from a SQL schema, to and from which you will morph your business data-types.\n*
  Illegal states are made harder (but not impossible) to represent. Generic deriving
  of entities is encouraged, and\n  quasi-quoters are provided to denote fields in
  a safer way. \n* Escape hatches are provided at every level. The types that are
  manipulated are Query for which an `IsString` instance exists.\n  Don't force yourself
  to use the higher-level API if the lower-level combinators work for you, and if
  those don't either, “Just Write SQL”™.\n\nIts dependency footprint is optimised
  for my own setups, and as such it makes use of [text][text], [vector][vector] and\n[pg-transact][pg-transact].\n\n\n\nTable
  of Contents\n=================\n\n* [Installation](#installation)\n* [Documentation](#documentation)\n
  \ * [Usage](#usage)\n  * [Escape hatches](#escape-hatches)\n* [Acknowledgements](#acknowledgements)\n\n##
  Installation\n\nAt present time, `pg-entity` is published on Hackage but not on
  Stackage. To use it in your projects, add it in your\ncabal file like this:\n\n```\npg-entity
  ^>= 0.0\n```\n\nor in your `stack.yaml` file:\n\n```\nextra-deps:\n  - pg-entity-0.0.1.0\n```\n\nThe
  following GHC versions are supported:\n\n* 8.8\n* 8.10\n* 9.0\n\n## Documentation\n\nThis
  library aims to be thoroughly tested, by the means of Oleg Grerus' [cabal-docspec][docspec]\nand
  more traditional tests for database roundtrips.\n\nI aim to produce and maintain
  a decent documentation, therefore do not hesitate to raise an issue if you feel
  that\nsomething is badly explained and should be improved.\n\nYou will find the
  Tutorial [here][docs-url], and you will find below a short showcase of the library.\n\n###
  Usage\n\nThe idea is to implement the `Entity` typeclass for the datatypes that
  represent your PostgreSQL table. \n\n```Haskell\n-- Traditional list & string syntax\n{-#
  LANGUAGE OverloadedLists #-}\n{-# LANGUAGE OverloadedStrings #-}\n-- Quasi-quoter
  to construct SQL expressions\n{-# LANGUAGE QuasiQuotes #-}\n-- Deriving machinery\n{-#
  LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE
  DerivingVia #-}\n\nimport Data.UUID (UUID)\nimport Data.Vector (Vector)\nimport
  Database.PostgreSQL.Simple.SqlQQ\n\nimport Database.PostgreSQL.Entity\n\n-- This
  is our Primary Key newtype. It is wrapped in a newtype to make\n-- it impossible
  to mitake with a plain `UUID`, but we still want to\n-- benefit from the pre-existing
  typeclass instances that exist for\n-- `UUID`. You can read the last two lines as:\n--
  > We use the definitions posessed by `UUID` for our own newtype.\nnewtype JobId
  = JobId { getJobId :: UUID }\n  deriving (Eq, Show, FromField, ToField)\n    via
  UUID\n\n-- A straightforward table definition, which lets us use\n-- the DerivingVia
  mechanism to declare the table name\n-- in the `deriving` clause, and infer the
  fields and primary key.\n-- The field names will be converted to snake_case.\n\ndata
  Job\n  = Job { jobId    :: JobId\n        , lockedAt :: UTCTime\n        , jobName
  \ :: Text\n        }\n  deriving stock (Eq, Generic, Show)\n  deriving anyclass
  (FromRow, ToRow)\n  deriving Entity\n    via (GenericEntity '[TableName \"jobs\"]
  Job)\n\n-- In the above deriving clause, we only had to specify the table name in
  order to pluralise it,\n-- leaving the guessing of the primary key and the table
  names to the library.\n\n-- Below is a richer table definition that needs some type
  annotations to help PostgreSQL.\n-- We will have to write out the full instance
  by hand\n\nnewtype BagId = BagId { getBagId :: UUID }\n  deriving (Eq, Show, FromField,
  ToField)\n    via UUID\n\n-- | This is a PostgreSQL Enum, which needs to be marked
  as such in SQL type annotations.\ndata Properties = P1 | P2 | P3\n  deriving stock
  (Eq, Generic, Show)\n  deriving anyclass (FromRow, ToRow)\n\ndata Bag\n  = Bag {
  bagId      :: BagId\n        , someField  :: Vector UUID\n        , properties ::
  Vector Properties\n        }\n  deriving stock (Eq, Generic, Show)\n  deriving anyclass
  (FromRow, ToRow)\n\n\ninstance Entity Bag where\n  tableName  = \"bags\"\n  primaryKey
  = [field| bag_id |]\n  fields     = [ [field| bag_id |]\n               , [field|
  some_field :: uuid[] |]\n               , [field| properties :: properties[] |]\n
  \              ]\n\n-- You can write specialised functions to remove the noise of
  Type Applications\n\ninsertBag :: Bag -> DBT IO ()\ninsertBag = insert -- `insert`
  will be specialised to `Bag`\n\n-- And you can insert raw SQL through postgresql-simple\n\nisJobLocked
  :: Int -> DBT IO (Only Bool)\nisJobLocked jobId = queryOne Select q (Only jobId)\n
  \ where q = [sql| SELECT\n                    CASE WHEN locked_at IS NULL then false\n
  \                        ELSE true\n                     END\n                   FROM
  jobs WHERE job_id = ?\n            |]\n```\n\nFor more examples, see the [BlogPost][BlogPost-module]
  module for the data-type that is used throughout the tests and doctests.\n\n###
  Escape hatches\n\nSafe SQL generation is a complex subject, and it is far from being
  the objective of this library. The main topic it\naddresses is listing the fields
  of a table, which is definitely something easier. This is why every level of this
  wrapper\nis fully exposed, so that you can drop down a level at your convience.\n\nIt
  is my personal belief, firmly rooted in experience, that we should not aim to produce
  statically-checked SQL and have\nit \"verified\" by the compiler. The techniques
  that would allow that in Haskell are still far from being optimised and\nergonomic.
  As such, this library makes no effort to produce semantically valid SQL queries,
  because one would have to\nencode the semantics of SQL in the type system (or in
  a rule engine of some sort), and this is clearly not the kind of\nthings I want
  to spend my youth on.\n\nEach function is tested for its output with doctests, and
  the ones that cannot (due to database connections) are tested\nin the more traditional
  test-suite.\n\nThe conclusion is : Test your DB queries. Test the encoding/decoding.
  Make roundtrip tests for your data-structures.\n\n## Acknowledgements \n\nI wish
  to thank\n\n* Clément Delafargue, whose [anorm-pg-entity][anorm-pg-entity] library
  and its [initial port in Haskell][entity-blogpost-fretlink]\n  are the spiritual
  parents of this library\n* Koz Ross, for his piercing eyes and his immense patience\n*
  Joe Kachmar, who enlightened me many times\n\n[docs]: https://img.shields.io/badge/Tutorial%20and%20Guides-pg--entity-blueviolet\n[docs-url]:
  https://tchoutri.github.io/pg-entity/\n[docspec]: https://github.com/phadej/cabal-extras/blob/master/cabal-docspec/MANUAL.md\n[pg-transact-hspec]:
  https://github.com/jfischoff/pg-transact-hspec.git\n[entity-blogpost-fretlink]:
  https://tech.fretlink.com/yet-another-unsafe-db-layer/\n[anorm-pg-entity]: https://github.com/CleverCloud/anorm-pg-entity\n[pg-simple]:
  https://hackage.haskell.org/package/postgresql-simple\n[pg-transact]: https://hackage.haskell.org/package/pg-transact\n[text]:
  https://hackage.haskell.org/package/text\n[vector]: https://hackage.haskell.org/package/vector\n[CI-badge]:
  https://img.shields.io/github/workflow/status/tchoutri/pg-entity/CI?style=flat-square\n[CI-url]:
  https://github.com/tchoutri/pg-entity/actions\n[simple-haskell]: https://img.shields.io/badge/Simple-Haskell-purple?style=flat-square\n[BlogPost-module]:
  https://github.com/tchoutri/pg-entity/blob/main/src/Database/PostgreSQL/Entity/Internal/BlogPost.hs\n\n"
license-name: MIT

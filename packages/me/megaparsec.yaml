homepage: https://github.com/mrkkrp/megaparsec
changelog-type: markdown
hash: aa17fa6f41e825466e085f5fcaa3ce7c2558b330a324f3638533d1a7fcd1210d
test-bench-deps:
  test-framework-hunit: ==0.3.*
  bytestring: ! '>=0.10 && <2'
  test-framework: ! '>=0.6 && <1'
  base: ! '>=4.6 && <5'
  text: ! '>=0.2'
  megaparsec: ! '>=4.4.0'
  test-framework-quickcheck2: ! '>=0.3 && <0.4'
  criterion: ! '>=0.6.2.1 && <1.2'
  HUnit: ! '>=1.2 && <1.4'
  mtl: ==2.*
  transformers: ! '>=0.4 && <0.6'
  QuickCheck: ! '>=2.4 && <3'
maintainer: Mark Karpov <markkarpov@opmbx.org>
synopsis: Monadic parser combinators
changelog: ! "## Megaparsec 4.4.0\n\n* Now state returned on failure is the exact
  state of parser at the moment\n  when it failed, which makes incremental parsing
  feature much better and\n  opens possibilities for features like “on-the-fly” recovering
  from parse\n  errors.\n\n* The `count` combinator now works with `Applicative` instances
  (previously\n  it worked only with instances of `Alternative`). It's now also faster.\n\n*
  `tokens` and parsers built upon it (such as `string` and `string'`)\n  backtrack
  automatically on failure now, that is, when they fail, they\n  never consume any
  input. This is done to make their consumption model\n  match how error messages
  are reported (which becomes an important thing as\n  user gets more control with
  primitives like `withRecovery`). This means,\n  in particular, that it's no longer
  necessary to use `try` with\n  `tokens`-based parsers. This new feature *does not*
  affect performance in\n  any way.\n\n* New primitive parser `withRecovery` added.
  The parser allows to recover\n  from parse errors “on-the-fly” and continue parsing.
  Once parsing is\n  finished, several parse errors may be reported or ignored altogether.\n\n*
  `eitherP` combinator added.\n\n* Removed `Enum` instance of `Message` type. This
  was Parsec's legacy that\n  we should eliminate now. `Message` does not constitute
  enumeration,\n  `toEnum` was never properly defined for it. The idea to use `fromEnum`
  to\n  determine type of `Message` is also ugly, for this purpose new functions\n
  \ `isUnexpected`, `isExpected`, and `isMessage` are defined in\n  `Text.Megaparsec.Error`.\n\n*
  Minor tweak in signature of `MonadParsec` type class. Collection of\n  constraints
  changed from `Alternative m, Monad m, Stream s t` to\n  `Alternative m, MonadPlus
  m, Stream s t`. This is done to make it easier\n  to write more abstract code with
  older GHC where such primitives as\n  `guard` are defined for instances of `MonadPlus`,
  not `Alternative`.\n\n## Megaparsec 4.3.0\n\n* Canonicalized `Applicative`/`Monad`
  instances. Thanks to Herbert Valerio\n  Riedel.\n\n* Custom messages in `ParseError`
  are printed each on its own line.\n\n* Now accumulated hints are not used with `ParseError`
  records that have\n  only custom messages in them (created with `Message` constructor,
  as\n  opposed to `Unexpected` or `Expected`). This strips “expected” line from\n
  \ custom error messages where it's unlikely to be relevant anyway.\n\n* Added higher-level
  combinators for indentation-sensitive grammars:\n  `indentLevel`, `nonIndented`,
  and `indentBlock`.\n\n## Megaparsec 4.2.0\n\n* Made `newPos` constructor and other
  functions in `Text.Megaparsec.Pos`\n  smarter. Now it's impossible to create `SourcePos`
  with non-positive line\n  number or column number. Unfortunately we cannot use `Numeric.Natural`\n
  \ because we need to support older versions of `base`.\n\n* `ParseError` is now
  a monoid. `mergeError` is used as `mappend`.\n\n* Added functions `addErrorMessages`
  and `newErrorMessages` to add several\n  messages to existing error and to construct
  error with several attached\n  messages respectively.\n\n* `parseFromFile` now lives
  in `Text.Megaparsec.Prim`. Previously we had 5\n  nearly identical definitions of
  the function, varying only in\n  type-specific `readFile` function. Now the problem
  is solved by\n  introduction of `StorableStream` type class. All supported stream
  types\n  are instances of the class out of box and thus we have polymorphic version\n
  \ of `parseFromFile`.\n\n* `ParseError` is now instance of `Exception` (and `Typeable`).\n\n*
  Introduced `runParser'` and `runParserT'` functions that take and return\n  parser
  state. This makes it possible to partially parse input, resume\n  parsing, specify
  non-standard initial textual position, etc.\n\n* Introduced `failure` function that
  allows to fail with arbitrary\n  collection of messages. `unexpected` is now defined
  in terms of\n  `failure`. One consequence of this design decision is that `failure`
  is\n  now method of `MonadParsec`, while `unexpected` is not.\n\n* Removed deprecated
  combinators from `Text.Megaparsec.Combinator`:\n\n    * `chainl`\n    * `chainl1`\n
  \   * `chainr`\n    * `chainr1`\n\n* `number` parser in `Text.Megaparsec.Lexer`
  now can be used with `signed`\n  combinator to parse either signed `Integer` or
  signed `Double`.\n\n## Megaparsec 4.1.1\n\n* Fixed bug in implementation of `sepEndBy`
  and `sepEndBy1` and removed\n  deprecation notes for these functions.\n\n* Added
  tests for `sepEndBy` and `sepEndBy1`.\n\n## Megaparsec 4.1.0\n\n* Relaxed dependency
  on `base`, so that minimal required version of `base`\n  is now 4.6.0.0. This allows
  Megaparsec to compile with GHC 7.6.x.\n\n* `Text.Megaparsec` and `Text.Megaparsec.Prim`
  do not export data types\n  `Consumed` and `Reply` anymore because they are rather
  low-level\n  implementation details that should not be visible to end-user.\n\n*
  Representation of file name and textual position in error messages was\n  made conventional.\n\n*
  Fixed some typos is documentation and other materials.\n\n## Megaparsec 4.0.0\n\n###
  General changes\n\n* Renamed `many1` → `some` as well as other parsers that had
  `many1` part in\n  their names.\n\n* The following functions are now re-exported
  from `Control.Applicative`:\n  `(<|>)`, `many`, `some`, `optional`. See #9.\n\n*
  Introduced type class `MonadParsec` in the style of MTL monad\n  transformers. Eliminated
  built-in user state since it was not flexible\n  enough and can be emulated via
  stack of monads. Now all tools in\n  Megaparsec work with any instance of `MonadParsec`,
  not only with\n  `ParsecT`.\n\n* Added new function `parseMaybe` for lightweight
  parsing where error\n  messages (and thus file name) are not important and entire
  input should be\n  parsed. For example it can be used when parsing of single number
  according\n  to specification of its format is desired.\n\n* Fixed bug with `notFollowedBy`
  always succeeded with parsers that don't\n  consume input, see #6.\n\n* Flipped
  order of arguments in the primitive combinator `label`, see #21.\n\n* Renamed `tokenPrim`
  → `token`, removed old `token`, because `tokenPrim` is\n  more general and original
  `token` is little used.\n\n* Made `token` parser more powerful, now its second argument
  can return\n  `Either [Message] a` instead of `Maybe a`, so it can influence error\n
  \ message when parsing of token fails. See #29.\n\n* Added new primitive combinator
  `hidden p` which hides “expected” tokens in\n  error message when parser `p` fails.\n\n*
  Tab width is not hard-coded anymore. It can be manipulated via\n  `getTabWidth`
  and `setTabWidth`. Default tab-width is `defaultTabWidth`,\n  which is 8.\n\n###
  Error messages\n\n* Introduced type class `ShowToken` and improved representation
  of\n  characters and strings in error messages, see #12.\n\n* Greatly improved quality
  of error messages. Fixed entire\n  `Text.Megaparsec.Error` module, see #14 for more
  information. Made\n  possible normal analysis of error messages without “render
  and re-parse”\n  approach that previous maintainers had to practice to write even
  simplest\n  tests, see module `Utils.hs` in `old-tests` for example.\n\n* Reduced
  number of `Message` constructors (now there are only `Unexpected`,\n  `Expected`,
  and `Message`). Empty “magic” message strings are ignored now,\n  all the library
  now uses explicit error messages.\n\n* Introduced hint system that greatly improves
  quality of error messages and\n  made code of `Text.Megaparsec.Prim` a lot clearer.\n\n###
  Built-in combinators\n\n* All built-in combinators in `Text.Megaparsec.Combinator`
  now work with any\n  instance of `Alternative` (some of them even with `Applicaitve`).\n\n*
  Added more powerful `count'` parser. This parser can be told to parse from\n  `m`
  to `n` occurrences of some thing. `count` is defined in terms of\n  `count'`.\n\n*
  Removed `optionMaybe` parser, because `optional` from\n  `Control.Applicative` does
  the same thing.\n\n* Added combinator `someTill`.\n\n* These combinators are considered
  deprecated and will be removed in future:\n\n    * `chainl`\n    * `chainl1`\n    *
  `chainr`\n    * `chainr1`\n    * `sepEndBy`\n    * `sepEndBy1`\n\n### Character
  parsing\n\n* Renamed some parsers:\n\n    * `alphaNum` → `alphaNumChar`\n    * `digit`
  → `digitChar`\n    * `endOfLine` → `eol`\n    * `hexDigit` → `hexDigitChar`\n    *
  `letter` → `letterChar`\n    * `lower` → `lowerChar`\n    * `octDigit` → `octDigitChar`\n
  \   * `space` → `spaceChar`\n    * `spaces` → `space`\n    * `upper` → `upperChar`\n\n*
  Added new character parsers in `Text.Megaparsec.Char`:\n\n    * `asciiChar`\n    *
  `charCategory`\n    * `controlChar`\n    * `latin1Char`\n    * `markChar`\n    *
  `numberChar`\n    * `printChar`\n    * `punctuationChar`\n    * `separatorChar`\n
  \   * `symbolChar`\n\n* Descriptions of old parsers have been updated to accent
  some\n  Unicode-specific moments. For example, old description of `letter` stated\n
  \ that it parses letters from “a” to “z” and from “A” to “Z”. This is wrong,\n  since
  it used `Data.Char.isAlpha` predicate internally and thus parsed\n  many more characters
  (letters of non-Latin languages, for example).\n\n* Added combinators `char'`, `oneOf'`,
  `noneOf'`, and `string'` which are\n  case-insensitive variants of `char`, `oneOf`,
  `noneOf`, and `string`\n  respectively.\n\n### Lexer\n\n* Rewritten parsing of numbers,
  fixed #2 and #3 (in old Parsec project these\n  are number 35 and 39 respectively),
  added per bug tests.\n\n    * Since Haskell report doesn't say anything about sign,
  `integer` and\n      `float` now parse numbers without sign.\n\n    * Removed `natural`
  parser, it's equal to new `integer` now.\n\n    * Renamed `naturalOrFloat` → `number`
  — this doesn't parse sign too.\n\n    * Added new combinator `signed` to parse all
  sorts of signed numbers.\n\n* Transformed `Text.Parsec.Token` into `Text.Megaparsec.Lexer`.
  Little of\n  Parsec's code remains in the new lexer module. New module doesn't impose\n
  \ any assumptions on user and should be vastly more useful and\n  general. Hairy
  stuff from original Parsec didn't get here, for example\n  built-in Haskell functions
  are used to parse escape sequences and the like\n  instead of trying to re-implement
  the whole thing.\n\n### Other\n\n* Renamed the following functions:\n\n    * `permute`
  → `makePermParser`\n    * `buildExpressionParser` → `makeExprParser`\n\n* Added
  comprehensive QuickCheck test suite.\n\n* Added benchmarks.\n\n## Parsec 3.1.9\n\n*
  Many and various updates to documentation and package description\n  (including
  the homepage links).\n\n* Add an `Eq` instance for `ParseError`.\n\n* Fixed a regression
  from 3.1.6: `runP` is again exported from module\n  `Text.Parsec`.\n\n## Parsec
  3.1.8\n\n* Fix a regression from 3.1.6 related to exports from the main module.\n\n##
  Parsec 3.1.7\n\n* Fix a regression from 3.1.6 related to the reported position of
  error\n  messages. See bug #9 for details.\n\n* Reset the current error position
  on success of `lookAhead`.\n\n## Parsec 3.1.6\n\n* Export `Text` instances from
  `Text.Parsec`.\n\n* Make `Text.Parsec` exports more visible.\n\n* Re-arrange `Text.Parsec`
  exports.\n\n* Add functions `crlf` and `endOfLine` to `Text.Parsec.Char` for handling\n
  \ input streams that do not have normalized line terminators.\n\n* Fix off-by-one
  error in `Token.charControl`.\n\n## Parsec 3.1.4 & 3.1.5\n\n* Bump dependency on
  `text`.\n\n## Parsec 3.1.3\n\n* Fix a regression introduced in 3.1.2 related to
  positions reported by\n  error messages.\n"
basic-deps:
  bytestring: -any
  fail: ==4.9.*
  base: ! '>=4.6 && <5'
  text: ! '>=0.2'
  semigroups: ==0.18.*
  mtl: ==2.*
  transformers: ! '>=0.4 && <0.6'
all-versions:
- '4.0.0'
- '4.1.0'
- '4.1.1'
- '4.2.0'
- '4.3.0'
- '4.4.0'
author: ! 'Megaparsec contributors,

  Paolo Martini <paolo@nemail.it>,

  Daan Leijen <daan@microsoft.com>'
latest: '4.4.0'
description-type: markdown
description: ! "# Megaparsec\n\n[![License FreeBSD](https://img.shields.io/badge/license-FreeBSD-brightgreen.svg)](http://opensource.org/licenses/BSD-2-Clause)\n[![Hackage](https://img.shields.io/hackage/v/megaparsec.svg?style=flat)](https://hackage.haskell.org/package/megaparsec)\n[![Stackage
  Nightly](http://stackage.org/package/megaparsec/badge/nightly)](http://stackage.org/nightly/package/megaparsec)\n[![Stackage
  LTS](http://stackage.org/package/megaparsec/badge/lts)](http://stackage.org/lts/package/megaparsec)\n[![Build
  Status](https://travis-ci.org/mrkkrp/megaparsec.svg?branch=master)](https://travis-ci.org/mrkkrp/megaparsec)\n[![Coverage
  Status](https://coveralls.io/repos/mrkkrp/megaparsec/badge.svg?branch=master&service=github)](https://coveralls.io/github/mrkkrp/megaparsec?branch=master)\n\n*
  [Features](#features)\n    * [Core features](#core-features)\n    * [Character parsing](#character-parsing)\n
  \   * [Permutation parsing](#permutation-parsing)\n    * [Expression parsing](#expression-parsing)\n
  \   * [Lexer](#lexer)\n* [Documentation](#documentation)\n* [Tutorials](#tutorials)\n*
  [Comparison with other solutions](#comparison-with-other-solutions)\n    * [Megaparsec
  and Attoparsec](#megaparsec-and-attoparsec)\n    * [Megaparsec and Parsec](#megaparsec-and-parsec)\n
  \   * [Megaparsec and Parsers](#megaparsec-and-parsers)\n* [Related packages](#related-packages)\n*
  [Authors](#authors)\n* [Contribution](#contribution)\n* [License](#license)\n\nThis
  is an industrial-strength monadic parser combinator library. Megaparsec\nis a fork
  of [Parsec](https://github.com/aslatter/parsec) library originally\nwritten by Daan
  Leijen.\n\n## Features\n\nThis project provides flexible solutions to satisfy common
  parsing\nneeds. The section describes them shortly. If you're looking for\ncomprehensive
  documentation, see the\n[section about documentation](#documentation).\n\n### Core
  features\n\nThe package is built around `MonadParsec`, a MTL-style monad\ntransformer.
  All tools and features work with any instance of\n`MonadParsec`. You can achieve
  various effects combining monad transformers,\ni.e. building monad stack. Since
  most common monad transformers like\n`WriterT`, `StateT`, `ReaderT` and others are
  instances of `MonadParsec`,\nyou can wrap `ParsecT` *in* these monads, achieving,
  for example,\nbacktracking state.\n\nOn the other hand `ParsecT` is instance of
  many type classes as well. The\nmost useful ones are `Monad`, `Applicative`, `Alternative`,
  and\n`MonadParsec`.\n\nThe module\n[`Text.Megaparsec.Combinator`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Combinator.html)\n(its
  functions are included in `Text.Megaparsec`) contains traditional,\ngeneral combinators
  that work with any instance of `Alternative` and some\neven with instances of `Applicative`.\n\nRole
  of `Monad`, `Applicative`, and `Alternative` should be obvious, so\nlet's enumerate
  methods of `MonadParsec` type class. The class represents\ncore, basic functions
  of Megaparsec parsing. The rest of library is built\nvia combination of these primitives:\n\n*
  `failure` allows to fail with arbitrary collection of messages.\n\n* `label` allows
  to add a “label” to any parser, so when it fails the user will\n  see the label
  in the error message where “expected” items are enumerated.\n\n* `hidden` hides
  any parser from error messages altogether, this is\n  officially recommended way
  to hide things, prefer it to the `label \"\"`\n  approach.\n\n* `try` enables backtracking
  in parsing.\n\n* `lookAhead` allows to parse something without consuming input.\n\n*
  `notFollowedBy` succeeds when its argument fails, it does not consume\n  input.\n\n*
  `withRecovery` allows to recover from parse errors “on-the-fly” and\n  continue
  parsing. Once parsing is finished, several parse errors may be\n  reported or ignored
  altogether.\n\n* `eof` only succeeds at the end of input.\n\n* `token` is used to
  parse single token.\n\n* `tokens` makes it easy to parse several tokens in a row.\n\n*
  `getParserState` returns full parser state.\n\n* `updateParserState` applies given
  function on parser state.\n\nThis list of core functions is longer than in some
  other libraries. Our goal\nwas easy and readable implementation of functionality
  provided by every such\nprimitive, not minimal number of them. You can read the
  comprehensive\ndescription of every primitive function in [Megaparsec documentation](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Prim.html).\n\nMegaparsec
  can currently work with the following types of input stream:\n\n* `String` = `[Char]`\n\n*
  `ByteString` (strict and lazy)\n\n* `Text` (strict and lazy)\n\n### Character parsing\n\nMegaparsec
  has decent support for Unicode-aware character parsing. Functions\nfor character
  parsing live in [`Text.Megaparsec.Char`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Char.html)
  (they all are\nincluded in `Text.Megaparsec`). The functions can be divided into
  several\ncategories:\n\n* *Simple parsers* — parsers that parse certain character
  or several\n  characters of the same kind. This includes `newline`, `crlf`, `eol`,\n
  \ `tab`, and `space`.\n\n* *Parsers corresponding to categories of characters* parse
  single character\n  that belongs to certain category of characters, for example:\n
  \ `controlChar`, `spaceChar`, `upperChar`, `lowerChar`, `printChar`,\n  `digitChar`,
  and others.\n\n* *General parsers* that allow you to parse a single character you
  specify\n  or one of given characters, or any character except for given ones, or\n
  \ character satisfying given predicate. Case-insensitive versions of the\n  parsers
  are available.\n\n* *Parsers for sequences of characters* parse strings. These are
  more\n  efficient and provide better error messages than other approaches most\n
  \ programmers can come up with. Case-sensitive `string` parser is available\n  as
  well as case-insensitive `string'`.\n\n### Permutation parsing\n\nFor those who
  are interested in parsing of permutation phrases, there is\n[`Text.Megaparsec.Perm`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Perm.html).
  You have to import the module explicitly, it's not\nincluded in the `Text.Megaparsec`
  module.\n\n### Expression parsing\n\nMegaparsec has a solution for parsing of expressions.
  Take a look at\n[`Text.Megaparsec.Expr`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Expr.html).
  You have to import the module explicitly, it's not\nincluded in the `Text.Megaparsec`.\n\nGiven
  a table of operators that describes their fixity and precedence, you\ncan construct
  a parser that will parse any expression involving the\noperators. See documentation
  for comprehensive description of how it works.\n\n### Lexer\n\n[`Text.Megaparsec.Lexer`](https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Lexer.html)\nis
  a module that should help you write your lexer. If you have used `Parsec`\nin the
  past, this module “fixes” its particularly inflexible\n`Text.Parsec.Token`.\n\n`Text.Megaparsec.Lexer`
  is intended to be imported qualified, it's not\nincluded in `Text.Megaparsec`. The
  module doesn't impose how you should\nwrite your parser, but certain approaches
  may be more elegant than\nothers. An especially important theme is parsing of white
  space, comments,\nand indentation.\n\nThe design of the module allows you quickly
  solve simple tasks and doesn't\nget in your way when you want to implement something
  less standard.\n\n## Documentation\n\nMegaparsec is well-documented. All functions
  and data-types are thoroughly\ndescribed. We pay attention to avoid outdated info
  or unclear phrases in our\ndocumentation. See the [current version of Megaparsec
  documentation on\nHackage](https://hackage.haskell.org/package/megaparsec) for yourself.\n\n##
  Tutorials\n\nYou can visit [site of the project](https://mrkkrp.github.io/megaparsec/)\nwhich
  has [several tutorials](https://mrkkrp.github.io/megaparsec/tutorials.html) that\nshould
  help you to start with your parsing tasks. The site also has\ninstructions and tips
  for Parsec users who decide to switch.\n\n## Comparison with other solutions\n\nThere
  are quite a few libraries that can be used for parsing in Haskell,\nlet's compare
  Megaparsec with some of them.\n\n### Megaparsec and Attoparsec\n\n[Attoparsec](https://github.com/bos/attoparsec)
  is another prominent Haskell\nlibrary for parsing. Although the both libraries deal
  with parsing, it's\nusually easy to decide which you will need in particular project:\n\n*
  *Attoparsec* is much faster but not that feature-rich. It should be used\n  when
  you want to process large amounts of data where performance matters\n  more than
  quality of error messages.\n\n* *Megaparsec* is good for parsing of source code
  or other human-readable\n  texts. It has better error messages and it's implemented
  as monad\n  transformer.\n\nSo, if you work with something human-readable where
  size of input data is\nusually not huge, just go with Megaparsec, otherwise Attoparsec
  may be a\nbetter choice.\n\n### Megaparsec and Parsec\n\nSince Megaparsec is a fork
  of Parsec, it's necessary to list main\ndifferences between the two libraries:\n\n*
  Better error messages. We test our error messages using dense QuickCheck\n  tests.
  Good error messages are just as important for us as correct return\n  values of
  our parsers. Megaparsec will be especially useful if you write\n  compiler or interpreter
  for some language.\n\n* Some quirks and “buggy features” (as well as plain bugs)
  of original\n  Parsec are fixed. There is no undocumented surprising stuff in Megaparsec.\n\n*
  Better support for Unicode parsing in `Text.Megaparsec.Char`.\n\n* Megaparsec has
  more powerful combinators and can parse languages where\n  indentation matters.\n\n*
  Comprehensive QuickCheck test suite covering nearly 100% of our code.\n\n* We have
  benchmarks to detect performance regressions.\n\n* Better documentation, with 100%
  of functions covered, without typos and\n  obsolete information, with working examples.
  Megaparsec's documentation is\n  well-structured and doesn't contain things useless
  to end users.\n\n* Megaparsec's code is clearer and doesn't contain “magic” found
  in original\n  Parsec.\n\nIf you want to see a detailed change log, `CHANGELOG.md`
  may be helpful.\n\nTo be honest Parsec's development has seemingly stagnated. It
  has no test\nsuite (only three per-bug tests), and all its releases beginning from\nversion
  3.1.2 (according or its change log) were about introducing and\nfixing regressions.
  Parsec is old and somewhat famous in Haskell community,\nso we understand there
  will be some kind of inertia, but we advise you use\nMegaparsec from now on because
  it solves many problems of original Parsec\nproject. If you think you still have
  a reason to use original Parsec, open\nan issue.\n\n### Megaparsec and Parsers\n\nThere
  is [Parsers](https://hackage.haskell.org/package/parsers) package,\nwhich is great.
  You can use it with Megaparsec or Parsec, but consider the\nfollowing:\n\n* It depends
  on *both* Attoparsec and Parsec, which means you always grab\n  useless code installing
  it. This is ridiculous, by the way, because this\n  package is supposed to be useful
  for parser builders, so they can write\n  basic core functionality and get the rest
  “for free”. But with these\n  useful functions you get two more parsers as dependencies.\n\n*
  It currently has a bug in definition of `lookAhead` for various monad\n  transformers
  like `StateT`, etc. which is visible when you create\n  backtracking state via monad
  stack, not via built-in features.\n\nWe intended to use Parsers library in Megaparsec
  at some point, but aside\nfrom already mentioned flaws the library has different
  conventions for\nnaming of things, different set of “core” functions, etc., different\napproach
  to lexer. So it didn't happen, Megaparsec has minimal dependencies,\nit is feature-rich
  and self-contained.\n\n## Related packages\n\nThe following packages are designed
  to be used with Megaparsec:\n\n* [`hspec-megaparsec`](https://hackage.haskell.org/package/hspec-megaparsec)\n
  \ — utilities for testing Megaparsec parsers with with\n  [Hspec](https://hackage.haskell.org/package/hspec).\n\n##
  Authors\n\nThe project was started and is currently maintained by Mark Karpov. You
  can\nfind complete list of contributors in `AUTHORS.md` file in official\nrepository
  of the project. Thanks to all the people who propose features and\nideas, although
  they are not in `AUTHORS.md`, without them Megaparsec would\nnot be that good.\n\n##
  Contribution\n\nIssues (bugs, feature requests or otherwise feedback) may be reported
  in\n[the GitHub issue tracker for this project](https://github.com/mrkkrp/megaparsec/issues).\n\nPull
  requests are also welcome (and yes, they will get attention and will be\nmerged
  quickly if they are good, we are progressive folks).\n\nIf you want to write a tutorial
  to be hosted on Megaparsec's site, open an\nissue or pull request [here](https://github.com/mrkkrp/megaparsec-site).\n\n##
  License\n\nCopyright © 2015–2016 Megaparsec contributors<br>\nCopyright © 2007 Paolo
  Martini<br>\nCopyright © 1999–2000 Daan Leijen\n\nDistributed under FreeBSD license.\n"
license-name: BSD2

homepage: https://github.com/aleksey-makarov/melf
changelog-type: markdown
hash: 1622a82aadc9d482861bf39a8b3deb454d9edaeae029fba0e59d661d82480e73
test-bench-deps:
  exceptions: -any
  bytestring: -any
  melf: -any
  base: '>=4.13 && <5.0'
  tasty-golden: '>=2.3.4 && <2.4'
  filepath: '>=1.4.2.1 && <1.5'
  binary: -any
  mtl: -any
  tasty-hunit: '>=0.10.0.3 && <0.11'
  prettyprinter: -any
  tasty: '>=1.4.1 && <1.5'
  directory: '>=1.3.6 && <1.4'
maintainer: aleksey.makarov@gmail.com
synopsis: An Elf parser
changelog: |
  1.3.0
  =====

  - Test with GHC 8.8.4, 8.10.7, 9.0.2, 9.2.7, 9.4.4, 9.6.1
  - Remove dependency on the `singletons` package
  - Move `getString` and `getSectionData` to `Headers.hs`
  - Fix docs
  - Support docs for the data generated by `Data.Elf.Constants.TH`
  - Remove default constructor name parameter in `Data.Elf.Constants.TH`
  - Few minor fixes
  - CI: Use github actions based on `haskell/actions/setup` (use cabal)

  1.2.0
  =====

  - Test with GHC 8.8.4, 8.10.7, 9.0.2, 9.2.4, 9.2.5, 9.4.4
  - Add a fantom parameter type to `ElfXX` to differentiate
    between nodes on the type level.
  - Revise warning options
  - Use monad optics for ELF write builder

  1.1.0
  =====

  - Compile with GHC 8.8, 9.0, 9.2.
  - Set up Github CI to build that.
  - Fix bug that did not allow to specify length of `NOBITS` sections.
  - Misc minor fixes

  1.0.2
  =====

  - Add documentation to `README.md`
  - examples: Rework `DummyLd`, add an x86 test file.
  - examples: Rework the last sections of the `README_ru.md`

  1.0.1
  =====

  - examples: Rename Aarch64 -> AArch64
  - examples: Fuse `MkObj` into `AsmAArch64`, rewrite `MkExe` as `DummyLd`
  - Implement `elfFindSectionByName`
  - Add test data into the hackage tarball

  1.0.0
  =====

  Initial release
basic-deps:
  exceptions: '>=0.10.4 && <0.11'
  bytestring: '>=0.10.10 && <0.12'
  melf: -any
  base: '>=4.13 && <5.0'
  lens: '>=5.0.1 && <5.3'
  binary: '>=0.8.7 && <0.9'
  mtl: '>=2.2.2 && <2.4'
  prettyprinter: '>=1.7.0 && <1.8'
  optparse-applicative: '>=0.16.1 && <0.18'
  template-haskell: '>=2.15 && <2.21'
all-versions:
- 1.0.0
- 1.0.1
- 1.0.2
- 1.1.0
- 1.2.0
- 1.3.0
author: Aleksey Makarov
latest: 1.3.0
description-type: markdown
description: "# melf\n\n> A [Haskell](https://www.haskell.org/) library to parse/serialize\n>
  Executable and Linkable Format ([ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format))\n>
  files.\n\n## Parsing the header and table entries\n\nModule\n[`Data.Elf.Headers`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html)\nimplements
  parsing and serialization of the ELF file header and the entries of section and
  segment tables.\n\nELF files come in two flavors: 64-bit and 32-bit.\nTo differentiate
  between them type\n[`ElfClass`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html#t:ElfClass)\nis
  defined:\n\n``` Haskell\ndata ElfClass\n    = ELFCLASS32 -- ^ 32-bit ELF format\n
  \   | ELFCLASS64 -- ^ 64-bit ELF format\n    deriving (Eq, Show)\n```\n\n[Singleton](https://blog.jle.im/entry/introduction-to-singletons-1.html)\ntypes
  for `ElfClass` are also defined:\n\n``` Haskell\n-- | Singletons for ElfClass\ndata
  SingElfClass :: ElfClass -> Type where\n    SELFCLASS32 :: SingElfClass 'ELFCLASS32
  \ -- ^ Singleton for `ELFCLASS32`\n    SELFCLASS64 :: SingElfClass 'ELFCLASS64  --
  ^ Singleton for `ELFCLASS64`\n```\n\nSome fields of the header and table entries
  have different bitwidth for 64-bit and 32-bit files.\nSo the type\n[`WordXX a`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html#t:WordXX)\nwas
  borrowed from the `data-elf` package:\n\n``` Haskell\n-- | @SingElfClassI a@ is
  defined for each constructor of `ElfClass`.\n--   It defines @WordXX a@, which is
  `Word32` for `ELFCLASS32` and `Word64` for `ELFCLASS64`.\n--   Also it defines singletons
  for each of the `ElfClass` type.\nclass ( Typeable c\n      , Typeable (WordXX c)\n
  \     , Data (WordXX c)\n      , Show (WordXX c)\n      , Read (WordXX c)\n      ,
  Eq (WordXX c)\n      , Ord (WordXX c)\n      , Bounded (WordXX c)\n      , Enum
  (WordXX c)\n      , Num (WordXX c)\n      , Integral (WordXX c)\n      , Real (WordXX
  c)\n      , Bits (WordXX c)\n      , FiniteBits (WordXX c)\n      , Binary (Be (WordXX
  c))\n      , Binary (Le (WordXX c))\n      ) => SingElfClassI (c :: ElfClass) where\n
  \   type WordXX c = r | r -> c\n    singElfClass :: SingElfClass c\n\ninstance SingElfClassI
  'ELFCLASS32 where\n    type WordXX 'ELFCLASS32 = Word32\n    singElfClass = SELFCLASS32\n\ninstance
  SingElfClassI 'ELFCLASS64 where\n    type WordXX 'ELFCLASS64 = Word64\n    singElfClass
  = SELFCLASS64\n```\n\nThe header of the ELF file is represented with the type\n[`HeaderXX
  a`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html#t:HeaderXX):\n\n```
  Haskell\n-- | Parsed ELF header\ndata HeaderXX c =\n    HeaderXX\n        { hData
  \      :: ElfData    -- ^ Data encoding (big- or little-endian)\n        , hOSABI
  \     :: ElfOSABI   -- ^ OS/ABI identification\n        , hABIVersion :: Word8      --
  ^ ABI version\n        , hType       :: ElfType    -- ^ Object file type\n        ,
  hMachine    :: ElfMachine -- ^ Machine type\n        , hEntry      :: WordXX c   --
  ^ Entry point address\n        , hPhOff      :: WordXX c   -- ^ Program header offset\n
  \       , hShOff      :: WordXX c   -- ^ Section header offset\n        , hFlags
  \     :: Word32     -- ^ Processor-specific flags\n        , hPhEntSize  :: Word16
  \    -- ^ Size of program header entry\n        , hPhNum      :: Word16     -- ^
  Number of program header entries\n        , hShEntSize  :: Word16     -- ^ Size
  of section header entry\n        , hShNum      :: Word16     -- ^ Number of section
  header entries\n        , hShStrNdx   :: ElfSectionIndex -- ^ Section name string
  table index\n        }\n```\n\nSo we have two types `HeaderXX 'ELFCLASS64` and `HeaderXX
  'ELFCLASS32`.\nTo be able to work with headers uniformly the type\n[`Header`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html#t:Header)\nwas
  introduced:\n\n``` Haskell\n-- | Header is a sigma type where the first entry defines
  the type of the second one\ndata Header = forall a . Header (SingElfClass a) (HeaderXX
  a)\n```\n\n`Header` is a pair.\nThe first element is an object of the type `SingElfClass`
  defining the width of the word.\nThe second element is `HeaderXX` parametrized with
  the first element (i. e. Î£-type from\nthe languages with dependent types).\n\n`Header`
  is an instance of the\n[`Binary`](https://hackage.haskell.org/package/binary-0.10.0.0/docs/Data-Binary.html#t:Binary)\nclass.\n\nSo
  given a lazy bytestring containing large enough initial part of ELF file one can
  get the header of\nthat file with a function like this:\n\n``` Haskell\nwithHeader
  ::                        BSL.ByteString ->\n    (forall a . SingElfClassI a =>
  HeaderXX a -> b) -> Either String b\nwithHeader bs f =\n    case decodeOrFail bs
  of\n        Left (_, _, err) -> Left err\n        Right (_, _, (Header sing hxx))
  -> Right $ withSingElfClassI sing f hxx\n```\n\nThe function\n[`decodeOrFail`](https://hackage.haskell.org/package/binary-0.10.0.0/docs/Data-Binary.html#v:decodeOrFail)\nis
  defined in the package\n[`binary`](https://hackage.haskell.org/package/binary).\nThe
  function\n[`withSingElfClassI`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html#v:withSingElfClassI)\ncreates
  a context with an implicit word width available and looks like\n[`withSingI`](https://hackage.haskell.org/package/singletons-3.0.1/docs/Data-Singletons.html#v:withSingI):\n\n\n```
  Haskell\n-- | Convenience function for creating a context with an implicit singleton
  available.\nwithSingElfClassI :: SingElfClass c -> (SingElfClassI c => r) -> r\nwithSingElfClassI
  SELFCLASS64 x = x\nwithSingElfClassI SELFCLASS32 x = x\n```\n\nThe module `Data.Elf.Headers`
  also defines the types\n[`SectionXX`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html#t:SectionXX),\n[`SegmentXX`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html#t:SegmentXX)
  and\n[`SymbolXX`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf-Headers.html#t:SymbolXX)\nfor
  the elements of section, segment and symbol tables.\n\n## Parsing the whole ELF
  file\n\nThe module\n[`Data.Elf`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf.html)\nimplements
  parsing and serialization of the whole ELF files.\nTo parse ELF file it reads ELF
  header, section table and segment table and uses that data to create\na list of
  type\n[`ElfListXX`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf.html#t:ElfListXX)\nof
  elements of the type\n[`ElfXX`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf.html#t:ElfXX)\nrepresenting
  the recursive structure of the ELF file.\nIt also restores section names from the
  the string table indexes.\nThat results in creating an object of type\n[`Elf`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf.html#t:Elf):\n\n```
  Haskell\n-- | `Elf` is a forrest of trees of type `ElfXX`.\n-- Trees are composed
  of `ElfXX` nodes, `ElfSegment` can contain subtrees\ndata ElfNodeType = Header |
  SectionTable | SegmentTable | Section | Segment | RawData | RawAlign\n\n-- | List
  of ELF nodes.\ndata ElfListXX c where\n    ElfListCons :: ElfXX t c -> ElfListXX
  c -> ElfListXX c\n    ElfListNull :: ElfListXX c\n\n-- | Elf is a sigma type where
  the first entry defines the type of the second one\ndata Elf = forall a . Elf (SingElfClass
  a) (ElfListXX a)\n\n-- | Section data may contain a string table.\n-- If a section
  contains a string table with section names, the data\n-- for such a section is generated
  and `esData` should contain `ElfSectionDataStringTable`\ndata ElfSectionData c\n
  \   = ElfSectionData                -- ^ Regular section data\n        { esdData
  :: BSL.ByteString -- ^ The content of the section\n        }\n    | ElfSectionDataStringTable
  \    -- ^ Section data will be generated from section names\n    | ElfSectionDataNoBits
  \         -- ^ SHT_NOBITS uninitialized section data: section has size but no content\n
  \       { esdSize :: WordXX c       -- ^ Size of the section\n        }\n\n-- |
  The type of node that defines Elf structure.\ndata ElfXX t c where\n    ElfHeader
  ::\n        { ehData       :: ElfData    -- ^ Data encoding (big- or little-endian)\n
  \       , ehOSABI      :: ElfOSABI   -- ^ OS/ABI identification\n        , ehABIVersion
  :: Word8      -- ^ ABI version\n        , ehType       :: ElfType    -- ^ Object
  file type\n        , ehMachine    :: ElfMachine -- ^ Machine type\n        , ehEntry
  \     :: WordXX c   -- ^ Entry point address\n        , ehFlags      :: Word32     --
  ^ Processor-specific flags\n        } -> ElfXX 'Header c\n    ElfSectionTable ::
  ElfXX 'SectionTable c\n    ElfSegmentTable :: ElfXX 'SegmentTable c\n    ElfSection
  ::\n        { esName      :: String         -- ^ Section name (NB: string, not offset
  in the string table)\n        , esType      :: ElfSectionType -- ^ Section type\n
  \       , esFlags     :: ElfSectionFlag -- ^ Section attributes\n        , esAddr
  \     :: WordXX c       -- ^ Virtual address in memory\n        , esAddrAlign ::
  WordXX c       -- ^ Address alignment boundary\n        , esEntSize   :: WordXX
  c       -- ^ Size of entries, if section has table\n        , esN         :: ElfSectionIndex
  -- ^ Section number\n        , esInfo      :: Word32         -- ^ Miscellaneous
  information\n        , esLink      :: Word32         -- ^ Link to other section\n
  \       , esData      :: ElfSectionData c -- ^ The content of the section\n        }
  -> ElfXX 'Section c\n    ElfSegment ::\n        { epType       :: ElfSegmentType
  -- ^ Type of segment\n        , epFlags      :: ElfSegmentFlag -- ^ Segment attributes\n
  \       , epVirtAddr   :: WordXX c       -- ^ Virtual address in memory\n        ,
  epPhysAddr   :: WordXX c       -- ^ Physical address\n        , epAddMemSize ::
  WordXX c       -- ^ Add this amount of memory after the section when the section
  is loaded to memory by execution system.\n                                         --
  \  Or, in other words this is how much `pMemSize` is bigger than `pFileSize`\n        ,
  epAlign      :: WordXX c       -- ^ Alignment of segment\n        , epData       ::
  ElfListXX c    -- ^ Content of the segment\n        } -> ElfXX 'Segment c\n    --
  | Some ELF files (some executables) don't bother to define\n    -- sections for
  linking and have just raw data in segments.\n    ElfRawData ::\n        { edData
  :: BSL.ByteString -- ^ Raw data in ELF file\n        } -> ElfXX 'RawData c\n    --
  | Align the next data in the ELF file.\n    -- The offset of the next data in the
  ELF file\n    -- will be the minimal @x@ such that\n    -- @x mod eaAlign == eaOffset
  mod eaAlign @\n    ElfRawAlign ::\n        { eaOffset :: WordXX c -- ^ Align value\n
  \       , eaAlign  :: WordXX c -- ^ Align module\n        } -> ElfXX 'RawAlign c\n\ninfixr
  9 ~:\n\n-- | Helper for `ElfListCons`\n(~:) :: ElfXX t a -> ElfListXX a -> ElfListXX
  a\n(~:) = ElfListCons\n```\n\nNot each object of that type can be serialized.\n\n
  \ * Constructor `ElfSection` still has a section number.\n    It is required as
  the symbol table and some other structures\n    refer to the sections by theirs
  indexes.\n    So the section indexes should be consecutive integers starting from
  1.\n    Section with index 0 is always empty and is created by the library.\n\n
  \ * There should be a single `ElfHeader`.  It should be the first nonempty node
  of the tree.\n\n  * If there exists at least one node `ElfSection` then there should
  exist exactly one\n    node `ElfSectionTable` and exactly one section that has `ElfSectionDataStringTable`
  as the value\n    of its `esData` field (the string table for the names of sections).\n\n
  \ * If there exists at least one node `ElfSegment` then there should exist exactly
  one\n    node `ElfSegmentTable`.\n\nCorrectly composed ELF object can be serialized
  with the function\n[`serializeElf`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf.html#v:serializeElf)\nand
  parsed with the function\n[`parseElf`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf.html#v:parseElf):\n\n```
  Haskell\nserializeElf :: MonadThrow m => Elf -> m ByteString\nparseElf :: MonadCatch
  m => ByteString -> m Elf\n```\n\n`ELF` is not an instance of the class `Binary`
  because\n[`PutM`](https://hackage.haskell.org/package/binary-0.10.0.0/docs/Data-Binary-Put.html#t:PutM)\nis
  not an instance of the class `MonadFail`.\n\n## Generation of object files\n\nTo
  create machine code that is used in the examples a pair of modules were created.\nThe
  module\n[`AsmAArch64`](https://github.com/aleksey-makarov/melf/blob/v1.2.0/examples/AsmAArch64.hs)\nprovides
  a DSL embedded in Haskell.\nThis DSL is a kind of assembler language for the AArch64
  platform.\nIt exports some primitives to generate machine instructions and organize
  machine code.\nIt also exports function `assemble` that consumes the monad composed
  of those primitives and\nproduces an object of the type `Elf`:\n\n``` Haskell\nassemble
  :: MonadCatch m => StateT CodeState m () -> m Elf\n```\n\nThe idea was inspired
  by the article\n[\"Monads to Machine Code\"](https://www.stephendiehl.com/posts/monads_machine_code.html)\nby
  Stephen Diehl.\nDetailed description of this module is available in russian:\n[README_ru.md](https://github.com/aleksey-makarov/melf/blob/v1.2.0/examples/README_ru.md)
  (outdated).\n\nThe module\n[`HelloWorld`](https://github.com/aleksey-makarov/melf/blob/v1.2.0/examples/HelloWorld.hs)\nuses
  primitives from `AsmAArch64` to compose relocatable executable code that uses system
  calls\nto output a \"Hello World!\" message into standard output and exit:\n\n```
  Haskell\nhelloWorld :: MonadCatch m => StateT CodeState m ()\n```\n\nFunction `assemble`
  uses the `melf` library to generate an object file:\n\n``` Haskell\n    return $
  Elf SELFCLASS64 $\n        ElfHeader\n            { ehData       = ELFDATA2LSB\n
  \           , ehOSABI      = ELFOSABI_SYSV\n            , ehABIVersion = 0\n            ,
  ehType       = ET_REL\n            , ehMachine    = EM_AARCH64\n            , ehEntry
  \     = 0\n            , ehFlags      = 0\n            }\n        ~: ElfSection\n
  \           { esName      = \".text\"\n            , esType      = SHT_PROGBITS\n
  \           , esFlags     = SHF_EXECINSTR .|. SHF_ALLOC\n            , esAddr      =
  0\n            , esAddrAlign = 8\n            , esEntSize   = 0\n            , esN
  \        = textSecN\n            , esLink      = 0\n            , esInfo      =
  0\n            , esData      = ElfSectionData txt\n            }\n        ~: ElfSection\n
  \           { esName      = \".shstrtab\"\n            , esType      = SHT_STRTAB\n
  \           , esFlags     = 0\n            , esAddr      = 0\n            , esAddrAlign
  = 1\n            , esEntSize   = 0\n            , esN         = shstrtabSecN\n            ,
  esLink      = 0\n            , esInfo      = 0\n            , esData      = ElfSectionDataStringTable\n
  \           }\n        ~: ElfSection\n            { esName      = \".symtab\"\n
  \           , esType      = SHT_SYMTAB\n            , esFlags     = 0\n            ,
  esAddr      = 0\n            , esAddrAlign = 8\n            , esEntSize   = symbolTableEntrySize
  ELFCLASS64\n            , esN         = symtabSecN\n            , esLink      =
  fromIntegral strtabSecN\n            , esInfo      = 1\n            , esData      =
  ElfSectionData symbolTableData\n            }\n        ~: ElfSection\n            {
  esName      = \".strtab\"\n            , esType      = SHT_STRTAB\n            ,
  esFlags     = 0\n            , esAddr      = 0\n            , esAddrAlign = 1\n
  \           , esEntSize   = 0\n            , esN         = strtabSecN\n            ,
  esLink      = 0\n            , esInfo      = 0\n            , esData      = ElfSectionData
  stringTableData\n            }\n        ~: ElfSectionTable\n        ~: ElfListNull\n```\n\nIt
  runs the `State` monad that was passed as an argument.\nAs a result the final state
  of `CodeState` includes all the data neÑessary to produce ELF file, in\nparticular:\n\n
  \ * `txt` refers to the content of the `.text` section,\n  * `symbolTableData` refers
  to the content of the symbol table section,\n  * `stringTableData` refers to the
  content of the string table section linked to the symbol table.\n\nNames with `SecN`
  suffixes (`textSecN`, `shstrtabSecN`, `symtabSecN`, `strtabSecN`)\nare predefined
  section numbers that conform to the conditions stated above.\n\nFor the sake of
  simplicity external symbol resolution and data section allocation were not implemented.\nIt
  requires implementation of relocation tables.  On the other hand, the resulting
  code\nis position-independent.\n\nUse this module to produce object file and try
  to link it:\n\n```\n[nix-shell:examples]$ ghci \nGHCi, version 8.10.7: https://www.haskell.org/ghc/
  \ :? for help\nPrelude> :l AsmAArch64.hs HelloWorld.hs \n[1 of 2] Compiling AsmAArch64
  \      ( AsmAArch64.hs, interpreted )\n[2 of 2] Compiling HelloWorld       ( HelloWorld.hs,
  interpreted )\nOk, two modules loaded.\n*AsmAArch64> import HelloWorld\n*AsmAArch64
  HelloWorld> elf <- assemble helloWorld\n*AsmAArch64 HelloWorld> bs <- serializeElf
  elf\n*AsmAArch64 HelloWorld> BSL.writeFile \"helloWorld.o\" bs\n*AsmAArch64 HelloWorld>
  \nLeaving GHCi.\n\n[nix-shell:examples]$ aarch64-unknown-linux-gnu-gcc -nostdlib
  helloWorld.o -o helloWorld\n\n[nix-shell:examples]$ \n```\n\nThe linker accepted
  the object file.  Try to run the result:\n\n```\n[nix-shell:examples]$ qemu-aarch64
  helloWorld\nHello World!\n\n[nix-shell:examples]$ \n```\n\nIt works.\n\n## Generation
  of executable files\n\nThe module\n[`DummyLd`](https://github.com/aleksey-makarov/melf/blob/v1.2.0/examples/DummyLd.hs)\nuses
  the section `.text` of object file to create an executable file.\nCode relocation
  and symbol resolution is not implemented so that procedure works only\nfor position-independent
  code that does not refer to external translation units,\nfor example, it works with
  the code described above.\n\nFunction `dummyLd` consumes an object of the type `Elf`
  and finds a section `.text`\n(using [`elfFindSectionByName`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf.html#v:elfFindSectionByName))\nand
  header\n(using [`elfFindHeader`](https://hackage.haskell.org/package/melf-1.3.0/docs/Data-Elf.html#v:elfFindHeader))\nin
  it.\nThen the header type is changed to `ET_EXEC`, the address of the first executable
  instruction is specified and\na loadable segment containing the header and the content
  of `.text` is formed:\n\n``` Haskell\ndata MachineConfig a\n    = MachineConfig\n
  \       { mcAddress :: WordXX a -- ^ Virtual address of the executable segment\n
  \       , mcAlign   :: WordXX a -- ^ Required alignment of the executable segment\n
  \                               --   in physical memory (depends on max page size)\n
  \       }\n\ngetMachineConfig :: (SingElfClassI a, MonadThrow m) => ElfMachine ->
  m (MachineConfig a)\ngetMachineConfig EM_AARCH64 = return $ MachineConfig 0x400000
  0x10000\ngetMachineConfig EM_X86_64  = return $ MachineConfig 0x400000 0x1000\ngetMachineConfig
  _          = $chainedError \"could not find machine config for this arch\"\n\ndummyLd'
  :: forall a m . (MonadThrow m, SingElfClassI a) => ElfListXX a -> m (ElfListXX a)\ndummyLd'
  es = do\n\n    section' <- elfFindSectionByName es \".text\"\n\n    txtSectionData
  <- case esData section' of\n        ElfSectionData textData -> return textData\n
  \       _ -> $chainedError \"could not find correct \\\".text\\\" section\"\n\n
  \   header' <- elfFindHeader es\n\n    MachineConfig { .. } <- getMachineConfig
  (ehMachine header')\n\n    return $\n        case header' of\n            ElfHeader
  { .. } ->\n                ElfSegment\n                    { epType       = PT_LOAD\n
  \                   , epFlags      = PF_X .|. PF_R\n                    , epVirtAddr
  \  = mcAddress\n                    , epPhysAddr   = mcAddress\n                    ,
  epAddMemSize = 0\n                    , epAlign      = mcAlign\n                    ,
  epData       =\n                        ElfHeader\n                            {
  ehType  = ET_EXEC\n                            , ehEntry = mcAddress + headerSize
  (fromSing $ sing @a)\n                            , ..\n                            }\n
  \                       ~: ElfRawData\n                            { edData = txtSectionData\n
  \                           }\n                        ~: ElfListNull\n                    }\n
  \               ~: ElfSegmentTable\n                ~: ElfListNull\n\n-- | @dummyLd@
  places the content of \".text\" section of the input ELF\n-- into the loadable segment
  of the resulting ELF.\n-- This could work if there are no relocations or references
  to external symbols.\ndummyLd :: MonadThrow m => Elf -> m Elf\ndummyLd (Elf c l)
  = Elf c <$> withSingElfClassI c dummyLd' l\n```\n\nTry to use this code to produce
  executable file without GNU linker:\n\n```\n[nix-shell:examples]$ ghci\nGHCi, version
  8.10.7: https://www.haskell.org/ghc/  :? for help\nPrelude> :l DummyLd.hs\n[1 of
  1] Compiling DummyLd          ( DummyLd.hs, interpreted )\nOk, one module loaded.\n*DummyLd>
  import Data.ByteString.Lazy as BSL\n*DummyLd BSL> i <- BSL.readFile \"helloWorld.o\"\n*DummyLd
  BSL> elf <- parseElf i\n*DummyLd BSL> elf' <- dummyLd elf\n*DummyLd BSL> o <- serializeElf
  elf'\n*DummyLd BSL> BSL.writeFile \"helloWorld2\" o\n*DummyLd BSL> \nLeaving GHCi.\n\n[nix-shell:examples]$
  chmod +x helloWorld2\n\n[nix-shell:examples]$ qemu-aarch64 helloWorld2\nHello World!\n\n[nix-shell:examples]$
  \n```\n\nIt works.\n\n## Related work\n\n- [elf](https://github.com/wangbj/elf)\n-
  [data-elf](https://github.com/mvv/data-elf)\n\nThese just parse/serialize ELF header
  and table entries but not the whole ELF files.\n\n## History\n\nFor the early history
  look at the branch \"[amakarov](https://github.com/aleksey-makarov/elf/tree/amakarov)\"
  of\nthe my copy of the [elf](https://github.com/aleksey-makarov/elf) repo.\n\n##
  Tests\n\nTest data is committed with [git-lfs](https://git-lfs.github.com/).\nOnly
  testdata/orig/* tests are included to hackage distributive to keep the tarball size
  small.\n\n## License\n\nBSD 3-Clause License (c) Aleksey Makarov\n"
license-name: BSD-3-Clause

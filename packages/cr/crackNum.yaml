homepage: http://github.com/LeventErkok/CrackNum
changelog-type: markdown
hash: 2cdc4dcb2fa756884a2719ee1f80e5248a84f59805351df78e560381cd013b90
test-bench-deps: {}
maintainer: erkokl@gmail.com
synopsis: Crack various integer and floating-point data formats
changelog: "* Hackage: <http://hackage.haskell.org/package/crackNum>\n* GitHub:  <http://github.com/LeventErkok/crackNum/>\n\n*
  Latest Hackage released version: 3.0, 2021-03-29\n\n### Version 3.0, 2021-03-29\n\n
  \ * A complete rewrite, much simplified, and supporting\n    arbitrary precision
  floats. Some of the old features\n    and the library are dropped; so if you rely
  on the library\n    nature of CrackNum, do not upgrade. For other users who\n    merely
  use crackNum as an executable, the new version is\n    strongly recommended.\n\n###
  Version 2.4, 2020-09-05\n\n  * Changes required to compile cleanly with GHC 8.10.2\n\n###
  Version 2.3, 2018-11-17\n\n  * Remove dependency on the ieee754 and reinterpret-cast
  packages. The goal is\n    to remove any FFI dependencies. We now define and export
  the required\n    utilities directly in the CrackNum package.\n\n### Version 2.2,
  2018-09-01\n\n  * Instead of data-binary-ieee754, use reinterpret-cast package.
  According\n    to documents, the former is deprecated.\n\n### Version 2.1, 2018-07-20\n\n
  \ * Support for vi-editor bindings. See the file \"crackNum.vim\" in the\n    distribution
  or in the github repo You can put \"so ~/.vim/crackNum.vim\"\n    (use the correct
  path!) and have vi crack numbers directly from inside\n    your editor. Simply locate
  your cursor on a binary/hex stream of digits\n    and type \":CrackNum\".  See the
  \"crackNum.vim\" file for binding details.\n\n### Version 2.0, 2018-03-17\n\n  *
  Import FloatingHex qualified to avoid GHC 8.4.1 compilation issue\n\n### Version
  1.9, 2017-01-22\n\n  * Minor fix to printing of +/-0\n\n### Version 1.8, 2017-01-15\n\n
  \ * Bump up FloatingHex dependency to >0.4, this enables\n    proper support for
  large doubles\n\n### Version 1.7, 2017-01-14\n\n  * Fix a snafu in reading hexadecimal
  floats\n\n### Version 1.6, 2017-01-14\n\n  * Add support for hexadecimal-floats.
  These now\n    work both in toIEEE option as input, and also\n    when printing
  the values out. (i.e., numbers\n    of the form 0x1.abp-3, etc.)\n\n### Version
  1.5, 2016-01-23\n\n  * Typo fixes; no functionality changes\n\n### Version 1.4,
  2016-01-17\n\n  * Fix NaN nomenclature: Screaming->Signaling\n  * Add an example
  to README.md\n\n### Version 1.3, 2015-04-11\n  \n  * Fix docs, github location\n\n###
  Version 1.2, 2015-04-11\n\n  * Fix the constant qnan values for SP/DP\n  * Add conversions
  from float/double. Much easier to use.\n  * Better handling of nan values.\n\n###
  Version 1.1, 2015-04-02\n  \n  * Clean-up the API, examples etc.\n\n### Version
  1.0, 2015-04-01\n\n  * First implementation. Supports HP/SP/DP\n    and signed/unsigned
  numbers in 8/16/32/64 bits.\n"
basic-deps:
  sbv: '>=8.14'
  base: '>=4.11 && <5'
  tasty-golden: -any
  libBF: -any
  filepath: -any
  process: -any
  tasty: -any
  directory: -any
all-versions:
- '1.9'
- '2.0'
- '2.1'
- '2.2'
- '2.3'
- '2.4'
- '3.0'
author: Levent Erkok
latest: '3.0'
description-type: markdown
description: |
  ## Decode/Encode Integers, Words, and IEE754 Floats

  [![Hackage version](http://img.shields.io/hackage/v/crackNum.svg?label=Hackage)](http://hackage.haskell.org/package/crackNum)
  [![Build Status](http://img.shields.io/travis/LeventErkok/crackNum.svg?label=Build)](http://travis-ci.org/LeventErkok/crackNum)

  ```
  Usage: crackNum value OR binary/hex-pattern
    -i N               Signed   integer of N-bits
    -w N               Unsigned integer of N-bits
    -f fp              Floating point format fp
    -r rm              Rounding mode to use. If not given, Nearest-ties-to-Even.
    -h, -?  --help     print help, with examples
    -v      --version  print version info

  Examples:
   Encoding:
     crackNum -i4   -- -2              -- encode as 4-bit signed integer
     crackNum -w4   2                  -- encode as 4-bit unsigned integer
     crackNum -f3+4 2.5                -- encode as float with 3 bits exponent, 4 bits significand
     crackNum -f3+4 2.5 -rRTZ          -- encode as above, but use RTZ rounding mode.
     crackNum -fbp  2.5                -- encode as a brain-precision float
     crackNum -fdp  2.5                -- encode as a double-precision float

   Decoding:
     crackNum -i4   0b0110             -- decode as 4-bit signed integer, from binary
     crackNum -w4   0xE                -- decode as 4-bit unsigned integer, from hex
     crackNum -f3+4 0b0111001          -- decode as float with 3 bits exponent, 4 bits significand
     crackNum -fbp  0x000F             -- decode as a brain-precision float
     crackNum -fdp  0x8000000000000000 -- decode as a double-precision float

   Notes:
     - For encoding:
         - Use -- to separate your argument if it's a negative number.
         - For floats: You can pass in NaN, Inf, -0, -Inf etc as the argument, along with a decimal float.
     - For decoding:
         - Use hexadecimal (0x) or binary (0b) as input. Input must have one of these prefixes.
         - You can use _,- or space as a digit to improve readability for the pattern to be decoded
  ```

  VIM users: You can use the https://github.com/LeventErkok/crackNum/blob/master/crackNum.vim file to
  use CrackNum directly from VIM. Simply locate your cursor on the text to crack, and use the
  command `:CrackNum options`.

  ### Example: Encode a decimal numer as a single-precision IEEE754 number
  ```
  $ crackNum -fsp -- -2.3e6
  Satisfiable. Model:
    ENCODED = -2300000.0 :: Float
                    3  2          1         0
                    1 09876543 21098765432109876543210
                    S ---E8--- ----------S23----------
     Binary layout: 1 10010100 00011000110000110000000
        Hex layout: CA0C 6180
         Precision: Single
              Sign: Negative
          Exponent: 21 (Stored: 148, Bias: 127)
    Classification: FP_NORMAL
            Binary: -0b1.0001100011000011p+21
             Octal: -0o1.061414p+21
           Decimal: -2300000.0
               Hex: -0x2.3186p+20
     Rounding mode: RNE: Round nearest ties to even.
  ```

  ### Example: Decode a double-precision IEEE754 number from memory-layout
  ```
  $ crackNum -fdp 0xfc00 abc1 7F80 0001
  Satisfiable. Model:
    DECODED = -2.0307920360962302e289 :: Double
                    6    5          4         3         2         1         0
                    3 21098765432 1098765432109876543210987654321098765432109876543210
                    S ----E11---- ------------------------S52-------------------------
     Binary layout: 1 11111000000 0000101010111100000101111111100000000000000000000001
        Hex layout: FC00 ABC1 7F80 0001
         Precision: Double
              Sign: Negative
          Exponent: 961 (Stored: 1984, Bias: 1023)
    Classification: FP_NORMAL
            Binary: -0b1.0000101010111100000101111111100000000000000000000001p+961
             Octal: -0o2.05274057740000001p+960
           Decimal: -2.0307920360962302e289
               Hex: -0x2.15782FF000002p+960
  ```

  ### Example: Encode an integer as a 7-bit signed word
  ```
  $ crackNum -i7 12
  Satisfiable. Model:
    ENCODED = 12 :: IntN 7
                    654 3210
     Binary layout: 000 1100
        Hex layout: 0C
              Type: Signed 7-bit 2's complement integer
              Sign: Positive
            Binary: 0b1100
             Octal: 0o14
           Decimal: 12
               Hex: 0xc
  ```
license-name: BSD-3-Clause

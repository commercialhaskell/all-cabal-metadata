homepage: http://www.cryptol.net/
changelog-type: markdown
hash: 70fa819a3e101abeacdb1e75a7a85a3c7e298044596a16ab0fab8957e5c81807
test-bench-deps:
  cryptol: -any
  sbv: -any
  base: -any
  text: -any
  filepath: -any
  criterion: -any
  deepseq: -any
  directory: -any
maintainer: cryptol@galois.com
synopsis: 'Cryptol: The Language of Cryptography'
changelog: "# 2.12.0\n\n## Language changes\n* Updates to the layout rule.  We simplified
  the specification and made\n  some minor changes, in particular:\n    - Paren blocks
  nested in a layout block need to respect the indentation\n      if the layout block\n
  \   - We allow nested layout blocks to have the same indentation, which is\n      convenient
  when writing `private` declarations as they don't need to\n      be indented as
  long as they are at the end of the file.\n\n* New enumeration forms `[x .. y by
  n]`, `[x .. <y by n]`,\n  `[x .. y down by n]` and `[x .. >y down by n]` have been\n
  \ implemented. These new forms let the user explicitly specify\n  the stride for
  an enumeration, as opposed to the previous\n  `[x, y .. z]` form (where the stride
  was computed from `x` and `y`).\n\n* Nested modules are now available (from pull
  request #1048). For example, the following is now valid Cryptol:\n\n        module
  SubmodTest where\n\n        import submodule B as C\n\n        submodule A where\n
  \         propA = C::y > 5\n\n        submodule B where\n          y : Integer\n
  \         y = 42\n\n## New features\n\n* What4 prover backends now feature an improved
  multi-SAT procedure\n  which is significantly faster than the old algorithm. Thanks
  to\n  Levent ErkoÌˆk for the suggestion.\n\n* There is a new `w4-abc` solver option,
  which communicates to ABC\n  as an external process via What4.\n\n* Expanded support
  for declaration forms in the REPL. You can now\n  define infix operators, type synonyms
  and mutually-recursive functions,\n  and state signatures and fixity declarations.
  Multiple declarations\n  can be combined into a single line by separating them with
  `;`,\n  which is necessary for stating a signature together with a\n  definition,
  etc.\n  \n* There is a new `:set path` REPL option that provides an alternative
  to\n  `CRYPTOLPATH` for controlling where to search for imported modules\n  (issue
  #631).\n\n* The `cryptol-remote-api` server now natively supports HTTPS (issue\n
  \ #1008), `newtype` values (issue #1033), and safety checking (issue\n  #1166).\n\n*
  Releases optionally include solvers (issue #1111). See the\n  `*-with-solvers*`
  files in the assets list for this release.\n\n## Bug fixes\n\n* Closed issues #422,
  #436, #619, #631, #633, #640, #680, #734, #735,\n  #759, #760, #764, #849, #996,
  #1000, #1008, #1019, #1032, #1033,\n  #1034, #1043, #1047, #1060, #1064, #1083,
  #1084, #1087, #1102, #1111,\n  #1113, #1117, #1125, #1133, #1142, #1144, #1145,
  #1146, #1157, #1160,\n  #1163, #1166, #1169, #1175, #1179, #1182, #1190, #1191,
  #1196, #1197,\n  #1204, #1209, #1210, #1213, #1216, #1223, #1226, #1238, #1239,
  #1240,\n  #1241, #1250, #1256, #1259, #1261, #1266, #1274, #1275, #1283, and\n  #1291.\n\n*
  Merged pull requests #1048, #1128, #1129, #1130, #1131, #1135, #1136,\n  #1137,
  #1139, #1148, #1149, #1150, #1152, #1154, #1156, #1158, #1159,\n  #1161, #1164,
  #1165, #1168, #1170, #1171, #1172, #1173, #1174, #1176,\n  #1181, #1183, #1186,
  #1188, #1192, #1193, #1194, #1195, #1199, #1200,\n  #1202, #1203, #1205, #1207,
  #1211, #1214, #1215, #1218, #1219, #1221,\n  #1224, #1225, #1227, #1228, #1230,
  #1231, #1232, #1234, #1242, #1243,\n  #1244, #1245, #1246, #1247, #1248, #1251,
  #1252, #1254, #1255, #1258,\n  #1263, #1265, #1268, #1269, #1270, #1271, #1272,
  #1273, #1276, #1281,\n  #1282, #1284, #1285, #1286, #1287, #1288, #1293, #1294,
  and #1295.\n\n# 2.11.0\n\n## Language changes\n\n* The `newtype` construct, which
  has existed in the interpreter in an\n  incomplete and undocumented form for quite
  a while, is now fullly\n  supported. The construct is documented in section 1.22
  of [Programming\n  Cryptol](https://cryptol.net/files/ProgrammingCryptol.pdf). Note,\n
  \ however, that the `cryptol-remote-api` RPC server currently does not\n  include
  full support for referring to `newtype` names, though it can\n  work with implementations
  that use `newtype` internally.\n\n## New features\n\n* By default, the interpreter
  will now track source locations of\n  expressions being evaluated, and retain call
  stack information.\n  This information is incorporated into error messages arising
  from\n  runtime errors. This additional bookkeeping incurs significant\n  runtime
  overhead, but may be disabled using the `--no-call-stacks`\n  command-line option.\n\n*
  The `:exhaust` command now works for floating-point types and the\n  `:check` command
  now uses more representative sampling of\n  floating-point input values to test.\n\n*
  The `cryptol-remote-api` RPC server now has methods corresponding to\n  the `:prove`
  and `:sat` commands in the REPL.\n\n* The `cryptol-eval-server` executable is a
  new, stateless server\n  providing a subset of the functionality of `cryptol-remote-api`\n
  \ dedicated entirely to invoking Cryptol functions on concrete inputs.\n\n## Internal
  changes\n\n* A single running instance of the SMT solver used for type checking\n
  \ (Z3) is now used to check a larger number of type correctness queries.\n  This
  means that fewer solver instances are invoked, and type checking\n  should generally
  be faster.\n\n* The Cryptol interpreter now builds against `libBF` version 0.6,
  which\n  fixes a few bugs in the evaluation of floating-point operations.\n\n##
  Bug fixes\n\n* Closed issues #118, #398, #426, #470, #491, #567, #594, #639, #656,\n
  \ #698, #743, #810, #858, #870, #905, #915, #917, #962, #973, #975,\n  #980, #984,
  #986, #990, #996, #997, #1002, #1006, #1009, #1012, #1024,\n  #1030, #1035, #1036,
  #1039, #1040, #1044, #1045, #1049, #1050, #1051,\n  #1052, #1063, #1092, #1093,
  #1094, and #1100.\n\n# 2.10.0\n\n## Language changes\n\n* Cryptol now supports primality
  checking at the type level. The\n  type-level predicate `prime` is true when its
  parameter passes the\n  Miller-Rabin probabilistic primality test implemented in
  the GMP\n  library.\n\n* The `Z p` type is now a `Field` when `p` is prime, allowing
  additional\n  operations on `Z p` values.\n\n* The literals `0` and `1` can now
  be used at type `Bit`, as\n  alternatives for `False` and `True`, respectively.\n\n##
  New features\n\n* The interpreter now includes a number of primitive functions that\n
  \ allow faster execution of a number of common cryptographic functions,\n  including
  the core operations of AES and SHA-2, operations on GF(2)\n  polynomials (the existing
  `pmod`, `pdiv`, and `pmult` functions), and\n  some operations on prime field elliptic
  curves. These functions are\n  useful for implementing higher-level algorithms,
  such as many\n  post-quantum schemes, with more acceptable performance than possible\n
  \ when running a top-to-bottom Cryptol implementation in the\n  interpreter.\n\n
  \ For a full list of the new primitives, see the new Cryptol\n  [`SuiteB`](https://github.com/GaloisInc/cryptol/blob/master/lib/SuiteB.cry)\n
  \ and\n  [`PrimeEC`](https://github.com/GaloisInc/cryptol/blob/master/lib/PrimeEC.cry)\n
  \ modules.\n\n* The REPL now allows lines containing only comments, making it easier\n
  \ to copy and paste examples.\n\n* The interpreter has generally improved performance
  overall.\n\n* Several error messages are more comprehensible and less verbose.\n\n*
  Cryptol releases and nightly builds now include an RPC server\n  alongside the REPL.
  This provides an alternative interface to the same\n  interpreter and proof engine
  available from the REPL, but is\n  better-suited to programmatic use. Details on
  the protocol used by the\n  server are available\n  [here](https://github.com/GaloisInc/argo/blob/master/docs/Protocol.rst).\n
  \ A Python client for this protocol is available\n  [here](https://github.com/GaloisInc/argo/tree/master/python).\n\n*
  Windows builds are now distributed as both `.tar.gz` and `.msi` files.\n\n## Bug
  Fixes\n\n* Closed issues #98, #485, #713, #744, #746, #787, #796, #803, #818,\n
  \ #826, #838, #856, #873, #875, #876, #877, #879, #880, #881, #883,\n  #886, #887,
  #888, #892, #894, #901, #910, #913, #924, #926, #931,\n  #933, #937, #939, #946,
  #948, #953, #956, #958, and #969.\n\n# 2.9.1\n\n## Language changes\n\n* The type
  of `generate` which is used for `a@i` sequence definitions,\n   is generalized so
  that the index type can be any `Integral` type\n   large enough to index the entire
  array being defined.\n\n## Bug Fixes\n\n* Closed issues #848, #850, #851, #859,
  and #861.\n\n* Fixed Windows installer paths.\n\n# 2.9.0\n\n## Language changes\n\n*
  Removed the `Arith` class. Replaced it instead with more specialized\n  numeric
  classes: `Ring`, `Integral`, `Field`, and `Round`.  `Ring`\n  is the closest analogue
  to the old `Arith` class; it contains the\n  `fromInteger`, `(+)`, `(*)`, `(-)`
  and `negate` methods.  `Ring`\n  contains all the base arithmetic types in Cryptol,
  and lifts\n  pointwise over tuples, sequences and functions, just as `Arith` did.\n\n
  \ The new `Integral` class now contains the integer division and\n  modulus methods
  (`(/)` and `(%)`), and the sequence indexing,\n  sequence update and shifting operations
  are generalized over\n  `Integral`.  The `toInteger` operation is also generalized
  over this\n  class.  `Integral` contains the bitvector types and `Integer`.\n\n
  \ The new `Field` class contains types representing mathematical\n  fields (or types
  that are approximately fields). It is currently\n  inhabited by the new `Rational`
  type, and the `Float`\n  family of types.  It will eventually also contain the\n
  \ `Real` type. It has the operation `recip` for reciprocal\n  and `(/.)` for field
  division (not to be confused for `(/)`,\n  which is Euclidean integral division).\n\n
  \ There is also a new `Round` class for types that can sensibly be\n  rounded to
  integers.  This class has the methods `floor`, `ceiling`,\n  `trunc`, `roundToEven`
  and `roundAway` for performing different\n  kinds of integer rounding.  `Rational`
  and `Float` inhabit `Round`.\n\n  The type of `(^^)` is modified to be\n  `{a, e}
  (Ring a, Integral e) => a -> e -> a`. This makes it clear\n  that the semantics
  are iterated multiplication, which makes sense\n  in any ring.\n\n  Finally, the
  `lg2`, `(/$)` and `(%$)` methods of `Arith` have\n  had their types specialized
  so they operate only on bitvectors.\n\n* Added an `Eq` class, and moved the equality
  operations\n  from `Cmp` into `Eq`. The `Z` type becomes a member of `Eq`\n  but
  not `Cmp`.\n\n* Added a base `Rational` type.  It is implemented as a pair of\n
  \ integers, quotiented in the usual way.  As such, it reduces to the\n  theory of
  integers and requires no new solver support (beyond\n  nonlinear integer arithmetic).
  \ `Rational` inhabits the new\n  `Field` and `Round` classes.  Rational values can
  be\n  constructed using the `ratio` function, or via `fromInteger`.\n\n* The `generate`
  function (and thus `x @ i= e` definitions) has had\n  its type specialized so the
  index type is always `Integer`.\n\n* The new typeclasses are arranged into a class
  hierarchy, and the\n  typechecker will use that information to infer superclass
  instances\n  from subclasses.\n\n* Added a family of base types, `Float e p`, for
  working with\n  floating point numbers.  The parameters control the precision of\n
  \ the numbers, with `e` being the number of bits to use in the exponent\n  and `p-1`
  being the number of bits to use in the mantissa.\n  The `Float` family of types
  may be used through the usual overloaded\n  functionality in Cryptol, and there
  is a new built-in module called\n  `Float`, which contains functionality specific
  to floating point numbers.\n\n* Add a way to write fractional literals in base 2,8,10,
  and 16.\n  Fractional literals are overloaded, and may be used for different types\n
  \ (currently `Rational` and the `Float` family).  Fractional literal in base\n  2,8,and
  16 must be precise, and will be rejected statically if they cannot be\n  represented
  exactly.  Fractional literals in base 10 are rounded to the\n  nearest even representable
  number.\n\n* Changes to the defaulting algorithm. The new algorithm only applies\n
  \ to constraints arising from literals (i.e., `Literal` and `FLiteral`\n  constraints).
  \ The guiding principle is that we now default these\n  to one of the infinite precision
  types `Integer` or `Rational`.\n  `Literal` constraints are defaulted to `Integer`,
  unless the corresponding\n  type also has `Field` constraint, in which case we use
  `Rational`.\n  Fractional literal constraints are always defaulted to `Rational.\n\n\n##
  New features\n\n* Document the behavior of lifted selectors.\n\n* Added support
  for symbolic simulation via the `What4` library\n  in addition to the previous method
  based on `SBV`. The What4\n  symbolic simulator is used when selecting solvers with
  the `w4`\n  prefix, such as `w4-z3`, `w4-cvc4`, `w4-yices`, etc.\n  The `SBV` and
  `What4` libraries make different tradeoffs in how\n  they represent formulae. You
  may find one works better than another\n  for the same problem, even with the same
  solver.\n\n* More detailed information about the status of various symbols\n  in
  the output of the `:browse` command (issue #688).\n\n* The `:safe` command will
  attempt to prove that a given Cryptol\n  term is safe; in other words, that it will
  not encounter a run-time\n  error for all inputs. Run-time errors arise from things
  like\n  division-by-zero, index-out-of-bounds situations and\n  explicit calls to
  `error` or `assert`.\n\n* The `:prove` and `:sat` commands now incorporate safety
  predicates\n  by default. In a `:sat` call, models will only be found that do not\n
  \ cause run-time errors. For `:prove` calls, the safety conditions are\n  added
  as additional proof goals.  The prior behavior\n  (which ignored safety conditions)
  can be restored using\n  `:set ignore-safety = on`.\n\n* Improvements to the `any`
  prover. It will now shut down external\n  prover processes correctly when one finds
  a solution. It will also\n  wait for the first _successful_ result to be returned
  from a prover,\n  instead of failing as soon as one prover fails.\n\n* An experimental
  `parmap` primitive that applies a function to a\n  sequence of arguments and computes
  the results in parallel.  This\n  operation should be considered experimental and
  may significantly\n  change or disappear in the future, and could possibly uncover\n
  \ unknown race conditions in the interpreter.\n\n## Bug fixes\n\n* Closed issues
  #346, #444, #614, #617, #636, #660, #662, #663, #664,\n  #667, #670, #702, #711,
  #712, #716, #723, #725, #731, #835, #836,\n  #839, #840, and #845\n\n# 2.8.0 (September
  4, 2019)\n\n## New features\n\n* Added support for indexing on the left-hand sides
  of declarations,\n  record field constructors, and record updaters (issue #577).
  This\n  builds on a new primitive function called `generate`, where the new\n  syntax
  `x @ i = e` is sugar for `x = generate (\\i -> e)`.\n\n* Added support for element
  type ascriptions on sequence enumerations.\n  The syntax `[a,b..c:t]` indicates
  that the elements should be of type\n  `t`.\n\n* Added support for wildcards in
  sequence enumerations. For example, the\n  syntax `[1 .. _] : [3][8]` yields `[0x01,
  0x02, 0x03]`. It can also be\n  used polymorphically. For example, the most general
  type of `[1 .. _]`\n  is `{n, a} (n >= 1, Literal n a, fin n) => [n]a`\n\n* Changed
  the syntax of type signatures to allow multiple constraint\n  arrows in type schemas
  (issue #599). The following are now equivalent:\n\n        f : {a} (fin a, a >=
  1) => [a] -> [a]\n\n        f : {a} (fin a) => (a >= 1) => [a] -> [a]\n\n* Added
  a mechanism for user-defined type constraint operators, and use\n  this to define
  the new type constraint synonyms (<) and (>) (issues\n  #400, #618).\n\n* Added
  support for primitive type declarations. The prelude now uses\n  this mechanism
  to declare all of the basic types.\n\n* Added support for Haskell-style \"block
  arguments\", reducing the need\n  for parentheses in some cases. For example, `generate
  (\\i -> i +1)`\n  can now be written `generate \\i -> i + 1`.\n\n* Improved shadowing
  errors (part of the fix for issue #569).\n\n## Bug fixes\n\n* Closed many issues,
  including #265, #367, #437, #508, #522, #549,\n  #557, #559, #569, #578, #590, #595,
  #596, #601, #607, #608, #610,\n  #615, #621, and #636.\n\n# 2.7.0 (April 30, 2019)\n\n##
  New features\n\n* Added syntax for record updates (see #399 for details of implemented\nand
  planned features).\n\n* Updated the `:browse` command to list module parameters
  (issue #586).\n\n* Added support for test vector creation (the `:dumptests` command).\nThis
  feature computes a list of random inputs and outputs for the\ngiven expression of
  function type and saves it to a file. This is\nuseful for generating tests from
  a trusted Cryptol specification to\napply to an implementation written in another
  language.\n\n## Breaking changes\n\n* Removed the `[x..]` construct from the language
  (issue #574). It\nwas shorthand for `[x..2^^n-1]` for a bit vector of size `n`,
  which was\noften not what the user intended. Users should instead write either\n`[x..y]`
  or `[x...]`, to construct a smaller range or a lazy sequence,\nrespectively.\n\n*
  Renamed the value-level `width` function to `length`, and generalized\nits type
  (issue #550). It does not behave identically to the\ntype-level `width` operator,
  which led to confusion. The name\n`length` matches more closely with similar functions
  in other\nlanguages.\n\n## Bug fixes\n\n* Improved type checking performance of
  decimal literals.\n\n* Improved type checking of `/^` and `%^` (issues #581, #582).\n\n*
  Improved performance of sequence updates with the `update` primitive\n(issue #579).\n\n*
  Fixed elapsed time printed by `:prove` and `:sat` (issue #572).\n\n* Fixed SMT-Lib
  formulas generated for right shifts (issue #566).\n\n* Fixed crash when importing
  non-parameterized modules with the\nbacktick prefix (issue #565).\n\n* Improved
  performance of symbolic execution for `Z n` (issue #554).\n\n* Fixed interpretation
  of the `satNum` option so finding multiple\nsolutions doesn't run forever (issue
  #553).\n\n* Improved type checking of the `length` function (issue #548).\n\n* Improved
  error message when trying to prove properties in\nparameterized modules (issue #545).\n\n*
  Stopped warning about defaulting at the REPL when `warnDefaulting` is\nset to `false`
  (issue #543).\n\n* Fixed builds on non-x86 architectures (issue #542).\n\n* Made
  browsing of interactively-bound identifiers work better (issue #538).\n\n* Fixed
  a bug that allowed changing the semantics of the `_ # _`\npattern and the `-` and
  `~` operators by creating local definitions\nof functions that they expand to (issue
  #568).\n\n* Closed issues #498, #547, #551, #562, and #563.\n"
basic-deps:
  tf-random: '>=0.5'
  exceptions: -any
  GraphSCC: '>=1.0.4'
  cryptol: -any
  cryptohash-sha1: '>=0.11 && <0.12'
  sbv: '>=8.6 && <8.17'
  bytestring: '>=0.10'
  extra: -any
  heredoc: '>=0.2'
  haskeline: '>=0.7 && <0.9'
  stm: '>=2.4'
  base: '>=4.8 && <5'
  time: '>=1.6.0.1'
  text: '>=1.1'
  bv-sized: '>=1.0 && <1.1'
  strict: -any
  monad-control: '>=1.0'
  libBF: '>=0.6 && <0.7'
  filepath: '>=1.3'
  gitrev: '>=1.0'
  process: '>=1.2'
  async: '>=2.2 && <2.3'
  monadLib: '>=3.7.2'
  what4: '>=1.2 && <1.3'
  array: '>=0.4'
  integer-gmp: '>=1.0 && <1.1'
  containers: '>=0.5'
  ansi-terminal: -any
  base-compat: '>=0.6 && <0.12'
  ghc-prim: -any
  panic: '>=0.3'
  mtl: '>=2.2.1'
  blaze-html: -any
  MemoTrie: '>=0.6 && <0.7'
  transformers-base: '>=0.4'
  prettyprinter: '>=1.7.0'
  transformers: -any
  temporary: -any
  optparse-applicative: -any
  deepseq: '>=1.3'
  simple-smt: '>=0.9.7'
  parameterized-utils: '>=2.0.2'
  directory: '>=1.2.2.0'
all-versions:
- 2.2.0
- 2.2.1
- 2.2.2
- 2.2.3
- 2.2.4
- 2.2.5
- 2.2.6
- 2.3.0
- 2.4.0
- 2.5.0
- 2.6.0
- 2.7.0
- 2.8.0
- 2.9.0
- 2.9.1
- 2.10.0
- 2.11.0
- 2.12.0
author: Galois, Inc.
latest: 2.12.0
description-type: haddock
description: Cryptol is a domain-specific language for specifying cryptographic algorithms.
  A Cryptol implementation of an algorithm resembles its mathematical specification
  more closely than an implementation in a general purpose language. For more, see
  <http://www.cryptol.net/>.
license-name: BSD-3-Clause

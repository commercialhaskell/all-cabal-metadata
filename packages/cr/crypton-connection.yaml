homepage: https://github.com/kazu-yamamoto/crypton-connection
changelog-type: markdown
hash: 4d0958537197956b536ea91718b1749949757022532f50b8f683290056a19021
test-bench-deps: {}
maintainer: Kazu Yamamoto <kazu@iij.ad.jp>
synopsis: Simple and easy network connections API
changelog: |
  ## Version 0.2.1 (16 April 2014)

  - Fix a difference between TLSSettings and TLSSettingsSimple,
    where connection would override the connection hostname and port in
    the simple case, but leave the field as is with TLSSettings.
    TLSSettings can now be used properly as template, and will be
    correctly overriden at the identification level only.
basic-deps:
  socks: '>=0.6'
  bytestring: -any
  basement: -any
  crypton-x509-validation: '>=1.5'
  base: '>=3 && <5'
  data-default-class: -any
  tls: '>=1.7'
  network: '>=2.6.3'
  crypton-x509-store: '>=1.5'
  containers: -any
  crypton-x509-system: '>=1.5'
  crypton-x509: '>=1.5'
all-versions:
- 0.3.1
author: Vincent Hanquez <vincent@snarc.org>
latest: 0.3.1
description-type: markdown
description: |
  haskell Connection library
  ==========================

  Simple network library for all your connection need.

  Features:

  - Really simple to use
  - SSL/TLS
  - SOCKS

  Usage
  -----

  Connect to www.example.com on port 4567 (without socks or tls), then send a
  byte, receive a single byte, print it, and close the connection:
  ```haskell
  import qualified Data.ByteString as B
  import Network.Connection
  import Data.Default

  main = do
      ctx <- initConnectionContext
      con <- connectTo ctx $ ConnectionParams
                                { connectionHostname  = "www.example.com"
                                , connectionPort      = 4567
                                , connectionUseSecure = Nothing
                                , connectionUseSocks  = Nothing
                                }
      connectionPut con (B.singleton 0xa)
      r <- connectionGet con 1
      putStrLn $ show r
      connectionClose con
  ```
  Using a socks proxy is easy, we just need replacing the connectionSocks
  parameter, for example connecting to the same host, but using a socks
  proxy at localhost:1080:
  ```haskell
  con <- connectTo ctx $ ConnectionParams
                         { connectionHostname  = "www.example.com"
                         , connectionPort      = 4567
                         , connectionUseSecure = Nothing
                         , connectionUseSocks  = Just $ SockSettingsSimple "localhost" 1080
                         }
  ```
  Connecting to a SSL style socket is equally easy, and need to set the UseSecure fields in ConnectionParams:
  ```haskell
  con <- connectTo ctx $ ConnectionParams
                         { connectionHostname  = "www.example.com"
                         , connectionPort      = 4567
                         , connectionUseSecure = Just def
                         , connectionUseSocks  = Nothing
                         }
  ```
  And finally, you can start TLS in the middle of an insecure connection. This is great for
  protocol using STARTTLS (e.g. IMAP, SMTP):

  ```haskell
  {-# LANGUAGE OverloadedStrings #-}
  import qualified Data.ByteString as B
  import Data.ByteString.Char8 ()
  import Network.Connection
  import Data.Default

  main = do
      ctx <- initConnectionContext
      con <- connectTo ctx $ ConnectionParams
                                { connectionHostname  = "www.example.com"
                                , connectionPort      = 4567
                                , connectionUseSecure = Nothing
                                , connectionUseSocks  = Nothing
                                }
      -- talk to the other side with no TLS: says hello and starttls
      connectionPut con "HELLO\n"
      connectionPut con "STARTTLS\n"

      -- switch to TLS
      connectionSetSecure ctx con def

      -- the connection is from now on using TLS, we can send secret for example
      connectionPut con "PASSWORD 123\n"
      connectionClose con
  ```
license-name: BSD-3-Clause

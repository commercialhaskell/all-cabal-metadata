homepage: https://github.com/gbwey/predicate-typed#readme
changelog-type: markdown
hash: 3c3f7945083a7a9c796d0912c0ac0f390460d5ff104ce25c6278ab5d1c70732a
test-bench-deps:
  pcre-light: -any
  bytestring: -any
  these: ! '>=1.0.0'
  stm: -any
  pcre-heavy: ! '>=1.0.0.2'
  base: ! '>=4.7 && <5'
  time: -any
  comonad: -any
  assoc: ! '>=1'
  text: -any
  doctest: -any
  containers: -any
  lens: -any
  binary: -any
  pretty-terminal: ! '>=0.1.0.0'
  ghc-prim: -any
  tasty-quickcheck: -any
  mtl: -any
  tasty-hunit: -any
  predicate-typed: -any
  tasty: -any
  deepseq: -any
  QuickCheck: -any
  th-lift: ! '>=0.8.0.1'
  tree-view: ! '>=0.5'
  pretty: -any
  aeson: -any
  template-haskell: -any
  safe: -any
  directory: -any
maintainer: Grant Weyburne <gbwey9@gmail.com>
synopsis: Predicates, Refinement types and Dsl
changelog: "# Changelog for predicate-typed\r\n\r\n"
basic-deps:
  pcre-light: -any
  bytestring: -any
  these: ! '>=1.0.0'
  pcre-heavy: ! '>=1.0.0.2'
  base: ! '>=4.7 && <5'
  time: -any
  comonad: -any
  assoc: ! '>=1'
  text: -any
  containers: -any
  lens: -any
  binary: -any
  pretty-terminal: ! '>=0.1.0.0'
  ghc-prim: -any
  mtl: -any
  deepseq: -any
  QuickCheck: -any
  th-lift: ! '>=0.8.0.1'
  tree-view: ! '>=0.5'
  pretty: -any
  aeson: -any
  template-haskell: -any
  safe: -any
  directory: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
author: Grant Weyburne <gbwey9@gmail.com>
latest: 0.1.0.3
description-type: markdown
description: "# predicate-typed\r\n\r\nwhat this library provides:\r\n1. a dsl for
  building refinement types\r\n2. Refined is simple refinement type that just validates
  the input against a predicate\r\n3. Refined3 is a more complex refinement type that
  allows you to change the input\r\n4. validation against input values\r\n5. visualisation
  of each step in the process\r\n6  template haskell methods for creating the refinement
  types at compile time\r\n7. ToJSON and FromJSON instances for Refined and Refined3\r\n8.
  Read and Show instance for Refined and Refined3\r\n9. Binary instances for Refined
  and Refined3\r\n10. database encoders and decoders using odbc(sqlhandler-odbcalt)
  or hdbc((sqlhandler-odbc)\r\n11. quickcheck arbitrary methods\r\n\r\n```haskell\r\ndata
  Refined p a = Refined a\r\n```\r\n* **_a_** is the input type\r\n* **_p_** predicate
  on **_a_**\r\n\r\n**_If you want to see an evaluation tree with colors for any of
  the examples, just replace 'ol' with 'o2' or if on unix use 'ou' (unicode)_**\r\n\r\n###
  Examples of Refined (for more information see [doctests](src/Refined.hs))\r\n\r\n1.
  reads in a number and checks to see that it is greater than 99\r\n```haskell\r\n>prtRefinedIO
  @(ReadP Int >> Id > 99) ol \"123\"\r\nRight (Refined {unRefined = \"123\"})\r\n```\r\n\r\n2.
  tries to read in a number but fails\r\n```haskell\r\n>prtRefinedIO @(ReadP Int >>
  Id > 99) ol \"1x2y3\"\r\nLeft (FailP \"ReadP Int (1x2y3) failed\")\r\n```\r\n\r\n3.
  reads in a hexadecimal string and checks to see that it is between 99 and 256\r\n```haskell\r\n>prtRefinedIO
  @(ReadBase Int 16 >> Between 99 256) ol \"000fe\"\r\nRight (Refined {unRefined =
  \"000fe\"})\r\n```\r\n\r\n4. reads in a hexadecimal string but fails the predicate
  check\r\n```haskell\r\n>prtRefinedIO @(ReadBase Int 16 >> Between 99 253) ol \"000fe\"\r\nLeft
  FalseP\r\n```\r\n\r\n5. same as 4. above but now we get details of where it went
  wrong\r\n```haskell\r\n>prtRefinedIO @(ReadBase Int 16 >> Between 99 253) o2 \"000fe\"\r\n```\r\n\r\n6.
  reads in a string as time and does simple validation\r\n```haskell\r\n>prtRefinedIO
  @(Resplit \":\" Id >> Map (ReadP Int) Id >> Len == 3) ol \"12:01:05\"\r\nRight (Refined
  {unRefined = \"12:01:05\"})\r\n```\r\n  * `Resplit \":\" Id`\r\n     split using
  regex using a colon as a delimiter  [\"12\",\"01\",\"05\"]\r\n  * `Map (ReadP Int)
  Id`\r\n     Read in the values as Ints                      [12,1,5]\r\n  * `Len
  == 3`\r\n     Check to see that the length of the list of Ints is 3\r\n\r\n\r\n###
  Testing out predicates\r\nWhen using _Refined_ the expression in _p_ must result
  in a True/False\\\r\n_pe2_ does not have that restriction so you can run the whole
  thing or the individual pieces\\\r\nfor less detail use _pl_\\\r\nif using a unicode-supported
  OS then _pu_ gives you nicer rendering than _pe2_\\\r\n\r\n```haskell\r\n>pe2 @(Resplit
  \":\" Id >> Map (ReadP Int) Id >> Len == 3) \"12:01:05\"\r\n\r\n>pe2 @(Resplit \":\"
  Id) \"12:01:05\"\r\n\r\n>pe2 @(Map (ReadP Int) Id) [\"12\",\"01\",\"05\"]\r\n\r\n>pe2
  @(Len == 3) [12,1,5]\r\n```\r\n\r\n### An example using Refined3 (for more information
  see [doctests](src/Refined3.hs) and [doctests](src/Refined3Helper.hs))\r\n\r\n```haskell\r\n>type
  Hex = '(ReadBase Int 16, Between 0 255, ShowBase 16, String)\r\n\r\n>prtEval3PIO
  (Proxy @Hex) ol \"0000fe\"\r\nRefined3 {in3 = 254, out3 = \"fe\"}\r\n```\r\n1. `ReadBase
  Int 16`\r\n    reads a hexadecimal string and returns 254\r\n2. `Between 0 255`\r\n
  \   checks to make sure the predicate holds ie the number is between 0 and 255\r\n3.
  `ShowBase 16`\r\n    formats the output as \"fe\" which is compatible with the input\r\n\r\nrun
  this to get details in color of each evaluation step:\r\n```haskell\r\n>prtEval3PIO
  (Proxy @Hex) o2 \"0000fe\"\r\n\r\n***Step 1. Success Initial Conversion(ip) [254]
  ***\r\n\r\nP ReadBase(Int) 16 254 | \"0000fe\"\r\n|\r\n`- P Id \"0000fe\"\r\n\r\n***Step
  2. Success Boolean Check(op) ***\r\n\r\nTrue  True && True\r\n|\r\n+- True  254
  >= 0\r\n|  |\r\n|  +- P I\r\n|  |\r\n|  `- P '0\r\n|\r\n`- True  254 <= 255\r\n
  \  |\r\n   +- P I\r\n   |\r\n   `- P '255\r\n\r\n***Step 3. Success Output Conversion(fmt)
  = \"fe\" ***\r\n\r\nP ShowBase 16 fe | 254\r\n```\r\n\r\nRead in the string \"0000fe\"
  as input to `ReadBase Int 16` and produce 254 as output\r\n```haskell\r\n>pe2 @(ReadBase
  Int 16) \"0000fe\"\r\nPresentT 254\r\n\r\n>pe2 @(Between 0 255) 254\r\nTrueT\r\n\r\n>pe2
  @(ShowBase 16) 254 = \"fe\"\r\nPresentT \"fe\"\r\n```\r\n\r\n**_Replace '$$(refinedTH
  ...)' $$(refinedTH' o2 ...)' for an evaluation tree **\r\n\r\n### Template Haskell
  versions\r\n\r\n```haskell\r\nex1 :: Refined (ReadP Int >> Id > 99) String\r\nex1
  = $$(refinedTH \"123\")\r\n```\r\n\r\n### Refined3 is the most useful refined type
  as you can control the input and output types (see documentation and [doctests](src/Refined3.hs))\r\n\r\n**_Replace
  '$$(refined3TH ...)' $$(refined3TH' o2 ...)' for a colored evaluation tree **\r\n\r\n```haskell\r\ntype
  Hex = '(ReadBase Int 16, Between 0 255, ShowBase 16, String)\r\n\r\n$$(refined3TH
  \"0000fe\") :: MakeR3 Hex\r\n```\r\n\r\nHere is an example where the predicate fails
  at compile-time and we choose to show the details using o2.\r\n```haskell\r\n>type
  Hex = '(ReadBase Int 16, Between 0 255, ShowBase 16, String)\r\n\r\n>$$(refined3TH'
  o2 \"000ffff\") :: MakeR3 Hex\r\n\r\n<interactive>:18:4: error:\r\n    *\r\n***
  Step 1. Success Initial Conversion(ip) [65535] ***\r\n\r\nP ReadBase(Int,16) 65535
  | \"000ffff\"\r\n|\r\n`- P Id \"000ffff\"\r\n\r\n*** Step 2. False Boolean Check(op)
  ***\r\n\r\nFalse True && False\r\n|\r\n+- True  65535 >= 0\r\n|  |\r\n|  +- P I\r\n|
  \ |\r\n|  `- P '0\r\n|\r\n`- False 65535 <= 255\r\n   |\r\n   +- P I\r\n   |\r\n
  \  `- P '255\r\n\r\nrefined3TH: predicate failed with Step 2. False Boolean Check(op)
  | FalseP\r\n    * In the Template Haskell splice $$(refined3TH' o0 \"000ffff\")\r\n
  \     In the expression: $$(refined3TH' o0 \"000ffff\") :: MakeR3 Hex\r\n      In
  an equation for `it':\r\n          it = $$(refined3TH' o0 \"000ffff\") :: MakeR3
  Hex\r\n```\r\n\r\n### Any valid Read/Show instance can be used with Refined3\r\n```haskell\r\n>$$(refined3TH
  \"13 % 3\") :: ReadShowR Rational\r\nRefined3 {r3In = 13 % 3, r3Out = \"13 % 3\"}\r\n\r\n>$$(refined3TH
  \"2016-11-09\") :: ReadShowR Day\r\nRefined3 {r3In = 2016-11-09, r3Out = \"2016-11-09\"}\r\n```\r\n\r\nAn
  example of an invalid refined3TH call\r\n```haskell\r\n>$$(refined3TH \"2016-xy-09\")
  :: ReadShowR Day\r\n\r\n<interactive>:171:4: error:\r\n    * refined3TH: predicate
  failed with Step 1. Initial Conversion(ip) Failed | ReadP Day (2016-xy-09) failed\r\n
  \   * In the Template Haskell splice $$(refined3TH \"2016-xy-09\")\r\n      In the
  expression: $$(refined3TH \"2016-xy-09\") :: ReadShowR Day\r\n      In an equation
  for `it':\r\n          it = $$(refined3TH \"2016-xy-09\") :: ReadShowR Day\r\n```\r\n\r\n###
  Json decoding\r\n\r\n#### This example is successful as it is a valid hexadecimal
  and is in the range 10 though 256\r\n```haskell\r\n>eitherDecode' @(Refined3 (ReadBase
  Int 16) (Id > 10 && Id < 256) (ShowP Id) String) \"\\\"00fe\\\"\"\r\nRight (Refined3
  {in3 = 254, out3 = \"254\"})\r\n```\r\n\r\n#### This example fails as the value
  is not a valid hexadecimal string\r\n```haskell\r\n>either putStrLn print $ eitherDecode'
  @(Refined3 (ReadBase Int 16) 'True (ShowP Id) String) \"\\\"00feg\\\"\"\r\nError
  in $: Refined3:Step 1. Initial Conversion(ip) Failed | invalid base 16\r\n\r\n***Step
  1. Initial Conversion(ip) Failed ***\r\n\r\n[Error invalid base 16] ReadBase(Int)
  16 as=00feg err=[(254,\"g\")]\r\n|\r\n`- P Id \"00feg\"\r\n```\r\n\r\n#### This
  example fails as the hexadecimal value is valid but is not between 10 and 256\r\n\r\n```haskell\r\n>either
  putStrLn print $ eitherDecode' @(Refined3 (ReadBase Int 16) (Id > 10 && Id < 256)
  (ShowP Id) String) \"\\\"00fe443a\\\"\"\r\nError in $: Refined3:Step 2. False Boolean
  Check(op) | FalseP\r\n\r\n***Step 1. Success Initial Conversion(ip) [16663610] ***\r\n\r\nP
  ReadBase(Int,16) 16663610 | \"00fe443a\"\r\n|\r\n`- P Id \"00fe443a\"\r\n\r\n***Step
  2. False Boolean Check(op) = FalseP ***\r\n\r\nFalse True && False\r\n|\r\n+- True
  \ 16663610 > 10\r\n|  |\r\n|  +- P Id 16663610\r\n|  |\r\n|  `- P '10\r\n|\r\n`-
  False 16663610 < 256\r\n   |\r\n   +- P Id 16663610\r\n   |\r\n   `- P '256\r\n```\r\n"
license-name: BSD-3-Clause

all-versions:
- 1.0.0.0
- 1.0.1.0
- 1.0.1.1
- 1.0.1.2
- 1.1.0.0
- 1.1.1.0
- 1.1.1.1
- 1.1.1.2
- 1.1.1.3
- 1.1.2.0
- 1.1.2.1
- 1.1.3.1
- 1.1.3.2
- 1.1.3.3
- 1.1.3.4
- 1.1.3.5
- 1.1.3.6
author: ''
basic-deps:
  base: '>=4.5 && <5'
  deepseq: '>=1.1'
  ghc-prim: '>=0'
changelog: "# Pretty library change log\n\n## 1.1.3.6 -- 30th January, 2018\n\n* Fix
  compatability with GHC-8.4/base-4.11 (by Herbert Valerio Riedel).\n* Add in benchmarking
  framework (by Alfredo Di Napoli).\n\n## 1.1.3.5 -- 1st February, 2017\n\n* Fix documentation
  formatting bug (by Ivan Lazar Miljenovic)\n* Fix missing git tag on Github for v1.1.3.4
  release.\n\n## 1.1.3.4 -- 3rd June, 2016\n\n* Fix over-zeleaous use of strictness
  causing stack allocation, fixes part of\n  issue #32 (by Neil Mitchell).\n\n## 1.1.3.3
  -- 29th February, 2016\n\n* Improve documentation.\n\n## 1.1.3.2 -- 19th March,
  2015\n\n* Fix bug with haddock documentation.\n* Clean up module intro documentation.\n\n##
  1.1.3.1 -- 11th March, 2015\n\n* Add support for annotations in pretty (by Trevor
  Elliott).\n\n## 1.1.2.1 -- 25th December, 2014\n\n* Fix overly-strict issue preventing
  use of pretty for very large\n  docs (by Eyal Lotem).\n\n## 1.1.2.0 -- 25th December,
  2014\n\n* Merge in prettyclass package -- new Text.PrettyPrint.HughesPHClass.\n*
  Add in 'maybe\\*' variants of various bracket functins.\n* Add Generic instances
  for appropriate data types.\n* Fix compilation under GHC 7.10\n\n## 1.1.1.3 -- 21st
  December, 2014\n\n* Remove upper bound on `deepseq` package to fix build issues
  with\n  latest GHC.\n\n## 1.1.1.2 -- 18th August, 2014\n\n* Add NFData and Eq instances
  (by Ivan Lazar Miljenovic).\n\n## 1.1.1.1 -- 27th October, 2013\n\n* Update pretty
  cabal file and readme.\n* Fix tests to work with latest quickcheck.\n\n## Version
  3.0, 28 May 1987\n\n* Cured massive performance bug. If you write:\n\n    foldl
  <> empty (map (text.show) [1..10000])\n\n  You get quadratic behaviour with V2.0.
  Why? For just the same\n  reason as you get quadratic behaviour with left-associated
  (++)\n  chains.\n\n  This is really bad news. One thing a pretty-printer abstraction\n
  \ should certainly guarantee is insensitivity to associativity. It\n  matters: suddenly
  GHC's compilation times went up by a factor of\n  100 when I switched to the new
  pretty printer.\n  \n  I fixed it with a bit of a hack (because I wanted to get
  GHC back\n  on the road). I added two new constructors to the Doc type, Above\n
  \ and Beside:\n  \n    <> = Beside\n    $$ = Above\n  \n  Then, where I need to
  get to a \"TextBeside\" or \"NilAbove\" form I\n  \"force\" the Doc to squeeze out
  these suspended calls to Beside and\n  Above; but in so doing I re-associate. It's
  quite simple, but I'm\n  not satisfied that I've done the best possible job. I'll
  send you\n  the code if you are interested.\n\n* Added new exports:\n    punctuate,
  hang\n    int, integer, float, double, rational,\n    lparen, rparen, lbrack, rbrack,
  lbrace, rbrace,\n\n* fullRender's type signature has changed. Rather than producing
  a\n  string it now takes an extra couple of arguments that tells it how\n  to glue
  fragments of output together:\n\n    fullRender :: Mode\n               -> Int                       --
  Line length\n               -> Float                     -- Ribbons per line\n               ->
  (TextDetails -> a -> a)   -- What to do with text\n               -> a                         --
  What to do at the end\n               -> Doc\n               -> a                         --
  Result\n\n  The \"fragments\" are encapsulated in the TextDetails data type:\n\n
  \   data TextDetails = Chr  Char\n                     | Str  String\n                     |
  PStr FAST_STRING\n\n  The Chr and Str constructors are obvious enough. The PStr\n
  \ constructor has a packed string (FAST_STRING) inside it. It's\n  generated by
  using the new \"ptext\" export.\n\n  An advantage of this new setup is that you
  can get the renderer to\n  do output directly (by passing in a function of type
  (TextDetails\n  -> IO () -> IO ()), rather than producing a string that you then\n
  \ print.\n\n## Version 3.0, 28 May 1987\n\n* Made empty into a left unit for <>
  as well as a right unit;\n  it is also now true that\n    nest k empty = empty\n
  \ which wasn't true before.\n\n* Fixed an obscure bug in sep that occasionally gave
  very weird behaviour\n\n* Added $+$\n\n* Corrected and tidied up the laws and invariants\n\n##
  Version 1.0\n\nRelative to John's original paper, there are the following new features:\n\n1.
  There's an empty document, \"empty\". It's a left and right unit for\n   both <>
  and $$, and anywhere in the argument list for\n   sep, hcat, hsep, vcat, fcat etc.\n\n
  \  It is Really Useful in practice.\n\n2. There is a paragraph-fill combinator,
  fsep, that's much like sep,\n   only it keeps fitting things on one line until it
  can't fit any more.\n\n3. Some random useful extra combinators are provided.\n     <+>
  puts its arguments beside each other with a space between them,\n         unless
  either argument is empty in which case it returns the other\n\n\n     hcat is a
  list version of <>\n     hsep is a list version of <+>\n     vcat is a list version
  of $$\n\n     sep (separate) is either like hsep or like vcat, depending on what
  fits\n\n     cat  behaves like sep,  but it uses <> for horizontal composition\n
  \    fcat behaves like fsep, but it uses <> for horizontal composition\n\n     These
  new ones do the obvious things:\n       char, semi, comma, colon, space,\n       parens,
  brackets, braces,\n       quotes, doubleQuotes\n\n4. The \"above\" combinator, $$,
  now overlaps its two arguments if the\n   last line of the top argument stops before
  the first line of the\n   second begins.\n\n     For example:  text \"hi\" $$ nest
  5 (text \"there\")\n     lays out as\n                   hi   there\n     rather
  than\n                   hi\n                        there\n\n   There are two places
  this is really useful\n\n     a) When making labelled blocks, like this:\n            Left
  ->   code for left\n            Right ->  code for right\n            LongLongLongLabel
  ->\n                      code for longlonglonglabel\n        The block is on the
  same line as the label if the label is\n        short, but on the next line otherwise.\n\n
  \    b) When laying out lists like this:\n            [ first\n            , second\n
  \           , third\n            ]\n        which some people like. But if the list
  fits on one line you\n        want [first, second, third]. You can't do this with
  John's\n        original combinators, but it's quite easy with the new $$.\n\n   The
  combinator $+$ gives the original \"never-overlap\" behaviour.\n\n5. Several different
  renderers are provided:\n     * a standard one\n     * one that uses cut-marks to
  avoid deeply-nested documents\n       simply piling up in the right-hand margin\n
  \    * one that ignores indentation (fewer chars output; good for machines)\n     *
  one that ignores indentation and newlines (ditto, only more so)\n\n6. Numerous implementation
  tidy-ups\n   Use of unboxed data types to speed up the implementation\n\n"
changelog-type: markdown
description: |+
  # Pretty : A Haskell Pretty-printer library

  [![Hackage](https://img.shields.io/hackage/v/pretty.svg?style=flat)](https://hackage.haskell.org/package/pretty)
  [![Hackage Dependencies](https://img.shields.io/hackage-deps/v/pretty.svg?style=flat)](http://packdeps.haskellers.com/reverse/pretty)
  [![BSD3 License](http://img.shields.io/badge/license-BSD3-brightgreen.svg?style=flat)][tl;dr Legal: BSD3]
  [![Build](https://img.shields.io/travis/haskell/pretty.svg?style=flat)](https://travis-ci.org/haskell/pretty)

  [tl;dr Legal: BSD3]:
    https://tldrlegal.com/license/bsd-3-clause-license-(revised)
    "BSD3 License"

  Pretty is a pretty-printing library, a set of API's that provides a
  way to easily print out text in a consistent format of your choosing.
  This is useful for compilers and related tools.

  It is based on the pretty-printer outlined in the  paper 'The Design
  of a Pretty-printing Library' by John Hughes in Advanced Functional
  Programming, 1995. It can be found
  [here](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.8777).

  ## Licensing

  This library is BSD-licensed.

  ## Building

  The library uses the Cabal build system, so building is simply a
  matter of running:

  ```
  cabal sandbox init
  cabal install "QuickCheck >= 2.5 && < 3"
  cabal install --only-dependencies
  cabal configure --enable-tests
  cabal build
  cabal test
  ```

  We have to install `QuickCheck` manually as otherwise Cabal currently
  throws an error due to the cyclic dependency between `pretty` and
  `QuickCheck`.

  *If `cabal test` freezes*, then run
  `cabal test --show-details=streaming` instead. This is due to a
  [bug](https://github.com/haskell/cabal/issues/1810) in certain
  versions of Cabal.

  ## Get involved!

  We are happy to receive bug reports, fixes, documentation enhancements,
  and other improvements.

  Please report bugs via the
  [github issue tracker](http://github.com/haskell/pretty/issues).

  Master [git repository](http://github.com/haskell/pretty):

  * `git clone git://github.com/haskell/pretty.git`

  ## Authors

  This library is maintained by David Terei, <code@davidterei.com>. It
  was originally designed by John Hughes's and since heavily modified by
  Simon Peyton Jones.

description-type: markdown
hash: e16ffc733e816cfc09e99cc7f2398805f1f4c872d238a6b81668b5527284b382
homepage: http://github.com/haskell/pretty
latest: 1.1.3.6
license-name: BSD-3-Clause
maintainer: David Terei <code@davidterei.com>
synopsis: Pretty-printing library
test-bench-deps:
  QuickCheck: '>=2.5 && <3'
  base: '>=4.5 && <5'
  criterion: '>=0'
  deepseq: '>=1.1'
  ghc-prim: '>=0'
  pretty: '>=0'

homepage: https://github.com/ollef/rock#readme
changelog-type: markdown
hash: ca51aeeee50d6008f52d02712e749f46f0a95f945c65d312a19911da4d0f37c7
test-bench-deps: {}
maintainer: fredriksson.olle@gmail.com
synopsis: A build system for incremental, parallel, and demand-driven computations
changelog: |
  # Unreleased

  # 0.1.0.0

  - Initial release
basic-deps:
  dependent-sum: -any
  dependent-sum-template: -any
  base: ! '>=4.7 && <5'
  deriving-compat: -any
  rock: -any
  dependent-map: -any
  protolude: -any
  mtl: -any
  transformers: -any
all-versions:
- 0.1.0.0
author: Olle Fredriksson
latest: 0.1.0.0
description-type: markdown
description: |
  # rock [![Hackage](https://img.shields.io/hackage/v/rock.svg)](https://hackage.haskell.org/package/rock)

  A build system inspired by [Build systems Ã  la carte](https://www.microsoft.com/en-us/research/publication/build-systems-la-carte/) and [Haxl](http://hackage.haskell.org/package/haxl).

  Used in [Sixten](https://github.com/ollef/sixten) and
  [Sixty](https://github.com/ollef/sixty) to achieve incremental and query driven
  compiler architectures.

  # Example

  ```haskell
  {-# language GADTs #-}
  {-# language NoImplicitPrelude #-}
  {-# language OverloadedStrings #-}
  {-# language StandaloneDeriving #-}
  {-# language TemplateHaskell #-}

  import Protolude

  import Data.GADT.Compare.TH (deriveGEq, deriveGCompare)
  import qualified Rock

  data Query a where
    A :: Query Integer
    B :: Query Integer
    C :: Query Integer
    D :: Query Integer

  deriving instance Show (Query a)

  deriveGEq ''Query
  deriveGCompare ''Query

  rules :: Rock.Rules Query
  rules key = do
    putText $ "Fetching " <> show key
    case key of
      A -> pure 10
      B -> do
        a <- Rock.fetch A
        pure $ a + 20
      C -> do
        a <- Rock.fetch A
        pure $ a + 30
      D ->
        (+) <$> Rock.fetch B <*> Rock.fetch C

  main :: IO ()
  main = do
    do
      putText "Running"
      result <- Rock.runTask Rock.sequentially rules (Rock.fetch D)
      print result
    do
      putText "Running with memoisation"
      memoVar <- newMVar mempty
      result <-
        Rock.runTask
          Rock.sequentially
          (Rock.memoise memoVar rules)
          (Rock.fetch D)
      print result
    do
      putText "Running with memoisation using the parallel strategy"
      memoVar <- newMVar mempty
      result <-
        Rock.runTask
          Rock.inParallel
          (Rock.memoise memoVar rules)
          (Rock.fetch D)
      print result
  ```

  Prints

  ```
  Running
  Fetching D
  Fetching B
  Fetching A
  Fetching C
  Fetching A
  70
  Running with memoisation
  Fetching D
  Fetching B
  Fetching A
  Fetching C
  70
  Running with memoisation using the parallel strategy
  Fetching D
  Fetching C
  Fetching B
  Fetching A
  70
  ```

  # Related projects

  * [Shake](http://hackage.haskell.org/package/shake)
  * [Salsa](https://crates.io/crates/salsa)

  # Contributions

  ... are very welcome, especially in the areas of documentation, examples,
  testing, and benchmarking.
license-name: BSD-3-Clause

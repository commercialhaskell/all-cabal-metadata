homepage: https://sqids.org/
changelog-type: markdown
hash: 7eb96f89e41c0a27b5b11df9444a9435ce2777bcc6427a0dd32725800756d7de
test-bench-deps:
  split: '>=0.2.3.5 && <0.3.0.0'
  base: '>=4.7 && <5'
  hspec: '>=2.10.10 && <2.12'
  text: '>=2.0.2 && <2.1.0'
  containers: '>=0.6.7 && <0.7.0'
  sqids: -any
  mtl: '>=2.2.2 && <2.4.0'
maintainer: hildenjohannes@gmail.com
synopsis: A small library that lets you generate YouTube-looking IDs from numbers.
changelog: "# CHANGELOG\n\n@todo\n\n[0.1.3.0] \n\n[0.1.2.1] \n"
basic-deps:
  base: '>=4.7 && <5'
  text: '>=2.0.2 && <2.1.0'
  containers: '>=0.6.7 && <0.7.0'
  mtl: '>=2.2.2 && <2.4.0'
  transformers: '>=0.5.6.2 && <0.7.0.0'
all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
- 0.1.2.1
- 0.1.3.0
author: Heikki Johannes Hildén
latest: 0.1.3.0
description-type: markdown
description: "# [Sqids Haskell](https://sqids.org/haskell)\n\n[![Haskell CI](https://github.com/sqids/sqids-haskell/actions/workflows/haskell.yml/badge.svg)](https://github.com/sqids/sqids-haskell/actions/workflows/haskell.yml)\n[![License:
  MIT](https://img.shields.io/badge/license-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Language](https://img.shields.io/badge/language-Haskell-orange.svg)](https://www.haskell.org/)\n[![Hackage](https://img.shields.io/hackage/v/sqids.svg)](https://hackage.haskell.org/package/sqids)\n\nSqids
  (pronounced \"squids\") is a small library that lets you generate YouTube-looking
  IDs from numbers. It's good for link shortening, fast & URL-safe ID generation and
  decoding back into numbers for quicker database lookups.\n\n### Table of contents\n\n*
  [Getting started](#getting-started)\n  * [Installation](#installation)\n  * [Usage](#usage)\n
  \   * [Encoding](#encoding)\n    * [Decoding](#decoding)\n    * [Setting options](#setting-options)\n
  \   * [Monad transformer](#monad-transformer)\n    * [Error handling](#error-handling)\n*
  [Options](#%EF%B8%8F-options)\n* [Errors](#-errors)\n* [Notes](#notes)\n* [API documentation](#-api-documentation)\n*
  [License](#license)\n\n## \U0001F3C3Getting started\n\n### Installation\n\nSqids
  is available on Hackage ([hackage.haskell.org/package/sqids](https://hackage.haskell.org/package/sqids)).
  To install this package, run:\n\n```\ncabal install sqids\n```\n\nOr using [Stack](https://docs.haskellstack.org/en/stable/):\n\n```\nstack
  install sqids\n```\n\n### Usage\n\nUse `encode` to translate a list of non-negative
  integers into an ID, and\n`decode` to retrieve back the list of numbers encoded
  by an ID.\n\n```\nencode :: [Int] -> Sqids Text\ndecode:: Text -> Sqids [Int]\n```\n\nThese
  functions return (monadic) values of type `Sqids a`. Calling `sqids` or\n`runSqids`
  (see below) is the most straightforward way to extract the `something`\nfrom a `Sqids
  something` value.\n\n```\nsqids :: Sqids a -> Either SqidsError a\n```\n\nTo be
  more accurate, this gives you a value of type `Either SqidsError a`, where\n`a`
  is the ID in the case of `encode`. If encoding fails for some reason, then\nthe
  `Left` constructor [contains the error](#error-handling).\nFor some use cases, directly
  calling `sqids` or `runSqids` in this way is\nsufficient. If you do this in multiple
  locations in your code, however,\nespecially when IO or other effects are involved,
  the\n[`SqidsT` monad transformer](#monad-transformer) is a better choice.\n\n####
  Encoding\n\n```haskell\nmodule Main where\n\nimport Web.Sqids\n\nmain :: IO ()\nmain
  =\n  case sqids (encode [1, 2, 3]) of\n    Left  {}   -> print \"Something went
  wrong.\"\n    Right sqid -> print sqid\n```\n\n> The output of this program is:\n>\n>
  ```\n> \"8QRLaD\"\n> ```\n\n#### Decoding\n\n```haskell\n{-# LANGUAGE OverloadedStrings
  #-}\nmodule Main where\n\nimport Web.Sqids\n\nmain :: IO ()\nmain =\n  case sqids
  (decode \"8QRLaD\") of\n    Left  {}   -> print \"Something went wrong.\"\n    Right
  nums -> print nums\n```\n\n> The output of this program is:\n>\n> ```\n> [1,2,3]\n>
  ```\n\n##### A note about the `OverloadedStrings` language extension\n\n`decode`
  takes a `Text` value as input. If you are not compiling with `OverloadedStrings`
  enabled, the `\"8QRLaD\"` string literal in the previous example would need to be
  explicitly converted, using the `pack` function from `Data.Text`.\n\n```haskell\nimport
  Data.Text (pack)\n```\n\n```haskell\ndecode (pack \"8QRLaD\")\n```\n\n#### Setting
  options\n\nTo pass custom options to `encode` and `decode`, use `runSqids` which
  takes\nan additional `SqidsOptions` argument.\n\n```\nrunSqids :: SqidsOptions ->
  Sqids a -> Either SqidsError a\n```\n\nSee [here](#%EF%B8%8F-options) for available
  options. You can override the default values using\n`defaultSqidsOptions`, and the
  following idiom:\n\n```haskell\nmain =\n  case runSqids defaultSqidsOptions{ minLength
  = 24 } (encode [1, 2, 3]) of\n    Left  {}   -> print \"Something went wrong.\"\n
  \   Right sqid -> print sqid\n```\n\n> The output of this program is:\n>\n> ```\n>
  \"75JILToVsGerOADWmT1cd0dL\"\n> ```\n\nTo set a custom alphabet:\n\n```haskell\nmain
  =\n  case runSqids defaultSqidsOptions{ alphabet = \"0123456789ABCDEF\" } (encode
  [1, 2, 3]) of\n    Left  {}   -> print \"Something went wrong.\"\n    Right sqid
  -> print sqid\n```\n\n> The output of this program is:\n>\n> ```\n> \"4D9D02\"\n>
  ```\n\nOr, you can set all options at once:\n\n```haskell\nmain = do\n  let options
  = SqidsOptions\n        { alphabet  = \"1234567890\"\n        , minLength = 8\n
  \       , blocklist = []\n        }\n  case runSqids options (encode [1, 2, 3])
  of\n    Left  {}   -> print \"Something went wrong.\"\n    Right sqid -> print sqid\n```\n\n>
  The output of this program is:\n>\n> ```\n> \"31764540\"\n> ```\n\n#### Monad transformer\n\nIn
  a more realistically sized application, calling `runSqids` every time you\nneed
  to access the value returned by `encode` or `decode` isn't ideal. Instead,\nyou
  probably want to create your `SqidsOptions` once, and then do things with\nthe IDs
  across the code without having to pass the options object along every\ntime. Assuming
  your application relies on a transformer stack to combine effects\nfrom different
  monads, then this implies adding the `SqidsT` transformer at\nsome suitable layer
  of the stack. Instead of `sqids` and `runSqids`, there are \ntwo corresponding functions
  to fish out the value from inside of `SqidsT`:\n\n```\nsqidsT :: Monad m => SqidsT
  m a -> m (Either SqidsError a)\nrunSqidsT :: Monad m => SqidsOptions -> SqidsT m
  a -> m (Either SqidsError a)\n```\n\nBelow is an example where `SqidsT` is used
  in combination with the `Writer` and\n`IO` monads.\n\n```haskell\nmodule Main where\n\nimport
  Control.Monad (forM_)\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Trans.Class
  (lift)\nimport Control.Monad.Writer (WriterT, execWriterT, tell)\nimport Data.Text
  (Text)\nimport Web.Sqids\n\nmain :: IO ()\nmain = do\n  w <- sqidsT (execWriterT
  makeIds)\n  case w of\n    Left  err -> print (\"Error: \" <> show err)\n    Right
  ids -> print ids\n\nmakeIds :: WriterT [Text] (SqidsT IO) ()\nmakeIds = do\n  liftIO
  $ print \"Generating IDs\"\n  forM_ [1 .. 50] $ \\n -> do\n    sqid <- encode [n,
  n, n, n]\n    tell [sqid]\n```\n\n> The output of this program is:\n>\n> ```\n>
  \"Generating IDs\"\n> [\"QkA3AmAC\",\"fh9rtRtv\",\"a7totm7V\",\"KF5Z5l4X\",\"ngqSq2b3\",\"pjkCJlJf\",\"yTrOSYSQ\",\"HKVia9J2\",\"0gTF2Zr3\",\"jiw7wbw1\",\"PtNNFWFA\",\"I0vlvGvD\",\"08TV2Sr5\",\"UPLILMlD\",\"ut2A2D20\",\"Inv5vZvK\",\"pDkBJTJJ\",\"P1N8FRFr\",\"R2eqeYeY\",\"Ki5o5Q4U\",\"1k70bzbD\",\"dK4cE6Es\",\"1L7XbJbZ\",\"FyGjG1G0\",\"ZEMReNre\",\"aKtMte79\",\"UtLNL9li\",\"o6lElt2f\",\"1w7ebtbl\",\"nuqNqqbk\",\"HlVSaOJ9\",\"IKvdvave\",\"3cWkDSD9\",\"oQlzlc2C\",\"RrezeDeC\",\"OhJcJoVR\",\"OEJFJzVJ\",\"oplJlm2F\",\"u8292F2H\",\"FZGiGzGI\",\"dN40E9EO\",\"Q0AdAhAR\",\"HJVzaaJC\",\"s08YCUdX\",\"sW8UCadW\",\"ZaMNekrp\",\"X4bsWS4Z\",\"OoJIJEVj\",\"Rqe1eTey\",\"3aWYDXDs\"]\n>
  ```\n\n#### Error handling\n\nEncoding and decoding can fail for various reasons.\n\n```haskell\n
  \ case runSqids options (encode numbers) of\n    Left SqidsNegativeNumberInInput
  ->\n      print \"Negative numbers are not allowed as input.\"\n    _ ->\n      --
  etc...\n```\n\nSee [here](#-errors) for possible errors.\n\nThe following is an
  example of how to handle errors with the help of\n`MonadError`s exception-handling
  mechanism:\n\n```haskell\n{-# LANGUAGE OverloadedStrings #-}\nmodule Main where\n\nimport
  Control.Monad.Except (catchError)\nimport Control.Monad.IO.Class (liftIO)\nimport
  Data.Either (fromRight)\nimport Data.Text (unpack)\nimport Text.Read (readMaybe)\nimport
  Web.Sqids\n\nrepl :: SqidsT IO ()\nrepl = do\n  input <- liftIO $ do\n    putStrLn
  \"Enter a comma-separated list of non-negative integers, or \\\"exit\\\".\"\n    putStr
  \"> \"\n    getLine\n  if input == \"exit\"\n    then pure ()\n    else do\n      case
  readMaybe (\"[\" <> input <> \"]\") of\n        Nothing ->\n          liftIO $ putStrLn
  \"Invalid input: Please try again.\"\n        Just numbers ->\n          catchError
  (encode numbers >>= liftIO . putStrLn . unpack) $ \\err ->\n            liftIO $
  case err of\n              SqidsNegativeNumberInInput ->\n                putStrLn
  \"Only non-negative integers are accepted as input.\"\n              _ ->\n                putStrLn
  \"Unexpected error\"\n      repl\n\nrunRepl :: IO (Either SqidsError ())\nrunRepl
  = runSqidsT defaultSqidsOptions repl\n\nmain :: IO ()\nmain = fromRight () <$> runRepl\n```\n\n>
  Program example output: \n>\n> ![Example](readme/example.gif)\n\n## ⚙️ Options\n\n###
  `alphabet :: Text`\n\nThe alphabet used by the algorithm for encoding and decoding.\n\n*
  Default value: `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`\n\n###
  `minLength :: Int`\n\nThe minimum allowed length of IDs.\n\n* Default value: `0`\n\n###
  `blocklist :: [Text]`\n\nA list of words that must never appear in IDs.\n\n* Default
  value: See [src/Web/Sqids/Blocklist.hs](src/Web/Sqids/Blocklist.hs).\n* Also see
  [the official Sqids blocklist repository](https://github.com/sqids/sqids-blocklist).\n\n##
  \U0001F4A3 Errors\n\n### `SqidsAlphabetTooShort`\n\nThe alphabet must be at least
  5 characters long.\n\n### `SqidsAlphabetRepeatedCharacters`\n\nThe provided alphabet
  contains duplicate characters. E.g., `\"abcdefgg\"` is not\na valid alphabet.\n\n###
  `SqidsInvalidMinLength`\n\nThe given `minLength` value is not within the valid range.\n\n###
  `SqidsNegativeNumberInInput`\n\nOne or more numbers in the list passed to `encode`
  are negative. Only\nnon-negative integers can be used as input.\n\n## Notes\n\n-
  **Do not encode sensitive data.** These IDs can be easily decoded.\n- **Default
  blocklist is auto-enabled.** It's configured for the most common profanity words.
  Create your own custom list by using the blocklist parameter, or pass an empty list
  to allow all words.\n- Read more at https://sqids.org/haskell\n\n## \U0001F4C4 API
  documentation\n\nSee https://hackage.haskell.org/package/sqids.\n\n## License\n\n[MIT](LICENSE)\n"
license-name: MIT

homepage: ''
changelog-type: markdown
hash: bf328f1c8bb7fe00a5e8c1dc919a55b32cf268deb73d9b1e8475d7af26d577dc
test-bench-deps: {}
maintainer: chessai <chessai1996@gmail.com>
synopsis: Generate swift types from haskell types.
changelog: "# Revision history for shwifty\n\n## 0.0.2.0 - 2020-02-26\n\n* Primitive
  lower bound: 0.7 -> 0.6.4\n* Fix issue with type defaulting in disambiguate\n* Add
  docs to 'toSwift'\n* Add 'Codec' API for cleaner deriving\n* Remove usage of -XDuplicateRecordFields\n*
  Add getShwiftyCodecTags \n* Cleanup internal code (organise but maintain external
  API)\n* Add support for private enums/structs \n* Add support for 'base' types\n*
  Add support for omitting fields and cases \n* Remove indent option \n* Fix pretty-printing
  for functions in swift\n* Remove instance for Void\n* Make 'prettySwiftData' a top-level
  function\n* Remove 'Comparable' protocol\n\n## 0.0.1.0 -- 2020-02-03\n\n* First
  version. Released on an unsuspecting world.\n"
basic-deps:
  bytestring: '>=0.10 && <0.11'
  case-insensitive: '>=1.2 && <1.3'
  base: '>=4.11 && <4.15'
  time: '>=1.8 && <1.11'
  unordered-containers: '>=0.2 && <0.3'
  text: '>=1.2 && <1.3'
  th-abstraction: '>=0.3 && <0.4'
  containers: '>=0.5.9 && <0.7'
  mtl: '>=2.2 && <2.3'
  uuid-types: '>=1.0 && <1.1'
  template-haskell: '>=2.11 && <2.17'
  primitive: '>=0.6.4 && <0.8'
  vector: '>=0.12 && <0.13'
all-versions:
- 0.0.1.0
- 0.0.2.0
- 0.0.3.0
author: chessai
latest: 0.0.3.0
description-type: markdown
description: "# Shwifty\n\n## Generate Swift types from Haskell types\n\nExamples:
  \n\n#### A simple sum type\n```haskell\ndata SumType = Sum1 | Sum2 | Sum3\ngetShwifty
  ''SumType\n```\n\n```swift\nenum SumType {\n    case sum1\n    case sum2\n    case
  sum3\n}\n```\n\n#### A simple product type\n```haskell\ndata ProductType = ProductType
  { x :: Int, y :: Int }\ngetShwifty ''ProductType\n```\n\n```swift\nstruct ProductType
  {\n    let x: Int\n    let y: Int\n}\n```\n\n#### A sum type with type variables\n```haskell\ndata
  SumType a b = SumL a | SumR b\ngetShwifty ''SumType\n```\n\n```swift\nenum SumType<A,
  B> {\n    case sumL(A)\n    case sumR(B)\n}\n```\n\n#### A product type with type
  variables\n```haskell\ndata ProductType a b = ProductType \n  { aField :: a\n  ,
  bField :: b \n  }\ngetShwifty ''ProductType\n```\n\n```swift\nstruct ProductType<A,
  B> {\n    let aField: A\n    let bField: B\n}\n```\n\n#### A newtype\n```haskell\nnewtype
  Newtype a = Newtype { getNewtype :: a }\ngetShwifty ''Newtype\n```\n\n```swift\nstruct
  Newtype<A> {\n    let getNewtype: A\n}\n```\n\n#### A type with a function field\n```haskell\nnewtype
  Endo a = Endo { appEndo :: a -> a }\ngetShwifty ''Endo\n```\n\n```swift\nstruct
  Endo<A> {\n    let appEndo: ((A) -> A)\n}\n```\n\n#### A weird type with nested
  fields. Also note the Result's types being flipped from that of the Either.\n```haskell\ndata
  YouveGotProblems a b = YouveGotProblems \n  { field1 :: Maybe (Maybe (Maybe a))\n
  \ , field2 :: Either (Maybe a) (Maybe b) \n  }\ngetShwifty ''YouveGotProblems\n```\n\n```swift\nstruct
  YouveGotProblems<A, B> {\n    let field1: A???\n    let field2: Result<B?, A?>\n}\n```\n\n####
  A type with polykinded type variables\n```haskell\ndata PolyKinded (a :: k) = PolyKinded\ngetShwifty
  ''PolyKinded\n```\n\n```swift\nstruct PolyKinded<A> { }\n```\n\n#### A sum type
  where constructors might be records\n```haskell\ndata SumType a b (c :: k) \n  =
  Sum1 Int a (Maybe b) \n  | Sum2 b \n  | Sum3 { x :: Int, y :: Int }\ngetShwifty
  ''SumType\n```\n\n```swift\nenum SumType<A, B, C> {\n  case field1(Int, A, B?)\n
  \ case field2(B)\n  case field3(_ x: Int, _ y: Int)\n}\n```\n\n#### A type containing
  another type with instance generated by 'getShwifty'\n```haskell\nnewtype MyFirstType
  a = MyFirstType { getMyFirstType :: a }\ngetShwifty ''MyFirstType\n\ndata Contains
  a = Contains \n  { x :: MyFirstType Int\n  , y :: MyFirstType a \n  }\ngetShwifty
  ''Contains\n```\n\n```swift\nstruct MyFirstType<A> {\n  let getMyFirstType: A\n}\n\nstruct
  Contains<A> {\n  let x: MyFirstType<Int>\n  let y: MyFirstType<A>\n}\n```\n"
license-name: MIT

homepage: ''
changelog-type: markdown
hash: 3ba1fa0ccd45a2c3f150410f8982ce8b315da4cc8827adcc4943dbf78f67235f
test-bench-deps:
  base: ! '>=4.9'
  async: -any
  doctest: -any
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
  shh: -any
  directory: -any
maintainer: lukec@themk.net
synopsis: Simple shell scripting from Haskell
changelog: |
  # Revision history for shh

  ## 0.5.0.0 -- 2019-05-23

  * Change how identifiers are encoded to avoid clashes in all scenarios
    (Potentially breaking change)

  ## 0.4.0.0 -- 2019-04-20

  * Pre-compile Shell.hs for faster loading of shh shell
  * Introduce `nativeProc` interface and related functions (`pureProc`...)
  * Allow type-changing `|>` which enables `capture` and
    similar "processes" to replace the less consistent `readProc`
    family of functions.  `s <- readProc $ echo "Hello"` can now
    be written `s <- echo "Hello" |> capture`. This allows capturing
    within the `Proc` monad to manipulate the stream in Haskell.
  * Introduce `xargs1` function which can replace some uses of the `xargs`
    utility, and provides a type-checked, and spell-checked interface
    similar to `xargs`.

  ## 0.3.X.X -- 2019-03-10

  * Changes how lazy reading works. We no longer terminate the process, we
    just close the handles and wait for the process to terminate naturally.

    This eliminates a source of non-determinism

  ## 0.2.X.X -- 2019-01-23

  * Extended the ExecArg typeclass to handle lists.

  ## 0.1.X.X  -- 2018-11-02

  * First version. Released on an unsuspecting world.
basic-deps:
  unix: ! '>=2.7.2 && <2.8'
  split: ! '>=0.2.3 && <0.3'
  base: ! '>=4.9 && <4.13'
  filepath: ! '>=1.4.2 && <1.5'
  process: ! '>=1.6.3 && <1.7'
  async: ! '>=2.2.1 && <2.3'
  containers: ! '>=0.5.11 && <0.7'
  mtl: ! '>=2.2.2 && <2.3'
  temporary: -any
  deepseq: ! '>=1.4.3 && <1.5'
  shh: -any
  template-haskell: ! '>=2.13.0 && <2.15'
  directory: ! '>=1.3.1 && <1.4'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.2.0.0
- 0.2.0.1
- 0.2.0.2
- 0.2.0.3
- 0.2.0.4
- 0.2.0.5
- 0.2.0.6
- 0.3.0.0
- 0.3.0.1
- 0.3.1.0
- 0.3.1.1
- 0.3.1.2
- 0.3.1.3
- 0.4.0.0
- 0.4.0.1
- 0.5.0.0
author: Luke Clifton
latest: 0.5.0.0
description-type: markdown
description: "# Shh\n\n[![](https://img.shields.io/hackage/v/shh.svg?colorB=%23999&label=shh)](http://hackage.haskell.org/package/shh)\n[![](https://img.shields.io/hackage/v/shh-extras.svg?colorB=%23999&label=shh-extras)](http://hackage.haskell.org/package/shh-extras)\n[![](https://builds.sr.ht/~lukec/shh/nix.yml.svg)](https://builds.sr.ht/~lukec/shh/nix.yml?)\n\nShh
  is a library to enable convinient shell-like programming in Haskell.\nIt works well
  in scripts, and from GHCi, allowing you to use GHCi as a shell.\n\nIt's primary
  purpose is in replacing shell scripts. As such, many\nfunctions are provided to
  mimic the shell environment, and porting shell\nscripts to shh should be fairly
  straightforward. A simple\n[\"cargo culting\" port](docs/porting.md) should work
  in most situations,\nand perhaps be even more robust than the original.\n\nIt is
  also a wrapper tool around launching GHCi as a shell.\n\nIt supports\n\n * Automatically
  defining a function for each executable on your `$PATH`\n   using template Haskell,
  as well as a runtime check to ensure they all\n   exist on startup.\n\n * Redirction
  of stdout and stderr\n       \n       -- Redirect stdout\n       λ echo \"Hello\"
  &> StdErr\n       λ echo \"Hello\" &> Truncate \".tmp_file\"\n\n       -- Redirect
  stderr\n       λ echo \"Hello\" &!> Append \"/dev/null\"\n       λ echo \"Hello\"
  &!> StdOut\n\n\n * Piping stdout or stderr to the input of a chained process\n       \n
  \      λ cat \"/dev/urandom\" |> xxd |> head \"-n\" 5\n\n * Multiple processes sequentially
  feeding a single process\n\n       λ (echo 1 >> echo 2) |> cat\n\n * Use of Haskells
  concurrency primitives.\n\n       λ race (sleep 1) $ curl \"http://this_needs_to_timeout_after_1_second\"\n\n
  \      λ d <- readTrim $ mktemp \"-d\"\n       λ :{\n       | System.Directory.withCurrentDirectory
  d $ do\n       |   mapConcurrently_ (curl \"-LOJs\")\n       |     [ \"https://raw.githubusercontent.com/luke-clifton/shh/master/shell.nix\"\n
  \      |     , \"https://raw.githubusercontent.com/luke-clifton/shh/master/shh.cabal\"\n
  \      |     ]\n       |   ls\n       | :}\n\n * Capturing of process output\n\n
  \      λ s <- echo \"Hello\" |> tr \"-d\" \"l\" |> capture\n\n       λ loggedIn
  <- nub . words <$> readProc users\n       λ putStrLn $ \"Logged in users: \" ++
  show loggedIn\n\n       λ mapM_ putStrLn =<< readSplit0 (Shh.Example.find \"-maxdepth\"
  1 \"-print0\")\n\n * Capturing infinite output of a process lazily\n\n       λ withRead
  (cat \"/dev/urandom\" |> xxd) $ mapM_ putStrLn . take 3 . lines\n       00000000:
  8fcb ebee 9228 a897 3bfc 1d05 491d aceb  .....(..;...I...\n       00000010: 47de
  3ea3 2788 44ac 9b85 0a0f a458 b949  G.>.'.D......X.I\n       00000020: 5308 ddfe
  5790 5a5f 39e3 bbb6 b689 2b03  S...W.Z_9.....+.\n\n * Write strings to stdin of
  a process.\n\n       λ writeProc cat \"Hello\\n\"\n       Hello\n\n       λ \"Hello\"
  >>> shasum\n       f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0  -\n\n       λ shasum
  <<< \"Hello\"\n       f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0  -\n\n * Proper exceptions,
  when a process exits with a failure code, an exception\n   is thrown. You can catch
  these normally. The exception includes the error\n   code, the command, and all
  it's arguments.\n\n       λ false \"Ha, it died\"\n       *** Exception: Command
  `false \"Ha, it died\"` failed [exit 1]\n\n       λ catchCode false\n       1\n\n
  * \"Native\" processes, i.e. Haskell functions that behave like a process.\n\n       λ
  echo \"Hello\" |> pureProc (map toUpper) |> tr \"-d\" \"L\"\n       HEO\n\n * And
  much, much more! Look at the documentation on Hackage for a\n   comprehensive overview
  of all the possibilities.\n\n## Mnemonics \n\nShh has many symbols that might seem
  intimidating at first, but there\nis a simple mnemonic for them.\n\n    |     Piping.
  Looks like a pipe, same as in POSIX shells.\n    &     Redirection, think of the
  shell `2>&1`\n    >,<   The direction of flow of a command\n    !     Operate on
  stderr instead of stdout\n\nSo, for example,\n\n    ls |> cat      Pipe the stdout
  of `ls` into stdin of `cat`\n    cat <| ls      Same as above\n    ls &> StdErr
  \  Redirect stdout of `ls` to wherever stderr is going.\n    StdErr <& ls   Same
  as above\n    ls &!> StdOut  Redirect stderr of `ls` to wherever stdout is going.\n
  \   StdOut <!& ls  Same as above\n\n## Globbing\n\nCurrently Shh does not have any
  built in globbing support. Rather, it is\ncurrently suggested to use another library
  to do globbing. For example,\nusing the [Glob](http://hackage.haskell.org/package/Glob)
  package, it is\npossible to do something like\n\n    wc =<< glob \"*.md\"\n\nCertainly
  more verbose than the Bash equivalent, however, also more explicit,\nwhich is probably
  a good thing. If this turns out to be too cumbersome, we\nmight introduce a more
  succinct globbing feature, though it will always be\nexplicit, and thus always more
  verbose than most other shells.\n\n## Usage\n\nEnable Temlpate Haskell and load
  the environment\n\n    {-# LANGUAGE TemplateHaskell #-}\n    $(loadEnv SearchPath)\n\nYou
  now have all your executables available as simple to read\nHaskell functions.\n\nIf
  you want to check that all the dependenies still exist, you can use\n`missingExecutables
  :: IO [String]`, which will tell you if anything is\nmissing.\n\n### Usage in GHCi\n\nIf
  you want `^D` to be recognised as a EOF marker (when running commands\nthat read
  from stdin) when running in GHCi, you will need to run the\n`initInteractive` function.
  This sets the line buffering appropriately and\nensures the terminal is in canonical
  mode.\n\n### Shh as a Shell\n\nThere is a tool called `shh` which is a fairly small
  wrapper around launching\nGHCi which automatically loads your environment and allows
  you to have custom\nconfig when using GHCi as a shell.\n\nThe `shh` binary will
  look in your `$SHH_DIR` (defaults to `$HOME/.shh`) for\na `Shell.hs`, `init.ghci`
  and `wrapper` files. If these don't exist default\nones will be created.\n\nThe
  `Shell.hs` file should contain any top level definitions that you would\nlike to
  be available in your Shell. By default it loads your environment.\n\nThe `init.ghci`
  file is loaded by GHCi after your `.ghci` files. This lets\nyou specify settings
  that you want to take effect when using GHCi as a shell.\nBy default it sets a shell-like
  prompt.\n\nThe `wrapper` file is an executable that is called with the command that
  is\nto be executed. By default it just calls `exec` with the arguments passed to\nit.
  The use-case for this is to be able to set up the environment for `shh`.\nYou might,
  for example, wrap the execution in a `nix-shell`. Either way,\nit is up to you to
  make sure that the compiler, and packages you require are\navailable, either globally,
  or provided by the `wrapper` script.\n\n#### Faster Startup\n\n`shh` precompiles
  your `Shell.hs` file so that starting up `shh` is very\nquick on subsequent launches.
  Unfortunately, `shh` isn't quite able to detect\nthis perfectly. If you see GHCi
  telling you that it is `Compiling Shell`,\nand you notice the delay when starting
  `shh`, try manually forcing a rebuild\nby passing in the `--rebuild` argument to
  `shh`.\n\nThis is particularly likely to happen if you upgrade your GHC, or installed\npackages,
  or even `shh` itself.\n\n#### Nix Wrapper Example\n\nThe following snippet could
  act as a `wrapper` file to set up a suitable\nenvironment using `nix-shell`\n\n
  \   #! /usr/bin/env nix-shell\n    #! nix-shell -i bash -p \"(haskellPackages.ghcWithPackages
  (p: with p; [shh shh-extras]))\"\n    exec \"$@\"\n\n### Script Usage\n\nTODO: Fill
  this in once the user experience is better.\n"
license-name: BSD-3-Clause

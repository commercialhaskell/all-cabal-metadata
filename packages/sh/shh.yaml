homepage: ''
changelog-type: markdown
hash: 6ac65caec0bc03965b799fb0a9ad47f57e6e6b6dc77161b1e69b697f6fa3d5d0
test-bench-deps:
  base: ! '>=4.9'
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
  shh: -any
maintainer: lukec@themk.net
synopsis: Simple shell scripting from Haskell
changelog: "# Revision history for execpath\n\n## 0.2.0.0 -- 2019-01-23\n\n* Extended
  the ExecArg typeclass to handle lists.\n\n## 0.1.1.0 -- 2019-01-22\n\n* Generate
  an IO action to check for missing dependencies at runtime.\n\n* Add ability to use
  TH to load a list of specific executables.\n\n## 0.1.0.1 -- 2019-01-22\n\n* Force
  output of lazy read functions to normal form to prevent\n  people from accidentally
  holding onto resources.\n\n* New helper functions for reading.\n  \n## 0.1.0.0  --
  2018-11-02\n\n* First version. Released on an unsuspecting world.\n"
basic-deps:
  unix: ! '>=2.7.2 && <2.8'
  split: ! '>=0.2.3 && <0.3'
  base: ! '>=4.11 && <4.13'
  filepath: ! '>=1.4.2 && <1.5'
  process: ! '>=1.6.3 && <1.7'
  async: ! '>=2.2.1 && <2.3'
  mtl: ! '>=2.2.2 && <2.3'
  deepseq: ! '>=1.4.3 && <1.5'
  shh: -any
  template-haskell: ! '>=2.13.0 && <2.15'
  directory: ! '>=1.3.1 && <1.4'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.2.0.0
- 0.2.0.1
author: Luke Clifton
latest: 0.2.0.1
description-type: markdown
description: "# Shh\n\n[![](https://img.shields.io/hackage/v/shh.svg?colorB=%23999)](http://hackage.haskell.org/package/shh)\n[![](https://travis-ci.org/luke-clifton/shh.svg?branch=master)](https://travis-ci.org/luke-clifton/shh)\n\nShh
  is a library to enable convinient shell-like programming in Haskell.\nIt works well
  in scripts, and from GHCi, allowing you to use GHCi as a shell.\n\nIt supports\n\n
  * Automatically defining a function for each executable on your `$PATH`\n   using
  template Haskell, as well as a runtime check to ensure they all\n   exist on startup.\n\n
  * Redirction of stdout and stderr\n       \n       -- Redirect stdout\n       λ
  echo \"Hello\" &> StdErr\n       λ echo \"Hello\" &> Truncate \".tmp_file\"\n\n
  \      -- Redirect stderr\n       λ echo \"Hello\" &!> Append \"/dev/null\"\n       λ
  echo \"Hello\" &!> StdOut\n\n\n * Piping stdout or stderr to the input of a chained
  process\n       \n       λ cat \"/dev/urandom\" |> xxd |> head \"-n\" 5\n\n * Multiple
  processes sequentially feeding a single process\n\n       λ (echo 1 >> echo 2) |>
  cat\n\n * Use of Haskells concurrency primitives.\n\n       λ race (sleep 1) $ curl
  \"http://this_needs_to_timeout_after_1_second\"\n\n       λ d <- readTrim $ mktemp
  \"-d\"\n       λ :{\n       | System.Directory.withCurrentDirectory d $ do\n       |
  \  mapConcurrently_ (curl \"-LOJs\")\n       |     [ \"https://raw.githubusercontent.com/luke-clifton/shh/master/shell.nix\"\n
  \      |     , \"https://raw.githubusercontent.com/luke-clifton/shh/master/shh.cabal\"\n
  \      |     ]\n       |   ls\n       | :}\n\n * Capturing of process output\n\n
  \      λ loggedIn <- nub . words <$> readProc users\n       λ putStrLn $ \"Logged
  in users: \" ++ show loggedIn\n\n       λ mapM_ putStrLn =<< readSplit0 (Shh.Example.find
  \"-maxdepth\" 1 \"-print0\")\n\n * Capturing infinite output of a process lazily\n\n
  \      λ withRead (cat \"/dev/urandom\" |> xxd) $ mapM_ putStrLn . take 3 . lines\n
  \      00000000: 8fcb ebee 9228 a897 3bfc 1d05 491d aceb  .....(..;...I...\n       00000010:
  47de 3ea3 2788 44ac 9b85 0a0f a458 b949  G.>.'.D......X.I\n       00000020: 5308
  ddfe 5790 5a5f 39e3 bbb6 b689 2b03  S...W.Z_9.....+.\n\n * Write strings to stdin
  of a process.\n\n       λ writeProc cat \"Hello\\n\"\n       Hello\n\n       λ \"Hello\"
  >>> shasum\n       f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0  -\n\n       λ shasum
  <<< \"Hello\"\n       f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0  -\n\n * Proper exceptions,
  when a process exits with a failure code, an exception\n   is thrown. You can catch
  these normally. The exception includes the error\n   code, the command, and all
  it's arguments.\n\n       λ false \"Ha, it died\"\n       *** Exception: Command
  `false \"Ha, it died\"` failed [exit 1]\n\n       λ catchCode false\n       1\n\n##
  Mnemonics \n\nShh has many symbols that might seem intimidating at first, but there\nis
  a simple mnemonic for them.\n\n    |     Piping. Looks like a pipe, same as in POSIX
  shells.\n    &     Redirection, think of the shell `2>&1`\n    >,<   The direction
  of flow of a command\n    !     Operate on stderr instead of stdout\n\nSo, for example,\n\n
  \   ls |> cat      Pipe the stdout of `ls` into stdin of `cat`\n    cat <| ls      Same
  as above\n    ls &> StdErr   Redirect stdout of `ls` to wherever stderr is going.\n
  \   StdErr <& ls   Same as above\n    ls &!> StdOut  Redirect stderr of `ls` to
  wherever stdout is going.\n    StdOut <!& ls  Same as above\n\n## Usage\n\nEnable
  Temlpate Haskell and load the environment\n\n    {-# LANGUAGE TemplateHaskell #-}\n
  \   $(loadEnv SearchPath)\n\nYou now have all your executables available as simple
  to read\nHaskell functions.\n\nIf you want to check that all the dependenies still
  exist, you can use\n`missingExecutables :: IO [String]`, which will tell you if
  anything is\nmissing.\n\n### Usage in GHCi\n\nIf you want `^D` to be recognised
  as a EOF marker (when running commands\nthat read from stdin) when running in GHCi,
  you will need to run the\n`initInteractive` function. This sets the line buffering
  appropriately and\nensures the terminal is in canonical mode.\n\n### Script Usage\n\nTODO:
  Fill this in once on Hackage.\n    \n"
license-name: BSD-3-Clause

homepage: ''
changelog-type: markdown
hash: 73c01bc855497d705ddc05e521197847c327bb93b2d679bf793fa9e6c6870282
test-bench-deps:
  base: ! '>=4.9'
  tasty-quickcheck: -any
  tasty-hunit: -any
  tasty: -any
  shh: -any
maintainer: lukec@themk.net
synopsis: Simple shell scripting from Haskell
changelog: ! '# Revision history for execpath


  ## 0.1.0.0  -- YYYY-mm-dd


  * First version. Released on an unsuspecting world.

'
basic-deps:
  unix: -any
  split: -any
  base: ! '>=4.9 && <4.13'
  filepath: -any
  process: -any
  async: -any
  mtl: -any
  deepseq: -any
  shh: -any
  template-haskell: -any
  directory: -any
all-versions:
- 0.1.0.0
author: Luke Clifton
latest: 0.1.0.0
description-type: markdown
description: ! "# Shh\n\nShh is a library to enable convinient shell-like programming
  in Haskell.\nIt works well in scripts, and from GHCi, allowing you to use GHCi as
  a shell.\n\nIt supports\n\n * Automatically defining a function for each executable
  on your `$PATH`\n   using template Haskell.\n\n * Redirction of stdout and stderr\n
  \      \n       -- Redirect stdout\n       λ echo \"Hello\" &> StdErr\n       λ
  echo \"Hello\" &> Truncate \".tmp_file\"\n\n       -- Redirect stderr\n       λ
  echo \"Hello\" &!> Append \"/dev/null\"\n       λ echo \"Hello\" &!> StdOut\n\n\n
  * Piping stdout or stderr to the input of a chained process\n       \n       λ cat
  \"/dev/urandom\" |> xxd |> head \"-n\" 5\n\n * Multiple processes sequentially feeding
  a single process\n\n       λ (echo 1 >> echo 2) |> cat\n\n * Use of Haskells concurrency
  primitives.\n\n       λ race (sleep 1) $ curl \"http://this_needs_to_timeout_after_1_second\"\n\n
  \      λ d <- readTrim $ mktemp \"-d\"\n       λ :{\n       | System.Directory.withCurrentDirectory
  d $ do\n       |   mapConcurrently_ (curl \"-LOJs\")\n       |     [ \"https://raw.githubusercontent.com/luke-clifton/shh/master/shell.nix\"\n
  \      |     , \"https://raw.githubusercontent.com/luke-clifton/shh/master/shh.cabal\"\n
  \      |     ]\n       |   ls\n       | :}\n\n * Capturing of process output\n\n
  \      λ loggedIn <- nub . words <$> readProc users\n       λ putStrLn $ \"Logged
  in users: \" ++ show loggedIn\n\n       λ mapM_ putStrLn =<< readSplit0 (Shh.Example.find
  \"-maxdepth\" 1 \"-print0\")\n\n * Capturing infinite output of a process lazily\n\n
  \      λ withRead (cat \"/dev/urandom\" |> xxd) $ mapM_ putStrLn . take 3 . lines\n
  \      00000000: 8fcb ebee 9228 a897 3bfc 1d05 491d aceb  .....(..;...I...\n       00000010:
  47de 3ea3 2788 44ac 9b85 0a0f a458 b949  G.>.'.D......X.I\n       00000020: 5308
  ddfe 5790 5a5f 39e3 bbb6 b689 2b03  S...W.Z_9.....+.\n\n * Write strings to stdin
  of a process.\n\n       λ writeProc cat \"Hello\\n\"\n       Hello\n\n       λ \"Hello\"
  >>> shasum\n       f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0  -\n\n       λ shasum
  <<< \"Hello\"\n       f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0  -\n\n * Proper exceptions,
  when a process exits with a failure code, an exception\n   is thrown. You can catch
  these normally. The exception includes the error\n   code, the command, and all
  it's arguments.\n\n       λ false \"Ha, it died\"\n       *** Exception: Command
  `false \"Ha, it died\"` failed [exit 1]\n\n       λ catchCode false\n       1\n\n##
  Mnemonics \n\nShh has many symbols that might seem intimidating at first, but there\nis
  a simple mnemonic for them.\n\n    |     Piping. Looks like a pipe, same as in POSIX
  shells.\n    &     Redirection, think of the shell `2>&1`\n    >,<   The direction
  of flow of a command\n    !     Operate on stderr instead of stdout\n\nSo, for example,\n\n
  \   ls |> cat      Pipe the stdout of `ls` into stdin of `cat`\n    cat <| ls      Same
  as above\n    ls &> StdErr   Redirect stdout of `ls` to wherever stderr is going.\n
  \   StdErr <& ls   Same as above\n    ls &!> StdOut  Redirect stderr of `ls` to
  wherever stdout is going.\n    StdOut <!& ls  Same as above\n\n## Usage\n\nEnable
  Temlpate Haskell and load the environment\n\n    {-# LANGUAGE TemplateHaskell #-}\n
  \   $(loadEnv)\n\nYou now have all your executables available as simple to read\nHaskell
  functions.\n\n### Usage in GHCi\n\nIf you want `^D` to be recognised as a EOF marker
  (when running commands\nthat read from stdin) when running in GHCi, you will need
  to run the\n`initInteractive` function. This sets the line buffering appropriately
  and\nensures the terminal is in canonical mode.\n\n### Script Usage\n\nTODO: Fill
  this in once on Hackage.\n    \n"
license-name: BSD-3-Clause

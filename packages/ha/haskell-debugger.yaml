all-versions:
- 0.5.0.0
- 0.6.0.0
- 0.7.0.0
- 0.8.0.0
- 0.9.0.0
- 0.10.0.0
author: Rodrigo Mesquita
basic-deps:
  aeson: '>=2.2.3 && <2.3'
  array: '>=0.5.8 && <0.6'
  async: '>=2.2.5 && <2.3'
  base: '>=4.22 && <5'
  base16-bytestring: '>=1.0.2.0 && <1.1'
  binary: '>=0.8.9 && <0.11'
  bytestring: '>=0.12.1 && <0.13'
  co-log-core: '>=0.3.2.5 && <0.4'
  containers: '>=0.7 && <0.9'
  cryptohash-sha1: '>=0.11.101.0 && <0.12'
  dap: '>=0.3 && <1'
  directory: '>=1.3.9.0 && <1.4'
  exceptions: '>=0.10.9 && <0.11'
  file-embed: '>=0.0.16 && <0.1'
  filepath: '>=1.5.4 && <1.6'
  ghc: '>=9.14 && <9.16'
  ghc-boot: '>=9.14 && <9.16'
  ghc-boot-th: '>=9.14 && <9.16'
  ghci: '>=9.14 && <9.16'
  haskeline: '>=0.8 && <1'
  haskell-debugger: '>=0'
  haskell-debugger-view: '>=0.1 && <1.0'
  hie-bios: '>=0.15 && <0.18'
  implicit-hie: ^>=0.1.4.0
  mtl: '>=2.3 && <3'
  network: '>=3.2.8'
  network-run: '>=0.4.4'
  optparse-applicative: '>=0.18 && <0.20'
  prettyprinter: '>=1.7.1 && <2'
  process: '>=1.6.25 && <1.7'
  text: '>=2.1 && <2.3'
  time: '>=1.14 && <2'
  transformers: '>=0.6 && <0.7'
  unix: '>=2.8.6 && <2.9'
  unordered-containers: '>=0.2.19 && <0.3'
changelog: |
  # Revision history for haskell-debugger

  ## 0.10.0.0 -- 2025-11-18

  * Adds Custom Debug Visualisations!
      * The value inspection internals were refactored to always try first to use a
        custom visualization and fallback to the general-case visualization which
        mimics the heap representation of a value.
      * We ship a handful of custom visualisations for base types like `String`,
        `Int`, etc, and for types from a few core packages: `Text`, `ByteString`, `Map` and `IntMap`.
      * The user can add custom visualizations for the desired types by
        implementing an instance for `DebugView` from `haskell-debugger-view`
          * At runtime, `hdb` will pick up the `DebugView` instances in scope and use them when possible.
      * When the package dependency closure includes `haskell-debugger-view`, we
        will use that unit specifically. When it is not in the dependencies, we
        will load a built-in version in memory.
  * Evaluate requests now return a structured and expandable response, akin to the variables pane
      * To show the whole value inline one can recover the previous behavior by
        calling `show` on the value to display.
      * This makes it possible to have structured results in the "Watch" pane.
  * Adds support for conditional breakpoints and hit count breakpoints
  * Bug fixes in variable inspection
  * Bug fixes in multiple-home-units

  ## 0.9.0.0 -- 2025-10-13

  ### Main changes

  * Run a proxy program with `runInTerminal` to allow stdin via the terminal process, if the client supports it.

  ### Bug fixes

  * Fix bug where build failures were reported in a pop-up rather than stderr
  * Fix crashes panicking with `findUnitIdOfEntryFile`
  * Fix cli bug by use absolute entryFile path
  * Fix bug caused by not canonicalizing special target and root
  * Fix in variable expansion (expand `Term`s iteratively as the user expands the tree)

  ## 0.8.0.0 -- 2025-09-19

  * Allow defaults for all settings except `entryFile` and return a proper error in that case
  * Fix bug that crashed debugger when attempting to load newtype constructor closure
  * Fix bug that broke displaying newtype variables
  * (Vscode) Allow the debugger to be run without a launch.json file
  * Don't display functions as a forceable thunk, instead just the type
  * Add `--version` flag

  ## 0.7.0.0 -- 2025-09-10

  * Fix line buffering of debuggee output (thus, stepping through a print line, will indeed print it to the console now).
      * In fact, this was only caused by not building with `--enable-executable-dynamic`

  ## 0.6.0.0 -- 2025-09-10

  * Improve unit handling and fix running when `main` functions exist across different units
      * Add interactive home unit id
      * The entry file determines which of the `main`s to run.
  * Add proper option parsing
  * Add preview version of `hdb cli` interactive mode, as an alternative to DAP server
      * Experimental and incomplete
  * Fix: output uncaught exceptions to stderr
  * Fix: output eval completed result to console

  ## 0.5.0.0 -- 2025-08-26

  * Compatibility with GHC 9.14
  * Add support for stepping out of functions as a tech preview
  * Use implicit cradle discovery to better support multiple configurations,
    mirroring HLS (and thus providing a more similar experience)
  * Query the GHC runtime version via hie-bios, now honoring e.g. `with-compiler:
    ...` in `cabal.project` to fetch the right GHC version
  * Rename package from `ghc-debugger` to `haskell-debugger`, and
    `ghc-debug-adapter` to `hdb`, to be consistent with other tools and
    ecosystems and to avoid ambiguity with `ghc-debug` (program heap analysis library and
    tool)
  * Use cache directories for `hdb` to have faster startup times. This will only
    be enabled for compilers supporting the upcoming `.gbc` (compiled bytecode
    artifact) files.

  ## 0.4.0.0 -- 2025-06-27

  * Add support for debugging multiple home units (MHU)

  ## 0.3.0.0 -- 2025-06-07

  * Critical fixes for variables inspection

  ## 0.2.0.0 -- 2025-05-13

  * Significantly improves variable inspection and expansion commands.

  ## 0.1.0.0 -- 2025-05-08

  * First version. Released on an unsuspecting world.
changelog-type: markdown
description: |
  # Haskell Debugger

  We are working on a first class debugger for Haskell!

  ![CI badge](https://github.com/well-typed/haskell-debugger/actions/workflows/debugger.yaml/badge.svg) ![Hackage badge](https://img.shields.io/hackage/v/haskell-debugger.svg)

  # Installation

  Please find up to date installation instructions on the
  [project homepage](https://well-typed.github.io/haskell-debugger/)!

  > [!WARNING]
  > `hdb` can currently be compiled with the 9.14 alpha pre-releases or with a nightly version
  > The first release it will be compatible with is GHC 9.14.

  To install and use the debugger, you need the executable `hdb`
  and the VSCode extension [Haskell Debugger](https://marketplace.visualstudio.com/items?itemName=Well-Typed.haskell-debugger-extension).

  Since `hdb` implements the [Debug Adapter Protocol
  (DAP)](https://microsoft.github.io/debug-adapter-protocol/), it also supports
  debugging with tools such as vim, neovim, or emacs -- as long as a DAP client is
  installed and the `launch` arguments for `hdb` configured.

  To run the debugger, the same version of GHC which compiled it needs to be in
  PATH. Make sure the DAP client knows this. For instance, to launch VSCode with a specific GHC use:
  ```
  PATH=/path/to/ghc-dir:$PATH code /path/to/proj
  ```

  # Usage

  To use the debugger in VSCode, select the debugger tab, select Haskell Debugger,
  and create a `launch.json` file by clicking the debugger settings icon (next to
  the green run button). Now, it is also supported to just Run a file which
  contains a `main` function.

  The `launch.json` file contains some settings about the debugger session here.
  Namely:

  | Setting | Description |
  | --- | --- |
  | `projectRoot`  | the full path to the project root. this is typically `${workspaceFolder}`, a value which is interpolated by the editor with the actual path                                           |
  | `entryFile`    | the relative path from the project root to the file with the entry point for execution                                                                                                |
  | `entryPoint`   | the name of the function that is called to start execution                                                                                                                            |
  | `entryArgs`    | the arguments passed to the `entryPoint`. If the `entryPoint` is `main`, these arguments are passed as environment arguments (as in `getArgs`) rather than direct function arguments. |
  | `extraGhcArgs` | additional flags to pass to the ghc invocation that loads the program for debugging.                                                                                                  |

  Change them accordingly.

  To run the debugger, simply hit the green run button.
  See the Features section below for what is currently supported.

  # Multiple home units session

  Multiple home units is supported but currently may require a workaround (issue is tracked by [#38](https://github.com/well-typed/haskell-debugger/issues/38)).

  If your multiple home units session does not work by default (e.g. if you
  cannot set breakpoints on different units), and you do not have a `hie.yaml`
  file, you may want to try creating a `hie.yaml` file in the root of the
  workspace with:
  ```
  cradle:
      cabal:
          component: "all"
  ```

  # Related Work

  `hdb` is inspired by the original
  [`haskell-debug-adapter`](https://github.com/phoityne/haskell-debug-adapter/) by @phoityne.

  `hdb` improves on the original ideas implemented in
  `haskell-debug-adapter` but makes them more robust by implementing the debugger
  directly via the GHC API (similarly to HLS), rather than by communicating with a
  custom `ghci` process.

  We have been doing custom work on GHC to support debugging in a predictable,
  robust, and more performant way. That is why `hdb` is only
  compatible with the latest and greatest GHC. If you want to debug using an older
  GHC version (9.12 and older), please check out `haskell-debug-adapter`.

  To implement the Debug Adapter Protocol (DAP) server part, we are using the
  [`dap`](https://hackage.haskell.org/package/dap-0.2.0.0) library by @dmjio.
  `dap` is a framework for building language-agnostic DAP.

  The `hdb` is transparently compatible with most projects (simple,
  Cabal, Stack, custom `hie.yaml`) because
  it uses [`hie-bios`](https://github.com/haskell/hie-bios) to figure out the
  right flags to prepare the GHC session with.

  # Features

  Many not listed! Here are a few things:

  ## Stepping

  - [x] Continue (resume execution forward)
  - [x] Next (step within local function)
  - [x] Step into (single step to next immediate tick)
  - [x] Step out (execute until end of function and break after the call)

  ### In Reverse

  - [ ] Local step backwards (ie reverse of Next)
  - [ ] Single step backwards (ie reverse of Step into)
  - [ ] Continue backwards (resume execution backwards until a breakpoint is hit)

  ## Breakpoints

  - [x] Module breakpoints
  - [x] Function breakpoints
  - [x] Exception breakpoints
  - [ ] Data breakpoints
  - [ ] Instruction breakpoints

  ### Conditionals
  - [x] Conditional breakpoints     (breakpoint is hit only if condition is satisfied)
  - [x] Hit conditional breakpoints (stop after N number of hits)

  ## Custom Debug Visualizations

  The user can extend the debugger visualization behavior (in a plugin sort of
  way) by implementing `DebugView` from
  [`haskell-debugger-view`](https://hackage.haskell.org/package/haskell-debugger-view)
  for the desired types.

  We ship built-in custom instances for various `base` datatypes, such as
  `String` and `(a, b)`, and for a core packages as well, such as `Text`,
  `ByteString`, `Map` and `IntMap`.

  Here is an example of a completely custom `DebugView` instance for a
  user-defined datatype. You can also see how the `IntMap` is displayed as a pair
  of `Int` keys to their values as opposed as as a `Bin/Tip` tree mimicking its
  real definition:

  ![Image showing custom debug view instance](https://github.com/user-attachments/assets/2ccb5858-4893-4b5a-a889-077d61937f28)

  When the package dependency closure includes `haskell-debugger-view`, we will
  use that unit specifically. When it is not in the dependencies, we will load a
  built-in version in memory.

  # Talks

  ### MuniHac 2025: A modern step-through debugger for Haskell
  [![MuniHac 2025 - Friday, September 12th - Rodrigo Mesquita: A modern step-through debugger for Haskell](https://img.youtube.com/vi/urYtE15ryA0/0.jpg)](https://youtu.be/urYtE15ryA0)

  ### ZuriHac 2025: Haskell Implementor's Workshop: The GHC Debugger
  [![Rodrigo Mesquita - The GHC Debugger (ZuriHac)](https://img.youtube.com/vi/p-hBweQg42s/0.jpg)](https://youtu.be/p-hBweQg42s)

  # Building from source

  To build `hdb`:
  ```
  cabal build -w /path/to/recent/ghc exe:hdb
  ```

  To build the VSCode extension
  ```
  cd vscode-extension
  nix-build
  ```

  ## Testing

  ```
  cd test/integration-tests
  make GHC=/path/to/recent/ghc \
       DEBUGGER=$(cd ../.. && cabal list-bin -w /path/to/recent/ghc exe:hdb)
  ```
description-type: markdown
hash: 2a74325a60f5ee9c08a5395e507c5d99d1bb7aa1b29f4137d1a904127feba4b2
homepage: https://github.com/well-typed/haskell-debugger
latest: 0.10.0.0
license-name: BSD-3-Clause
maintainer: rodrigo@well-typed.com
synopsis: A step-through debugger for GHC Haskell
test-bench-deps:
  aeson: '>=0'
  aeson-pretty: '>=0.8.10'
  async: '>=2.2.5'
  base: '>=4.14'
  bytestring: '>=0'
  containers: '>=0'
  dap: '>=0'
  filepath: '>=0'
  haskell-debugger: '>=0'
  network: '>=0'
  network-run: '>=0'
  process: '>=0'
  random: '>=1.3.1'
  regex: '>=1.1'
  tasty: '>=1.5.3'
  tasty-golden: '>=2.3.5'
  tasty-hunit: '>=0.10.2'
  temporary: '>=1.3'
  text: '>=0'
  unordered-containers: '>=0'

homepage: https://github.com/typeclasses/hash-addressed
changelog-type: markdown
hash: 4ca8b04b926ef8e92b1ced3c8582108f7b48b9660dbd8bef9d56677edbb3091b
test-bench-deps: {}
maintainer: Chris Martin, Julie Moronuki
synopsis: Hash-addressed file storage
changelog: |
  0.2.0.0 (2023-02-08)
  ----------------------------------------------------------------

  Change type of stream parameter in `writeExcept` from

  ```haskell
  Producer ByteString (ExceptT abort IO) commit
  ```

  to

  ``haskell
  Producer ByteString IO (Either abort commit)
  ```

  The new version is equivalent (via the `ExceptT` constructor) to

  ``haskell
  ExceptT abort (Producer ByteString IO) commit
  ```

  and so what this change is doing is reversing the order of the
  monad transformers. The overall result is the same, but the new
  version seems slightly easier to work with.


  0.1.0.0 (2023-01-31)
  ----------------------------------------------------------------

  ### HashFunction

  `HashFunction` type is no longer opaque; any hash function can be supported.
  The type is now a newtype for `Fold` from the `gambler` library.

  ### Directory

  Renamed `ContentAddressedDirectory` to `Directory`

  `Directory` constructor is now exported

  Removed `init` function, which is redundant to `Directory` constructor

  ### Pipes

  Now using the `pipes` library to express streams.

  Removed:

  ```haskell
  writeStreaming :: ContentAddressedDirectory
      -> (forall m. MonadIO m => (ByteString -> m ()) -> m ())
      -> IO WriteResult
  ```

  Added:

  ```haskell
  writeStream :: MonadIO m =>
      Directory -> Producer ByteString IO a -> m (a, WriteResult)
  ```

  Removed:

  ```haskell
  writeEither :: ContentAddressedDirectory
      -> (forall m. MonadIO m => (ByteString -> m ()) -> m (Either bad good))
      -> IO (Either bad (good, WriteResult))
  ```

  Added:

  ```haskell
  writeExcept :: (MonadIO m, MonadError abort m) =>
      Directory
      -> Producer ByteString (ExceptT abort IO) commit
      -> m (commit, WriteResult)
  ```

  ### WriteResult

  Renamed field from `contentAddressedFile` to `hashAddressedFile`


  0.0.1.0 (2023-01-27)
  ----------------------------------------------------------------

  Add `HashAddressed.Directory.writeEither`


  0.0.0.0 (2023-01-27)
  ----------------------------------------------------------------

  Initial release
basic-deps:
  quaalude: ^>=0.0.0
  bytestring: ^>=0.11.3
  base: ^>=4.16 || ^>=4.17
  filepath: ^>=1.4.2
  pipes: ^>=4.3.16
  cryptohash-sha256: ^>=0.11.102
  gambler: ^>=0.0.0
  mtl: ^>=2.2.2
  base16-bytestring: ^>=1.0.2
  temporary: ^>=1.3
  resourcet: ^>=1.2.6 || ^>=1.3.0
  directory: ^>=1.3.6
all-versions:
- 0.0.0.0
- 0.0.1.0
- 0.1.0.0
- 0.2.0.0
author: Chris Martin
latest: 0.2.0.0
description-type: markdown
description: |
  `hash-addressed` is a simple system for maintaining a directory wherein each
  file's name is a hash of its content.

  ```haskell
  import qualified HashAddressed.Directory    as Dir
  import qualified HashAddressed.HashFunction as Hash
  import qualified Data.ByteString.Lazy       as Lazy
  import qualified Data.ByteString            as Strict
  ```

  First define a `ContentAddressedDirectory` value by specifying which hash
  function to use and the path of the directory in which the files shall be kept.
  The directory does not need to already exist.

  ```haskell
  Dir.init :: Hash.HashFunction -> FilePath
      -> Dir.ContentAddressedDirectory
  ```

  Presently the only supported hash function is `Hash.SHA_256`.

  You can then write files into the directory using one of the two *write*
  functions:

  ```haskell
  Dir.writeLazy :: Dir.ContentAddressedDirectory
      -> Lazy.ByteString -> IO Dir.WriteResult
  ```

  ```haskell
  Dir.writeStreaming :: Dir.ContentAddressedDirectory
      -> (forall m. MonadIO m => (Strict.ByteString -> m ()) -> m ())
      -> IO Dir.WriteResult
  ```

  The `IO` action returns a `WriteResult`, which gives you the path of the file in
  the store, including the path of the store itself. The `WriteType` value
  indicates whether the file was actually written by this action or was present in
  the store already.

  ```haskell
  data WriteResult = WriteResult{ contentAddressedFile :: FilePath,
                                  writeType :: Dir.WriteType }
  ```

  ```haskell
  data WriteType = AlreadyPresent | NewContent
  ```

  All operations that write into a hash-addressed directory are performed by first
  writing the content somewhere within the system temporary directory and then
  moving the file to its target location. This ensures that the store never makes
  visible the results of a partial write.
license-name: Apache-2.0

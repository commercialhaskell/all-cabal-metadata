homepage: https://github.com/evolutics/haskell-formatter.git#readme
changelog-type: ''
hash: 6353679939b8534a824926c480d7a393ac204d84f411a07f30a0e9258a1b093f
test-bench-deps:
  hlint: -any
  filemanip: -any
  base: ! '>=4.6 && <5'
  filepath: -any
  doctest: -any
  containers: -any
  directory-tree: -any
  tasty-hunit: -any
  tasty: -any
  QuickCheck: -any
  haskell-formatter: -any
maintainer: Benjamin Fischer <benjamin.fischer@evolutics.info>
synopsis: Haskell source code formatter
changelog: ''
basic-deps:
  base: ! '>=4.6 && <5'
  unordered-containers: -any
  text: -any
  filepath: -any
  containers: -any
  haskell-src-exts: -any
  optparse-applicative: -any
  scientific: -any
  yaml: -any
  haskell-formatter: -any
  directory: -any
all-versions:
- 0.1.0
- 1.0.0
- 2.0.0
- 2.0.1
- 2.0.2
author: Benjamin Fischer
latest: 2.0.2
description-type: markdown
description: "# Haskell Formatter\n\n[![Build](https://img.shields.io/travis/evolutics/haskell-formatter.svg)](https://travis-ci.org/evolutics/haskell-formatter)\n[![License](https://img.shields.io/github/license/evolutics/haskell-formatter.svg)](LICENSE)\n[![Package](https://img.shields.io/hackage/v/haskell-formatter.svg)](https://hackage.haskell.org/package/haskell-formatter)\n\nThe
  Haskell Formatter formats Haskell source code. It is strict in that it fundamentally
  rearranges code.\n\n## Installation\n\nInstall it by running\n\n```bash\nstack install
  haskell-formatter\n```\n\nor\n\n```bash\ncabal new-install haskell-formatter\n```\n\nYou
  are ready when\n\n```bash\nhaskell-formatter --help\n```\n\nworks.\n\n## Usage\n\n###
  Basics\n\nRead source code from `Input.hs`, format it, and write it to `Output.hs`
  by\n\n```bash\nhaskell-formatter --input Input.hs --output Output.hs\n```\n\nIf
  the input or output file is not given, it defaults to the corresponding standard
  stream. This allows commands like\n\n```bash\nhaskell-formatter < Input.hs\n```\n\nTo
  format a file in-place, use the `--force` option as in\n\n```bash\n# Warning: this
  overwrites the file `Code.hs`.\nhaskell-formatter --force --input Code.hs --output
  Code.hs\n```\n\nFor more help about the usage, call\n\n```bash\nhaskell-formatter
  --help\n```\n\n### Formatting Many Files\n\nFor a diff of how code in the current
  folder would be formatted, without actually changing anything, run\n\n```bash\nfind
  . -name '*.hs' -type f -print0 \\\n  | xargs -0 -n 1 bash -c 'haskell-formatter
  < \"$@\" | diff -u \"$@\" -' --\n```\n\nThe returned exit status is nonzero if there
  are unformatted files. This may be useful for continuous integration.\n\nTo format
  any `*.hs` files in a folder `code/` or (recursively) in its subfolders, run\n\n```bash\n#
  Warning: this overwrites files, so better back them up first.\nfind code/ -name
  '*.hs' -type f -print0 \\\n  | xargs -0 -I {} -n 1 haskell-formatter --force --input
  {} --output {}\n```\n\n### Style Configuration\n\nThe formatting style can be configured
  with a file referred by the `--style` option. For instance, the call\n\n```bash\nhaskell-formatter
  --style my_style.yaml --input Input.hs --output Output.hs\n```\n\nuses `my_style.yaml`
  as a style file. Such files are in the [YAML format](http://en.wikipedia.org/wiki/YAML).
  The following is an [example style file](testsuite/resources/examples/default_style.yaml),
  which at the same time shows the available keys with their default values.\n\n<!---
  GitHub does currently not allow to include files (https://github.com/github/markup/issues/346).\n\nThus,
  the file content is replicated here. There is a test which checks that the strings
  of both sources are equal. --->\n\n```yaml\n# Lines should be no longer than this
  length in characters.\nline_length_limit: 80\n\n# How much to spread code over multiple
  lines instead of trying to fill a single\n# line. More precisely, this guides the
  ratio of \"line_length_limit\" to the\n# ribbon length (the number of characters
  on a line without leading and trailing\n# whitespace). Only the lowest value of
  1 forces \"line_length_limit\" to be\n# applied strictly.\n# Reference: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.8777\nribbons_per_line:
  1\n\n# More than this number of empty lines in succession are merged.\nsuccessive_empty_lines_limit:
  1\n\n# Indentation lengths in characters.\nindentations:\n    class:  8    # \"class\"
  and \"instance\" declarations.\n    do:     3    # \"do\" notation. \n    case:
  \  4    # Body of \"case\" expressions.\n    let:    4    # Declarations in \"let\"
  expressions.\n    where:  6    # Declarations in \"where\" clauses.\n    onside:
  2    # Continuation lines which would otherwise be offside.\n\n# Decides which parts
  of the code to sort.\norder:\n    # Sequence of import declarations.\n    import_declarations:
  true\n\n    # Entities of import lists.\n    import_entities: true\n```\n\n## Related
  Projects\n\nYou may like to have a look at the following projects, which aim at
  formatting Haskell code, too.\n\n- [brittany](https://github.com/lspitzner/brittany)\n-
  [hfmt](https://github.com/danstiner/hfmt)\n- [hindent](https://github.com/chrisdone/hindent)\n-
  [stylish-haskell](https://github.com/jaspervdj/stylish-haskell)\n"
license-name: MIT

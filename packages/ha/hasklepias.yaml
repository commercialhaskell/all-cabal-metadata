homepage: https://github.com/novisci/asclepias/#readme
changelog-type: markdown
hash: 327920870a000a6787abebd35da2e65f325305cc08a73add84bed8db05e14445
test-bench-deps:
  interval-algebra: ==0.8.0
  bytestring: '>=0.10'
  flow: ==1.0.22
  base: ==4.14.*
  time: '>=1.9'
  unordered-containers: '>=0.2.10'
  hspec: -any
  text: '>=1.2.3'
  containers: '>=0.6.0'
  hasklepias: -any
  QuickCheck: -any
  aeson: '>=1.4.0.0 && <2'
  vector: '>=0.12'
maintainer: bsaul@novisci.com
synopsis: Define features from events
changelog: |
  # Changelog for hasklepias

  ## 0.4.2

  * Updates `interval-algebra` to 0.8.0

  ## 0.4.1

  * Modifies the example in `example/ExampleFeatures3` to use the pipe `|>` operator.
  * Adds the `hasAllConcepts` function to the `HasConcepts` class.
  * Adds a `Reexports` module with the goal to re-export everything one might need from other Haskell libraries to build a cohort.
  * Removes a number of unneeded/unused functions from the `Functions` module.
  * Adds the `Safe` language extension to modules where possible.

  ## 0.4.0

  * Adds the `FeatureDefinition` to represent common patterns for building `Feature`s:

  ```haskell
  data FeatureDefinition e a d =
      EF  (Events a -> Feature d)
    | FEF (Feature e -> Events a -> Feature d)
  ```

  * Provides an initial set of functions designed to make defining `Feature`s easier, namely `defineEF` and `defineFEF`. These functions construct `FeatureDefinition`s of using `EF` and `FEF` constructors, respectively. The example features in `examples/ExampleFeatures1` demonstrate their use.
  * Adds the `allPairs` function to form all pairs of elements of two lists.
  * Adds the `splitByConcepts` to split a container of events into a pair such that first element contains
  events have any of the first argument's concepts, and similarly for the second element.
  * Demonstrates how `allPairs` and `splitByConcepts` might be used in the `examples/ExampleFeatures3` module.
  * Adds a rudimentary `ToJSON` instance for `Feature`s so that data can be encoded and output from the software. This is pretty rough; e.g. encoding an `Interval Int` feature produces: `"{\"end\":10,\"begin\":0}"`.
  * Removes the `Transformations` module and `transformToMeetingSequence` function. The same functionality is available by using the `formMeetingSequence` function from `interval-algebra`. See `examples/ExampleFeatures2` for the updated example.
  * Adds the `toConceptEventOf` function which creates a `ConceptEvent` but takes the `intersection` of `Concepts` in the first argument and concepts in the context of the `Event` in the second argument to form the new `ConceptEvent`. This is a way to keep only those concepts you need in the event.

  ## 0.3.0

  * Updates code as needed to work with interval-algebra v0.6.2. In particular, the `Event a` is now a synonym for `PairedInterval Context a`, hence any methods that work on the `PairedInterval` also work for the `Event` type.
  * Adds the `ConceptEvent a` type which is a synonym for `PairedInterval Concept a`; i.e, this is an event without facts or a source.
  * Adds the `toConceptEvent` function for dropping from an `Event a` to a `ConceptEvent a`, and `mkConceptEvent` function for directly making a `ConceptEvent` from concepts and an interval.
  * Adds generators for lists of arbitrary events. The generator for `Concepts` is limited at this point; it simply takes a subsample of the first 10 letters of the alphabet. Currently, only generators for `Event Int` are provided by the `generateEventsInt`. For example, in the `repl` `generateEventsInt 2` produces two randomly generated events:

  ```haskell
  *Hasklepias> generateEventsInt 2
  [{(-33, -16), Context {getConcepts = fromList ["G","I"], getFacts = Nothing, getSource = Nothing}},{(12, 13), Context {getConcepts = fromList ["A","C","D","E","G","I"], getFacts = Nothing, getSource = Nothing}}]
  ```

  * Adds the `transformToMeetingSequence` function which takes a set of concepts and a list of possibly non-disjoint `ConceptEvents`s and returns a list of `ConceptEvents`, where each consecutive event meets the next. Moreover, only those concepts selected (in the first argument) are kept in the output list of events. In the case that none of the events have the chosen concepts during an interval, an `ConceptEvent` with an empty set of concept is returned. A few examples might make this more clear.

  ```haskell
  *Hasklepias> :set -XOverloadedStrings
  *Hasklepias> x <- fmap (map toConceptEvent) (generateEventsInt 1)
  *Hasklepias> x
  [{(3, 4), fromList ["B","C"]}]
  *Hasklepias> transformToMeetingSequence (map packConcept ["A"]) x
  [{(3, 4), fromList []}]
  *Hasklepias> transformToMeetingSequence (map packConcept ["B"]) x
  [{(3, 4), fromList ["B"]}]
  *Hasklepias> x <- fmap (map toConceptEvent) (generateEventsInt 10)
  *Hasklepias> x
  [{(-44, 7), fromList ["C","D","E","F","H","J"]},{(-30, -29), fromList ["A","B","F","G","H","I","J"]},{(-25, 5), fromList ["C","D","E","I"]},{(-20, -19), fromList ["A","C","E","G","I","J"]},{(-17, -16), fromList ["B","D","F","J"]},{(-6, -5), fromList ["E","F","H","J"]},{(2, 21), fromList ["A","F","J"]},{(18, 19), fromList ["D","F","G","H","I"]},{(19, 20), fromList ["B","C","D","E","F","H"]},{(30, 31), fromList ["B","C","D","H","J"]}]
  *Hasklepias> transformToMeetingSequence (map packConcept ["B", "I"]) x
  [{(-44, -30), fromList []},{(-30, -29), fromList ["B","I"]},{(-29, -25), fromList []},{(-25, -17), fromList ["I"]},{(-17, -16), fromList ["B","I"]},{(-16, 5), fromList ["I"]},{(5, 18), fromList []},{(18, 19), fromList ["I"]},{(19, 20), fromList ["B"]},{(20, 30), fromList []},{(30, 31), fromList ["B"]}]
  ```

  * Adds an example of `transformToMeetingSequence` could be used to derive a feature that is the list of durations that a subject was both hospitalized and on antibiotics at the same time in the `examples/ExampleFeatures2` module.
basic-deps:
  interval-algebra: ==0.8.0
  bytestring: '>=0.10'
  flow: ==1.0.22
  base: '>=4.14 && <4.15'
  time: '>=1.9'
  unordered-containers: '>=0.2.10'
  text: '>=1.2.3'
  containers: '>=0.6.0'
  QuickCheck: -any
  aeson: '>=1.4.0.0 && <2'
  safe: '>=0.3'
  vector: '>=0.12'
all-versions:
- 0.4.2
author: Bradley Saul
latest: 0.4.2
description-type: markdown
description: |
  # Project Asclepias

  _Asclepias (n)_:

  1. The genus of North American milkweeds, named after Linnaeus after the greek god of healing, Asclepius.
  2. A language and software project for defining and deriving features from temporally ordered events using the [interval algebra](https://hackage.haskell.org/package/interval-algebra-0.8.0).

  ## Current status

  The initial versions of `hasklepias` will focus on the ability to derive features from a sorted collection of events. At this time, developers can experiment with feature definitions (see the `examples` directory).

  ## Getting started

  The official implementation of Asclepias is the embedded domain specific language (eDSL) provided by the `hasklepias` [Haskell](https://www.haskell.org/) library. To get started then, you'll need to install the Haskell toolchain, especially the [Glasgow Haskell Compiler](https://www.haskell.org/ghc/) (GHC) and the building and packaging system [cabal](https://www.haskell.org/cabal/), for which you can use the [`ghcup` utility](https://www.haskell.org/ghcup/).

  You can use any development environment you chose, but for maximum coding pleasure, it is highly recommended that you install the [Haskell language server](https://github.com/haskell/haskell-language-server) (`hsl`). This can be installed using `ghcup` or some integrated development environments, such as [Visual Studio Code](https://code.visualstudio.com/), have [excellent `hsl` integration](https://marketplace.visualstudio.com/items?itemName=haskell.haskell).

  ## Defining features

  At this time, `hasklepias` can be used for experimenting with `Feature` definitions. A `Feature d` is currently a wrapper of an [`Either`](https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Either.html) type:

  ```haskell
  type Feature d = Feature { getFeature :: Either MissingReason d }
  ```

  The `Either` type means there are two possibilities for the type of a `Feature`. The `Left` can be a `MissingReason`, which is a sum type enumerating the reasons that the data is missing:

  ```haskell
  data MissingReason = -- this list may grow/change in the future
      InsufficientData
    | Excluded
    | Other String
    | Unknown
  ```

  The `Right` has the type `d`, meaning it can be any type you choose. In the module`ExampleFeatures1`, the `index` feature has type `Feature (Interval a)`. The (`Right`) type of `index` is an `Interval a`, where again `a` can be any type you chose, subject to the constraints of intervals. The `hasDuckHistory` feature has the type `Feature (Bool, Maybe (Interval a)`, where the `Bool` is used an indicator of a history with ducks and the `Maybe (Interval a)` is the `Interval a` of the last encounter with a duck if it exists. The `countOfHospitalEvents` feature has the type `Feature (Int, Maybe b)` where the `Int` is the count of hospital visits and `Maybe b` is the duration of the last visit if one exists. These examples show how the data (or shape) of a `Feature` can be defined as `Interval a`, `(Bool, Maybe (Interval a))`, or `(Int, Maybe b)`. In fact, as long as the data is derivable from other `Feature`s and/or a list of `Event`s, you can shape a `Feature` however you'd like!

  ## Interactive use/development

  To run the examples interactively, open a `ghci` session with:

  ```sh
  cabal repl hasklepias:examples --repl-options -itest
  ```

  The option flag `--repl-options -itest` allows to make changes to the files in the `examples` folder and reload with `:reload` (or `:r`) without exiting the `ghci` session. Developers working on `src` files can add the `--repl-options -isrc` option flag to make changes to `src` files too.

  In `ghci` you have access to all exposed functions in `hasklepias`, `interval-algebra`, and those in the `examples` folders. For example, `exampleEvents1` is a list of events used to check some of the example features, which you can interact with:

  ```sh
  *Main> headMay exampleEvents1
  Just {(1, 10), Context {getConcepts = ["enrollment"], getFacts = Nothing, getSource = Nothing}}
  *Main> length exampleEvents1
  24
  *Main> combineIntervals $ intervals exampleEvents1
  [(1, 10),(11, 20),(21, 30),(31, 40),(45, 100)]
  *Main> mapM_ print exampleEvents1
  {(1, 10), Context {getConcepts = fromList ["enrollment"], getFacts = Nothing, getSource = Nothing}}
  {(2, 3), Context {getConcepts = fromList ["wasScratchedByCat"], getFacts = Nothing, getSource = Nothing}}
  {(5, 6), Context {getConcepts = fromList ["hadMinorSurgery"], getFacts = Nothing, getSource = Nothing}}
  {(5, 10), Context {getConcepts = fromList ["tookAntibiotics"], getFacts = Nothing, getSource = Nothing}}
  {(11, 20), Context {getConcepts = fromList ["enrollment"], getFacts = Nothing, getSource = Nothing}}
  {(21, 30), Context {getConcepts = fromList ["enrollment"], getFacts = Nothing, getSource = Nothing}}
  {(31, 40), Context {getConcepts = fromList ["enrollment"], getFacts = Nothing, getSource = Nothing}}
  {(45, 46), Context {getConcepts = fromList ["wasStruckByDuck"], getFacts = Nothing, getSource = Nothing}}
  <<<result truncated>>>
  ```
license-name: BSD-3-Clause

all-versions:
- 0.1.0.0
author: Stefanos Anagnostou
basic-deps:
  base: '>=4.18.3 && <4.21'
  containers: '>=0.6 && <0.7'
  haal: '>=0'
  mtl: '>=2.3.1 && <2.4'
  process: '>=1.6.19 && <1.6.25'
  random: '>=1.2.1 && <1.2.2'
  vector: '>=0.13.1 && <0.13.2'
changelog: "# Changelog for `haal`\n\nAll notable changes to this project will be
  documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand
  this project adheres to the\n[Haskell Package Versioning Policy](https://pvp.haskell.org/).\n\n##
  Unreleased\n\n## 0.1.0.0 - 2025-12-02\n\n- Initial release of `haal`.\n    - Support
  for Mealy Automata and DFAs.\n    - One learner for Mealy Automata and DFAs with
  2 configurations. \n        - LStar.\n        - LPlus.\n    - Basic equivalence
  oracles. \n    - Examples that showcase usage of the library.\n\n\n"
changelog-type: markdown
description: "```text\n\n\n                        _       _           _                   _
  \                  _     \n                       / /\\    / /\\        / /\\                /
  /\\                _\\ \\   \n                      / / /   / / /       / /  \\
  \             / /  \\              /\\__ \\  \n                     / /_/   / /
  /       / / /\\ \\            / / /\\ \\            / /_ \\_\\ \n                    /
  /\\ \\__/ / /       / / /\\ \\ \\          / / /\\ \\ \\          / / /\\/_/ \n
  \                  / /\\ \\___\\/ /       / / /  \\ \\ \\        / / /  \\ \\ \\
  \       / / /      \n                  / / /\\/___/ /       / / /___/ /\\ \\      /
  / /___/ /\\ \\      / / /       \n                 / / /   / / /       / / /_____/
  /\\ \\    / / /_____/ /\\ \\    / / / ____   \n                / / /   / / /       /
  /_________/\\ \\ \\  / /_________/\\ \\ \\  / /_/_/ ___/\\ \n               / /
  /   / / /       / / /_       __\\ \\_\\/ / /_       __\\ \\_\\/_______/\\__\\/ \n
  \              \\/_/    \\/_/        \\_\\___\\     /____/_/\\_\\___\\     /____/_/\\_______\\/
  \    \n\n                                                                           \n\n```\n##
  A Haskell library for Active Automata Learning\n\n**Haal** is an [Active Automata
  Learning](https://wcventure.github.io/Active-Automata-Learning/) library aimed at
  making it easy to construct learning experiments and explore different configurations
  of learning algorithms and equivalence oracles. The library is still in its early
  stages, so nothing is set in stone yet. Most probably, the more features are added
  the more will the structure of the library change. For the time being, a summary
  of the current architecture can be found below. Of course, the best documentation
  is the source code itself.\n\n## \U0001F527 Features (constantly updated)\n\n| Automaton
  Type     | Learning Algorithms         | Equivalence Oracles    |\n|--------------------|-----------------------------|------------------------|\n|
  Mealy Machines     | ✅ LM\\*                     | ✅ W-method Oracle     |\n|                    |
  ✅ LM\\+                     | ✅ Wp-method Oracle    |\n|                    |                             |
  ✅ Random Words Oracle |\n|                    |                             | ✅
  Random Walk Oracle  |\n|                    |                             | ✅ Random
  W-method Oracle |\n|                    |                             | ✅ Random
  Wp-method Oracle  |\n\n\n## Table of Contents\n\n- [Architecture](#architecture)\n
  \ - [Systems under learning](#systems-under-learning)\n  - [Automata](#automata)\n
  \ - [Learning algorithms](#learning-algorithms)\n  - [Equivalence oracles](#equivalence-oracles)\n
  \ - [Experiment](#experiment)\n- [Installing](#installing)\n- [Example](#example)\n\n##
  Architecture\n\nThe library consists of the following main components:\n- Systems
  under learning\n- Automata\n- Learning algorithms\n- Equivalence oracles\n- Experiment\n\n###
  Systems under learning\n\nSystems under learning are defined by the `SUL` typeclass,
  parameterized by the types of their inputs and outputs. They must implement functions
  that allow them to be queried by learning algorithms and equivalence oracles. They
  are also parameterized by a monad which they operate in. For example, a SUL that
  is an external program performs IO actions, whereas a SUL that is a pure function
  operates in the Identity monad.\n\n### Automata\n\nAutomata are a subclass of systems
  under learning that also expose information about their internal states. In addition
  to being queryable, they must implement functions that expose useful structural
  information, particularly for use by equivalence oracles.\n\n### Learning algorithms\n\nLearning
  algorithms are used to construct hypotheses based on a `SUL`. They must support
  initialization, hypothesis construction, and refinement via counterexamples. Not
  all learning algorithms learn the same type of automaton; the type of automaton
  to be learned is determined by the algorithm itself. At the moment, all learning
  algorithms are represented by a typeclass and each specific learning algorithm is
  meant to be its own data type. The values of the data type are the different configurations
  of the algorithm.\n\n### Equivalence oracles\n\nEquivalence oracles are algorithms
  that generate a test suite of queries, which are sent to both the current hypothesis
  and the `SUL`, in order to discover counterexamples. They must implement functions
  to report the size of the test suite, generate the suite, and test the hypothesis
  for counterexamples. As in the case of learning algorithm, equivalence oracles as
  a whole are represented by a typeclass and a specific equivalence oracle algorithm
  is meant to be represented by a data type, with the possible values of it being
  the different configurations of the algorithm.\n\n### Experiment\n\nAn experiment
  ties all the components above together. In this library, experiments are represented
  as values and can be built with various configurations. An experiment is a function
  that takes a learning algorithm and an oracle, and returns an environment that awaits
  a `SUL` to execute the experiment. This is implemented using a `Reader` monad, where
  the environment provides access to the `SUL`.\n\n## Installing\n\nThe project is
  still in its early stages and has not yet been published. For now, you can clone
  the repository, build, and install it locally using:\n\n```bash\nstack install\n```\n\nMoreover,
  I try to add haddock comments as much as possible. Therefore, documentation can
  be built using:\n\n```bash\nstack haddock\n```\n\n## Example\n\nHere's a quick GHCi
  session putting it all together, showing how to define a simple Mealy machine, configure
  an experiment, and run a learning algorithm using `haal`. This session is also available
  as a program `examples/demo.hs` which can be run with `stack runghc examples/demo.hs`,
  or `stack run demo` and can also be loaded interactively with `stack ghci haal:exe:demo`.\n\n```haskell\nghci>
  :set +m\nghci> import qualified Data.Set as Set\n\n-- Define input, output, and
  state types\nghci> data Input = A | B deriving (Show, Eq, Ord, Enum, Bounded)\nghci>
  data Output = X | Y deriving (Show, Eq, Ord, Enum, Bounded)\nghci> data State =
  S0 | S1 | S2 deriving (Show, Eq, Ord, Enum, Bounded)\n\n-- Define the transition
  function for the system under learning\nghci> let sulTransitions S0 _ = (S1, X)\nghci|
  \    sulTransitions S1 _ = (S2, Y)\nghci|     sulTransitions S2 A = (S0, X)\nghci|
  \    sulTransitions S2 B = (S0, Y)\n\n-- Set up the experiment.\nghci> myexperiment
  = experiment (mkLMstar Star) (mkWMethod 2)\n\n-- Define the Mealy system under learning.
  Remember that automata can act as suls.\nghci> mysul = mkMealyAutomaton2 sulTransitions
  (Set.fromList [S0, S1, S2]) S0\n\n-- Run the experiment\nghci> (learnedmodel, stats)
  = runExperiment myexperiment mysul\n\n-- View the learned model\nghci> learnedmodel\n{\n
  \   Current State: 0,\n    Initial State: 0,\n    Transitions: fromList [\n        ((0,A),(1,X)),\n
  \       ((0,B),(1,X)),\n        ((1,A),(2,Y)),\n        ((1,B),(2,Y)),\n        ((2,A),(0,X)),\n
  \       ((2,B),(0,Y))\n    ]\n}\n```\n\nThis shows how a simple Mealy machine can
  be learned using the `LM*` algorithm and a `W`-method equivalence oracle.\n\nThis
  also showcases some strong points of using a functional programming language like
  haskell for the task of active automata learning:\n\n### 1. Type-safe alphabets\n\nIn
  Haal, the input and output alphabets are represented as plain Haskell data types.
  This means the compiler can catch errors early — for example, if a symbol not defined
  in the alphabet accidentally appears in a transition, the type checker will reject
  the code. This eliminates entire classes of bugs that are easy to make in more loosely
  typed implementations.\n\n```haskell\ndata Input = A | B deriving (Show, Eq, Ord,
  Enum, Bounded)\ndata Output = X | Y deriving (Show, Eq, Ord, Enum, Bounded)\n```\n\n###
  2. Automata as functions\n\nInstead of defining transitions via tables or external
  formats like `dot`, Haskell allows transitions to be encoded as pure functions:\n\n```haskell\nsulTransitions
  :: State -> Input -> (State, Output)\nsulTransitions S0 _ = (S1, X)\nsulTransitions
  S1 _ = (S2, Y)\nsulTransitions S2 A = (S0, X)\nsulTransitions S2 B = (S0, Y)\n```\n\nCombined
  with exhaustive pattern matching and totality checking, this ensures that:\n- All
  input cases are handled for each state\n- No states or transitions are forgotten\n-
  The definition is both human-readable and machine-checkable\n\nIn essence, **Haskell
  itself is the language for defining automata**, without needing external DSLs or
  formats like DOT.\n\n---\n\n\n"
description-type: markdown
hash: f25d218c9f7eafbc6526e1c55bb5a6c15feed06d62cf16bfdf5b09bc75e34996
homepage: https://github.com/steve-anunknown/haal#readme
latest: 0.1.0.0
license-name: BSD-3-Clause
maintainer: steve.anunknown@gmail.com
synopsis: A Haskell library for Active Automata Learning.
test-bench-deps:
  QuickCheck: '>=0'
  base: '>=4.18.3 && <4.21'
  containers: '>=0.6 && <0.7'
  haal: '>=0'
  hspec: '>=0'
  mtl: '>=2.3.1 && <2.4'
  random: '>=1.2.1 && <1.2.2'

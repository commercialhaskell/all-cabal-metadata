homepage: ''
changelog-type: ''
hash: 7acf42f49ef4f2e676b98f67161e305d216af04b89dca115fc2b67a7fbc6a300
test-bench-deps:
  hjugement-protocol: -any
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2.8'
  text: ! '>=1.2'
  containers: ! '>=0.5'
  tasty-quickcheck: -any
  hashable: ! '>=1.2.6'
  tasty-hunit: ! '>=0.9'
  transformers: ! '>=0.5'
  random: ! '>=1.1'
  tasty: ! '>=0.11'
  QuickCheck: ! '>=2.0'
maintainer: Julien Moutinho <julm+hjugement@autogeree.net>
synopsis: A cryptographic protocol for the Majority Judgment.
changelog: ''
basic-deps:
  bytestring: ! '>=0.10'
  base: ! '>=4.6 && <5'
  unordered-containers: ! '>=0.2.8'
  text: ! '>=1.2'
  memory: ! '>=0.14'
  containers: ! '>=0.5'
  cryptonite: ! '>=0.25'
  mmorph: ! '>=1.1'
  transformers: ! '>=0.5'
  random: ! '>=1.1'
all-versions:
- 0.0.0.20190428
author: Julien Moutinho <julm+hjugement@autogeree.net>
latest: 0.0.0.20190428
description-type: haddock
description: |-
  This work-in-progress library aims at implementing an online voting protocol
  named <https://eprint.iacr.org/2013/177.pdf Helios-C> (Helios with Credentials)
  by its authors from the <https://www.cnrs.fr/ CNRS>,
  the <http://www.loria.fr INRIA>
  and the <https://www.univ-lorraine.fr/ Université de Lorraine>:
  <http://www.loria.fr/~cortier/ Véronique Cortier>,
  <https://dgalindo.es/ David Galindo>,
  <http://www.loria.fr/~gaudry/ Pierrick Gaudry>,
  <http://stephane.glondu.net/ Stéphane Glondu>
  and Malika Izabachène.

  (TODO) Actually, this protocol is adapted a little bit here to better support
  a better method of voting known as the <http://libgen.io/book/index.php?md5=BF67AA4298C1CE7633187546AA53E01D Majority Judgment>.

  A large-public introduction (in french) to Helios-C is available here:
  <https://members.loria.fr/VCortier/files/Papers/Bulletin1024-2016.pdf Bulletin de la société informatique de France – numéro 9, novembre 2016>.

  The main properties of this protocol are:

  * /fully correct/: the published result are proven to correspond
  to the (sum of) intended votes of the voters,
  while accounting for a malicious bulletin board (BB) (adding fake ballots)
  by requiring a registration authority (RA)
  (responsible for generating and sending voters' credentials).
  Assuming that the BB and the RA are not simultaneously dishonest.

  * /verifiable/: each voter is able to check that:
  his\/her ballot did contribute to the outcome (/individual verifiability/),
  and that the tallying authorities did their job properly (/universal verifiability/).

  * /private/: the identities of the voters who cast a vote are not publicly revealed.

  More specifically, in this protocol :

  * Ballots are encrypted using public-key cryptography
  secured by the /Discrete Logarithm problem/:
  finding @x@ in @g^x `mod` p@, where @p@ is a large prime
  and @g@ a generator of @Gq@, the multiplicative subgroup of order @q@,
  in @Fp@ (the finite prime field whose characteristic is @p@).
  Here, @p@ is 2048-bit and @q@ is 256-bit.
  The signing (Schnorr-like), the encrypting (ElGamal-like)
  and the /Decisional Diffe Hellman/ (DDH) assumption,
  all rely on the hardness of that problem.
  * Ballots are added without being decrypted
  because adding (multiplying actually) ciphertexts then decrypting,
  is like decrypting then adding plaintexts (/additive homomorphism/).
  Which requires to solve the /Discrete Logarithm Problem/
  for numbers in the order of the number of voters,
  which is not hard for small numbers (with a lookup table as here,
  or with Pollard’s rho algorithm for logarithms).
  * The /Schnorr protocol/ is used to prove that a voter has knowledge
  of the secret key used to sign their votes.
  A voter's credentials is a secret key (the signing key)
  that has a public part (the verification key).
  The association between the public part and the corresponding voter’s identity
  does not need to be known, and actually should not be disclosed to satisfy
  e.g. the French requirements regarding voting systems.
  Using credentials prevent the submission of duplicated ballots
  (because they are added as an additional input to the random oracle
  in the /non-interactive zero-knowledge/ (NIZK) proofs for ciphertext well-formedness).
  This allows a testing of duplicates which depends only on the size of the number of voters,
  and thus enables Helios-C to scale for larger elections while attaining correctness.
  * The /Chaum-Pedersen protocol/ (proving that equality of discrete logarithms)
  is used to prove that ciphertexts are well-formed
  (encrypting a 0 or a 1… or any expected natural) without decrypting them.
  Which is known as a /Disjunctive Chaum-Pedersen/ proof of partial knowledge.
  * A /strong Fiat-Shamir transformation/ is used
  to transform the /interactive zero-knowledge/ (IZK) /Chaum-Pedersen protocol/
  into a /non-interactive zero-knowledge/ (NIZK) proof, using a SHA256 hash.
  * (TODO) A Pedersen's /distributed key generation/ (DKG) protocol
  coupled with ElGamal keys (under the DDH assumption),
  is used to have a fully distributed semantically secure encryption.
license-name: GPL-3.0-only

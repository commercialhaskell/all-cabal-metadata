homepage: https://github.com/michalkonecny/aern2#readme
changelog-type: markdown
hash: cf974bd059b28dbeba3db0c23e53ebaee23a55f67d3cb00d87f9b0b25fa8ec04
test-bench-deps: {}
maintainer: mikkonecny@gmail.com
synopsis: Real numbers as sequences of MPBalls
changelog: |+
  # Change log for aern2-real

  * v 0.2.1 2021-05-18
    * add conversion from WithAnyPrec
  * v 0.2.0 2021-05-17
    * moving Arrow-based functionality to package aern2-net
    * replacing Arrow-based sequences by list-based sequences
    * switch to new simplified collect-errors, mixed-types-num 0.5.0
      * got rid of EnsureCE etc.
      * not introducing CN wrapper unless at least one parameter is already CN
  * v 0.1.2 2019-03-19
    * adapts to mixed-types-num 0.3.2 (new divI, mod)
  * v 0.1.1.0 2017-12-06
    * disable aern2-generate-netlog-elm for now
  * v 0.1.0.3 2017-12-06
    * remove further upper bounds
  * v 0.1.0.2 2017-11-14
    * remove most upper bounds, building with ghc 8.2
  * v 0.1.0.1 2017-09-12
    * first release on Hackage
    * fast convergent sequences indexed by AccuracySG
    * arrow-based networks of nodes communicating via query-answer protocols
    * networks executable with cached and parallel strategies
    * network execution can be visualised in browser using an Elm frontend

basic-deps:
  integer-logarithms: -any
  aern2-mp: '>=0.2.1'
  base: ==4.*
  hspec: -any
  collect-errors: '>=0.1'
  mixed-types-num: '>=0.5.1'
  QuickCheck: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
- 0.1.1.0
- 0.1.2
- 0.2.0.0
- 0.2.1.0
author: Michal Konecny
latest: 0.2.1.0
description-type: markdown
description: "# aern2-real <!-- omit in toc -->\n\nExact real arithmetic\n\nAPI documentation
  available on the [Hackage page](https://hackage.haskell.org/package/aern2-real).\n\n##
  Table of contents <!-- omit in toc -->\n\n- [1. Numeric data types](#1-numeric-data-types)\n-
  [2. Basic usage with Prelude](#2-basic-usage-with-prelude)\n- [3. Basic usage with
  MixedTypesNumPrelude](#3-basic-usage-with-mixedtypesnumprelude)\n- [4. Partial functions
  and error handling](#4-partial-functions-and-error-handling)\n- [5. Limits](#5-limits)\n-
  [6. Multivalued selection](#6-multivalued-selection)\n  - [6.1. Parallel branching](#61-parallel-branching)\n
  \ - [6.2. Multi-valued selection](#62-multi-valued-selection)\n- [7. Specification
  and tests](#7-specification-and-tests)\n\n## 1. Numeric data types\n\nThis package
  provides the following two data types:\n\n- `CReal`:  Exact real numbers via lazy
  sequences of interval approximations\n  \n- `CKleenean`: Lazy Kleeneans, naturally
  arising from comparisons of `CReal`s\n  \nThe type `CReal` has instances of both
  [mixed-types-num](https://hackage.haskell.org/package/mixed-types-num) type classes
  such as `CanAdd`, `CanSqrt` as well as with traditional Prelude type classes such
  as `Ord`, `Num` and `Floating`.\nThe type `CKleenean` supports the usual Boolean
  operations.\n\n## 2. Basic usage with Prelude\n\nFirst, let us load the package
  with **Prelude** operations:\n\n```Text\n$ stack ghci aern2-real:lib --no-load --ghci-options
  AERN2.Real\n*AERN2.MP> import Prelude hiding (pi)\n*AERN2.MP Prelude>\n```\n\nWe
  can obtain approximations of a real number with any **requested accuracies**:\n\n```Text\n...>
  pi ? (bits 1000)\n[3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117...
  ± ~0.0000 ~2^(-1230)]\n\n...> pi ? (bits 1000000)\n[3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117...
  ± ~0.0000 ~2^(-1028468)]\n(4.12 secs, 270,972,152 bytes)\n```\n\nInstead of accuracy,
  we can request that the computation is performed with a certain **precision**, which
  roughly corresponds to the number of significant bits.  This usually trades speed
  with guaranteed accuracy:\n\n```Text\n...> (sin pi) ? (bits 10000) -- guaranteed
  accuracy at least 10000\n[-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...
  ± ~0.0000 ~2^(-13539)]\n(0.27 secs, 196,580,192 bytes)\n\n...> (sin pi) ? (prec
  10000) -- no guaranteed accuracy\n[-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...
  ± ~0.0000 ~2^(-13539)]\n(0.21 secs, 107,844,784 bytes)\n```\n\nWhen formatting a
  real number, a **default precision** is used:\n\n```Text\n...> pi\n{?(prec 36):
  [3.141592653584666550159454345703125 ± ~1.4552e-11 ~2^(-36)]}\n```\n\nThe Prelude
  power operator works only for integral types:\n\n```Text\n...> pi ^ 2\n[9.8696044010893586188344909998725639610631902560...
  ± ~8.1120e-30 ~2^(-96)]\n{?(prec 36): [9.8696044009993784129619598388671875 ± ~1.4964e-10
  ~2^(-32)]}\n\n...> pi ^ pi\n<interactive>:18:1: error:\n    • No instance for (Integral
  CReal) arising from a use of ‘^’\n```\n\nNumerical order cannot be decided when
  the two numbers are equal:\n\n```Text\n...> pi > 0\nTrue\n\n...> pi == pi\n*** Exception:
  Failed to decide equality of Sequences.  If you switch to MixedTypesNumPrelude instead
  of Prelude, comparison of Sequences returns CSequence Kleenean or similar instead
  of Bool.\n```\n\nPrelude comparison fails to determine also inequality when the
  two numbers are very close:\n\n```Text\n...> pi == pi + 0.00000000000000000000000000000000001\nFalse\n\n...>
  pi == pi + 0.00000000000000000000000000000000000001\n*** Exception: Failed to decide
  equality of Sequences.  If you switch to MixedTypesNumPrelude instead of Prelude,
  comparison of Sequences returns CSequence Kleenean or similar instead of Bool.\n```\n\n##
  3. Basic usage with MixedTypesNumPrelude\n\nWe see that some things do not work
  with Prelude. Let us use **MixedTypesNumPrelude** operations instead:\n\n```Text\n$
  stack ghci aern2-real:lib --no-load --ghci-options AERN2.Real\n*AERN2.MP> import
  MixedTypesNumPrelude\n*AERN2.MP MixedTypesNumPrelude>\n```\n\nWe get a more general
  power operator:\n\n```Text\n...> 2^0.5\n{?(prec 36): [1.414213562371930730340852514178195642186126256312482171419747717302107387071785637999710161238908...
  ± ~1.0305e-11 ~2^(-36)]}\n\n...> pi ^ pi\n{?(prec 36): [36.462159605538498632520418490483602438877178488347481362195878876490337527904728176508797332644462...
  ± ~2.7112e-9 ~2^(-28)]}\n\n...> (pi ^ pi) ? (bits 10000)\n[36.462159607207911770990826022692123666365508402228818738709335922934074368881699904620079875706774...
  ± ~0.0000 ~2^(-13532)]\n(0.90 secs, 631,865,912 bytes)\n```\n\nReal comparison now
  returns a `CKleenean` instead of `Bool`, supporting undecided comparisons and comparisons
  with a specified precision:\n\n```Text\n...> pi > 0\n{?(prec 36): CertainTrue}\n\n...>
  pi == pi\n{?(prec 36): TrueOrFalse}\n\n...> pi == pi + 2^(-100)\n{?(prec 36): TrueOrFalse}\n\n...>
  (pi == pi + 2^(-100)) ? (prec 1000)\nCertainFalse\n```\n\n## 4. Partial functions
  and error handling\n\nSince comparisons can be only semi-decided, also errors such
  as division by zero or logarithm of a negative number can be only semi-detected.\nTherefore,
  an invalid input leads to a normal `CReal` value, and the error is demonstrated
  only when we extract an approximation, and sometimes an error cannot be determined
  with certainty:\n\n```Text\n...> bad1 = pi/0\n...> bad1 ? (prec 100)\n{{ERROR: division
  by 0}}}\n\n...> bad2 = 1/(pi-pi)\n...> bad2 ? (prec 100)\n{{POTENTIAL ERROR: division
  by 0}}\n```\n\nWhen we are sure that potential errors are harmless, we can clear
  them:\n\n```Text\n...> ok3 = sqrt (pi-pi)\n...> ok3 ? (prec 10)\n[0.022097086912079610143710452219156792352805496193468570709228515625
  ± ~2.2097e-2 ~2^(-5)]{{POTENTIAL ERROR: out of domain: negative sqrt argument}}\n...>
  clearPotentialErrors $ ok3 ? (prec 10)\n[0.022097086912079610143710452219156792352805496193468570709228515625
  ± ~2.2097e-2 ~2^(-5)]\n```\n\n## 5. Limits\n\nComputing a limit of a fast converging
  sequence of numbers or functions is one of the most fundamental operations for real
  numbers.\nFor example, we can compute `e` as the limit of the partial sums of terms
  `1/n!` for `n` ranging from `0` onwards:\n\n```Text\n... MixedTypesNumPrelude> fact
  n = creal $ product [1..n]\n... MixedTypesNumPrelude> e_sum n = sum $ map (recip
  . fact) [0..n]\n```\n\nTODO\n\n## 6. Multivalued selection\n\nWhen a comparison
  is needed for branching, its semi-decidability becomes a challenge.  As an example,
  consider the task of defining the `abs` function by cases.\nWe have two ways to
  overcome the challenge:\n\n### 6.1. Parallel branching\n\n```Text\n... MixedTypesNumPrelude>
  abs1 x = if x < 0 then -x else x\n... MixedTypesNumPrelude> abs1 (pi - pi)\n{?(prec
  36): [0 ± ~2.9104e-11 ~2^(-35)]}\n```\n\nThis simple definition works even when
  x = 0 because AERN2 has redefined the if-then-else operator for a `CKleenean` condition
  and real number branches in such a way that in situations where the condition is
  inconclusive, both branches are computed and the results safely merged.  This is
  convenient, but can lead to inefficient code if the number of branches that need
  to be considered grows large.\n\n### 6.2. Multi-valued selection\n\nTODO\n\n## 7.
  Specification and tests\n\nThe approximations obtained using `? (bits n)` or `?
  (prec p)` are intervals of type `CN MPBall` from package [aern2-mp](../aern2-mp/README.md).
  \ This type is also used internally for all `CReal` arithmetic.  The `MPBall` arithmetic
  is tested against a fairly complete hspec/QuickCheck specification of algebraic
  properties.\n"
license-name: BSD-3-Clause

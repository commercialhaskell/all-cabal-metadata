homepage: https://github.com/michalkonecny/aern2#readme
changelog-type: markdown
hash: 522c6bd71906077117abfffd02bf2c482420ca42cb5f5125b098388bb7fcd699
test-bench-deps: {}
maintainer: mikkonecny@gmail.com
synopsis: Real numbers as sequences of MPBalls
changelog: |+
  # Change log for aern2-real

  * v 0.2.0 2021-05-17
    * moving Arrow-based functionality to package aern2-net
    * replacing Arrow-based sequences by list-based sequences
    * switch to new simplified collect-errors, mixed-types-num 0.5.0
      * got rid of EnsureCE etc.
      * not introducing CN wrapper unless at least one parameter is already CN
  * v 0.1.2 2019-03-19
    * adapts to mixed-types-num 0.3.2 (new divI, mod)
  * v 0.1.1.0 2017-12-06
    * disable aern2-generate-netlog-elm for now
  * v 0.1.0.3 2017-12-06
    * remove further upper bounds
  * v 0.1.0.2 2017-11-14
    * remove most upper bounds, building with ghc 8.2
  * v 0.1.0.1 2017-09-12
    * first release on Hackage
    * fast convergent sequences indexed by AccuracySG
    * arrow-based networks of nodes communicating via query-answer protocols
    * networks executable with cached and parallel strategies
    * network execution can be visualised in browser using an Elm frontend

basic-deps:
  integer-logarithms: -any
  aern2-mp: '>=0.2'
  base: ==4.*
  hspec: -any
  collect-errors: '>=0.1'
  mixed-types-num: '>=0.5.1'
  QuickCheck: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.0.2
- 0.1.0.3
- 0.1.1.0
- 0.1.2
- 0.2.0.0
author: Michal Konecny
latest: 0.2.0.0
description-type: markdown
description: "# aern2-real\n\nExact real arithmetic\n\n## Numeric data types\n\nThis
  package provides the following two data types:\n\n* `CReal`:  Exact real numbers
  via lazy sequences of interval approximations\n  \n* `CKleenean`: Lazy Kleeneans,
  naturally arising from comparisons of `CReal`s\n  \nThe type `CReal` has instances
  of both [mixed-types-num](https://hackage.haskell.org/package/mixed-types-num) type
  classes such as `CanAdd`, `CanSqrt` as well as with traditional Prelude type classes
  such as `Ord`, `Num` and `Floating`.\nThe type `CKleenean` supports the usual Boolean
  operations.\n\n### Examples\n\nFirst, let us test exact real arithmetic with Prelude
  operations:\n\n    $ stack ghci aern2-real:lib --no-load --ghci-options AERN2.Real\n
  \   *AERN2.MP> import Prelude hiding (pi)\n    *AERN2.MP Prelude>\n\n    ...> pi\n
  \   {?(prec 36): [3.141592653584666550159454345703125 ± ~1.4552e-11 ~2^(-36)]}\n\n
  \   ...> pi ? (bits 1000)\n    [3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117...
  ± ~0.0000 ~2^(-1230)]\n\n    ...> pi ? (bits 1000000)\n    [3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117...
  ± ~0.0000 ~2^(-1028468)]\n    (4.12 secs, 270,972,152 bytes)\n\n    ...> pi ^ 2\n
  \   [9.8696044010893586188344909998725639610631902560... ± ~8.1120e-30 ~2^(-96)]\n
  \   {?(prec 36): [9.8696044009993784129619598388671875 ± ~1.4964e-10 ~2^(-32)]}\n\n
  \   ...> pi ^ pi\n    <interactive>:18:1: error:\n        • No instance for (Integral
  CReal) arising from a use of ‘^’\n\n    ...> sin pi\n    {?(prec 36): [0.000000000005126565838509122841060161590576171875
  ± ~1.4559e-11 ~2^(-35)]}\n\n    ...> (sin pi) ? (bits 10000) -- guaranteed accuracy
  at least 10000\n    [-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...
  ± ~0.0000 ~2^(-13539)]\n    (0.21 secs, 196,580,192 bytes)\n\n    ...> (sin pi)
  ? (prec 10000) -- no guaranteed accuracy\n    [-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...
  ± ~0.0000 ~2^(-13539)]\n    (0.13 secs, 107,844,784 bytes)\n\n    ...> pi > 0\n
  \   True\n\n    ...> pi == pi\n    *** Exception: Failed to decide equality of Sequences.
  \ If you switch to MixedTypesNumPrelude instead of Prelude, comparison of Sequences
  returns CSequence Kleenean or similar instead of Bool.\n\nSome things do not work
  with Prelude. Let us try using MixedTypesNumPrelude operations:\n\n    $ stack ghci
  aern2-real:lib --no-load --ghci-options AERN2.Real\n    *AERN2.MP> import MixedTypesNumPrelude\n
  \   *AERN2.MP MixedTypesNumPrelude>\n\n    ...> pi ^ pi\n    {?(prec 36): [36.462159605538498632520418490483602438877178488347481362195878876490337527904728176508797332644462...
  ± ~2.7112e-9 ~2^(-28)]}\n\n    ...> (pi ^ pi) ? (bits 10000)\n    [36.462159607207911770990826022692123666365508402228818738709335922934074368881699904620079875706774...
  ± ~0.0000 ~2^(-13532)]\n    (0.81 secs, 631,865,912 bytes)\n\n    ...> pi > 0\n
  \   {?(prec 36): CertainTrue}\n\n    ...> pi == pi\n    {?(prec 36): TrueOrFalse}\n\n
  \   ...> pi == pi + 2^(-100)\n    {?(prec 36): TrueOrFalse}\n\n    ...> (pi == pi
  + 2^(-100)) ? (prec 1000)\n    CertainFalse\n\n    ...> 2^0.5\n    {?(prec 36):
  [1.414213562371930730340852514178195642186126256312482171419747717302107387071785637999710161238908...
  ± ~1.0305e-11 ~2^(-36)]}\n\n## Partial functions and error handling\n\nErrors due
  to invalid input, such as division by zero or logarithm of a negative number can
  be only semi-detected in the same way as comparisons can be only semi-decided.\nTherefore,
  an invalid input gives a `CReal` leads to errors or potential errors only when extracting
  an approximation:\n\n    ...> bad1 = pi/0\n    ...> bad1 ? (prec 100)\n    {{ERROR:
  division by 0}}}\n\n    ...> bad2 = 1/(pi-pi)\n    ...> bad2 ? (prec 100)\n    {{POTENTIAL
  ERROR: division by 0}}\n\nWhen we are sure that potential errors are harmless, we
  can clear them:\n\n    ...> ok3 = sqrt (pi-pi)\n    ...> ok3 ? (prec 10)\n    [0.022097086912079610143710452219156792352805496193468570709228515625
  ± ~2.2097e-2 ~2^(-5)]{{POTENTIAL ERROR: out of domain: negative sqrt argument}}\n
  \   ...> clearPotentialErrors $ ok3 ? (prec 10)\n    [0.022097086912079610143710452219156792352805496193468570709228515625
  ± ~2.2097e-2 ~2^(-5)]\n\n## Specification and tests\n\nThe approximations obtained
  using `? (bits n)` or `? (prec p)` are intervals of type `CN MPBall` from package
  [aern2-mp](../aern2-mp/README.md).  This type is also used internally for all `CReal`
  arithmetic.  The `MPBall` arithmetic is tested against a fairly complete hspec/QuickCheck
  specification of algebraic properties.\n"
license-name: BSD-3-Clause

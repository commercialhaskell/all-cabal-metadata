homepage: ''
changelog-type: markdown
hash: fbab4892aa7991da27a752331c0950e75ed94ae1e8ca457120a35aaa3ae99517
test-bench-deps:
  aeson-gadt-th: -any
  dependent-sum: -any
  base: -any
  hspec: -any
  HUnit: -any
  aeson-qq: -any
  aeson: -any
maintainer: maintainer@obsidian.systems
synopsis: Derivation of Aeson instances for GADTs
changelog: |
  # Revision history for aeson-gadt-th

  ## 0.2.1.2

  * Add version bounds to cabal file

  ## 0.2.1.1

  * Drop markdown-unlit in favor of "Bird"-style LHS to avoid some cross-compilation issues.

  ## 0.2.1.0

  * Extend type variable substitution to handle all current cases in template-haskell.
  * Better deal with data constructors having an index that is polymorphic, but can be determined from the other type parameters.
  * Handle data constructors that are constrained by type classes.

  ## 0.2.0.0

  * Add changelog
  * Add option to modify constructor tag in derived JSON
  * Add test suite
basic-deps:
  aeson-gadt-th: -any
  dependent-sum: ! '>=0.6.2 && <0.7'
  dependent-sum-template: ! '>=0.1 && <0.2'
  base: ! '>=4.8 && <4.13'
  dependent-map: ! '>=0.3 && <0.4'
  containers: ! '>=0.5 && <0.7'
  transformers: ! '>=0.5 && <0.6'
  aeson: ==1.4.*
  template-haskell: ! '>=2.11.0 && <2.15'
all-versions:
- 0.1.0.0
- 0.1.1.0
- 0.1.2.0
- 0.1.2.1
- 0.2.0.0
- 0.2.1.0
- 0.2.1.1
- 0.2.1.2
author: Obsidian Systems LLC
latest: 0.2.1.2
description-type: text
description: "aeson-gadt-th\n=============\n\nProvides Template Haskell expressions
  for deriving `ToJSON` and `FromJSON` instances for GADTs.\n\nExample Usage:\n--------------\n\n```haskell\n>
  {-# LANGUAGE GADTs #-}\n> {-# LANGUAGE KindSignatures #-}\n> {-# LANGUAGE TemplateHaskell
  #-}\n> {-# LANGUAGE FlexibleContexts #-}\n> {-# LANGUAGE FlexibleInstances #-}\n>
  {-# LANGUAGE UndecidableInstances #-}\n> {-# LANGUAGE MultiParamTypeClasses #-}\n>
  \n> import Data.Aeson\n> import Data.Aeson.GADT.TH\n> \n> import Data.Dependent.Map
  (DMap, Some(..))\n> import Data.Dependent.Sum (DSum)\n> import Data.Functor.Identity\n>
  import Data.GADT.Compare\n> import Data.GADT.Show.TH\n> \n> data A :: * -> * where\n>
  \  A_a :: A a\n>   A_b :: Int -> A ()\n> \n> deriveJSONGADT ''A\n> deriveGShow ''A\n>\n>
  data B c :: * -> * where\n>   B_a :: c -> A a -> B c a\n>   B_x :: B c a\n>\n> deriveJSONGADT
  ''B\n> \n> data C t :: * -> * where\n>   C_t :: t -> C t t\n> \n> deriveJSONGADT
  ''C\n> \n> -- Some real-world-ish examples.\n> \n> -- | Edit operations for `LabelledGraph`\n>
  data LabelledGraphEdit v vm em :: * -> * where\n>   LabelledGraphEdit_ClearAll ::
  LabelledGraphEdit v vm em ()\n>   LabelledGraphEdit_AddVertex :: vm -> LabelledGraphEdit
  v vm em v\n>   LabelledGraphEdit_AddEdge :: v -> v -> em -> LabelledGraphEdit v
  vm em ()\n>   LabelledGraphEdit_SetVertexProperties :: v -> vm -> LabelledGraphEdit
  v vm em ()\n>   LabelledGraphEdit_SetEdgeProperties :: v -> v -> em -> LabelledGraphEdit
  v vm em ()\n> \n> -- | PropertyGraphEdit operatios for `PropertyGraph`\n> data PropertyGraphEdit
  v vp ep r where\n>   PropertyGraphEdit_ClearAll :: PropertyGraphEdit v vp ep ()\n>
  \  PropertyGraphEdit_AddVertex :: (DMap vp Identity) -> PropertyGraphEdit v vp ep
  v\n>   PropertyGraphEdit_AddEdge :: v -> v -> (DMap ep Identity) -> PropertyGraphEdit
  v vp ep ()\n>   PropertyGraphEdit_SetVertexProperty :: GCompare vp => v -> DSum
  vp Identity -> PropertyGraphEdit v vp ep ()\n>   PropertyGraphEdit_SetEdgeProperty
  :: GCompare ep => v -> v -> DSum ep Identity -> PropertyGraphEdit v vp ep ()\n>
  \n> -- | View operations for `LabelledGraph`\n> data LabelledGraphView v vm em ::
  * -> * where\n>   LabelledGraphView_All :: LabelledGraphView v vm em ()\n>   LabelledGraphView_GetVertexProperties
  :: v -> LabelledGraphView v vm em vm\n>   LabelledGraphView_GetEdgeProperties ::
  v -> v -> LabelledGraphView v vm em em\n> \n> deriveJSONGADT ''LabelledGraphEdit\n>
  deriveJSONGADT ''PropertyGraphEdit\n> deriveJSONGADT ''LabelledGraphView\n> \n>
  main :: IO ()\n> main = do\n>   putStrLn $ unlines\n>     [ \"Encoding of A_a:\"\n>
  \    , show $ encode A_a\n>     , \"Decoding of encoded A_a:\"\n>     , show (decode
  $ encode A_a :: Maybe (Some A))\n>     ]\n>\n>   putStrLn $ unlines\n>     [ \"Encoding
  of (A_b 1):\"\n>     , show $ encode (A_b 1)\n>     , \"Decoding of encoded (A_b
  1):\"\n>     , show (decode $ encode (A_b 1) :: Maybe (Some A))\n>     ]\n>\n>   putStrLn
  $ unlines\n>     [ \"Encoding of (B_a 'a' (A_b 1)):\"\n>     , show $ encode (B_a
  'a' (A_b 1))\n>     , \"Decoding of encoded (B_a 'a' (A_b 1)):\"\n>     , case (decode
  $ encode (B_a 'a' (A_b 1)) :: Maybe (Some (B Char))) of\n>         Just (This (B_a
  'a' (A_b 1))) -> \"Succeeded\"\n>         _-> \"Failed\"\n>     ]\n```\n"
license-name: BSD-3-Clause

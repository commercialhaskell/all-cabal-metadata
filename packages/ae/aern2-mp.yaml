homepage: https://github.com/michalkonecny/aern2#readme
changelog-type: markdown
hash: e9c37631300832c9b4d8300e5901ecb6344fdd4acb3529f696a26d8167d6e017
test-bench-deps:
  integer-logarithms: -any
  reflection: -any
  aern2-mp: -any
  base: ==4.*
  hspec: -any
  collect-errors: '>=0.1.3'
  regex-tdfa: -any
  mixed-types-num: '>=0.5.1'
  deepseq: -any
  QuickCheck: -any
  cdar-mBound: '>=0.1.0.0'
  template-haskell: -any
maintainer: mikkonecny@gmail.com
synopsis: Multi-precision ball (interval) arithmetic
changelog: |
  # Change log for aern2-mp

  * v 0.2.0 2021-05-17
    * switch to new simplified collect-errors, mixed-types-num 0.5.0
      * got rid of EnsureCE etc.
      * not introducing CN wrapper unless at least one parameter is already CN
    * using CDAR backend only, no MPFR for now
    * WithCurrentPrec for specifying default precision via types
  * v 0.1.4 2019-03-19
    * CDAR-based Integer-only backend
      * needs the mBound branch of CDAR
    * adapts to mixed-types-num 0.3.2 (new divI, mod)
  * v 0.1.3.1 2018-11-21
    * small fixes, mainly documentation
  * v 0.1.3.0 2018-11-20
    * only one MPFR backend - rounded
    * reduce backend-specific code
  * v 0.1.2.0 2017-11-14
    * fix compilation with haskell-mpfr
  * v 0.1.1.0 2017-11-14
    * using Claude Heiland-Allen's Numeric.Rounded.Simple
  * v 0.1.0.1 2017-09-12
    * first release on Hackage
    * backends: hmpfr and (tweaked) rounded
basic-deps:
  integer-logarithms: -any
  reflection: -any
  base: ==4.*
  hspec: -any
  collect-errors: '>=0.1.3'
  regex-tdfa: -any
  mixed-types-num: '>=0.5.1'
  deepseq: -any
  QuickCheck: -any
  cdar-mBound: '>=0.1.0.0'
  template-haskell: -any
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
- 0.1.2.0
- 0.1.3.0
- 0.1.3.1
- 0.1.4
- 0.2.0.0
author: Michal Konecny
latest: 0.2.0.0
description-type: markdown
description: "# aern2-mp\n\nVariable-precision interval arithmetic\n\n## Numeric data
  types\n\nThis package provides the following two data types:\n\n* `Dyadic`:  variable-precision
  floats with exact ring operations\n  \n* `MPBall`: variable-precision interval (float
  centre ± error bound) with field & elementary interval operations\n  \nThe type
  `MPBall` has instances of both [mixed-types-num](https://hackage.haskell.org/package/mixed-types-num)
  type classes such as `CanAdd`, `CanSqrt` as well as with traditional Prelude type
  classes such as `Ord`, `Num` and `Floating`.\nThe type `Dyadic` also has an appropriate
  subset of such instances.\n\nPackage [aern2-real](../aern2-real/README.md) provides
  an arithmetic of exact real numbers as converging lazy sequences of `MPBall`s of
  increasing precision.  Exact real numbers offer additional convenience and readability
  to validated numeric programming.\n\n### Examples\n\nFirst, let us test interval
  arithmetic with **Prelude** operations:\n\n    $ stack ghci aern2-mp:lib --no-load
  --ghci-options AERN2.MP\n    *AERN2.MP> import Prelude\n    *AERN2.MP Prelude>\n\n
  \   ...> pi100 = piBallP (prec 100)\n    ...> pi10000 = piBallP (prec 10000)\n\n
  \   ...> pi100 ^ 2\n    [9.8696044010893586188344909998725639610631902560... ± ~8.1120e-30
  ~2^(-96)]\n\n    ...> pi100 ^ pi100\n    <interactive>:18:1: error:\n        • No
  instance for (Integral MPBall) arising from a use of ‘^’\n\n    ...> sin pi100\n
  \   [0.0000000000000000000000000000001694818351060767... ± ~7.8925e-31 ~2^(-99)]\n\n
  \   ...> sin pi10000\n    [0.0000000000000000000000000000000000000000000000... ±
  ~0.0000 ~2^(-9999)]\n    (0.07 secs, 64,466,432 bytes)\n\n    ...> pi100 > 0\n    True\n\n
  \   ...> pi100 == pi100\n    *** Exception: Failed to decide equality of MPBalls.
  \ If you switch to MixedTypesNumPrelude instead of Prelude, comparison of MPBalls
  returns Kleenean instead of Bool.\n\nSome things do not work with Prelude. Let us
  try using **MixedTypesNumPrelude** operations:\n\n    $ stack ghci aern2-mp:lib
  --no-load --ghci-options AERN2.MP\n    *AERN2.MP> import MixedTypesNumPrelude\n
  \   *AERN2.MP MixedTypesNumPrelude>\n\n    ...> pi100 = piBallP (prec 100)\n    ...>
  pi10000 = piBallP (prec 10000)\n\n    ...> pi100 ^ pi100\n    [36.4621596072079117709908260226198218149834948802...
  ± ~1.8696e-28 ~2^(-92)]\n\n    ...> pi10000 ^ pi10000\n    [36.4621596072079117709908260226921236663655084022...
  ± ~0.0000 ~2^(-9992)]\n    (0.27 secs, 204,657,248 bytes)\n\n    ...> pi100 > 0\n
  \   CertainTrue\n\n    ...> pi100 == pi100\n    TrueOrFalse\n\n### Internal types
  and backends\n\nThe type `MPBall` internally uses the type:\n\n* `MPFloat`: arbitrary-precision
  floats with both upwards and downwards-rounded arithmetic operations such as `*^`
  and `*.`\n\nThe package uses [cdar-mBound](https://hackage.haskell.org/package/cdar-mBound),
  a fork of [cdar](https://github.com/jensblanck/cdar) as its backend for `Dyadic`
  and `MPFloat`.\n\nIn previous versions, there was an MPFR backend via [rounded](https://hackage.haskell.org/package/rounded).
  \ This may be added again in future.\n\n## Specifications and tests\n\nThis package
  also provides a fairly complete hspec/QuickCheck specification of algebraic properties
  for the above types.  \n\nFor `MPFloat`, the properties are given mostly as approximate
  versions of algebraic equalities with a small rounding error tolerance.  \n\nFor
  `MPBall`, the properties are given mostly as (interval) set over-approximations
  of the usual algebraic equalities.\n"
license-name: BSD-3-Clause

homepage: https://github.com/mesabloo/diagnose#readme
changelog-type: ''
hash: a8b00422303ec4762a21a8469f54f82c3a7c54342872d9fc85e2a2255f4e02a7
test-bench-deps:
  diagnose: -any
  base: '>=4.7 && <5'
  unordered-containers: ==0.2.*
  text: '>=1.2 && <=2.0'
  dlist: ==1.0.*
  data-default: '>=0.7 && <1'
  array: ==0.5.*
  wcwidth: '>=0.0.1 && <1'
  hashable: '>=1.3 && <2'
  prettyprinter: '>=1.7.0 && <2'
  prettyprinter-ansi-terminal: '>=1.1.0 && <2'
maintainer: Ghilain Bergeron
synopsis: Beautiful error reporting done easily
changelog: ''
basic-deps:
  base: '>=4.7 && <5'
  unordered-containers: ==0.2.*
  text: '>=1.0.0.0 && <=2.0'
  dlist: ==1.0.*
  data-default: '>=0.7 && <1'
  array: ==0.5.*
  wcwidth: '>=0.0.1 && <1'
  hashable: '>=1.3 && <2'
  prettyprinter: '>=1.7.0 && <2'
  prettyprinter-ansi-terminal: '>=1.1.0 && <2'
all-versions:
- 1.6.3
- 1.6.4
- 1.7.0
- 1.7.1
- 1.7.2
- 1.8.0
- 1.8.1
- 1.8.2
- 1.9.0
- 2.0.0
- 2.0.1
- 2.1.1
- 2.2.0
- 2.3.0
- 2.3.1
author: Ghilain Bergeron
latest: 2.3.1
description-type: markdown
description: "# Error reporting made easy\n\nDiagnose is a small library used to report
  compiler/interpreter errors in a beautiful yet readable way.\nIt was in the beginning
  heavily inspired by [ariadne](https://github.com/zesterer/ariadne), but ended up
  quickly becoming its own thing.\n\nAs a great example, here's the output of the
  last test:\n\n![first example](./assets/real-world-example-unicode.png)\n\nIf you
  do not like unicode characters, or choose to target platforms which cannot output
  them natively;\nyou may alternatively print the whole diagnostic with ASCII characters,
  like this:\n\n![second example](./assets/real-world-example-ascii.png)\n\nColors
  are also optional, and you may choose not to print them.\n\n## Features\n\n- Show
  diagnostics with/without 8-bit colors, with/without Unicode characters\n- Inline
  and multiline markers are nicely displayed\n- The order of markers matters!\n  If
  there are multiple markers on the same line, they are ordered according to how they
  were put in each report\n- Reports spanning across multiple files are handled as
  well\n- Generic over the type of message which can be displayed, meaning that you
  can output custom data types as well as they can be pretty-printed\n- Diagnostics
  can be exported to JSON, if you don't quite like the rendering as it is, or if you
  need to transmit them to e.g. a website\n- Plug and play (mega)parsec integration
  and it magically works with your parsers!\n- Support for optional custom error codes,
  if you want to go the Rust way\n- Variable width Unicode characters are handled
  in a crossplatform manner\n- TAB characters have custom sizes specified when printing
  a diagnostic, so that *you* decide the width of a TAB, not your terminal emulator!\n-
  Colors can be tweaked thanks to the ability to export diagnostics as `Doc`uments\n\n##
  Usage\n\nYou only need to `import Error.Diagnose`, and everything should be ready
  to go.\nYou don't even need to `import Prettyprinter`, as it is already provided
  to you by `Error.Diagnose`!\n\n--------\n\nA diagnostic can be viewed as a collection
  of reports, spanning on files.\nThis is what the `Diagnostic` type embodies.\n\nIt
  has a `Default` instance, which can be used to construct an empty diagnostic (contains
  no reports, and has no files).\n\nThe second step is to add some reports.\nThere
  are two kinds of reports:\n- Error reports, created through `err`\n- Warning reports,
  created by using `warn`\n\nBoth of these fonctions have the following type:\n```haskell\n--
  | An optional error code, shown right after @error@ or @warning@ in the square brackets\nMaybe
  msg ->\n-- | The main message, which is output at the top right after @[error]@
  or @[warning]@\nmsg ->\n-- | A list of markers, along with the positions they span
  on\n[(Position, Marker msg)] ->\n-- | Some hints to be output at the bottom of the
  report\n[Note msg] ->\n-- | The created report\nReport msg\n```\n\nEach report contains
  markers, which are what underlines the code in the screenshots above.\nThey come
  in three flavors:\n- A `This` marker indicates the main reason of the error.\n  It
  is highlighted in red (for errors) or yellow (for warnings).\n  Ideally, there is
  only one per report, but this isn't strictly required.\n- A `Where` marker adds
  additional context to the error by adding highlighted code to the error.\n  This
  can be used to remind used that a variable was found of a given type earlier, or
  even where a previous declaration was found in another file.\n  This is output in
  blue by default.\n- A `Maybe` marker is probably the rarest one.\n  It is basically
  a way of suggesting fixes (as when GCC tells you that you probably mistyped a variable
  name).\n  These markers are highlighted in green.\n\nThe `Position` datatype is
  however required to be used with this library.\nIf you use another way of keeping
  track of position information, you will need to convert them to the `Position` datatype.\n\nOnce
  your reports are created, you will need to add them inside the diagnostic using
  `addReport`.\nYou will also need to put your files into the diagnostic with `addFile`,
  else lines won't be printed and you will get `<no-line>` in your reports.\n\nAfter
  all of this is done, you may choose to either:\n- print the diagnostic onto a file
  `Handle` (most likely `stdout` or `stderr`) using `printDiagnostic`;\n- create a
  `Doc`ument which can be further altered using `prettyDiagnostic`;\n- or export it
  to JSON with `diagnosticToJson` or the `ToJSON` class of Aeson (the output format
  is documented under the `diagnosticToJson` function).\n\n## Example\n\nHere is how
  the above screenshot was generated:\n```haskell\nlet beautifulExample =\n      err\n
  \       Nothing\n        \"Could not deduce constraint 'Num(a)' from the current
  context\"\n        [ (Position (1, 25) (2, 6) \"somefile.zc\", This \"While applying
  function '+'\"),\n          (Position (1, 11) (1, 16) \"somefile.zc\", Where \"'x'
  is supposed to have type 'a'\"),\n          (Position (1, 8) (1, 9) \"somefile.zc\",
  Where \"type 'a' is bound here without constraints\")\n        ]\n        [\"Adding
  'Num(a)' to the list of constraints may solve this problem.\"]\n        -- ^^^^
  This is a 'Note' not a 'Hint', as specified by its 'IsString' instance\n\n-- Create
  the diagnostic \nlet diagnostic  = addFile def \"somefile.zc\" \"let id<a>(x : a)
  : a := x\\n  + 1\"\nlet diagnostic' = addReport diagnostic beautifulExample\n\n--
  Print with unicode characters, colors and the default style\nprintDiagnostic stdout
  True True 4 defaultStyle diagnostic'\n```\n\nMore examples are given in the [`test/rendering`](./test/rendering)
  folder (execute `stack test` to see the output).\n\n## TODO list\n\n<< empty, for
  now >>\n\n## License\n\nThis work is licensed under the BSD-3 clause license.\n\nCopyright
  (c) 2021-2022 Mesabloo, all rights reserved.\n"
license-name: BSD-3-Clause

homepage: https://github.com/lykahb/variadic-function#readme
changelog-type: markdown
hash: d5baabfed733d2d7118aa23a59cbbf6cbea0e9479160b8565e04fef5c0c1c17a
test-bench-deps:
  variadic-function: -any
  base: '>=4.7 && <5'
  hspec: -any
maintainer: lykahb@gmail.com
synopsis: Create and transform functions with variable arity.
changelog: |-
  # Changelog for variadic-function

  ## Changes in 0.1.0.1

  - Fix markup in README

  ## Changes in 0.1.0.0

  - The first release
basic-deps:
  base: '>=4.7 && <5'
all-versions:
- 0.1.0.0
- 0.1.0.1
author: Boris Lykah
latest: 0.1.0.1
description-type: markdown
description: "# variadic-function\n\nCreate and transform functions with variable
  arity.\n\n### How to use\n\nThe core of the library is the `Function` class. Use
  `createFunction` to make a function with a variable number of arguments. Use `transformFunction`
  to access the arguments and change the result of any function.\n\n\n```haskell\nconstN
  :: Function f args a EmptyConstraint\n       => a -> f\nconstN a = createFunction\n
  \ -- The arguments are not constrained\n  (undefined :: p EmptyConstraint)\n  --
  Combine argument with accumulator. Here we just ignore the argument\n  const\n  --
  Ignore the accumulator and return `a` as a result\n  (const a)\n  -- Accumulator
  for combining with the arguments.\n  -- We don't take any information from the arguments,
  so it is just ()\n  ()\n\ncomposeN :: (Function f args b EmptyConstraint, Function
  g args a EmptyConstraint)\n         => (a -> b) -> g -> f\ncomposeN f = transformFunction\n
  \ -- The arguments are not constrained\n  (undefined :: p EmptyConstraint)\n  --
  Ignore arguments\n  const\n  -- Ignore the accumulator and apply f to result of
  the original function `g`\n  (\\_ r -> f r)\n  -- Composition does not use the accumulator
  either, so it is ()\n  ()\n```\n\nHere is a more complex example that constrains
  arguments and uses the accumulator:\n\n```haskell\nsumN :: forall r f args. (Function
  f args r ((~) r), Num r)\n     => f\nsumN = createFunction\n  -- The argument must
  be the same type as the function result. \n  -- To be able to mention `r` in here,
  the function signature \n  -- has `forall` and ScopedTypeVariables is enabled.\n
  \ (undefined :: proxy ((~) r))\n  -- Add argument to the accumulator\n  (+)\n  --
  Return accumulator as the result\n  id\n  -- The initial value of accumulator\n
  \ 0\n```"
license-name: BSD-3-Clause

all-versions:
- '0.1'
- '0.2'
- 0.2.1
author: ''
basic-deps:
  array: '>=0.4.0.0'
  base: '>=4.5.0.0 && <5'
  binary: '>=0.8.4.1 && <0.9'
  containers: '>=0.6.6 && <0.8'
  deepseq: '>=1.2 && <1.6'
  hashable: '>=1.2.7.0 && <1.6'
  indexed-traversable: '>=0.1.1 && <0.2'
  primitive: '>=0.6.4.0 && <0.10'
  strict: '>=0.4 && <0.6'
  template-haskell: '>=0'
  unordered-containers: '>=0.2.19.1 && <0.3'
  vector: '>=0.13.0.0 && <0.14'
  vector-binary-instances: '>=0.2.2.0 && <0.3'
changelog: |
  # Revision history for strict-containers

  ## 0.2.1 -- 2024-08-05

  - Update to containers v0.6.7, unordered-containers v0.2.20, vector
    v0.13.1.0. Includes support for GHC 9.10.

  ## 0.2 -- 2022-12-12

  - Update to containers v0.6.6, unordered-containers v0.2.19.1, vector
    v0.13.0.0. Includes support for GHC 9.4.

  ## 0.1 -- 2021-04-20

  - Initial release, defining strict versions of `Data.HashMap`, `Data.IntMap`,
    `Data.Map`, `Data.Sequence`, and `Data.Vector`.
changelog-type: markdown
description: |-
  This package provides strict versions of some standard Haskell containers -
  including 'HashMap', 'IntMap', 'Map', 'Sequence', and 'Vector'.

  The reasoning is the same as that for our @strict@ package - though some
  containers already define strict /operations/ that force their inputs, the
  underlying data type is shared between the lazy and strict variants, i.e. by
  default lazy. In particular, instances are defined lazily on the common type,
  meaning that external utilities such as @lens@, @optics@, and deserialisation
  instances e.g. for @binary@ and @serialise@, all work lazily and there is not
  even the option to go strict.

  This package defines separate data types, to avoid these problems. Instances
  can then be defined on these fully-strict data types.

  To be clear, the "strict" vs "lazy" discussion refers to the values of a map
  or the elements of a sequence. The standard variants of these data structures
  that can be lazy-or-strict are already always-strict in their keys (for maps)
  and lengths (for sequences) respectively. This is also why we don't define
  strict variants of sets here, since the standard variants are already strict
  in their elements.

  Note: generally, instances for strict containers violate their respective
  laws in the presence of bottom (undefined, error, infinite-loop). In the
  absence of bottom, laws are preserved.

  This library mirrors the API of the standard lazy-or-strict variants in
  @containers@ and @unordered-containers@, including methods and fundamental
  instances. It also contains instances for @binary@ and @indexed-traversable@.
  More instances are defined in other packages, e.g. @strict-containers-lens@
  and @strict-containers-serialise@.

  The current version of this library has been autogenerated from:

  * containers v0.7
  * unordered-containers v0.2.20
  * vector vector-0.13.1.0
description-type: haddock
hash: ea58d1f30c9867a4c4241864881e0d2576ad72fb6333c49d88c5e42c8f7a04b1
homepage: https://github.com/haskellari/strict-containers
latest: 0.2.1
license-name: BSD-3-Clause
maintainer: Ximin Luo <infinity0@pwned.gg>
synopsis: Strict containers.
test-bench-deps:
  ChasingBottoms: '>=0'
  HUnit: '>=0'
  QuickCheck: '>=2.9 && <2.15'
  array: '>=0.4.0.0'
  base: '>=4.10 && <5'
  base-orphans: '>=0.6'
  containers: '>=0'
  deepseq: '>=1.2 && <1.6'
  primitive: '>=0'
  random: '>=0'
  strict-containers: '>=0'
  tasty: '>=0'
  tasty-hunit: '>=0'
  tasty-quickcheck: '>=0'
  template-haskell: '>=0'
  transformers: '>=0.2.0.0'
  vector: '>=0'

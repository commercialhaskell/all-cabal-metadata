homepage: ''
changelog-type: markdown
hash: 6e6e3c7e64ccfe8eb1e07233fb4f31bed1b955ad6ebf3e27faaf28f3acd16d12
test-bench-deps:
  streaming: -any
  exceptions: -any
  streaming-concurrency: -any
  testbench: ! '>=0.2.1.0 && <0.3'
  base: -any
  hspec: ==2.4.*
  monad-control: -any
  HUnit: -any
  quickcheck-instances: -any
  lifted-async: -any
  QuickCheck: ==2.*
maintainer: Ivan.Miljenovic@gmail.com
synopsis: Concurrency support for the streaming ecosystem
changelog: ! "# Revision history for streaming-concurrency\n\n## 0.3.1.2 -- 2018-05-23\n\n*
  Bump lifted-async dependency.\n\n## 0.3.1.1 -- 2018-03-23\n\n* Bump exceptions dependency.\n\n##
  0.3.1.0 -- 2018-03-14\n\n* Allow `streaming-0.2.*`\n\n* Improved performance for
  `withStreamMap` and `withStreamMapM`.\n\n    - Previously used additional `Stream`s
  within the concurrent\n      buffers which isn't actually needed.\n\n    - A benchmark
  is available to compare various implementations.\n\n* Primitives to help defining
  custom stream-mapping functions are now\n  exported.\n\n## 0.3.0.1 -- 2017-07-07\n\n*
  Allow `streaming-with-0.2.*`\n\n## 0.3.0.0 -- 2017-07-05\n\n* Removed support for
  streaming `ByteString`s.\n\n    The ByteString-related functions which were previously
  implemented\n    are broken conceptually and should not be used.\n\n    A ByteString
  consists of a stream of bytes; the meaning of each byte\n    is dependent upon its
  position in the overall stream.\n\n    In terms of implementation, these bytes are
  accumulated into\n    _chunks_, each of which may very well be of a different size.\n\n
  \   As such, if such a chunk is fed into a buffer with multiple readers,\n    then
  there is no guarantee which reader will actually receive it or if\n    it makes
  sense about what it is in isolation (e.g. it could be split\n    mid-word, or possibly
  even in the middle of a Unicode character).\n\n    If, however, multiple ByteStrings
  are fed into a buffer with a single\n    reader, the order it has when coming out
  is similarly undeterministic:\n    it isn't possible to coherently ensure the sanity
  of the resulting\n    ByteString.\n\n    As such, unless you really want to consider
  it as a stream of\n    raw 8-bit numbers, trying to do any concurrency with a ByteString\n
  \   will only lead to trouble.  If you do need such functionality, you\n    can
  implement it yourself using buffers containing `Word8` values\n    (in which case
  you can use `Data.ByteString.Streaming.unpack`).\n\n* Fix lower bound of `lifted-async`
  (`replicateConcurrently_` was\n  added in 0.9.3).\n\n## 0.2.0.0 -- 2017-07-05\n\n*
  Rename functions to match the `with...` naming scheme:\n\n    - `merge{Streams,ByteStrings}`
  to `withMerged{Streams,ByteStrings}`\n    - `read{Stream,ByteString}Basket` to `with{Stream,ByteString}Basket`\n\n*
  Add the ability to use buffers to concurrently transform the stream;\n  following
  functions added:\n\n    - `withBufferedTransform`\n    - `withStreamMap`\n    -
  `withStreamMapM`\n    - `withStreamTransform`\n\n    (Note: it is not sound in the
  general case to transform a\n    streaming `ByteString`; as such, functions for
  this are not\n    implemented though it is possible to do yourself.)\n\n## 0.1.0.0
  -- 2017-07-04\n\n* First version.\n"
basic-deps:
  streaming: ! '>=0.1.4.0 && <0.3'
  exceptions: ! '>=0.6 && <0.11'
  stm: ! '>=2.4 && <3'
  base: ==4.*
  streaming-with: ! '>=0.1.0.0 && <0.3'
  monad-control: ==1.*
  lifted-async: ! '>=0.9.3 && <0.111'
  transformers-base: -any
all-versions:
- '0.1.0.0'
- '0.3.0.0'
- '0.3.0.1'
- '0.3.1.0'
- '0.3.1.1'
- '0.3.1.2'
author: Ivan Lazar Miljenovic
latest: '0.3.1.2'
description-type: markdown
description: ! "streaming-concurrency\n==============\n\n[![Hackage](https://img.shields.io/hackage/v/streaming-concurrency.svg)](https://hackage.haskell.org/package/streaming-concurrency)
  [![Build Status](https://travis-ci.org/haskell-streaming/streaming-concurrency.svg)](https://travis-ci.org/haskell-streaming/streaming-concurrency)\n\n>
  Concurrency for the [streaming] ecosystem\n\n[streaming]: http://hackage.haskell.org/package/streaming\n\nThere
  are two primary higher-level use-cases for this library:\n\n1. Merge multiple `Stream`s
  together.\n\n2. A conceptual `Stream`-based equivalent to [`parMap`] (albeit\n   utilising
  concurrency rather than true parallelism).\n\n    [`parMap`]: http://hackage.haskell.org/package/parallel/docs/Control-Parallel-Strategies.html#v:parMap\n\nHowever,
  low-level functions are also exposed so you can construct\nyour own methods of concurrently
  using `Stream`s (and there are also\nnon-`Stream`-specific functions if you wish
  to use it with other data\ntypes).\n\nConceptually, the approach taken is to consider
  a typical\ncorrespondence system with an in-basket/tray for receiving messages\nfor
  others, and an out-basket/tray to be later dealt with.  Inputs are\nthus provided
  into the `InBasket` and removed once available from the\n`OutBasket`.\n\nThanks
  and recognition\n----------------------\n\nThe code here is heavily based upon --
  and borrows the underlying\n`Buffer` code from -- Gabriel Gonzalez's [pipes-concurrency].
  \ It\ndiffers from it primarily in being more bracket-oriented rather than\nproviding
  a `spawn` primitive, thus not requiring explicit garbage\ncollection.\n\n[pipes-concurrency]:
  http://hackage.haskell.org/package/pipes-concurrency\n\nAnother main difference
  is that the naming of the `input` and `output`\ntypes has been switched around:
  [pipes-concurrency] seems to consider\nthem from the point of view of the supplying/consuming
  `Pipe`s,\nwhereas here they are considered from the point of view of the\n`Buffer`
  itself.\n"
license-name: MIT

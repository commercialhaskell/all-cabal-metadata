homepage: http://github.com/ekmett/streams
changelog-type: markdown
hash: 06fed6284e032a0a63e22b8a690212c26654aff2dd9f34eff97d8d85036067ed
test-bench-deps: {}
maintainer: Edward A. Kmett <ekmett@gmail.com>
synopsis: Various Haskell 2010 stream comonads
changelog: "3.3.1 [2022.11.30]\r\n------------------\r\n* Add `Boring` and `Absurd`
  instances for infinite streams.\r\n* Add a `head :: Stream a -> a` function to `Data.Stream.Infinite`.\r\n\r\n3.3\r\n---\r\n*
  Removed a number of redundant parts of the API. If a method you were using has been
  removed, consider the classes available. No functionality was lost.\r\n* Better
  support for GHC 7.10, the `Foldable (length, null)` members are now defined directly
  leading to asymptotic improvements and helping to further shrink the API.\r\n* Added
  `prepend` and `concat` functions to `Data.Stream.Infinite`\r\n* Allow `comonad-5`\r\n\r\n3.2.2\r\n-----\r\n*
  Bug fix in `Data.Stream.Infinite.Skew` and removed `fromList`.\r\n\r\n3.2.1\r\n-----\r\n*
  Add support for `semigroupoids` 5 and GHC 7.10\r\n\r\n3.2\r\n---\r\n* Switched to
  `tabulate` and `index` from `adjunctions`. Note: this reversed the argument order
  to `index`.\r\n* Proper upper bounds on dependencies.\r\n\r\n3.1.1\r\n-----\r\n*
  Marked modules appropriately Trustworthy\r\n\r\n3.0.1\r\n-----\r\n* Removed intra-package
  dependency bounds for my packages\r\n* Build system improvements\r\n* IRC Buildbot
  notification\r\n\r\n3.0\r\n---\r\n* Version sync with the rest of my packages\r\n\r\n0.7\r\n--\r\n*
  \"Data.Stream.NonEmpty\" renamed to \"Data.List.NonEmpty\" and pushed upstream into
  the semigroups package.\r\n\r\n0.6.3\r\n-----\r\n* Removed a redundant UNPACK pragma\r\n\r\n0.5.1\r\n-----\r\n*
  Data.Stream.Supply added\r\n\r\nSince 0.1:\r\n----------\r\n* A number of strictness
  issues with 'NonEmpty' were fixed\r\n* More documentation\r\n"
basic-deps:
  semigroupoids: '>=4 && <6'
  base: '>=4 && <5'
  comonad: '>=4 && <6'
  adjunctions: '>=4.0.1 && <5'
  distributive: '>=0.2.1 && <1'
  boring: '>=0.2 && <0.3'
all-versions:
- 0.1.1
- '0.2'
- '0.3'
- 0.3.1
- '0.4'
- 0.5.0
- 0.5.1
- 0.5.1.1
- 0.5.1.2
- 0.6.0
- 0.6.0.1
- 0.6.1.1
- 0.6.1.2
- 0.6.3
- 0.7.0
- 0.7.1
- 0.7.2
- 0.8.0
- 0.8.0.1
- 0.8.0.2
- 0.8.0.3
- 0.8.0.4
- 0.8.1
- 0.8.2
- '3.0'
- 3.0.0.1
- 3.0.1
- 3.0.1.1
- '3.1'
- 3.1.1
- '3.2'
- 3.2.1
- '3.3'
- 3.3.1
author: Edward A. Kmett
latest: 3.3.1
description-type: text
description: "-- currently implemented\r\n\r\n* Data.Stream.Supply          data Supply
  a = Supply a (Supply a) (Supply a)\r\n* Data.Stream.Branching       data Stream
  f a = a :< f (Stream a)\r\n* Data.Stream.NonEmpty        data NonEmpty a = a :|
  [a] \r\n* Data.Stream.Future               data Future a = Last a | a :<   Future
  a\r\n* Data.Stream.Future.Skew          data Future a = Last a | !(Complete a) :<
  Future a\r\n* Data.Stream.Infinite                    data Future a = a :<   Future
  a\r\n* Data.Stream.Infinite.Skew               data Future a = !(Complete a) :<
  Future a\r\n* Data.Stream.Infinite.Functional.Zipper  data Zipper a = Zipper !(Integer
  -> a) !Integer\r\n\r\n-- TODO: refactor the existing Functional.Zipper to have a
  lower bound and add a Symmetric variant\r\n-- Data.Stream.Infinite.Functional.Zipper
  data Zipper a = Zipper !(Integer -> a) !Integer !Integer -- can seek arbitrarily\r\n\r\nData.Stream.Causal
  \              data Causal a = First a |   Causal a  :> a   \r\nData.Stream.Causal.Infinite
  \     data Causal a =             Causal a  :> a\r\nData.Stream.Causal.Finite        data
  Causal a = First a | !(Causal a) :> a\r\nData.Stream.Causal.Skew          data Causal
  a = First a |   Causal a  :> !(Complete a)\r\nData.Stream.Causal.Infinite.Skew data
  Causal a =             Causal a  :> !(Complete a)\r\n\r\nData.Stream.Future.Finite
  \       data Future a = Last a | a :< !(Future a)\r\n\r\nData.Stream.Zipper                         data
  Zipper a = Now !(Finite.Causal a) | !(Finite.Causal a) :| (Future a) \r\nData.Stream.Zipper.Symmetric
  \              data Zipper a = Now !(Causal a)        | !(Causal a)        :| (Future
  a) \r\nData.Stream.Zipper.Infinite                data Zipper a =                          !(Finite.Causal
  a) :| Infinite.Future a\r\nData.Stream.Zipper.Infinite.Symmetric      data Zipper
  a =         {- #UNPACK #-} !(Infinite.Causal a) :| Infinite.Future a\r\nData.Stream.Zipper.Finite
  \                 data Zipper a = Now !(Finite.Causal a) | !(Finite.Causal a) :|
  !(Finite.Future a)\r\nData.Stream.Zipper.Skew                    data Zipper a =
  Zipper !(Seq a) !(Seq a) !(Skew.Future a)\r\nData.Stream.Zipper.Skew.Symmetric          data
  Zipper a = Zipper !(S.Causal a) !(Seq a) !(Seq a) !(Skew.Future a)\r\nData.Stream.Zipper.Infinite.Skew
  \          data Zipper a = Zipper !(S.Causal a) !(Seq a) !(Seq a) !(IS.Future a)\r\nData.Stream.Zipper.Infinite.Skew.Symmetric
  data Zipper a = Zipper !(IS.Causal a) !(Seq a) !(Seq a) !(IS.Future a)\r\n\r\nData.Stream.Infinite.Functional.Future
  \          data Future a = Future !(Integer -> a) !Integer -- increment only\r\nData.Stream.Infinite.Functional.Causal
  \          data Causal a = Causal !(Integer -> a) !Integer -- decrement only\r\n\r\nData.Sequence.Future
  \       data Future a = Future !(Int# -> a)      Int# Int#\r\nData.Sequence.Causal
  \       data Causal a = Causal !(Int# -> a) Int# Int#\r\nData.Sequence.Zipper        data
  Zipper a = Zipper !(Int# -> a) Int# Int# Int#\r\n\r\nData.Tensors          data
  Tensors f a = Last a | a :-   Tensors f (f a)\r\nData.Tensors.Infinite data Tensors
  f a =          a :-   Tensors f (f a)\r\nData.Tensors.Finite   data Tensors f a
  = Last a | a :- !(Tensors f (f a))\r\n"
license-name: BSD-3-Clause

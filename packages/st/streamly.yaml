homepage: https://github.com/composewell/streamly
changelog-type: markdown
hash: c989d1f7733fb7a728d0e221020dddd198968ec9fe4588b4082057cdc7a6c14d
test-bench-deps:
  base: ! '>=4.8 && <5'
  hspec: ! '>=2.0 && <3'
  criterion: ! '>=1 && <2'
  containers: ! '>=0.5 && <0.6'
  atomic-primops: ! '>=0.8 && <0.9'
  mtl: ! '>=2.2 && <3'
  streamly: -any
maintainer: harendra.kumar@gmail.com
synopsis: Beautiful Streaming, Concurrent and Reactive Composition
changelog: ! "## 0.1.2\n\n### Enhancements\n* Add `iterate`, `iterateM` stream operations\n\n###
  Bug Fixes\n* Fixed a bug that casued unexpected behavior when `pure` was used to
  inject\n  values in Applicative composition of `ZipStream` and `ZipAsync` types.\n\n##
  0.1.1\n\n### Enhancements\n* Make `cons` right associative and provide an operator
  form `.:` for it\n* Add `null`, `tail`, `reverse`, `replicateM`, `scan` stream operations\n*
  Improve performance of some stream operations (`foldl`, `dropWhile`)\n\n### Bug
  Fixes\n* Fix the `product` operation. Earlier, it always returned 0 due to a bug\n*
  Fix the `last` operation, which returned `Nothing` for singleton streams\n\n## 0.1.0\n\n*
  Initial release\n"
basic-deps:
  exceptions: ! '>=0.8 && <0.11'
  stm: ! '>=2.4.3 && <2.5'
  base: ! '>=4.8 && <5'
  monad-control: ! '>=1.0 && <2'
  lockfree-queue: ! '>=0.2.3 && <0.3'
  lifted-base: ! '>=0.2 && <0.3'
  containers: ! '>=0.5 && <0.6'
  atomic-primops: ! '>=0.8 && <0.9'
  mtl: ! '>=2.2 && <3'
  transformers-base: ! '>=0.4 && <0.5'
  transformers: ! '>=0.4 && <0.6'
all-versions:
- '0.1.0'
- '0.1.1'
- '0.1.2'
author: Harendra Kumar
latest: '0.1.2'
description-type: markdown
description: ! "# Streamly\n\n## Stream`ing` `Concurrent`ly\n\nStreamly is a monad
  transformer unifying non-determinism\n([list-t](https://hackage.haskell.org/package/list-t)/[logict](https://hackage.haskell.org/package/logict)),\nconcurrency
  ([async](https://hackage.haskell.org/package/async)),\nstreaming ([conduit](https://hackage.haskell.org/package/conduit)\\/[pipes](https://hackage.haskell.org/package/pipes)),\nand
  FRP ([Yampa](https://hackage.haskell.org/package/Yampa)\\/[reflex](https://hackage.haskell.org/package/reflex))\nfunctionality
  in a concise and intuitive API.\nHigh level concurrency makes concurrent applications
  almost indistinguishable\nfrom non-concurrent ones.  By changing a single combinator
  you can control\nwhether the code runs serially or concurrently.  It naturally integrates\nconcurrency
  with streaming rather than adding it as an afterthought.\nMoreover, it interworks
  with the popular streaming libraries.\n\nSee the haddock documentation for full
  reference.  It is recommended that you\nread `Streamly.Tutorial` first. Also see
  `Streamly.Examples` for some working\nexamples.\n\n`Streamly` has best in class
  performance even though it generalizes streaming\nto concurrent composition that
  does not mean it sacrifices non-concurrent\nperformance. See\n[streaming-benchmarks](https://github.com/composewell/streaming-benchmarks)
  for\ndetailed performance comparison with regular streaming libraries and the\nexplanation
  of the benchmarks. The following graphs show a summary, the first\none measures
  how four pipeline stages in a series perform, the second one\nmeasures the performance
  of individual stream operations; in both cases the\nstream processes a million elements:\n\n![Composing
  Pipeline Stages](charts/ComposingPipelineStages.svg)\n![All Operations at a Glance](charts/AllOperationsataGlance.svg)\n\n##
  Non-determinism\n\nThe monad instance composes like a list monad.\n\n``` haskell\nimport
  Streamly\nimport qualified Streamly.Prelude as S\n\nloops = do\n    x <- S.each
  [1,2]\n    y <- S.each [3,4]\n    liftIO $ putStrLn $ show (x, y)\n\nmain = runStreaming
  $ serially $ loops\n```\n```\n(1,3)\n(1,4)\n(2,3)\n(2,4)\n```\n\n## Magical Concurrency\n\nTo
  run the above code with demand-driven concurrency i.e. each iteration in the\nloops
  can run concurrently depending on the consumer rate:\n\n``` haskell\nmain = runStreaming
  $ asyncly $ loops\n```\n\nTo run it with full parallelism irrespective of demand:\n\n```
  haskell\nmain = runStreaming $ parallely $ loops\n```\n\nTo run it serially but
  interleaving the outer and inner loop iterations:\n\n``` haskell\nmain = runStreaming
  $ interleaving $ loops\n```\n\nYou can fold multiple streams or IO actions using
  parallel combinators like\n`<|`, `<|>`. For example, to concurrently generate the
  squares and then\nconcurrently sum the square roots of all combinations:\n\n```
  haskell\nimport Streamly\nimport qualified Streamly.Prelude as S\n\nmain = do\n
  \   s <- S.sum $ asyncly $ do\n        -- Squaring is concurrent (<|)\n        x2
  <- forEachWith (<|) [1..100] $ \\x -> return $ x * x\n        y2 <- forEachWith
  (<|) [1..100] $ \\y -> return $ y * y\n        -- sqrt is concurrent (asyncly)\n
  \       return $ sqrt (x2 + y2)\n    print s\n```\n\nOf course, the actions running
  in parallel could be arbitrary IO actions.  To\nconcurrently list the contents of
  a directory tree recursively:\n\n``` haskell\nimport Path.IO (listDir, getCurrentDir)\nimport
  Streamly\n\nmain = runStreaming $ serially $ getCurrentDir >>= readdir\n   where
  readdir d = do\n            (dirs, files) <- lift $ listDir d\n            liftIO
  $ mapM_ putStrLn $ map show files\n            -- read the subdirs concurrently\n
  \           foldMapWith (<|>) readdir dirs\n```\n\nIn the above examples we do not
  think in terms of threads, locking or\nsynchronization, rather we think in terms
  of what can run in parallel, the rest\nis taken care of automatically. With `asyncly`
  and `<|` the programmer does not\nhave to worry about how many threads are to be
  created they are automatically\nadjusted based on the demand of the consumer.\n\nThe
  concurrency facilities provided by streamly can be compared with\n[OpenMP](https://en.wikipedia.org/wiki/OpenMP)
  and\n[Cilk](https://en.wikipedia.org/wiki/Cilk) but with a more declarative\nexpression.
  \ Concurrency support does not compromise performance in\nnon-concurrent cases,
  the performance of the library is at par or better than\nmost of the existing streaming
  libraries.\n\n## Streaming\n\nStreaming is effortless, simple and straightforward.
  Streamly data type behaves\njust like a list and combinators are provided in `Streamly.Prelude`
  to\ntransform or fold streamly streams. Unlike other libraries and like `streaming`\nlibrary
  the combinators explicitly consume a stream and produce a stream,\ntherefore, no
  special operator is needed to join stream stages, just a forward\n(`$`) or reverse
  (`&`) function application operator is enough.\n\n```haskell\nimport Streamly\nimport
  qualified Streamly.Prelude as S\nimport Data.Function ((&))\n\nmain = S.each [1..10]\n
  \    & fmap (+ 1)\n     & S.drop 2\n     & S.filter even\n     & fmap (* 3)\n     &
  S.takeWhile (< 25)\n     & S.mapM (\\x -> putStrLn (\"saw \" ++ show x) >> return
  x)\n     & S.toList . serially\n     >>= print\n```\n\nFold style combinators can
  be used to fold purely or monadically. You can also\nuse the beautiful `foldl` library
  for folding.\n\n```haskell\nmain = S.each [1..10]\n     & serially\n     & S.foldl
  (+) 0 id\n     >>= print\n```\n\nStreams can be combined together in multiple ways:\n\n```haskell\nmain
  = do\n    let p s = (toList . serially) s >>= print\n    p $ return 1 <> return
  2               -- serial, combine atoms\n    p $ S.each [1..10] <> S.each [11..20]
  \ -- serial\n    p $ S.each [1..10] <| S.each [11..20]  -- demand driven parallel\n
  \   p $ S.each [1..10] <=> S.each [11..20] -- serial but interleaved\n    p $ S.each
  [1..10] <|> S.each [11..20] -- fully parallel\n```\n\nAs we have already seen streams
  can be combined using monadic composition in a\nnon-deterministic manner. This allows
  arbitrary manipulation and combining of\nstreams. See `Streamly.Examples.MergeSortedStreams`
  for a more complicated\nexample.\n\n## Reactive Programming (FRP)\n\nStreamly is
  a foundation for first class reactive programming as well by virtue\nof integrating
  concurrency and streaming. See `Streamly.Examples.AcidRainGame`\nand `Streamly.Examples.CirclingSquare`
  for an SDL based animation example.\n\n## Contributing\n\nThe code is available
  under BSD-3 license\n[on github](https://github.com/composewell/streamly). Join
  the\n[gitter chat](https://gitter.im/composewell/streamly) channel for discussions.\nYou
  can find some of the\n[todo items on the github wiki](https://github.com/composewell/streamly/wiki/Things-To-Do).\nPlease
  ask on the gitter channel or [contact the maintainer directly](mailto:harendra.kumar@gmail.com)\nfor
  more details on each item. All contributions are welcome!\n\nThis library was originally
  inspired by the `transient` package authored by\nAlberto G. Corona.\n"
license-name: BSD3

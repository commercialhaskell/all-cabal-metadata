homepage: https://github.com/raehik/strongweak#readme
changelog-type: markdown
hash: 61162370ca9d45ba2dffa331974c45b07ae91d2e79014d2723c259584d9002be
test-bench-deps: {}
maintainer: Ben Orchard <thefirstmuffinman@gmail.com>
synopsis: Convert between strong and weak representations of types
changelog: |
  ## 0.1.0 (2022-05-16)
  Initial release.

    * basic instances (lists, numerics)
    * generic derivations
    * super explicit errors
basic-deps:
  base: '>=4.14 && <5'
  vector-sized: '>=1.5.0 && <1.6'
  refined: '>=0.6.3 && <0.7'
  prettyprinter: '>=1.7.1 && <1.8'
  validation: '>=1.1.2 && <1.2'
all-versions:
- 0.1.0
author: Ben Orchard
latest: 0.1.0
description-type: markdown
description: |
  # strongweak
  Definitions for transforming between types.

    * `strong -> weak` drops invariants (e.g. going from a bounded to an unbounded
      numeric type)
    * `weak -> Maybe strong` introduces invariants

  This is not a `Convertible` library that enumerates transformations between
  types into a dictionary.

    * A "strong" type has exactly one "weak" representation.
    * Weakening a type is safe.
    * Strengthening a type may fail.

  There are generic derivers for generating `Strengthen` and `Weaken` instances
  for arbitrary data types. The `Strengthen` instances annotate errors
  extensively, telling you the datatype & record for which strengthening failed -
  recursively, for nested types.

  This is a validation library. We don't fail on the first error -- we attempt to
  validate every part of a data type, and collate the errors into a list. This
  happens magically in the generic deriver, but if you're writing your own
  instances, you may want `ApplicativeDo` so you can use do notation. So it'll
  monadic, but actually everything will get checked.
license-name: MIT

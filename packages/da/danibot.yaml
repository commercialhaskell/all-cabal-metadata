all-versions:
- 0.2.0.0
author: Daniel Diaz
basic-deps:
  aeson: '>=0.11.0.0'
  async: '>=2.1.0'
  attoparsec: '>=0.13'
  base: '>=4.7 && <5'
  bytestring: '>=0.10.6.0'
  conceit: '>=0.4.0.0'
  containers: '>=0.5'
  danibot: '>=0'
  foldl: '>=1.1.5'
  lens: '>=4.5'
  lens-aeson: '>=1.0.0.0'
  monoid-subclasses: '>=0.4.2'
  network: '>=2.6'
  optparse-applicative: '>=0.12.1.0'
  stm: '>=2.4.4'
  streaming: '>=0.1.4'
  text: '>=1.2.2.0'
  transformers: '>=0.4.3.0'
  websockets: '>=0.9.6.0'
  wreq: '>=0.4.1.0'
  wuss: '>=1.0.2'
changelog: ''
changelog-type: text
description: "A very basic framework for creating Slack bots.\n\nThe bot will respond
  to messages in IM channels, and also to  messages\nexplicitly directed at him in
  general channels (`@nameofthebot: some message`).\n\nThe bot reads the Slack api
  token from the environment variable\n\"DANIBOT_SLACK_API_TOKEN\".\n\nThe default
  danibot executable comes with a few example handlers:\n\n- *up? host port* \n\n
  \ Checks if a port is open in a host.\n\n- *lookup key* \n\n  Checks the value of
  key in a dictionary that is loaded at\n  startup with the --dict parameter. The
  dictionary is a json object with\n  string values.\n\n- *help* \n\n  Lists available
  options.\n\nRight now the bot ignores most chat events apart from messages.\n\nTo
  create your own customized bot, import `Network.Danibot.Main` and pass a\nvalue
  of type `IO (Either String (Text -> IO Text))` to `mainWith`, where `Text\n-> IO
  Text` is the type of the handler function.\n\n"
description-type: markdown
hash: da9b4cfa3bdd8fa75abfff4a5e45eca41c7ddbde6a3066dbea31322c5af09332
homepage: ''
latest: 0.2.0.0
license-name: MIT
maintainer: diaz_carrete@yahoo.com
synopsis: Basic Slack bot framework.
test-bench-deps: {}

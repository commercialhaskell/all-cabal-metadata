homepage: https://github.com/RubenAstudillo/data-forced
changelog-type: markdown
hash: 15870c64922e0d0ed491a3e351cdc74815aec01f1e17f997a669b94f11170cc5
test-bench-deps:
  data-forced: -any
  base: ^>=4.16.4.0
  HUnit: -any
  containers: -any
maintainer: ruben.astud@gmail.com
synopsis: Specify that lifted values were forced to WHNF or NF.
changelog: |+
  # Revision history for data-elevator-forced

  ## 0.1.0.0 -- YYYY-mm-dd

  * First version. Released on an unsuspecting world.

  ## 0.2.0.0 -- 2023-04-14

  * Use a StrictValueExtractor instead of a raw Strict.

  This avoid a common pitfall where let bound destructuring will fallback to
  lazy semantics. This way we force the use to bound the two values with
  names. Any inconsistency will be reported by
  -Werror=unbanged-strict-patterns .

  * Use a strict tuple type called Pairy

  We have more oportunities to trigger evaluation like that.

  * Give a good tutorial

  I am pretty proud of it.

basic-deps:
  base: ^>=4.16.4.0
  data-elevator: '>=0.1.0.0'
  deepseq: '>=1.4.6.0'
all-versions:
- 0.1.0.0
- 0.2.0.0
- 0.3.0.0
author: Ruben Astudillo
latest: 0.3.0.0
description-type: haddock
description: "Alternative to bang patterns using CBV functions and unlifted data types.\nTag
  your values to maintain the invariant that they were forced. Avoid\nliveness leaks
  on long lived data structures.\n\nMain tutorial on the only module. Here is a taste
  of how it will look\nlike.\n\n> {-# Language QualifiedDo #-}\n> \n> import qualified
  Data.Forced as DF\n> import Data.Forced hiding (pure, fmap, (\\<*\\>), return, (>>=),
  (>>))\n> import Data.Map.Lazy qualified as ML\n> \n> noThunksForWHNF :: IO ()\n>
  noThunksForWHNF = do\n>   -- map0 actually evaluated on here.\n>   let map0 :: Demand
  (ML.Map Char (ForcedWHNF Int))\n>       map0 = DF.do\n>         v <- demandWHNF
  (const (2 + 2) 'a')\n>         DF.pure $ ML.insert 'a' v ML.empty\n> \n>   map1
  <- extractDemand map0\n>   go (ML.lookup 'a' map1)\n> \n> -- pattern matching for
  de-structuring, no construction allowed.\n> go :: ForcedWHNF Int -> IO ()\n> go
  (ForcedWHNF i) =  print i"
license-name: MIT

homepage: ''
changelog-type: markdown
hash: 216bce1c1c6af8f4f768b20cc1406e8516f4215baeb552733f7d59f8514addc6
test-bench-deps:
  data-forced: -any
  base: ^>=4.16.4.0
  HUnit: -any
  containers: -any
maintainer: ruben.astud@gmail.com
synopsis: Specify that lifted values were forced to WHNF or NF.
changelog: |
  # Revision history for data-elevator-forced

  ## 0.1.0.0 -- YYYY-mm-dd

  * First version. Released on an unsuspecting world.
basic-deps:
  base: ^>=4.16.4.0
  data-elevator: '>=0.1.0.0'
  deepseq: '>=1.4.6.0'
all-versions:
- 0.1.0.0
author: Ruben Astudillo
latest: 0.1.0.0
description-type: haddock
description: "Alternative to bang patterns using CBV functions and unlifted data types.\nTag
  your values to maintain the invariant that they were forced. Avoid\nliveness leaks
  on long running data structures.\n\n> import Data.Map.Lazy as ML -- Spine strict\n>
  \n> -- No references on added leafs even though it is a lazy map.\n> basicEvent
  :: ML.Map Char (ForcedWHNF Int) -> IO (ML.Map Char (ForcedWHNF Int))\n> basicEvent
  map0 = do\n>   let val0 :: Strict (ForcedWHNF Int)\n>       -- val0 = strictlyWHNF
  (error \"argument evaluated\") -- would fail\n>       val0 = strictlyWHNF (2 + 2)\n>
  \      -- CBV function, 2 + 2 reduced before val0 is bound.\n>       Strict val1
  = val0  -- De-structure\n>       map1 = ML.insert 'a' val1 map0\n>   pure map1"
license-name: MIT

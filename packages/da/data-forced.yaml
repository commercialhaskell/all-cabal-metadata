homepage: https://github.com/RubenAstudillo/data-forced
changelog-type: markdown
hash: 7509f712bbfb11ef069cb3506f70ca4ee6cf7ce63f9e0a7259476010823ab9f2
test-bench-deps:
  data-forced: -any
  base: ^>=4.16.4.0
  HUnit: -any
  containers: -any
maintainer: ruben.astud@gmail.com
synopsis: Specify that lifted values were forced to WHNF or NF.
changelog: |+
  # Revision history for data-elevator-forced

  ## 0.1.0.0 -- YYYY-mm-dd

  * First version. Released on an unsuspecting world.

  ## 0.2.0.0 -- 2023-04-14

  * Use a StrictValueExtractor instead of a raw Strict.

  This avoid a common pitfall where let bound destructuring will fallback to
  lazy semantics. This way we force the use to bound the two values with
  names. Any inconsistency will be reported by
  -Werror=unbanged-strict-patterns .

  * Use a strict tuple type called Pairy

  We have more oportunities to trigger evaluation like that.

  * Give a good tutorial

  I am pretty proud of it.

basic-deps:
  base: ^>=4.16.4.0
  data-elevator: '>=0.1.0.0'
  deepseq: '>=1.4.6.0'
all-versions:
- 0.1.0.0
- 0.2.0.0
author: Ruben Astudillo
latest: 0.2.0.0
description-type: haddock
description: |-
  Alternative to bang patterns using CBV functions and unlifted data types.
  Tag your values to maintain the invariant that they were forced. Avoid
  liveness leaks on long lived data structures.

  Main tutorial on the only module. Here is a taste of how it will look
  like.

  > import Data.Map.Lazy as ML -- Spine strict
  >
  > -- No references on added leafs even though it is a lazy map.
  > basicEvent :: ML.Map Char (ForcedWHNF Int) -> IO (ML.Map Char (ForcedWHNF Int))
  > basicEvent map0 = do
  >   let
  >     -- Step1: bind the strict value with a strict let. (2 + 2) reduced
  >     -- before val0 is bound.
  >     val0 :: StrictValueExtractor (ForcedWHNF Int)
  >     val0 = strictlyWHNF (2 + 2)
  >     -- val0 = strictlyWHNF (error "argument evaluated") -- would fail
  >
  >     -- Step2: extract the strict value to be use on lazy setting. A
  >     -- neccesary idiom to avoid a pitfall.
  >     val1 = case val0 of { Pairy val0' ext -> ext val0' }
  >
  >     -- Step3: Store the value free of references. Even though map1 is a lazy
  >     -- map, the references to evaluate val1 were already freed.
  >     map1 = ML.insert 'a' val1 map0
  >   pure map1
license-name: MIT

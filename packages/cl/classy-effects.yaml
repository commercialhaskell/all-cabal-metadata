homepage: ''
changelog-type: markdown
hash: 9d219a1602967b1cdde3f33b47c891a36a981e9217f5ac51d8faa13992e46e1b
test-bench-deps:
  base: -any
  tasty-hunit: ^>=0.10
  tasty: ^>=1.4
  classy-effects: -any
maintainer: Yamada Ryo <ymdfield@outlook.jp>
synopsis: An interface for a handler-independent, typeclass-based effect system.
changelog: |
  # Revision history for classy-effects

  ## 0.1.0.0 -- 2023-09-18

  * Initial public release.
basic-deps:
  classy-effects-th: ^>=0.1
  base: ^>=4.16.4.0
  classy-effects-base: ^>=0.1
all-versions:
- 0.1.0.0
author: Yamada Ryo <ymdfield@outlook.jp>
latest: 0.1.0.0
description-type: markdown
description: |
  # classy-effects

  This repository is for **CEPs** and its associated Haskell library.

  CEPs (Classy-Effects Protocols) are a collection of protocols for expressing and defining effects in Haskell, aimed at the fist objective in the [Sayo Project](https://github.com/sayo-hs):

  > Exploring ways to improve interoperability among the myriad Haskell effect system libraries

  For more details, please refer to [CEPs/README.md](https://github.com/sayo-hs/classy-effects/blob/master/CEPs/README.md).

  ## Background
  In Haskell, there are numerous libraries to realize an effect system. The issue here is interoperability between these libraries. For instance, the [Reader effect in `fused-effects`](https://hackage.haskell.org/package/fused-effects-1.1.2.2/docs/Control-Effect-Reader.html#t:Reader) and the [Reader effect in `polysemy`](https://hackage.haskell.org/package/polysemy-1.9.1.1/docs/Polysemy-Reader.html) have completely identical definitions. If we could extract and define effects purely as interfaces, eliminating this redundancy in effect definitions, then an effectful program could be handled by both effect system library A and effect system library B. The specific mechanisms for handling effects vary from one library to another, and unifying them isn't the goal. We're specifically looking to unify the overlapping and common definitions of effects as interfaces.

  Based on this idea, CEPs (classy-effects protocols) were developed. CEPs propose a convention (protocol) for unified effect definitions in Haskell. It's expected that effects defined in accordance with CEPs will be usable across various effect systems and backends.

  ## Encoding of Effect
  First, for the representation of effects, there is the GADTs encoding typical in Extensible Effects and the type-class encoding typical in the monad transformer approach. In principle, if the type class representing the effect is decided, GADTs can be automatically generated, and the reverse is probably also possible. There's a kind of symmetry here. However, type classes have the advantage of expressing inclusion relationships of effects naturally by specifying superclasses. From this perspective, CEPs primarily adopt type class representation for effects. Moreover, a mechanism has been implemented to derive GADTs from type classes[^1], and from GADTs and the type classes that cast them to monads ([`SendIns`](https://hackage.haskell.org/package/classy-effects-base-0.1.0.0/docs/Control-Effect-Class.html#t:SendIns), [`SendSig`](https://hackage.haskell.org/package/classy-effects-base-0.1.0.0/docs/Control-Effect-Class.html#t:SendSig)), to automatically derive instances of the effect's type class ([`classy-effects-th`](https://hackage.haskell.org/package/classy-effects-th)). This allows compliance with CEPs automatically by just writing the type class that represents the effect.

  [^1]: In the future, we might also consider implementing the derivation of type classes from GADTs.

  ## Examples
  Examples of using classy-effects combined with the Heftia effect handler backend can be found [here](https://github.com/sayo-hs/heftia/blob/master/docs/examples/01%20First-order.md).

  ## Your contributions are welcome!
  Please see [CONTRIBUTING.md](https://github.com/sayo-hs/classy-effects/blob/master/CONTRIBUTING.md).
license-name: MPL-2.0

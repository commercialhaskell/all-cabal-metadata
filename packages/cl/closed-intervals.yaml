homepage: ''
changelog-type: markdown
hash: 26603804ce1b2c6a46f6471e54e6c07815ed9effc9cac4d83bbf2b1866a99668
test-bench-deps:
  base: -any
  time: -any
  closed-intervals: -any
  doctest-exitcode-stdio: '>=0.0 && <0.1'
  utility-ht: -any
  containers: '>=0.5.4.0'
  doctest-lib: '>=0.1 && <0.2'
  QuickCheck: '>=2.12'
maintainer: olaf.klinke@phymetric.de, olf@aatal-apotheke.de
synopsis: Closed intervals of totally ordered types
changelog: "# Changelog for closed-intervals\n\n- 0.1.1.0 added properOverlap, splitIntersecting
  and splitProperlyIntersecting.\n  Added maybeBounds to the IntersectionQuery class.\n\n-
  0.1.0.1 bugfix in hullSeqNonOverlap which was not caught \n  because the QuickCheck
  generator generated data which \n  did not meet the assumptions made by hullSeqNonOverlap.\n\n##
  Unreleased changes\n"
basic-deps:
  base: '>=4.7 && <5'
  time: <1.12
  containers: '>=0.5.4.0'
all-versions:
- 0.1.0.0
- 0.1.0.1
- 0.1.1.0
author: Olaf Klinke, Henning Thielemann
latest: 0.1.1.0
description-type: markdown
description: "# closed-intervals\nThis package provides the two-parameter type class
  `Interval` of types \nthat represent closed intervals (meaning the end-points are
  included) \npossibly with some extra annotation. \nA particular use case are time
  intervals annotated with event data. \nThe simplest example of an interval type
  `i` with end points of type `e` \nis the type `i = (e,e)`. A more complicated type
  could be a record containing \ntwo fields of the end-point type:\n```haskell \n\tdata
  Status = Status {\n\t\tstatusText  :: String,\n\t\tstatusBegin :: UTCTime,\n\t\tstatusEnd
  \  :: UTCTime}\n\tinstance Interval UTCTime Status where\n\t\tlb = statusBegin\n\t\tub
  = statusEnd\n\tinstance Adjust Status where\n\t\tadjustBounds f g s = s {\n\t\t\tstatusBegin
  = f (statusBegin s),\n\t\t\tstatusEnd   = g (statusEnd   s)}\t\n```\n\nThe functions
  exported from this package are mainly concerned with overlap queries, \nthat is,
  to identify which intervals in a collection overlap a given interval \nand if so,
  to what extent. \nThis functionality is encapsuled in the class `IntersectionQuery`.\nIf
  the collection of intervals is known to overlap in end-points only, \none can simply
  use a sequence ordered by left end-point as the search structure. \nFor arbitrary
  collections we provide the `ITree` structure \n(centered interval tree) which stores
  intervals in subtrees and bins \nthat are annotated with their convex hull, so that
  it can be decided \neasily whether there is an interval inside which overlaps a
  given interval. \n\nIn addition to the `Interval` class we provide a sub-class `Adjust`
  \ncomprising the interval types whose end-points can be adjusted \nin a Bifunctor-like
  manner. \nThis is necessary for set operations like union, intersection and difference.
  \n\nThe behaviour of the functions is undefined for intervals that \nviolate the
  implicit assumption that the left end-point is less than or equal to \nthe right
  end-point. \n\nMost functions are property-checked for correctness. \nChecks were
  implemented by Henning Thielemann.\n\n## Related packages\nThe `Interval` type class
  is shared by the `Data.IntervalMap.Generic.Interval` module of the \n[IntervalMap](https://hackage.haskell.org/package/IntervalMap)
  package. \nIntervalMap provides augmented red-black trees as the search structure.
  \n\nThe overlap functionality provided is similar to the `Interval` data type in
  the  \n[data-interval](https://hackage.haskell.org/package/data-interval) package
  \nbut we focus on closed intervals and let the user decide which \nconcrete data
  type to use. \n"
license-name: GPL-3.0-only
